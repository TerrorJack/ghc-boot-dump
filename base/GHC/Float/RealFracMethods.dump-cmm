
==================== Output Cmm ====================
2018-03-16 15:55:02.433360798 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:02.434002951 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt3_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.434593036 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt2_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt2_closure:
         const GHC.Types.F#_con_info;
         const 0.0 :: W32;
         const 0 :: W32;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.435164177 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt1_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.436370919 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInt_info;
 },
 GHC.Float.RealFracMethods.properFractionFloatInt_entry() //  [R2]
         { info_tbl: [(coQ4,
                       label: GHC.Float.RealFracMethods.properFractionFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coQ4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coQ5; else goto coQ6;
       coQ5: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coQ6: // global
           I64[Sp - 8] = block_coQ1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoQu; else goto coQ2;
       uoQu: // global
           call _coQ1(R1) args: 0, res: 0, upd: 0;
       coQ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coQ1() //  [R1]
         { info_tbl: [(coQ1,
                       label: block_coQ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coQ1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto coQb; else goto coQa;
       coQb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coQa: // global
           _soLU::F32 = F32[R1 + 7];
           if (%MO_F_Eq_W32(_soLU::F32,
                            0.0 :: W32)) goto coQt; else goto coQs;
       coQt: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coQs: // global
           I64[Hp - 48] = GHC.Types.F#_con_info;
           _soLW::I64 = %MO_FS_Conv_W32_W64(_soLU::F32);
           F32[Hp - 40] = %MO_F_Sub_W32(_soLU::F32,
                                        %MO_SF_Conv_W64_W32(_soLW::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soLW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.438910109 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInt_closure" {
     GHC.Float.RealFracMethods.floorFloatInt_closure:
         const GHC.Float.RealFracMethods.floorFloatInt_info;
 },
 GHC.Float.RealFracMethods.floorFloatInt_entry() //  [R2]
         { info_tbl: [(coQC,
                       label: GHC.Float.RealFracMethods.floorFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coQC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coQD; else goto coQE;
       coQD: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coQE: // global
           I64[Sp - 8] = block_coQz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoR2; else goto coQA;
       uoR2: // global
           call _coQz(R1) args: 0, res: 0, upd: 0;
       coQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coQz() //  [R1]
         { info_tbl: [(coQz,
                       label: block_coQz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coQz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coQJ; else goto coQI;
       coQJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coQI: // global
           _soM3::F32 = F32[R1 + 7];
           _soM4::I64 = %MO_FS_Conv_W32_W64(_soM3::F32);
           if (%MO_F_Lt_W32(_soM3::F32,
                            %MO_SF_Conv_W64_W32(_soM4::I64))) goto coR1; else goto coQV;
       coR1: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coQV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.440453927 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInt_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInt_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInt_info;
 },
 GHC.Float.RealFracMethods.ceilingFloatInt_entry() //  [R2]
         { info_tbl: [(coRa,
                       label: GHC.Float.RealFracMethods.ceilingFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coRa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coRb; else goto coRc;
       coRb: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coRc: // global
           I64[Sp - 8] = block_coR7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoRA; else goto coR8;
       uoRA: // global
           call _coR7(R1) args: 0, res: 0, upd: 0;
       coR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coR7() //  [R1]
         { info_tbl: [(coR7,
                       label: block_coR7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coR7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coRh; else goto coRg;
       coRh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coRg: // global
           _soMa::F32 = F32[R1 + 7];
           _soMb::I64 = %MO_FS_Conv_W32_W64(_soMa::F32);
           if (%MO_F_Lt_W32(%MO_SF_Conv_W64_W32(_soMb::I64),
                            _soMa::F32)) goto coRz; else goto coRt;
       coRz: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coRt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.441861479 UTC

[section ""data" . lvl_roLO_closure" {
     lvl_roLO_closure:
         const lvl_roLO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_roLO_entry() //  [R1]
         { info_tbl: [(coRH,
                       label: lvl_roLO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coRH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto coRI; else goto coRJ;
       coRI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       coRJ: // global
           (_coRE::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_coRE::I64 == 0) goto coRG; else goto coRF;
       coRG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       coRF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _coRE::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.444351913 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInteger_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_info;
         const 0;
 },
 sat_soMn_entry() //  [R1]
         { info_tbl: [(coS6,
                       label: sat_soMn_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coS6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto coS7; else goto coS8;
       coS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       coS8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_coS4_info;
           R2 = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _coS4() //  [R1]
         { info_tbl: [(coS4,
                       label: block_coS4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coS4: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMx_entry() //  [R1]
         { info_tbl: [(coSv,
                       label: sat_soMx_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coSv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto coSJ; else goto coSK;
       coSJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       coSK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_coSA_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _coSA() //  [R1]
         { info_tbl: [(coSA,
                       label: block_coSA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coSA: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_coSE_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _coSE() //  [F1]
         { info_tbl: [(coSE,
                       label: block_coSE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coSE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coSO; else goto coSN;
       coSO: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       coSN: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMs_entry() //  [R1]
         { info_tbl: [(coST,
                       label: sat_soMs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coST: // global
           if ((Sp + -16) < SpLim) (likely: False) goto coSU; else goto coSV;
       coSU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       coSV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMG_entry() //  [R1]
         { info_tbl: [(coTc,
                       label: sat_soMG_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coTc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto coTq; else goto coTr;
       coTq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       coTr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_coTh_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _coTh() //  [R1]
         { info_tbl: [(coTh,
                       label: block_coTh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coTh: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_coTl_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _coTl() //  [F1]
         { info_tbl: [(coTl,
                       label: block_coTl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coTl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coTv; else goto coTu;
       coTv: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       coTu: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMB_entry() //  [R1]
         { info_tbl: [(coTA,
                       label: sat_soMB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coTA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto coTB; else goto coTC;
       coTB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       coTC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionFloatInteger_entry() //  [R2]
         { info_tbl: [(coTD,
                       label: GHC.Float.RealFracMethods.properFractionFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coTD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto coTE; else goto coTF;
       coTE: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coTF: // global
           I64[Sp - 8] = block_coRO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoU0; else goto coRP;
       uoU0: // global
           call _coRO(R1) args: 0, res: 0, upd: 0;
       coRP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coRO() //  [R1]
         { info_tbl: [(coRO,
                       label: block_coRO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coRO: // global
           I64[Sp - 8] = block_coRT_info;
           F1 = F32[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _coRT() //  [R1, R2]
         { info_tbl: [(coRT,
                       label: block_coRT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coRT: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _coRU() args: 0, res: 0, upd: 0;
     }
 },
 _coRU() //  []
         { info_tbl: [(coRU,
                       label: block_coRU_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coRU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto coTJ; else goto coTI;
       coTJ: // global
           HpAlloc = 96;
           I64[Sp] = block_coRU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       coTI: // global
           _soMj::I64 = I64[Sp + 16];
           _soMk::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soMk::I64, 0)) goto coTM; else goto coTX;
       coTM: // global
           I64[Hp - 88] = sat_soMn_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = (,)_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
           _coTK::P64 = Hp - 55;
           Hp = Hp - 40;
           R1 = _coTK::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coTX: // global
           _soMo::I64 = -_soMk::I64;
           if (%MO_S_Le_W64(_soMo::I64, 23)) goto coTT; else goto coTW;
       coTT: // global
           if (%MO_S_Ge_W64(_soMj::I64, 0)) goto coTP; else goto coTR;
       coTP: // global
           I64[Hp - 88] = sat_soMx_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMr::I64 = _soMj::I64 >> _soMo::I64;
           I64[Hp - 48] = _soMr::I64;
           I64[Hp - 40] = sat_soMs_info;
           I64[Hp - 24] = _soMr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coTR: // global
           I64[Hp - 88] = sat_soMG_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMy::I64 = -%MO_S_Shr_W64(-_soMj::I64, _soMo::I64);
           I64[Hp - 48] = _soMy::I64;
           I64[Hp - 40] = sat_soMB_info;
           I64[Hp - 24] = _soMy::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coTW: // global
           I64[Hp - 88] = (,)_con_info;
           P64[Hp - 80] = lvl_roLO_closure;
           P64[Hp - 72] = P64[Sp + 24];
           _coTV::P64 = Hp - 87;
           Hp = Hp - 72;
           R1 = _coTV::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.448760076 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateFloatInteger_closure" {
     GHC.Float.RealFracMethods.truncateFloatInteger_closure:
         const GHC.Float.RealFracMethods.truncateFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateFloatInteger_entry() //  [R2]
         { info_tbl: [(coU9,
                       label: GHC.Float.RealFracMethods.truncateFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coU9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto coUa; else goto coUb;
       coUa: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coUb: // global
           I64[Sp - 8] = block_coU6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoUU; else goto coU7;
       uoUU: // global
           call _coU6(R1) args: 0, res: 0, upd: 0;
       coU7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coU6() //  [R1]
         { info_tbl: [(coU6,
                       label: block_coU6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coU6: // global
           I64[Sp] = block_coUe_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _coUe() //  [R1, R2]
         { info_tbl: [(coUe,
                       label: block_coUe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coUe: // global
           if (%MO_S_Ge_W64(R2, 0)) goto coUp; else goto coUJ;
       coUp: // global
           I64[Sp - 8] = block_coUn_info;
           _soMM::I64 = R2;
           R2 = R1;
           I64[Sp] = _soMM::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       coUJ: // global
           _soMP::I64 = -R2;
           if (%MO_S_Le_W64(_soMP::I64, 23)) goto coUH; else goto coUI;
       coUH: // global
           if (%MO_S_Ge_W64(R1, 0)) goto coUE; else goto coUF;
       coUE: // global
           R2 = R1 >> _soMP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       coUF: // global
           R2 = -%MO_S_Shr_W64(-R1, _soMP::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       coUI: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _coUn() //  [R1]
         { info_tbl: [(coUn,
                       label: block_coUn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coUn: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.450329522 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt2_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt2_closure:
         const GHC.Types.D#_con_info;
         const 0.0 :: W64;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.450875455 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt1_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.451846265 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_info;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInt_entry() //  [R2]
         { info_tbl: [(coV2,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coV2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coV3; else goto coV4;
       coV3: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coV4: // global
           I64[Sp - 8] = block_coUZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoVs; else goto coV0;
       uoVs: // global
           call _coUZ(R1) args: 0, res: 0, upd: 0;
       coV0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coUZ() //  [R1]
         { info_tbl: [(coUZ,
                       label: block_coUZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coUZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto coV9; else goto coV8;
       coV9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coV8: // global
           _soMY::F64 = F64[R1 + 7];
           if (%MO_F_Eq_W64(_soMY::F64,
                            0.0 :: W64)) goto coVr; else goto coVq;
       coVr: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coVq: // global
           I64[Hp - 48] = GHC.Types.D#_con_info;
           _soN0::I64 = %MO_FS_Conv_W64_W64(_soMY::F64);
           F64[Hp - 40] = %MO_F_Sub_W64(_soMY::F64,
                                        %MO_SF_Conv_W64_W64(_soN0::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soN0::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.45348483 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInt_closure" {
     GHC.Float.RealFracMethods.floorDoubleInt_closure:
         const GHC.Float.RealFracMethods.floorDoubleInt_info;
 },
 GHC.Float.RealFracMethods.floorDoubleInt_entry() //  [R2]
         { info_tbl: [(coVA,
                       label: GHC.Float.RealFracMethods.floorDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coVA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coVB; else goto coVC;
       coVB: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coVC: // global
           I64[Sp - 8] = block_coVx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoW0; else goto coVy;
       uoW0: // global
           call _coVx(R1) args: 0, res: 0, upd: 0;
       coVy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coVx() //  [R1]
         { info_tbl: [(coVx,
                       label: block_coVx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coVx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coVH; else goto coVG;
       coVH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coVG: // global
           _soN7::F64 = F64[R1 + 7];
           _soN8::I64 = %MO_FS_Conv_W64_W64(_soN7::F64);
           if (%MO_F_Lt_W64(_soN7::F64,
                            %MO_SF_Conv_W64_W64(_soN8::I64))) goto coVZ; else goto coVT;
       coVZ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coVT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.455025486 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInt_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_info;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInt_entry() //  [R2]
         { info_tbl: [(coW8,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coW8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coW9; else goto coWa;
       coW9: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coWa: // global
           I64[Sp - 8] = block_coW5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoWy; else goto coW6;
       uoWy: // global
           call _coW5(R1) args: 0, res: 0, upd: 0;
       coW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coW5() //  [R1]
         { info_tbl: [(coW5,
                       label: block_coW5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coW5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coWf; else goto coWe;
       coWf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coWe: // global
           _soNe::F64 = F64[R1 + 7];
           _soNf::I64 = %MO_FS_Conv_W64_W64(_soNe::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_soNf::I64),
                            _soNe::F64)) goto coWx; else goto coWr;
       coWx: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       coWr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.456472143 UTC

[section ""data" . GHC.Float.RealFracMethods.double2Int_closure" {
     GHC.Float.RealFracMethods.double2Int_closure:
         const GHC.Float.RealFracMethods.double2Int_info;
 },
 GHC.Float.RealFracMethods.double2Int_entry() //  [R2]
         { info_tbl: [(coWG,
                       label: GHC.Float.RealFracMethods.double2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coWG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coWN; else goto coWO;
       coWN: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.double2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coWO: // global
           I64[Sp - 8] = block_coWD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoWS; else goto coWE;
       uoWS: // global
           call _coWD(R1) args: 0, res: 0, upd: 0;
       coWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coWD() //  [R1]
         { info_tbl: [(coWD,
                       label: block_coWD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coWD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coWR; else goto coWQ;
       coWR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coWQ: // global
           _soNm::I64 = %MO_FS_Conv_W64_W64(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.457842792 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Double_closure" {
     GHC.Float.RealFracMethods.int2Double_closure:
         const GHC.Float.RealFracMethods.int2Double_info;
 },
 GHC.Float.RealFracMethods.int2Double_entry() //  [R2]
         { info_tbl: [(coX0,
                       label: GHC.Float.RealFracMethods.int2Double_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coX0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coX7; else goto coX8;
       coX7: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Double_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coX8: // global
           I64[Sp - 8] = block_coWX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoXc; else goto coWY;
       uoXc: // global
           call _coWX(R1) args: 0, res: 0, upd: 0;
       coWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coWX() //  [R1]
         { info_tbl: [(coWX,
                       label: block_coWX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coWX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coXb; else goto coXa;
       coXb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coXa: // global
           _soNq::F64 = %MO_SF_Conv_W64_W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _soNq::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.459159403 UTC

[section ""data" . GHC.Float.RealFracMethods.float2Int_closure" {
     GHC.Float.RealFracMethods.float2Int_closure:
         const GHC.Float.RealFracMethods.float2Int_info;
 },
 GHC.Float.RealFracMethods.float2Int_entry() //  [R2]
         { info_tbl: [(coXk,
                       label: GHC.Float.RealFracMethods.float2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coXk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coXr; else goto coXs;
       coXr: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.float2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coXs: // global
           I64[Sp - 8] = block_coXh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoXw; else goto coXi;
       uoXw: // global
           call _coXh(R1) args: 0, res: 0, upd: 0;
       coXi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coXh() //  [R1]
         { info_tbl: [(coXh,
                       label: block_coXh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coXh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coXv; else goto coXu;
       coXv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coXu: // global
           _soNu::I64 = %MO_FS_Conv_W32_W64(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.460497628 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Float_closure" {
     GHC.Float.RealFracMethods.int2Float_closure:
         const GHC.Float.RealFracMethods.int2Float_info;
 },
 GHC.Float.RealFracMethods.int2Float_entry() //  [R2]
         { info_tbl: [(coXE,
                       label: GHC.Float.RealFracMethods.int2Float_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coXE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coXL; else goto coXM;
       coXL: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Float_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coXM: // global
           I64[Sp - 8] = block_coXB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoXQ; else goto coXC;
       uoXQ: // global
           call _coXB(R1) args: 0, res: 0, upd: 0;
       coXC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coXB() //  [R1]
         { info_tbl: [(coXB,
                       label: block_coXB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coXB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coXP; else goto coXO;
       coXP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coXO: // global
           _soNy::F32 = %MO_SF_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _soNy::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.461609343 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule4_bytes" {
     GHC.Float.RealFracMethods.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.462179763 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule3_closure" {
     GHC.Float.RealFracMethods.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.462789785 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule2_bytes" {
     GHC.Float.RealFracMethods.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,82,101,97,108,70,114,97,99,77,101,116,104,111,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.463354309 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule1_closure" {
     GHC.Float.RealFracMethods.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.463912331 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule_closure" {
     GHC.Float.RealFracMethods.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.RealFracMethods.$trModule3_closure+1;
         const GHC.Float.RealFracMethods.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.464809816 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInt_closure" {
     GHC.Float.RealFracMethods.roundDoubleInt_closure:
         const GHC.Float.RealFracMethods.roundDoubleInt_info;
 },
 GHC.Float.RealFracMethods.roundDoubleInt_entry() //  [R2]
         { info_tbl: [(coXY,
                       label: GHC.Float.RealFracMethods.roundDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coXY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coY7; else goto coY8;
       coY7: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coY8: // global
           I64[Sp - 8] = block_coXV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoYc; else goto coXW;
       uoYc: // global
           call _coXV(R1) args: 0, res: 0, upd: 0;
       coXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coXV() //  [R1]
         { info_tbl: [(coXV,
                       label: block_coXV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coXV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coYb; else goto coYa;
       coYb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coYa: // global
           (_soNF::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W64_W64(_soNF::F64);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.466371683 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInteger_closure" {
     GHC.Float.RealFracMethods.roundDoubleInteger_closure:
         const GHC.Float.RealFracMethods.roundDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.roundDoubleInteger_entry() //  [R2]
         { info_tbl: [(coYk,
                       label: GHC.Float.RealFracMethods.roundDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coYk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto coYl; else goto coYm;
       coYl: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coYm: // global
           I64[Sp - 8] = block_coYh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoYN; else goto coYi;
       uoYN: // global
           call _coYh(R1) args: 0, res: 0, upd: 0;
       coYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coYh() //  [R1]
         { info_tbl: [(coYh,
                       label: block_coYh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coYh: // global
           (_soNN::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Sp] = block_coYr_info;
           D1 = _soNN::F64;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _coYr() //  [R1, R2]
         { info_tbl: [(coYr,
                       label: block_coYr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coYr: // global
           if (%MO_S_Ge_W64(R2, 0)) goto coYA; else goto coYE;
       coYA: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       coYE: // global
           I64[Sp - 8] = block_coYD_info;
           _soNQ::I64 = R2;
           R2 = R1;
           I64[Sp] = _soNQ::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _coYD() //  [R1]
         { info_tbl: [(coYD,
                       label: block_coYD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coYD: // global
           R2 = %MO_S_Shr_W64(R1, -I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.468145668 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInteger_closure" {
     GHC.Float.RealFracMethods.roundFloatInteger_closure:
         const GHC.Float.RealFracMethods.roundFloatInteger_info;
 },
 GHC.Float.RealFracMethods.roundFloatInteger_entry() //  [R2]
         { info_tbl: [(coYV,
                       label: GHC.Float.RealFracMethods.roundFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coYV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto coYW; else goto coYX;
       coYW: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coYX: // global
           I64[Sp - 8] = block_coYS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoZo; else goto coYT;
       uoZo: // global
           call _coYS(R1) args: 0, res: 0, upd: 0;
       coYT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coYS() //  [R1]
         { info_tbl: [(coYS,
                       label: block_coYS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coYS: // global
           (_soO1::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Sp] = block_coZ2_info;
           F1 = _soO1::F32;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _coZ2() //  [R1, R2]
         { info_tbl: [(coZ2,
                       label: block_coZ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZ2: // global
           if (%MO_S_Ge_W64(R2, 0)) goto coZd; else goto coZi;
       coZd: // global
           I64[Sp - 8] = block_coZb_info;
           _soO4::I64 = R2;
           R2 = R1;
           I64[Sp] = _soO4::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       coZi: // global
           R2 = %MO_S_Shr_W64(R1, -R2);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _coZb() //  [R1]
         { info_tbl: [(coZb,
                       label: block_coZb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZb: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.469875461 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInt_closure" {
     GHC.Float.RealFracMethods.roundFloatInt_closure:
         const GHC.Float.RealFracMethods.roundFloatInt_info;
 },
 GHC.Float.RealFracMethods.roundFloatInt_entry() //  [R2]
         { info_tbl: [(coZw,
                       label: GHC.Float.RealFracMethods.roundFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto coZF; else goto coZG;
       coZF: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       coZG: // global
           I64[Sp - 8] = block_coZt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uoZK; else goto coZu;
       uoZK: // global
           call _coZt(R1) args: 0, res: 0, upd: 0;
       coZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coZt() //  [R1]
         { info_tbl: [(coZt,
                       label: block_coZt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto coZJ; else goto coZI;
       coZJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       coZI: // global
           (_soOf::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W32_W64(_soOf::F32);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.474000974 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInteger_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_info;
         const 0;
 },
 sat_soOo_entry() //  [R1]
         { info_tbl: [(cp05,
                       label: sat_soOo_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp05: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp06; else goto cp07;
       cp06: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp07: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOz_entry() //  [R1]
         { info_tbl: [(cp0w,
                       label: sat_soOz_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cp0K; else goto cp0L;
       cp0K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp0L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cp0B_info;
           R2 = I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]);
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cp0B() //  [R1]
         { info_tbl: [(cp0B,
                       label: block_cp0B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0B: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cp0F_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cp0F() //  [D1]
         { info_tbl: [(cp0F,
                       label: block_cp0F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cp0P; else goto cp0O;
       cp0P: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cp0O: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOu_entry() //  [R1]
         { info_tbl: [(cp0U,
                       label: sat_soOu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp0V; else goto cp0W;
       cp0V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp0W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOK_entry() //  [R1]
         { info_tbl: [(cp1g,
                       label: sat_soOK_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp1g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cp1x; else goto cp1y;
       cp1x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp1y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cp1o_info;
           R2 = -(I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]));
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cp1o() //  [R1]
         { info_tbl: [(cp1o,
                       label: block_cp1o_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp1o: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cp1s_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cp1s() //  [D1]
         { info_tbl: [(cp1s,
                       label: block_cp1s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp1s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cp1C; else goto cp1B;
       cp1C: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cp1B: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOE_entry() //  [R1]
         { info_tbl: [(cp1J,
                       label: sat_soOE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp1J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp1K; else goto cp1L;
       cp1K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp1L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionDoubleInteger_entry() //  [R2]
         { info_tbl: [(cp1M,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp1M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cp1N; else goto cp1O;
       cp1N: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp1O: // global
           I64[Sp - 8] = block_coZP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up2i; else goto coZQ;
       up2i: // global
           call _coZP(R1) args: 0, res: 0, upd: 0;
       coZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _coZP() //  [R1]
         { info_tbl: [(coZP,
                       label: block_coZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZP: // global
           I64[Sp - 8] = block_coZU_info;
           D1 = F64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _coZU() //  [R1, R2]
         { info_tbl: [(coZU,
                       label: block_coZU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZU: // global
           I64[Sp - 8] = R2;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call _coZV() args: 0, res: 0, upd: 0;
     }
 },
 _coZV() //  []
         { info_tbl: [(coZV,
                       label: block_coZV_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       coZV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cp1S; else goto cp1R;
       cp1S: // global
           HpAlloc = 56;
           I64[Sp] = block_coZV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cp1R: // global
           _soOl::P64 = P64[Sp + 16];
           _soOm::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soOm::I64, 0)) goto cp1V; else goto cp2f;
       cp1V: // global
           I64[Hp - 48] = sat_soOo_info;
           P64[Hp - 32] = _soOl::P64;
           I64[Hp - 24] = _soOm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cp2f: // global
           _soOp::I64 = -_soOm::I64;
           if (%MO_S_Le_W64(_soOp::I64, 52)) goto cp1X; else goto cp2e;
       cp1X: // global
           Hp = Hp - 56;
           I64[Sp] = block_cp0f_info;
           R3 = lvl_roLO_closure;
           R2 = _soOl::P64;
           I64[Sp + 24] = _soOp::I64;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cp2e: // global
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = lvl_roLO_closure;
           P64[Hp - 32] = P64[Sp + 24];
           _cp2d::P64 = Hp - 47;
           Hp = Hp - 32;
           R1 = _cp2d::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cp0f() //  [R1]
         { info_tbl: [(cp0f,
                       label: block_cp0f_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0f: // global
           _soOl::P64 = P64[Sp + 16];
           if (R1 == 1) goto cp27; else goto cp21;
       cp27: // global
           I64[Sp] = block_cp0Z_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cp21: // global
           I64[Sp] = block_cp0j_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp0Z() //  [R1]
         { info_tbl: [(cp0Z,
                       label: block_cp0Z_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0Z: // global
           I64[Sp] = block_cp13_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp13() //  [R1]
         { info_tbl: [(cp13,
                       label: block_cp13_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp13: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cp2b; else goto cp2a;
       cp2b: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cp2a: // global
           I64[Hp - 88] = sat_soOK_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOC::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOC::I64;
           I64[Hp - 40] = sat_soOE_info;
           I64[Hp - 24] = _soOC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cp0j() //  [R1]
         { info_tbl: [(cp0j,
                       label: block_cp0j_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp0j: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cp24; else goto cp23;
       cp24: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cp23: // global
           I64[Hp - 88] = sat_soOz_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOt::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOt::I64;
           I64[Hp - 40] = sat_soOu_info;
           I64[Hp - 24] = _soOt::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.47917986 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateDoubleInteger_closure" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_closure:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateDoubleInteger_entry() //  [R2]
         { info_tbl: [(cp2q,
                       label: GHC.Float.RealFracMethods.truncateDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp2q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cp2r; else goto cp2s;
       cp2r: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp2s: // global
           I64[Sp - 8] = block_cp2n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up3m; else goto cp2o;
       up3m: // global
           call _cp2n(R1) args: 0, res: 0, upd: 0;
       cp2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp2n() //  [R1]
         { info_tbl: [(cp2n,
                       label: block_cp2n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp2n: // global
           I64[Sp] = block_cp2v_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cp2v() //  [R1, R2]
         { info_tbl: [(cp2v,
                       label: block_cp2v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp2v: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cp2E; else goto cp3g;
       cp2E: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cp3g: // global
           _soOS::I64 = -R2;
           if (%MO_S_Le_W64(_soOS::I64, 52)) goto cp2P; else goto cp3f;
       cp2P: // global
           I64[Sp - 16] = block_cp2N_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           I64[Sp - 8] = _soOS::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cp3f: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cp2N() //  [R1]
         { info_tbl: [(cp2N,
                       label: block_cp2N_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp2N: // global
           _soOP::P64 = P64[Sp + 16];
           if (R1 == 1) goto cp39; else goto cp2W;
       cp39: // global
           I64[Sp] = block_cp33_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cp2W: // global
           I64[Sp] = block_cp2T_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp33() //  [R1]
         { info_tbl: [(cp33,
                       label: block_cp33_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp33: // global
           I64[Sp] = block_cp37_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp37() //  [R1]
         { info_tbl: [(cp37,
                       label: block_cp37_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp37: // global
           R2 = -%MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cp2T() //  [R1]
         { info_tbl: [(cp2T,
                       label: block_cp2T_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp2T: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.481009113 UTC

[section ""data" . sat_soP1_closure" {
     sat_soP1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.481663235 UTC

[section ""data" . sat_soP2_closure" {
     sat_soP2_closure:
         const :_con_info;
         const sat_soP1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.48244116 UTC

[section ""data" . lvl1_roLP_closure" {
     lvl1_roLP_closure:
         const lvl1_roLP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_roLP_entry() //  [R1]
         { info_tbl: [(cp3t,
                       label: lvl1_roLP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp3u; else goto cp3v;
       cp3u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp3v: // global
           (_cp3q::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cp3q::I64 == 0) goto cp3s; else goto cp3r;
       cp3s: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cp3r: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cp3q::I64;
           R3 = sat_soP2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.483811783 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInteger_closure" {
     GHC.Float.RealFracMethods.floorFloatInteger_closure:
         const GHC.Float.RealFracMethods.floorFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorFloatInteger_entry() //  [R2]
         { info_tbl: [(cp3D,
                       label: GHC.Float.RealFracMethods.floorFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp3D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp3E; else goto cp3F;
       cp3E: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp3F: // global
           I64[Sp - 8] = block_cp3A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up4g; else goto cp3B;
       up4g: // global
           call _cp3A(R1) args: 0, res: 0, upd: 0;
       cp3B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp3A() //  [R1]
         { info_tbl: [(cp3A,
                       label: block_cp3A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp3A: // global
           I64[Sp] = block_cp3I_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cp3I() //  [R1, R2]
         { info_tbl: [(cp3I,
                       label: block_cp3I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp3I: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cp3T; else goto cp4e;
       cp3T: // global
           I64[Sp - 8] = block_cp3R_info;
           _soP8::I64 = R2;
           R2 = R1;
           I64[Sp] = _soP8::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cp4e: // global
           _soPb::I64 = -R2;
           if (%MO_S_Le_W64(_soPb::I64, 23)) goto cp45; else goto cp4d;
       cp45: // global
           R2 = %MO_S_Shr_W64(R1, _soPb::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cp4d: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cp4b; else goto cp4c;
       cp4b: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cp4c: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cp3R() //  [R1]
         { info_tbl: [(cp3R,
                       label: block_cp3R_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp3R: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.485910374 UTC

[section ""data" . sat_soPf_closure" {
     sat_soPf_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.486475803 UTC

[section ""data" . sat_soPg_closure" {
     sat_soPg_closure:
         const :_con_info;
         const sat_soPf_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.487239381 UTC

[section ""data" . lvl2_roLQ_closure" {
     lvl2_roLQ_closure:
         const lvl2_roLQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_roLQ_entry() //  [R1]
         { info_tbl: [(cp4n,
                       label: lvl2_roLQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp4n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp4o; else goto cp4p;
       cp4o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp4p: // global
           (_cp4k::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cp4k::I64 == 0) goto cp4m; else goto cp4l;
       cp4m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cp4l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cp4k::I64;
           R3 = sat_soPg_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.488633206 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInteger_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingFloatInteger_entry() //  [R2]
         { info_tbl: [(cp4x,
                       label: GHC.Float.RealFracMethods.ceilingFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp4x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp4y; else goto cp4z;
       cp4y: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp4z: // global
           I64[Sp - 8] = block_cp4u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up5p; else goto cp4v;
       up5p: // global
           call _cp4u(R1) args: 0, res: 0, upd: 0;
       cp4v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp4u() //  [R1]
         { info_tbl: [(cp4u,
                       label: block_cp4u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp4u: // global
           I64[Sp] = block_cp4G_info;
           F1 = %MO_F_Neg_W32(F32[R1 + 7]);
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cp4G() //  [R1, R2]
         { info_tbl: [(cp4G,
                       label: block_cp4G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp4G: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cp4U; else goto cp5o;
       cp4U: // global
           I64[Sp - 8] = block_cp4O_info;
           _soPn::I64 = R2;
           R2 = R1;
           I64[Sp] = _soPn::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cp5o: // global
           _soPr::I64 = -R2;
           if (%MO_S_Le_W64(_soPr::I64, 23)) goto cp5c; else goto cp5n;
       cp5c: // global
           I64[Sp] = block_cp5a_info;
           R2 = %MO_S_Shr_W64(R1, _soPr::I64);
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cp5n: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cp5l; else goto cp5m;
       cp5l: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cp5m: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cp4O() //  [R1]
         { info_tbl: [(cp4O,
                       label: block_cp4O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp4O: // global
           _soPn::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cp4S_info;
           R3 = _soPn::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp4S() //  [R1]
         { info_tbl: [(cp4S,
                       label: block_cp4S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp4S: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cp5a() //  [R1]
         { info_tbl: [(cp5a,
                       label: block_cp5a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp5a: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.490794865 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInteger_closure" {
     GHC.Float.RealFracMethods.floorDoubleInteger_closure:
         const GHC.Float.RealFracMethods.floorDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorDoubleInteger_entry() //  [R2]
         { info_tbl: [(cp5x,
                       label: GHC.Float.RealFracMethods.floorDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp5x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp5y; else goto cp5z;
       cp5y: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp5z: // global
           I64[Sp - 8] = block_cp5u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up6g; else goto cp5v;
       up6g: // global
           call _cp5u(R1) args: 0, res: 0, upd: 0;
       cp5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp5u() //  [R1]
         { info_tbl: [(cp5u,
                       label: block_cp5u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp5u: // global
           I64[Sp] = block_cp5C_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cp5C() //  [R1, R2]
         { info_tbl: [(cp5C,
                       label: block_cp5C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp5C: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cp5L; else goto cp6e;
       cp5L: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cp6e: // global
           _soPD::I64 = -R2;
           if (%MO_S_Le_W64(_soPD::I64, 52)) goto cp5W; else goto cp63;
       cp5W: // global
           I64[Sp - 8] = block_cp5U_info;
           R2 = R1;
           I64[Sp] = _soPD::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cp63: // global
           I64[Sp] = block_cp62_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp5U() //  [R1]
         { info_tbl: [(cp5U,
                       label: block_cp5U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp5U: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cp62() //  [R1]
         { info_tbl: [(cp62,
                       label: block_cp62_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp62: // global
           if (R1 == 1) goto cp6d; else goto cp69;
       cp6d: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cp69: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.492876803 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInteger_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInteger_entry() //  [R2]
         { info_tbl: [(cp6o,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp6o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp6p; else goto cp6q;
       cp6p: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp6q: // global
           I64[Sp - 8] = block_cp6l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up7m; else goto cp6m;
       up7m: // global
           call _cp6l(R1) args: 0, res: 0, upd: 0;
       cp6m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp6l() //  [R1]
         { info_tbl: [(cp6l,
                       label: block_cp6l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp6l: // global
           I64[Sp] = block_cp6x_info;
           D1 = %MO_F_Neg_W64(F64[R1 + 7]);
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cp6x() //  [R1, R2]
         { info_tbl: [(cp6x,
                       label: block_cp6x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp6x: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cp6H; else goto cp7l;
       cp6H: // global
           I64[Sp] = block_cp6F_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       cp7l: // global
           _soPR::I64 = -R2;
           if (%MO_S_Le_W64(_soPR::I64, 52)) goto cp72; else goto cp7a;
       cp72: // global
           I64[Sp - 8] = block_cp6T_info;
           R2 = R1;
           I64[Sp] = _soPR::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cp7a: // global
           I64[Sp] = block_cp79_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp6F() //  [R1]
         { info_tbl: [(cp6F,
                       label: block_cp6F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp6F: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cp6T() //  [R1]
         { info_tbl: [(cp6T,
                       label: block_cp6T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp6T: // global
           _soPU::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cp70_info;
           R2 = _soPU::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cp70() //  [R1]
         { info_tbl: [(cp70,
                       label: block_cp70_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp70: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cp79() //  [R1]
         { info_tbl: [(cp79,
                       label: block_cp79_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp79: // global
           if (R1 == 1) goto cp7k; else goto cp7g;
       cp7k: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cp7g: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.494823575 UTC

[section ""relreadonly" . SoU1_srt" {
     SoU1_srt:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
         const lvl_roLO_closure;
         const GHC.Float.RealFracMethods.truncateFloatInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Float.RealFracMethods.roundDoubleInteger_closure;
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
         const GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
         const sat_soP2_closure;
         const GHC.Float.RealFracMethods.floorFloatInteger_closure;
         const lvl1_roLP_closure;
         const sat_soPg_closure;
         const GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
         const lvl2_roLQ_closure;
         const GHC.Float.RealFracMethods.floorDoubleInteger_closure;
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.495414531 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:02.495892121 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt3_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.496433382 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt2_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt2_closure:
         const GHC.Types.F#_con_info;
         const 0.0 :: W32;
         const 0 :: W32;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.496996831 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt1_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.49803725 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInt_info;
 },
 GHC.Float.RealFracMethods.properFractionFloatInt_entry() //  [R2]
         { info_tbl: [(cp7u,
                       label: GHC.Float.RealFracMethods.properFractionFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp7u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cp7v; else goto cp7w;
       cp7v: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp7w: // global
           I64[Sp - 8] = block_cp7r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up7U; else goto cp7s;
       up7U: // global
           call _cp7r(R1) args: 0, res: 0, upd: 0;
       cp7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp7r() //  [R1]
         { info_tbl: [(cp7r,
                       label: block_cp7r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp7r: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cp7B; else goto cp7A;
       cp7B: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cp7A: // global
           _soLU::F32 = F32[R1 + 7];
           if (%MO_F_Eq_W32(_soLU::F32,
                            0.0 :: W32)) goto cp7T; else goto cp7S;
       cp7T: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cp7S: // global
           I64[Hp - 48] = GHC.Types.F#_con_info;
           _soLW::I64 = %MO_FS_Conv_W32_W64(_soLU::F32);
           F32[Hp - 40] = %MO_F_Sub_W32(_soLU::F32,
                                        %MO_SF_Conv_W64_W32(_soLW::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soLW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.499591799 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInt_closure" {
     GHC.Float.RealFracMethods.floorFloatInt_closure:
         const GHC.Float.RealFracMethods.floorFloatInt_info;
 },
 GHC.Float.RealFracMethods.floorFloatInt_entry() //  [R2]
         { info_tbl: [(cp82,
                       label: GHC.Float.RealFracMethods.floorFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp82: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cp83; else goto cp84;
       cp83: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp84: // global
           I64[Sp - 8] = block_cp7Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up8s; else goto cp80;
       up8s: // global
           call _cp7Z(R1) args: 0, res: 0, upd: 0;
       cp80: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp7Z() //  [R1]
         { info_tbl: [(cp7Z,
                       label: block_cp7Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp7Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cp89; else goto cp88;
       cp89: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cp88: // global
           _soM3::F32 = F32[R1 + 7];
           _soM4::I64 = %MO_FS_Conv_W32_W64(_soM3::F32);
           if (%MO_F_Lt_W32(_soM3::F32,
                            %MO_SF_Conv_W64_W32(_soM4::I64))) goto cp8r; else goto cp8l;
       cp8r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cp8l: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.501094887 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInt_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInt_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInt_info;
 },
 GHC.Float.RealFracMethods.ceilingFloatInt_entry() //  [R2]
         { info_tbl: [(cp8A,
                       label: GHC.Float.RealFracMethods.ceilingFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp8A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cp8B; else goto cp8C;
       cp8B: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cp8C: // global
           I64[Sp - 8] = block_cp8x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto up90; else goto cp8y;
       up90: // global
           call _cp8x(R1) args: 0, res: 0, upd: 0;
       cp8y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp8x() //  [R1]
         { info_tbl: [(cp8x,
                       label: block_cp8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp8x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cp8H; else goto cp8G;
       cp8H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cp8G: // global
           _soMa::F32 = F32[R1 + 7];
           _soMb::I64 = %MO_FS_Conv_W32_W64(_soMa::F32);
           if (%MO_F_Lt_W32(%MO_SF_Conv_W64_W32(_soMb::I64),
                            _soMa::F32)) goto cp8Z; else goto cp8T;
       cp8Z: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cp8T: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.502527103 UTC

[section ""data" . lvl_roLO_closure" {
     lvl_roLO_closure:
         const lvl_roLO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_roLO_entry() //  [R1]
         { info_tbl: [(cp97,
                       label: lvl_roLO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp97: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cp98; else goto cp99;
       cp98: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp99: // global
           (_cp94::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cp94::I64 == 0) goto cp96; else goto cp95;
       cp96: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cp95: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cp94::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.505119215 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInteger_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_info;
         const 0;
 },
 sat_soMn_entry() //  [R1]
         { info_tbl: [(cp9w,
                       label: sat_soMn_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp9w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cp9x; else goto cp9y;
       cp9x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cp9y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cp9u_info;
           R2 = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cp9u() //  [R1]
         { info_tbl: [(cp9u,
                       label: block_cp9u_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp9u: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMx_entry() //  [R1]
         { info_tbl: [(cp9V,
                       label: sat_soMx_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp9V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpa9; else goto cpaa;
       cpa9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpaa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpa0_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpa0() //  [R1]
         { info_tbl: [(cpa0,
                       label: block_cpa0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpa0: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpa4_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpa4() //  [F1]
         { info_tbl: [(cpa4,
                       label: block_cpa4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpa4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpae; else goto cpad;
       cpae: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpad: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMs_entry() //  [R1]
         { info_tbl: [(cpaj,
                       label: sat_soMs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpaj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpak; else goto cpal;
       cpak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpal: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMG_entry() //  [R1]
         { info_tbl: [(cpaC,
                       label: sat_soMG_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpaC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpaQ; else goto cpaR;
       cpaQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpaR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpaH_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpaH() //  [R1]
         { info_tbl: [(cpaH,
                       label: block_cpaH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpaH: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpaL_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpaL() //  [F1]
         { info_tbl: [(cpaL,
                       label: block_cpaL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpaL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpaV; else goto cpaU;
       cpaV: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpaU: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMB_entry() //  [R1]
         { info_tbl: [(cpb0,
                       label: sat_soMB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpb0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpb1; else goto cpb2;
       cpb1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionFloatInteger_entry() //  [R2]
         { info_tbl: [(cpb3,
                       label: GHC.Float.RealFracMethods.properFractionFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpb3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpb4; else goto cpb5;
       cpb4: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpb5: // global
           I64[Sp - 8] = block_cp9e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upbq; else goto cp9f;
       upbq: // global
           call _cp9e(R1) args: 0, res: 0, upd: 0;
       cp9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cp9e() //  [R1]
         { info_tbl: [(cp9e,
                       label: block_cp9e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp9e: // global
           I64[Sp - 8] = block_cp9j_info;
           F1 = F32[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cp9j() //  [R1, R2]
         { info_tbl: [(cp9j,
                       label: block_cp9j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp9j: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cp9k() args: 0, res: 0, upd: 0;
     }
 },
 _cp9k() //  []
         { info_tbl: [(cp9k,
                       label: block_cp9k_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cp9k: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpb9; else goto cpb8;
       cpb9: // global
           HpAlloc = 96;
           I64[Sp] = block_cp9k_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cpb8: // global
           _soMj::I64 = I64[Sp + 16];
           _soMk::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soMk::I64, 0)) goto cpbc; else goto cpbn;
       cpbc: // global
           I64[Hp - 88] = sat_soMn_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = (,)_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
           _cpba::P64 = Hp - 55;
           Hp = Hp - 40;
           R1 = _cpba::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpbn: // global
           _soMo::I64 = -_soMk::I64;
           if (%MO_S_Le_W64(_soMo::I64, 23)) goto cpbj; else goto cpbm;
       cpbj: // global
           if (%MO_S_Ge_W64(_soMj::I64, 0)) goto cpbf; else goto cpbh;
       cpbf: // global
           I64[Hp - 88] = sat_soMx_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMr::I64 = _soMj::I64 >> _soMo::I64;
           I64[Hp - 48] = _soMr::I64;
           I64[Hp - 40] = sat_soMs_info;
           I64[Hp - 24] = _soMr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpbh: // global
           I64[Hp - 88] = sat_soMG_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMy::I64 = -%MO_S_Shr_W64(-_soMj::I64, _soMo::I64);
           I64[Hp - 48] = _soMy::I64;
           I64[Hp - 40] = sat_soMB_info;
           I64[Hp - 24] = _soMy::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpbm: // global
           I64[Hp - 88] = (,)_con_info;
           P64[Hp - 80] = lvl_roLO_closure;
           P64[Hp - 72] = P64[Sp + 24];
           _cpbl::P64 = Hp - 87;
           Hp = Hp - 72;
           R1 = _cpbl::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.511031536 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateFloatInteger_closure" {
     GHC.Float.RealFracMethods.truncateFloatInteger_closure:
         const GHC.Float.RealFracMethods.truncateFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateFloatInteger_entry() //  [R2]
         { info_tbl: [(cpby,
                       label: GHC.Float.RealFracMethods.truncateFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpby: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpbz; else goto cpbA;
       cpbz: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpbA: // global
           I64[Sp - 8] = block_cpbv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upcj; else goto cpbw;
       upcj: // global
           call _cpbv(R1) args: 0, res: 0, upd: 0;
       cpbw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpbv() //  [R1]
         { info_tbl: [(cpbv,
                       label: block_cpbv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpbv: // global
           I64[Sp] = block_cpbD_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpbD() //  [R1, R2]
         { info_tbl: [(cpbD,
                       label: block_cpbD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpbD: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpbO; else goto cpc8;
       cpbO: // global
           I64[Sp - 8] = block_cpbM_info;
           _soMM::I64 = R2;
           R2 = R1;
           I64[Sp] = _soMM::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpc8: // global
           _soMP::I64 = -R2;
           if (%MO_S_Le_W64(_soMP::I64, 23)) goto cpc6; else goto cpc7;
       cpc6: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpc3; else goto cpc4;
       cpc3: // global
           R2 = R1 >> _soMP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpc4: // global
           R2 = -%MO_S_Shr_W64(-R1, _soMP::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpc7: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpbM() //  [R1]
         { info_tbl: [(cpbM,
                       label: block_cpbM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpbM: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.512503662 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt2_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt2_closure:
         const GHC.Types.D#_con_info;
         const 0.0 :: W64;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.513081358 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt1_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.514393984 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_info;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInt_entry() //  [R2]
         { info_tbl: [(cpcr,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpcr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpcs; else goto cpct;
       cpcs: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpct: // global
           I64[Sp - 8] = block_cpco_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upcR; else goto cpcp;
       upcR: // global
           call _cpco(R1) args: 0, res: 0, upd: 0;
       cpcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpco() //  [R1]
         { info_tbl: [(cpco,
                       label: block_cpco_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpco: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpcy; else goto cpcx;
       cpcy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpcx: // global
           _soMY::F64 = F64[R1 + 7];
           if (%MO_F_Eq_W64(_soMY::F64,
                            0.0 :: W64)) goto cpcQ; else goto cpcP;
       cpcQ: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpcP: // global
           I64[Hp - 48] = GHC.Types.D#_con_info;
           _soN0::I64 = %MO_FS_Conv_W64_W64(_soMY::F64);
           F64[Hp - 40] = %MO_F_Sub_W64(_soMY::F64,
                                        %MO_SF_Conv_W64_W64(_soN0::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soN0::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.516001865 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInt_closure" {
     GHC.Float.RealFracMethods.floorDoubleInt_closure:
         const GHC.Float.RealFracMethods.floorDoubleInt_info;
 },
 GHC.Float.RealFracMethods.floorDoubleInt_entry() //  [R2]
         { info_tbl: [(cpcZ,
                       label: GHC.Float.RealFracMethods.floorDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpcZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpd0; else goto cpd1;
       cpd0: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpd1: // global
           I64[Sp - 8] = block_cpcW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto updp; else goto cpcX;
       updp: // global
           call _cpcW(R1) args: 0, res: 0, upd: 0;
       cpcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpcW() //  [R1]
         { info_tbl: [(cpcW,
                       label: block_cpcW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpcW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpd6; else goto cpd5;
       cpd6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpd5: // global
           _soN7::F64 = F64[R1 + 7];
           _soN8::I64 = %MO_FS_Conv_W64_W64(_soN7::F64);
           if (%MO_F_Lt_W64(_soN7::F64,
                            %MO_SF_Conv_W64_W64(_soN8::I64))) goto cpdo; else goto cpdi;
       cpdo: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpdi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.517551105 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInt_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_info;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInt_entry() //  [R2]
         { info_tbl: [(cpdx,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpdx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpdy; else goto cpdz;
       cpdy: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpdz: // global
           I64[Sp - 8] = block_cpdu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto updX; else goto cpdv;
       updX: // global
           call _cpdu(R1) args: 0, res: 0, upd: 0;
       cpdv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpdu() //  [R1]
         { info_tbl: [(cpdu,
                       label: block_cpdu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpdu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpdE; else goto cpdD;
       cpdE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpdD: // global
           _soNe::F64 = F64[R1 + 7];
           _soNf::I64 = %MO_FS_Conv_W64_W64(_soNe::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_soNf::I64),
                            _soNe::F64)) goto cpdW; else goto cpdQ;
       cpdW: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpdQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.518943049 UTC

[section ""data" . GHC.Float.RealFracMethods.double2Int_closure" {
     GHC.Float.RealFracMethods.double2Int_closure:
         const GHC.Float.RealFracMethods.double2Int_info;
 },
 GHC.Float.RealFracMethods.double2Int_entry() //  [R2]
         { info_tbl: [(cpe5,
                       label: GHC.Float.RealFracMethods.double2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpe5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpec; else goto cped;
       cpec: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.double2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cped: // global
           I64[Sp - 8] = block_cpe2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upeh; else goto cpe3;
       upeh: // global
           call _cpe2(R1) args: 0, res: 0, upd: 0;
       cpe3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpe2() //  [R1]
         { info_tbl: [(cpe2,
                       label: block_cpe2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpe2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpeg; else goto cpef;
       cpeg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpef: // global
           _soNm::I64 = %MO_FS_Conv_W64_W64(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.520314686 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Double_closure" {
     GHC.Float.RealFracMethods.int2Double_closure:
         const GHC.Float.RealFracMethods.int2Double_info;
 },
 GHC.Float.RealFracMethods.int2Double_entry() //  [R2]
         { info_tbl: [(cpep,
                       label: GHC.Float.RealFracMethods.int2Double_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpep: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpew; else goto cpex;
       cpew: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Double_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpex: // global
           I64[Sp - 8] = block_cpem_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upeB; else goto cpen;
       upeB: // global
           call _cpem(R1) args: 0, res: 0, upd: 0;
       cpen: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpem() //  [R1]
         { info_tbl: [(cpem,
                       label: block_cpem_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpem: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpeA; else goto cpez;
       cpeA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpez: // global
           _soNq::F64 = %MO_SF_Conv_W64_W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _soNq::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.521700726 UTC

[section ""data" . GHC.Float.RealFracMethods.float2Int_closure" {
     GHC.Float.RealFracMethods.float2Int_closure:
         const GHC.Float.RealFracMethods.float2Int_info;
 },
 GHC.Float.RealFracMethods.float2Int_entry() //  [R2]
         { info_tbl: [(cpeJ,
                       label: GHC.Float.RealFracMethods.float2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpeJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpeQ; else goto cpeR;
       cpeQ: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.float2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpeR: // global
           I64[Sp - 8] = block_cpeG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upeV; else goto cpeH;
       upeV: // global
           call _cpeG(R1) args: 0, res: 0, upd: 0;
       cpeH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpeG() //  [R1]
         { info_tbl: [(cpeG,
                       label: block_cpeG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpeG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpeU; else goto cpeT;
       cpeU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpeT: // global
           _soNu::I64 = %MO_FS_Conv_W32_W64(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.52306774 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Float_closure" {
     GHC.Float.RealFracMethods.int2Float_closure:
         const GHC.Float.RealFracMethods.int2Float_info;
 },
 GHC.Float.RealFracMethods.int2Float_entry() //  [R2]
         { info_tbl: [(cpf3,
                       label: GHC.Float.RealFracMethods.int2Float_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpf3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpfa; else goto cpfb;
       cpfa: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Float_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpfb: // global
           I64[Sp - 8] = block_cpf0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upff; else goto cpf1;
       upff: // global
           call _cpf0(R1) args: 0, res: 0, upd: 0;
       cpf1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpf0() //  [R1]
         { info_tbl: [(cpf0,
                       label: block_cpf0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpf0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpfe; else goto cpfd;
       cpfe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpfd: // global
           _soNy::F32 = %MO_SF_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _soNy::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.524140151 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule4_bytes" {
     GHC.Float.RealFracMethods.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.524721203 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule3_closure" {
     GHC.Float.RealFracMethods.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.525337729 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule2_bytes" {
     GHC.Float.RealFracMethods.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,82,101,97,108,70,114,97,99,77,101,116,104,111,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.525891261 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule1_closure" {
     GHC.Float.RealFracMethods.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.526474019 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule_closure" {
     GHC.Float.RealFracMethods.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.RealFracMethods.$trModule3_closure+1;
         const GHC.Float.RealFracMethods.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.52740535 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInt_closure" {
     GHC.Float.RealFracMethods.roundDoubleInt_closure:
         const GHC.Float.RealFracMethods.roundDoubleInt_info;
 },
 GHC.Float.RealFracMethods.roundDoubleInt_entry() //  [R2]
         { info_tbl: [(cpfn,
                       label: GHC.Float.RealFracMethods.roundDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpfn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpfw; else goto cpfx;
       cpfw: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpfx: // global
           I64[Sp - 8] = block_cpfk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upfB; else goto cpfl;
       upfB: // global
           call _cpfk(R1) args: 0, res: 0, upd: 0;
       cpfl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpfk() //  [R1]
         { info_tbl: [(cpfk,
                       label: block_cpfk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpfk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpfA; else goto cpfz;
       cpfA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpfz: // global
           (_soNF::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W64_W64(_soNF::F64);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.528985508 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInteger_closure" {
     GHC.Float.RealFracMethods.roundDoubleInteger_closure:
         const GHC.Float.RealFracMethods.roundDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.roundDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpfJ,
                       label: GHC.Float.RealFracMethods.roundDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpfJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpfK; else goto cpfL;
       cpfK: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpfL: // global
           I64[Sp - 8] = block_cpfG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upgc; else goto cpfH;
       upgc: // global
           call _cpfG(R1) args: 0, res: 0, upd: 0;
       cpfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpfG() //  [R1]
         { info_tbl: [(cpfG,
                       label: block_cpfG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpfG: // global
           (_soNN::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Sp] = block_cpfQ_info;
           D1 = _soNN::F64;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpfQ() //  [R1, R2]
         { info_tbl: [(cpfQ,
                       label: block_cpfQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpfQ: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpfZ; else goto cpg3;
       cpfZ: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpg3: // global
           I64[Sp - 8] = block_cpg2_info;
           _soNQ::I64 = R2;
           R2 = R1;
           I64[Sp] = _soNQ::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpg2() //  [R1]
         { info_tbl: [(cpg2,
                       label: block_cpg2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpg2: // global
           R2 = %MO_S_Shr_W64(R1, -I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.531077374 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInteger_closure" {
     GHC.Float.RealFracMethods.roundFloatInteger_closure:
         const GHC.Float.RealFracMethods.roundFloatInteger_info;
 },
 GHC.Float.RealFracMethods.roundFloatInteger_entry() //  [R2]
         { info_tbl: [(cpgk,
                       label: GHC.Float.RealFracMethods.roundFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpgk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpgl; else goto cpgm;
       cpgl: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpgm: // global
           I64[Sp - 8] = block_cpgh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upgN; else goto cpgi;
       upgN: // global
           call _cpgh(R1) args: 0, res: 0, upd: 0;
       cpgi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpgh() //  [R1]
         { info_tbl: [(cpgh,
                       label: block_cpgh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpgh: // global
           (_soO1::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Sp] = block_cpgr_info;
           F1 = _soO1::F32;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpgr() //  [R1, R2]
         { info_tbl: [(cpgr,
                       label: block_cpgr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpgr: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpgC; else goto cpgH;
       cpgC: // global
           I64[Sp - 8] = block_cpgA_info;
           _soO4::I64 = R2;
           R2 = R1;
           I64[Sp] = _soO4::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpgH: // global
           R2 = %MO_S_Shr_W64(R1, -R2);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpgA() //  [R1]
         { info_tbl: [(cpgA,
                       label: block_cpgA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpgA: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.532711213 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInt_closure" {
     GHC.Float.RealFracMethods.roundFloatInt_closure:
         const GHC.Float.RealFracMethods.roundFloatInt_info;
 },
 GHC.Float.RealFracMethods.roundFloatInt_entry() //  [R2]
         { info_tbl: [(cpgV,
                       label: GHC.Float.RealFracMethods.roundFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpgV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cph4; else goto cph5;
       cph4: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cph5: // global
           I64[Sp - 8] = block_cpgS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uph9; else goto cpgT;
       uph9: // global
           call _cpgS(R1) args: 0, res: 0, upd: 0;
       cpgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpgS() //  [R1]
         { info_tbl: [(cpgS,
                       label: block_cpgS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpgS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cph8; else goto cph7;
       cph8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cph7: // global
           (_soOf::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W32_W64(_soOf::F32);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.535690922 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInteger_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_info;
         const 0;
 },
 sat_soOo_entry() //  [R1]
         { info_tbl: [(cphu,
                       label: sat_soOo_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cphv; else goto cphw;
       cphv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cphw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOz_entry() //  [R1]
         { info_tbl: [(cphV,
                       label: sat_soOz_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpi9; else goto cpia;
       cpi9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpi0_info;
           R2 = I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]);
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpi0() //  [R1]
         { info_tbl: [(cpi0,
                       label: block_cpi0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpi0: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpi4_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpi4() //  [D1]
         { info_tbl: [(cpi4,
                       label: block_cpi4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpi4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpie; else goto cpid;
       cpie: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cpid: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOu_entry() //  [R1]
         { info_tbl: [(cpij,
                       label: sat_soOu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpij: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpik; else goto cpil;
       cpik: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpil: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOK_entry() //  [R1]
         { info_tbl: [(cpiF,
                       label: sat_soOK_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpiF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpiW; else goto cpiX;
       cpiW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpiX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpiN_info;
           R2 = -(I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]));
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpiN() //  [R1]
         { info_tbl: [(cpiN,
                       label: block_cpiN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpiN: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpiR_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpiR() //  [D1]
         { info_tbl: [(cpiR,
                       label: block_cpiR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpiR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpj1; else goto cpj0;
       cpj1: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cpj0: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOE_entry() //  [R1]
         { info_tbl: [(cpj8,
                       label: sat_soOE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpj8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpj9; else goto cpja;
       cpj9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpja: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpjb,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpjb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpjc; else goto cpjd;
       cpjc: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpjd: // global
           I64[Sp - 8] = block_cphe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upjH; else goto cphf;
       upjH: // global
           call _cphe(R1) args: 0, res: 0, upd: 0;
       cphf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cphe() //  [R1]
         { info_tbl: [(cphe,
                       label: block_cphe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphe: // global
           I64[Sp - 8] = block_cphj_info;
           D1 = F64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cphj() //  [R1, R2]
         { info_tbl: [(cphj,
                       label: block_cphj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphj: // global
           I64[Sp - 8] = R2;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call _cphk() args: 0, res: 0, upd: 0;
     }
 },
 _cphk() //  []
         { info_tbl: [(cphk,
                       label: block_cphk_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpjh; else goto cpjg;
       cpjh: // global
           HpAlloc = 56;
           I64[Sp] = block_cphk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cpjg: // global
           _soOl::P64 = P64[Sp + 16];
           _soOm::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soOm::I64, 0)) goto cpjk; else goto cpjE;
       cpjk: // global
           I64[Hp - 48] = sat_soOo_info;
           P64[Hp - 32] = _soOl::P64;
           I64[Hp - 24] = _soOm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpjE: // global
           _soOp::I64 = -_soOm::I64;
           if (%MO_S_Le_W64(_soOp::I64, 52)) goto cpjm; else goto cpjD;
       cpjm: // global
           Hp = Hp - 56;
           I64[Sp] = block_cphE_info;
           R3 = lvl_roLO_closure;
           R2 = _soOl::P64;
           I64[Sp + 24] = _soOp::I64;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cpjD: // global
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = lvl_roLO_closure;
           P64[Hp - 32] = P64[Sp + 24];
           _cpjC::P64 = Hp - 47;
           Hp = Hp - 32;
           R1 = _cpjC::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cphE() //  [R1]
         { info_tbl: [(cphE,
                       label: block_cphE_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphE: // global
           _soOl::P64 = P64[Sp + 16];
           if (R1 == 1) goto cpjw; else goto cpjq;
       cpjw: // global
           I64[Sp] = block_cpio_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpjq: // global
           I64[Sp] = block_cphI_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpio() //  [R1]
         { info_tbl: [(cpio,
                       label: block_cpio_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpio: // global
           I64[Sp] = block_cpis_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpis() //  [R1]
         { info_tbl: [(cpis,
                       label: block_cpis_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpis: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpjA; else goto cpjz;
       cpjA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cpjz: // global
           I64[Hp - 88] = sat_soOK_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOC::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOC::I64;
           I64[Hp - 40] = sat_soOE_info;
           I64[Hp - 24] = _soOC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cphI() //  [R1]
         { info_tbl: [(cphI,
                       label: block_cphI_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cphI: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpjt; else goto cpjs;
       cpjt: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cpjs: // global
           I64[Hp - 88] = sat_soOz_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOt::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOt::I64;
           I64[Hp - 40] = sat_soOu_info;
           I64[Hp - 24] = _soOt::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.542518565 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateDoubleInteger_closure" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_closure:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpjP,
                       label: GHC.Float.RealFracMethods.truncateDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpjP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cpjQ; else goto cpjR;
       cpjQ: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpjR: // global
           I64[Sp - 8] = block_cpjM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upkL; else goto cpjN;
       upkL: // global
           call _cpjM(R1) args: 0, res: 0, upd: 0;
       cpjN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpjM() //  [R1]
         { info_tbl: [(cpjM,
                       label: block_cpjM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpjM: // global
           I64[Sp] = block_cpjU_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpjU() //  [R1, R2]
         { info_tbl: [(cpjU,
                       label: block_cpjU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpjU: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpk3; else goto cpkF;
       cpk3: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpkF: // global
           _soOS::I64 = -R2;
           if (%MO_S_Le_W64(_soOS::I64, 52)) goto cpke; else goto cpkE;
       cpke: // global
           I64[Sp - 16] = block_cpkc_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           I64[Sp - 8] = _soOS::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cpkE: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpkc() //  [R1]
         { info_tbl: [(cpkc,
                       label: block_cpkc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpkc: // global
           _soOP::P64 = P64[Sp + 16];
           if (R1 == 1) goto cpky; else goto cpkl;
       cpky: // global
           I64[Sp] = block_cpks_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpkl: // global
           I64[Sp] = block_cpki_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpks() //  [R1]
         { info_tbl: [(cpks,
                       label: block_cpks_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpks: // global
           I64[Sp] = block_cpkw_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpkw() //  [R1]
         { info_tbl: [(cpkw,
                       label: block_cpkw_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpkw: // global
           R2 = -%MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpki() //  [R1]
         { info_tbl: [(cpki,
                       label: block_cpki_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpki: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.54444136 UTC

[section ""data" . sat_soP1_closure" {
     sat_soP1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.544981526 UTC

[section ""data" . sat_soP2_closure" {
     sat_soP2_closure:
         const :_con_info;
         const sat_soP1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.545812932 UTC

[section ""data" . lvl1_roLP_closure" {
     lvl1_roLP_closure:
         const lvl1_roLP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_roLP_entry() //  [R1]
         { info_tbl: [(cpkS,
                       label: lvl1_roLP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpkS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpkT; else goto cpkU;
       cpkT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpkU: // global
           (_cpkP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpkP::I64 == 0) goto cpkR; else goto cpkQ;
       cpkR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpkQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpkP::I64;
           R3 = sat_soP2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.547172838 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInteger_closure" {
     GHC.Float.RealFracMethods.floorFloatInteger_closure:
         const GHC.Float.RealFracMethods.floorFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorFloatInteger_entry() //  [R2]
         { info_tbl: [(cpl2,
                       label: GHC.Float.RealFracMethods.floorFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpl2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpl3; else goto cpl4;
       cpl3: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpl4: // global
           I64[Sp - 8] = block_cpkZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uplF; else goto cpl0;
       uplF: // global
           call _cpkZ(R1) args: 0, res: 0, upd: 0;
       cpl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpkZ() //  [R1]
         { info_tbl: [(cpkZ,
                       label: block_cpkZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpkZ: // global
           I64[Sp] = block_cpl7_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpl7() //  [R1, R2]
         { info_tbl: [(cpl7,
                       label: block_cpl7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpl7: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpli; else goto cplD;
       cpli: // global
           I64[Sp - 8] = block_cplg_info;
           _soP8::I64 = R2;
           R2 = R1;
           I64[Sp] = _soP8::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cplD: // global
           _soPb::I64 = -R2;
           if (%MO_S_Le_W64(_soPb::I64, 23)) goto cplu; else goto cplC;
       cplu: // global
           R2 = %MO_S_Shr_W64(R1, _soPb::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cplC: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cplA; else goto cplB;
       cplA: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cplB: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cplg() //  [R1]
         { info_tbl: [(cplg,
                       label: block_cplg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cplg: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.548645063 UTC

[section ""data" . sat_soPf_closure" {
     sat_soPf_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.549287591 UTC

[section ""data" . sat_soPg_closure" {
     sat_soPg_closure:
         const :_con_info;
         const sat_soPf_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.550071846 UTC

[section ""data" . lvl2_roLQ_closure" {
     lvl2_roLQ_closure:
         const lvl2_roLQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_roLQ_entry() //  [R1]
         { info_tbl: [(cplM,
                       label: lvl2_roLQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cplM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cplN; else goto cplO;
       cplN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cplO: // global
           (_cplJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cplJ::I64 == 0) goto cplL; else goto cplK;
       cplL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cplK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cplJ::I64;
           R3 = sat_soPg_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.551522506 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInteger_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingFloatInteger_entry() //  [R2]
         { info_tbl: [(cplW,
                       label: GHC.Float.RealFracMethods.ceilingFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cplW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cplX; else goto cplY;
       cplX: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cplY: // global
           I64[Sp - 8] = block_cplT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upmO; else goto cplU;
       upmO: // global
           call _cplT(R1) args: 0, res: 0, upd: 0;
       cplU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cplT() //  [R1]
         { info_tbl: [(cplT,
                       label: block_cplT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cplT: // global
           I64[Sp] = block_cpm5_info;
           F1 = %MO_F_Neg_W32(F32[R1 + 7]);
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpm5() //  [R1, R2]
         { info_tbl: [(cpm5,
                       label: block_cpm5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpm5: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpmj; else goto cpmN;
       cpmj: // global
           I64[Sp - 8] = block_cpmd_info;
           _soPn::I64 = R2;
           R2 = R1;
           I64[Sp] = _soPn::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpmN: // global
           _soPr::I64 = -R2;
           if (%MO_S_Le_W64(_soPr::I64, 23)) goto cpmB; else goto cpmM;
       cpmB: // global
           I64[Sp] = block_cpmz_info;
           R2 = %MO_S_Shr_W64(R1, _soPr::I64);
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpmM: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpmK; else goto cpmL;
       cpmK: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpmL: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpmd() //  [R1]
         { info_tbl: [(cpmd,
                       label: block_cpmd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpmd: // global
           _soPn::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpmh_info;
           R3 = _soPn::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpmh() //  [R1]
         { info_tbl: [(cpmh,
                       label: block_cpmh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpmh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpmz() //  [R1]
         { info_tbl: [(cpmz,
                       label: block_cpmz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpmz: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.553755706 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInteger_closure" {
     GHC.Float.RealFracMethods.floorDoubleInteger_closure:
         const GHC.Float.RealFracMethods.floorDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpmW,
                       label: GHC.Float.RealFracMethods.floorDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpmW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpmX; else goto cpmY;
       cpmX: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpmY: // global
           I64[Sp - 8] = block_cpmT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upnF; else goto cpmU;
       upnF: // global
           call _cpmT(R1) args: 0, res: 0, upd: 0;
       cpmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpmT() //  [R1]
         { info_tbl: [(cpmT,
                       label: block_cpmT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpmT: // global
           I64[Sp] = block_cpn1_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpn1() //  [R1, R2]
         { info_tbl: [(cpn1,
                       label: block_cpn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpn1: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpna; else goto cpnD;
       cpna: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpnD: // global
           _soPD::I64 = -R2;
           if (%MO_S_Le_W64(_soPD::I64, 52)) goto cpnl; else goto cpns;
       cpnl: // global
           I64[Sp - 8] = block_cpnj_info;
           R2 = R1;
           I64[Sp] = _soPD::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cpns: // global
           I64[Sp] = block_cpnr_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpnj() //  [R1]
         { info_tbl: [(cpnj,
                       label: block_cpnj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpnj: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpnr() //  [R1]
         { info_tbl: [(cpnr,
                       label: block_cpnr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpnr: // global
           if (R1 == 1) goto cpnC; else goto cpny;
       cpnC: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpny: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.555903075 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInteger_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpnN,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpnN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpnO; else goto cpnP;
       cpnO: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpnP: // global
           I64[Sp - 8] = block_cpnK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upoL; else goto cpnL;
       upoL: // global
           call _cpnK(R1) args: 0, res: 0, upd: 0;
       cpnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpnK() //  [R1]
         { info_tbl: [(cpnK,
                       label: block_cpnK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpnK: // global
           I64[Sp] = block_cpnW_info;
           D1 = %MO_F_Neg_W64(F64[R1 + 7]);
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpnW() //  [R1, R2]
         { info_tbl: [(cpnW,
                       label: block_cpnW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpnW: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpo6; else goto cpoK;
       cpo6: // global
           I64[Sp] = block_cpo4_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       cpoK: // global
           _soPR::I64 = -R2;
           if (%MO_S_Le_W64(_soPR::I64, 52)) goto cpor; else goto cpoz;
       cpor: // global
           I64[Sp - 8] = block_cpoi_info;
           R2 = R1;
           I64[Sp] = _soPR::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cpoz: // global
           I64[Sp] = block_cpoy_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpo4() //  [R1]
         { info_tbl: [(cpo4,
                       label: block_cpo4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpo4: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpoi() //  [R1]
         { info_tbl: [(cpoi,
                       label: block_cpoi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpoi: // global
           _soPU::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cpop_info;
           R2 = _soPU::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpop() //  [R1]
         { info_tbl: [(cpop,
                       label: block_cpop_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpop: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpoy() //  [R1]
         { info_tbl: [(cpoy,
                       label: block_cpoy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpoy: // global
           if (R1 == 1) goto cpoJ; else goto cpoF;
       cpoJ: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpoF: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.557725828 UTC

[section ""relreadonly" . SoU1_srt" {
     SoU1_srt:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
         const lvl_roLO_closure;
         const GHC.Float.RealFracMethods.truncateFloatInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Float.RealFracMethods.roundDoubleInteger_closure;
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
         const GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
         const sat_soP2_closure;
         const GHC.Float.RealFracMethods.floorFloatInteger_closure;
         const lvl1_roLP_closure;
         const sat_soPg_closure;
         const GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
         const lvl2_roLQ_closure;
         const GHC.Float.RealFracMethods.floorDoubleInteger_closure;
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.558571761 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:02.559783543 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt3_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.561762115 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt2_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt2_closure:
         const GHC.Types.F#_con_info;
         const 0.0 :: W32;
         const 0 :: W32;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.563518625 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt1_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.565899738 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInt_info;
 },
 GHC.Float.RealFracMethods.properFractionFloatInt_entry() //  [R2]
         { info_tbl: [(cpoW,
                       label: GHC.Float.RealFracMethods.properFractionFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpoW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpoX; else goto cpoY;
       cpoX: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpoY: // global
           I64[Sp - 8] = block_cpoT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uppm; else goto cpoU;
       uppm: // global
           call _cpoT(R1) args: 0, res: 0, upd: 0;
       cpoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpoT() //  [R1]
         { info_tbl: [(cpoT,
                       label: block_cpoT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpoT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpp3; else goto cpp2;
       cpp3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpp2: // global
           _soLU::F32 = F32[R1 + 7];
           if (%MO_F_Eq_W32(_soLU::F32,
                            0.0 :: W32)) goto cppl; else goto cppk;
       cppl: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cppk: // global
           I64[Hp - 48] = GHC.Types.F#_con_info;
           _soLW::I64 = %MO_FS_Conv_W32_W64(_soLU::F32);
           F32[Hp - 40] = %MO_F_Sub_W32(_soLU::F32,
                                        %MO_SF_Conv_W64_W32(_soLW::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soLW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.572750474 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInt_closure" {
     GHC.Float.RealFracMethods.floorFloatInt_closure:
         const GHC.Float.RealFracMethods.floorFloatInt_info;
 },
 GHC.Float.RealFracMethods.floorFloatInt_entry() //  [R2]
         { info_tbl: [(cppM,
                       label: GHC.Float.RealFracMethods.floorFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cppM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cppN; else goto cppO;
       cppN: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cppO: // global
           I64[Sp - 8] = block_cppJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upqc; else goto cppK;
       upqc: // global
           call _cppJ(R1) args: 0, res: 0, upd: 0;
       cppK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cppJ() //  [R1]
         { info_tbl: [(cppJ,
                       label: block_cppJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cppJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cppT; else goto cppS;
       cppT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cppS: // global
           _soM3::F32 = F32[R1 + 7];
           _soM4::I64 = %MO_FS_Conv_W32_W64(_soM3::F32);
           if (%MO_F_Lt_W32(_soM3::F32,
                            %MO_SF_Conv_W64_W32(_soM4::I64))) goto cpqb; else goto cpq5;
       cpqb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpq5: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.580230481 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInt_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInt_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInt_info;
 },
 GHC.Float.RealFracMethods.ceilingFloatInt_entry() //  [R2]
         { info_tbl: [(cpqy,
                       label: GHC.Float.RealFracMethods.ceilingFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpqy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpqz; else goto cpqA;
       cpqz: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpqA: // global
           I64[Sp - 8] = block_cpqv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upqY; else goto cpqw;
       upqY: // global
           call _cpqv(R1) args: 0, res: 0, upd: 0;
       cpqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpqv() //  [R1]
         { info_tbl: [(cpqv,
                       label: block_cpqv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpqv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpqF; else goto cpqE;
       cpqF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpqE: // global
           _soMa::F32 = F32[R1 + 7];
           _soMb::I64 = %MO_FS_Conv_W32_W64(_soMa::F32);
           if (%MO_F_Lt_W32(%MO_SF_Conv_W64_W32(_soMb::I64),
                            _soMa::F32)) goto cpqX; else goto cpqR;
       cpqX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpqR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.586984973 UTC

[section ""data" . lvl_roLO_closure" {
     lvl_roLO_closure:
         const lvl_roLO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_roLO_entry() //  [R1]
         { info_tbl: [(cprj,
                       label: lvl_roLO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cprj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cprk; else goto cprl;
       cprk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cprl: // global
           (_cprg::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cprg::I64 == 0) goto cpri; else goto cprh;
       cpri: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cprh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cprg::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.592612255 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInteger_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_info;
         const 0;
 },
 sat_soMn_entry() //  [R1]
         { info_tbl: [(cprP,
                       label: sat_soMn_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cprP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cprQ; else goto cprR;
       cprQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cprR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cprN_info;
           R2 = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cprN() //  [R1]
         { info_tbl: [(cprN,
                       label: block_cprN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cprN: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMx_entry() //  [R1]
         { info_tbl: [(cpse,
                       label: sat_soMx_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpse: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpss; else goto cpst;
       cpss: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpst: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpsj_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpsj() //  [R1]
         { info_tbl: [(cpsj,
                       label: block_cpsj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpsj: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpsn_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpsn() //  [F1]
         { info_tbl: [(cpsn,
                       label: block_cpsn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpsn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpsx; else goto cpsw;
       cpsx: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpsw: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMs_entry() //  [R1]
         { info_tbl: [(cpsC,
                       label: sat_soMs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpsC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpsD; else goto cpsE;
       cpsD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpsE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMG_entry() //  [R1]
         { info_tbl: [(cpsV,
                       label: sat_soMG_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpsV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpt9; else goto cpta;
       cpt9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpt0_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpt0() //  [R1]
         { info_tbl: [(cpt0,
                       label: block_cpt0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpt0: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpt4_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpt4() //  [F1]
         { info_tbl: [(cpt4,
                       label: block_cpt4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpt4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpte; else goto cptd;
       cpte: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cptd: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soMB_entry() //  [R1]
         { info_tbl: [(cptj,
                       label: sat_soMB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cptj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cptk; else goto cptl;
       cptk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cptl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionFloatInteger_entry() //  [R2]
         { info_tbl: [(cptm,
                       label: GHC.Float.RealFracMethods.properFractionFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cptm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cptn; else goto cpto;
       cptn: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpto: // global
           I64[Sp - 8] = block_cprx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uptJ; else goto cpry;
       uptJ: // global
           call _cprx(R1) args: 0, res: 0, upd: 0;
       cpry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cprx() //  [R1]
         { info_tbl: [(cprx,
                       label: block_cprx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cprx: // global
           I64[Sp - 8] = block_cprC_info;
           F1 = F32[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cprC() //  [R1, R2]
         { info_tbl: [(cprC,
                       label: block_cprC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cprC: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cprD() args: 0, res: 0, upd: 0;
     }
 },
 _cprD() //  []
         { info_tbl: [(cprD,
                       label: block_cprD_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cprD: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpts; else goto cptr;
       cpts: // global
           HpAlloc = 96;
           I64[Sp] = block_cprD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cptr: // global
           _soMj::I64 = I64[Sp + 16];
           _soMk::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soMk::I64, 0)) goto cptv; else goto cptG;
       cptv: // global
           I64[Hp - 88] = sat_soMn_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = (,)_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
           _cptt::P64 = Hp - 55;
           Hp = Hp - 40;
           R1 = _cptt::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cptG: // global
           _soMo::I64 = -_soMk::I64;
           if (%MO_S_Le_W64(_soMo::I64, 23)) goto cptC; else goto cptF;
       cptC: // global
           if (%MO_S_Ge_W64(_soMj::I64, 0)) goto cpty; else goto cptA;
       cpty: // global
           I64[Hp - 88] = sat_soMx_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMr::I64 = _soMj::I64 >> _soMo::I64;
           I64[Hp - 48] = _soMr::I64;
           I64[Hp - 40] = sat_soMs_info;
           I64[Hp - 24] = _soMr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cptA: // global
           I64[Hp - 88] = sat_soMG_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMy::I64 = -%MO_S_Shr_W64(-_soMj::I64, _soMo::I64);
           I64[Hp - 48] = _soMy::I64;
           I64[Hp - 40] = sat_soMB_info;
           I64[Hp - 24] = _soMy::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cptF: // global
           I64[Hp - 88] = (,)_con_info;
           P64[Hp - 80] = lvl_roLO_closure;
           P64[Hp - 72] = P64[Sp + 24];
           _cptE::P64 = Hp - 87;
           Hp = Hp - 72;
           R1 = _cptE::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.622362103 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateFloatInteger_closure" {
     GHC.Float.RealFracMethods.truncateFloatInteger_closure:
         const GHC.Float.RealFracMethods.truncateFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateFloatInteger_entry() //  [R2]
         { info_tbl: [(cpv0,
                       label: GHC.Float.RealFracMethods.truncateFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpv0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpv1; else goto cpv2;
       cpv1: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpv2: // global
           I64[Sp - 8] = block_cpuX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upvL; else goto cpuY;
       upvL: // global
           call _cpuX(R1) args: 0, res: 0, upd: 0;
       cpuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpuX() //  [R1]
         { info_tbl: [(cpuX,
                       label: block_cpuX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpuX: // global
           I64[Sp] = block_cpv5_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpv5() //  [R1, R2]
         { info_tbl: [(cpv5,
                       label: block_cpv5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpv5: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpvg; else goto cpvA;
       cpvg: // global
           I64[Sp - 8] = block_cpve_info;
           _soMM::I64 = R2;
           R2 = R1;
           I64[Sp] = _soMM::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpvA: // global
           _soMP::I64 = -R2;
           if (%MO_S_Le_W64(_soMP::I64, 23)) goto cpvy; else goto cpvz;
       cpvy: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpvv; else goto cpvw;
       cpvv: // global
           R2 = R1 >> _soMP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpvw: // global
           R2 = -%MO_S_Shr_W64(-R1, _soMP::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpvz: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpve() //  [R1]
         { info_tbl: [(cpve,
                       label: block_cpve_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpve: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.6320084 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt2_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt2_closure:
         const GHC.Types.D#_con_info;
         const 0.0 :: W64;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.633828282 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt1_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.636261294 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_info;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInt_entry() //  [R2]
         { info_tbl: [(cpwd,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpwd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpwe; else goto cpwf;
       cpwe: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpwf: // global
           I64[Sp - 8] = block_cpwa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upwD; else goto cpwb;
       upwD: // global
           call _cpwa(R1) args: 0, res: 0, upd: 0;
       cpwb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpwa() //  [R1]
         { info_tbl: [(cpwa,
                       label: block_cpwa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpwa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpwk; else goto cpwj;
       cpwk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpwj: // global
           _soMY::F64 = F64[R1 + 7];
           if (%MO_F_Eq_W64(_soMY::F64,
                            0.0 :: W64)) goto cpwC; else goto cpwB;
       cpwC: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpwB: // global
           I64[Hp - 48] = GHC.Types.D#_con_info;
           _soN0::I64 = %MO_FS_Conv_W64_W64(_soMY::F64);
           F64[Hp - 40] = %MO_F_Sub_W64(_soMY::F64,
                                        %MO_SF_Conv_W64_W64(_soN0::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soN0::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.643916172 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInt_closure" {
     GHC.Float.RealFracMethods.floorDoubleInt_closure:
         const GHC.Float.RealFracMethods.floorDoubleInt_info;
 },
 GHC.Float.RealFracMethods.floorDoubleInt_entry() //  [R2]
         { info_tbl: [(cpx3,
                       label: GHC.Float.RealFracMethods.floorDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpx3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpx4; else goto cpx5;
       cpx4: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpx5: // global
           I64[Sp - 8] = block_cpx0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upxt; else goto cpx1;
       upxt: // global
           call _cpx0(R1) args: 0, res: 0, upd: 0;
       cpx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpx0() //  [R1]
         { info_tbl: [(cpx0,
                       label: block_cpx0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpx0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpxa; else goto cpx9;
       cpxa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpx9: // global
           _soN7::F64 = F64[R1 + 7];
           _soN8::I64 = %MO_FS_Conv_W64_W64(_soN7::F64);
           if (%MO_F_Lt_W64(_soN7::F64,
                            %MO_SF_Conv_W64_W64(_soN8::I64))) goto cpxs; else goto cpxm;
       cpxs: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpxm: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.650273752 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInt_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_info;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInt_entry() //  [R2]
         { info_tbl: [(cpxP,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpxP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpxQ; else goto cpxR;
       cpxQ: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpxR: // global
           I64[Sp - 8] = block_cpxM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upyf; else goto cpxN;
       upyf: // global
           call _cpxM(R1) args: 0, res: 0, upd: 0;
       cpxN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpxM() //  [R1]
         { info_tbl: [(cpxM,
                       label: block_cpxM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpxM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpxW; else goto cpxV;
       cpxW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpxV: // global
           _soNe::F64 = F64[R1 + 7];
           _soNf::I64 = %MO_FS_Conv_W64_W64(_soNe::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_soNf::I64),
                            _soNe::F64)) goto cpye; else goto cpy8;
       cpye: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpy8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.65685582 UTC

[section ""data" . GHC.Float.RealFracMethods.double2Int_closure" {
     GHC.Float.RealFracMethods.double2Int_closure:
         const GHC.Float.RealFracMethods.double2Int_info;
 },
 GHC.Float.RealFracMethods.double2Int_entry() //  [R2]
         { info_tbl: [(cpyB,
                       label: GHC.Float.RealFracMethods.double2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpyB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpyI; else goto cpyJ;
       cpyI: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.double2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpyJ: // global
           I64[Sp - 8] = block_cpyy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upyN; else goto cpyz;
       upyN: // global
           call _cpyy(R1) args: 0, res: 0, upd: 0;
       cpyz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpyy() //  [R1]
         { info_tbl: [(cpyy,
                       label: block_cpyy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpyy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpyM; else goto cpyL;
       cpyM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpyL: // global
           _soNm::I64 = %MO_FS_Conv_W64_W64(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.662785318 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Double_closure" {
     GHC.Float.RealFracMethods.int2Double_closure:
         const GHC.Float.RealFracMethods.int2Double_info;
 },
 GHC.Float.RealFracMethods.int2Double_entry() //  [R2]
         { info_tbl: [(cpz5,
                       label: GHC.Float.RealFracMethods.int2Double_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpz5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpzc; else goto cpzd;
       cpzc: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Double_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpzd: // global
           I64[Sp - 8] = block_cpz2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upzh; else goto cpz3;
       upzh: // global
           call _cpz2(R1) args: 0, res: 0, upd: 0;
       cpz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpz2() //  [R1]
         { info_tbl: [(cpz2,
                       label: block_cpz2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpz2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpzg; else goto cpzf;
       cpzg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpzf: // global
           _soNq::F64 = %MO_SF_Conv_W64_W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _soNq::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.668554545 UTC

[section ""data" . GHC.Float.RealFracMethods.float2Int_closure" {
     GHC.Float.RealFracMethods.float2Int_closure:
         const GHC.Float.RealFracMethods.float2Int_info;
 },
 GHC.Float.RealFracMethods.float2Int_entry() //  [R2]
         { info_tbl: [(cpzz,
                       label: GHC.Float.RealFracMethods.float2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpzz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpzG; else goto cpzH;
       cpzG: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.float2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpzH: // global
           I64[Sp - 8] = block_cpzw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upzL; else goto cpzx;
       upzL: // global
           call _cpzw(R1) args: 0, res: 0, upd: 0;
       cpzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpzw() //  [R1]
         { info_tbl: [(cpzw,
                       label: block_cpzw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpzw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpzK; else goto cpzJ;
       cpzK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpzJ: // global
           _soNu::I64 = %MO_FS_Conv_W32_W64(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.675471147 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Float_closure" {
     GHC.Float.RealFracMethods.int2Float_closure:
         const GHC.Float.RealFracMethods.int2Float_info;
 },
 GHC.Float.RealFracMethods.int2Float_entry() //  [R2]
         { info_tbl: [(cpA3,
                       label: GHC.Float.RealFracMethods.int2Float_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpA3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpAa; else goto cpAb;
       cpAa: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Float_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpAb: // global
           I64[Sp - 8] = block_cpA0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upAf; else goto cpA1;
       upAf: // global
           call _cpA0(R1) args: 0, res: 0, upd: 0;
       cpA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpA0() //  [R1]
         { info_tbl: [(cpA0,
                       label: block_cpA0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpA0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpAe; else goto cpAd;
       cpAe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpAd: // global
           _soNy::F32 = %MO_SF_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _soNy::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.680988876 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule4_bytes" {
     GHC.Float.RealFracMethods.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.682760329 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule3_closure" {
     GHC.Float.RealFracMethods.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.684454411 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule2_bytes" {
     GHC.Float.RealFracMethods.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,82,101,97,108,70,114,97,99,77,101,116,104,111,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.686181479 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule1_closure" {
     GHC.Float.RealFracMethods.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.687826985 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule_closure" {
     GHC.Float.RealFracMethods.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.RealFracMethods.$trModule3_closure+1;
         const GHC.Float.RealFracMethods.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.690029323 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInt_closure" {
     GHC.Float.RealFracMethods.roundDoubleInt_closure:
         const GHC.Float.RealFracMethods.roundDoubleInt_info;
 },
 GHC.Float.RealFracMethods.roundDoubleInt_entry() //  [R2]
         { info_tbl: [(cpAC,
                       label: GHC.Float.RealFracMethods.roundDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpAC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpAL; else goto cpAM;
       cpAL: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpAM: // global
           I64[Sp - 8] = block_cpAz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upAQ; else goto cpAA;
       upAQ: // global
           call _cpAz(R1) args: 0, res: 0, upd: 0;
       cpAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpAz() //  [R1]
         { info_tbl: [(cpAz,
                       label: block_cpAz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpAz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpAP; else goto cpAO;
       cpAP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpAO: // global
           (_soNF::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W64_W64(_soNF::F64);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.696379796 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInteger_closure" {
     GHC.Float.RealFracMethods.roundDoubleInteger_closure:
         const GHC.Float.RealFracMethods.roundDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.roundDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpB9,
                       label: GHC.Float.RealFracMethods.roundDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpB9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpBa; else goto cpBb;
       cpBa: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpBb: // global
           I64[Sp - 8] = block_cpB6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upBC; else goto cpB7;
       upBC: // global
           call _cpB6(R1) args: 0, res: 0, upd: 0;
       cpB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpB6() //  [R1]
         { info_tbl: [(cpB6,
                       label: block_cpB6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpB6: // global
           (_soNN::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Sp] = block_cpBg_info;
           D1 = _soNN::F64;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpBg() //  [R1, R2]
         { info_tbl: [(cpBg,
                       label: block_cpBg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpBg: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpBp; else goto cpBt;
       cpBp: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpBt: // global
           I64[Sp - 8] = block_cpBs_info;
           _soNQ::I64 = R2;
           R2 = R1;
           I64[Sp] = _soNQ::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpBs() //  [R1]
         { info_tbl: [(cpBs,
                       label: block_cpBs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpBs: // global
           R2 = %MO_S_Shr_W64(R1, -I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.706406641 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInteger_closure" {
     GHC.Float.RealFracMethods.roundFloatInteger_closure:
         const GHC.Float.RealFracMethods.roundFloatInteger_info;
 },
 GHC.Float.RealFracMethods.roundFloatInteger_entry() //  [R2]
         { info_tbl: [(cpC0,
                       label: GHC.Float.RealFracMethods.roundFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpC1; else goto cpC2;
       cpC1: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpC2: // global
           I64[Sp - 8] = block_cpBX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upCt; else goto cpBY;
       upCt: // global
           call _cpBX(R1) args: 0, res: 0, upd: 0;
       cpBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpBX() //  [R1]
         { info_tbl: [(cpBX,
                       label: block_cpBX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpBX: // global
           (_soO1::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Sp] = block_cpC7_info;
           F1 = _soO1::F32;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpC7() //  [R1, R2]
         { info_tbl: [(cpC7,
                       label: block_cpC7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpC7: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpCi; else goto cpCn;
       cpCi: // global
           I64[Sp - 8] = block_cpCg_info;
           _soO4::I64 = R2;
           R2 = R1;
           I64[Sp] = _soO4::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpCn: // global
           R2 = %MO_S_Shr_W64(R1, -R2);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpCg() //  [R1]
         { info_tbl: [(cpCg,
                       label: block_cpCg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpCg: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.715483046 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInt_closure" {
     GHC.Float.RealFracMethods.roundFloatInt_closure:
         const GHC.Float.RealFracMethods.roundFloatInt_info;
 },
 GHC.Float.RealFracMethods.roundFloatInt_entry() //  [R2]
         { info_tbl: [(cpCR,
                       label: GHC.Float.RealFracMethods.roundFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpCR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpD0; else goto cpD1;
       cpD0: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpD1: // global
           I64[Sp - 8] = block_cpCO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upD5; else goto cpCP;
       upD5: // global
           call _cpCO(R1) args: 0, res: 0, upd: 0;
       cpCP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpCO() //  [R1]
         { info_tbl: [(cpCO,
                       label: block_cpCO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpCO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpD4; else goto cpD3;
       cpD4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpD3: // global
           (_soOf::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W32_W64(_soOf::F32);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.723435846 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInteger_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_info;
         const 0;
 },
 sat_soOo_entry() //  [R1]
         { info_tbl: [(cpDB,
                       label: sat_soOo_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpDB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpDC; else goto cpDD;
       cpDC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOz_entry() //  [R1]
         { info_tbl: [(cpE2,
                       label: sat_soOz_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpE2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpEg; else goto cpEh;
       cpEg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpEh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpE7_info;
           R2 = I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]);
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpE7() //  [R1]
         { info_tbl: [(cpE7,
                       label: block_cpE7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpE7: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpEb_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpEb() //  [D1]
         { info_tbl: [(cpEb,
                       label: block_cpEb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpEl; else goto cpEk;
       cpEl: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cpEk: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOu_entry() //  [R1]
         { info_tbl: [(cpEq,
                       label: sat_soOu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpEr; else goto cpEs;
       cpEr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOK_entry() //  [R1]
         { info_tbl: [(cpEM,
                       label: sat_soOK_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpF3; else goto cpF4;
       cpF3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpEU_info;
           R2 = -(I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]));
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpEU() //  [R1]
         { info_tbl: [(cpEU,
                       label: block_cpEU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEU: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpEY_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpEY() //  [D1]
         { info_tbl: [(cpEY,
                       label: block_cpEY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpF8; else goto cpF7;
       cpF8: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cpF7: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_soOE_entry() //  [R1]
         { info_tbl: [(cpFf,
                       label: sat_soOE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpFf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpFg; else goto cpFh;
       cpFg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpFh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpFi,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpFi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpFj; else goto cpFk;
       cpFj: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpFk: // global
           I64[Sp - 8] = block_cpDl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upFO; else goto cpDm;
       upFO: // global
           call _cpDl(R1) args: 0, res: 0, upd: 0;
       cpDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpDl() //  [R1]
         { info_tbl: [(cpDl,
                       label: block_cpDl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpDl: // global
           I64[Sp - 8] = block_cpDq_info;
           D1 = F64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpDq() //  [R1, R2]
         { info_tbl: [(cpDq,
                       label: block_cpDq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpDq: // global
           I64[Sp - 8] = R2;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call _cpDr() args: 0, res: 0, upd: 0;
     }
 },
 _cpDr() //  []
         { info_tbl: [(cpDr,
                       label: block_cpDr_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpDr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpFo; else goto cpFn;
       cpFo: // global
           HpAlloc = 56;
           I64[Sp] = block_cpDr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cpFn: // global
           _soOl::P64 = P64[Sp + 16];
           _soOm::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soOm::I64, 0)) goto cpFr; else goto cpFL;
       cpFr: // global
           I64[Hp - 48] = sat_soOo_info;
           P64[Hp - 32] = _soOl::P64;
           I64[Hp - 24] = _soOm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpFL: // global
           _soOp::I64 = -_soOm::I64;
           if (%MO_S_Le_W64(_soOp::I64, 52)) goto cpFt; else goto cpFK;
       cpFt: // global
           Hp = Hp - 56;
           I64[Sp] = block_cpDL_info;
           R3 = lvl_roLO_closure;
           R2 = _soOl::P64;
           I64[Sp + 24] = _soOp::I64;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cpFK: // global
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = lvl_roLO_closure;
           P64[Hp - 32] = P64[Sp + 24];
           _cpFJ::P64 = Hp - 47;
           Hp = Hp - 32;
           R1 = _cpFJ::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpDL() //  [R1]
         { info_tbl: [(cpDL,
                       label: block_cpDL_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpDL: // global
           _soOl::P64 = P64[Sp + 16];
           if (R1 == 1) goto cpFD; else goto cpFx;
       cpFD: // global
           I64[Sp] = block_cpEv_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpFx: // global
           I64[Sp] = block_cpDP_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpEv() //  [R1]
         { info_tbl: [(cpEv,
                       label: block_cpEv_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEv: // global
           I64[Sp] = block_cpEz_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpEz() //  [R1]
         { info_tbl: [(cpEz,
                       label: block_cpEz_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpEz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpFH; else goto cpFG;
       cpFH: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cpFG: // global
           I64[Hp - 88] = sat_soOK_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOC::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOC::I64;
           I64[Hp - 40] = sat_soOE_info;
           I64[Hp - 24] = _soOC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpDP() //  [R1]
         { info_tbl: [(cpDP,
                       label: block_cpDP_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpDP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpFA; else goto cpFz;
       cpFA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cpFz: // global
           I64[Hp - 88] = sat_soOz_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOt::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOt::I64;
           I64[Hp - 40] = sat_soOu_info;
           I64[Hp - 24] = _soOt::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.759427549 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateDoubleInteger_closure" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_closure:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpHf,
                       label: GHC.Float.RealFracMethods.truncateDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cpHg; else goto cpHh;
       cpHg: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpHh: // global
           I64[Sp - 8] = block_cpHc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upIb; else goto cpHd;
       upIb: // global
           call _cpHc(R1) args: 0, res: 0, upd: 0;
       cpHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpHc() //  [R1]
         { info_tbl: [(cpHc,
                       label: block_cpHc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHc: // global
           I64[Sp] = block_cpHk_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpHk() //  [R1, R2]
         { info_tbl: [(cpHk,
                       label: block_cpHk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHk: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpHt; else goto cpI5;
       cpHt: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpI5: // global
           _soOS::I64 = -R2;
           if (%MO_S_Le_W64(_soOS::I64, 52)) goto cpHE; else goto cpI4;
       cpHE: // global
           I64[Sp - 16] = block_cpHC_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           I64[Sp - 8] = _soOS::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cpI4: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpHC() //  [R1]
         { info_tbl: [(cpHC,
                       label: block_cpHC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHC: // global
           _soOP::P64 = P64[Sp + 16];
           if (R1 == 1) goto cpHY; else goto cpHL;
       cpHY: // global
           I64[Sp] = block_cpHS_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpHL: // global
           I64[Sp] = block_cpHI_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpHS() //  [R1]
         { info_tbl: [(cpHS,
                       label: block_cpHS_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHS: // global
           I64[Sp] = block_cpHW_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpHW() //  [R1]
         { info_tbl: [(cpHW,
                       label: block_cpHW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHW: // global
           R2 = -%MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpHI() //  [R1]
         { info_tbl: [(cpHI,
                       label: block_cpHI_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpHI: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.774435619 UTC

[section ""data" . sat_soP1_closure" {
     sat_soP1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.776136169 UTC

[section ""data" . sat_soP2_closure" {
     sat_soP2_closure:
         const :_con_info;
         const sat_soP1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.778243351 UTC

[section ""data" . lvl1_roLP_closure" {
     lvl1_roLP_closure:
         const lvl1_roLP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_roLP_entry() //  [R1]
         { info_tbl: [(cpIL,
                       label: lvl1_roLP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpIM; else goto cpIN;
       cpIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpIN: // global
           (_cpII::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpII::I64 == 0) goto cpIK; else goto cpIJ;
       cpIK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpIJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpII::I64;
           R3 = sat_soP2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.782846562 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInteger_closure" {
     GHC.Float.RealFracMethods.floorFloatInteger_closure:
         const GHC.Float.RealFracMethods.floorFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorFloatInteger_entry() //  [R2]
         { info_tbl: [(cpJ2,
                       label: GHC.Float.RealFracMethods.floorFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpJ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpJ3; else goto cpJ4;
       cpJ3: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpJ4: // global
           I64[Sp - 8] = block_cpIZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upJF; else goto cpJ0;
       upJF: // global
           call _cpIZ(R1) args: 0, res: 0, upd: 0;
       cpJ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpIZ() //  [R1]
         { info_tbl: [(cpIZ,
                       label: block_cpIZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpIZ: // global
           I64[Sp] = block_cpJ7_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpJ7() //  [R1, R2]
         { info_tbl: [(cpJ7,
                       label: block_cpJ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpJ7: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpJi; else goto cpJD;
       cpJi: // global
           I64[Sp - 8] = block_cpJg_info;
           _soP8::I64 = R2;
           R2 = R1;
           I64[Sp] = _soP8::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpJD: // global
           _soPb::I64 = -R2;
           if (%MO_S_Le_W64(_soPb::I64, 23)) goto cpJu; else goto cpJC;
       cpJu: // global
           R2 = %MO_S_Shr_W64(R1, _soPb::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpJC: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpJA; else goto cpJB;
       cpJA: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpJB: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpJg() //  [R1]
         { info_tbl: [(cpJg,
                       label: block_cpJg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpJg: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.791759378 UTC

[section ""data" . sat_soPf_closure" {
     sat_soPf_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.793561715 UTC

[section ""data" . sat_soPg_closure" {
     sat_soPg_closure:
         const :_con_info;
         const sat_soPf_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.796145783 UTC

[section ""data" . lvl2_roLQ_closure" {
     lvl2_roLQ_closure:
         const lvl2_roLQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_roLQ_entry() //  [R1]
         { info_tbl: [(cpK6,
                       label: lvl2_roLQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpK6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpK7; else goto cpK8;
       cpK7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpK8: // global
           (_cpK3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpK3::I64 == 0) goto cpK5; else goto cpK4;
       cpK5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpK4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpK3::I64;
           R3 = sat_soPg_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.801146749 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInteger_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingFloatInteger_entry() //  [R2]
         { info_tbl: [(cpKn,
                       label: GHC.Float.RealFracMethods.ceilingFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpKo; else goto cpKp;
       cpKo: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpKp: // global
           I64[Sp - 8] = block_cpKk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upLf; else goto cpKl;
       upLf: // global
           call _cpKk(R1) args: 0, res: 0, upd: 0;
       cpKl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpKk() //  [R1]
         { info_tbl: [(cpKk,
                       label: block_cpKk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpKk: // global
           I64[Sp] = block_cpKw_info;
           F1 = %MO_F_Neg_W32(F32[R1 + 7]);
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpKw() //  [R1, R2]
         { info_tbl: [(cpKw,
                       label: block_cpKw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpKw: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpKK; else goto cpLe;
       cpKK: // global
           I64[Sp - 8] = block_cpKE_info;
           _soPn::I64 = R2;
           R2 = R1;
           I64[Sp] = _soPn::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpLe: // global
           _soPr::I64 = -R2;
           if (%MO_S_Le_W64(_soPr::I64, 23)) goto cpL2; else goto cpLd;
       cpL2: // global
           I64[Sp] = block_cpL0_info;
           R2 = %MO_S_Shr_W64(R1, _soPr::I64);
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpLd: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpLb; else goto cpLc;
       cpLb: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpLc: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpKE() //  [R1]
         { info_tbl: [(cpKE,
                       label: block_cpKE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpKE: // global
           _soPn::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpKI_info;
           R3 = _soPn::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpKI() //  [R1]
         { info_tbl: [(cpKI,
                       label: block_cpKI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpKI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpL0() //  [R1]
         { info_tbl: [(cpL0,
                       label: block_cpL0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpL0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.813965437 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInteger_closure" {
     GHC.Float.RealFracMethods.floorDoubleInteger_closure:
         const GHC.Float.RealFracMethods.floorDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpLN,
                       label: GHC.Float.RealFracMethods.floorDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpLO; else goto cpLP;
       cpLO: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpLP: // global
           I64[Sp - 8] = block_cpLK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upMw; else goto cpLL;
       upMw: // global
           call _cpLK(R1) args: 0, res: 0, upd: 0;
       cpLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpLK() //  [R1]
         { info_tbl: [(cpLK,
                       label: block_cpLK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpLK: // global
           I64[Sp] = block_cpLS_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpLS() //  [R1, R2]
         { info_tbl: [(cpLS,
                       label: block_cpLS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpLS: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpM1; else goto cpMu;
       cpM1: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpMu: // global
           _soPD::I64 = -R2;
           if (%MO_S_Le_W64(_soPD::I64, 52)) goto cpMc; else goto cpMj;
       cpMc: // global
           I64[Sp - 8] = block_cpMa_info;
           R2 = R1;
           I64[Sp] = _soPD::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cpMj: // global
           I64[Sp] = block_cpMi_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpMa() //  [R1]
         { info_tbl: [(cpMa,
                       label: block_cpMa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpMa: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpMi() //  [R1]
         { info_tbl: [(cpMi,
                       label: block_cpMi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpMi: // global
           if (R1 == 1) goto cpMt; else goto cpMp;
       cpMt: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpMp: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.825439341 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInteger_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInteger_entry() //  [R2]
         { info_tbl: [(cpMZ,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpMZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpN0; else goto cpN1;
       cpN0: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpN1: // global
           I64[Sp - 8] = block_cpMW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upNX; else goto cpMX;
       upNX: // global
           call _cpMW(R1) args: 0, res: 0, upd: 0;
       cpMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpMW() //  [R1]
         { info_tbl: [(cpMW,
                       label: block_cpMW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpMW: // global
           I64[Sp] = block_cpN8_info;
           D1 = %MO_F_Neg_W64(F64[R1 + 7]);
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cpN8() //  [R1, R2]
         { info_tbl: [(cpN8,
                       label: block_cpN8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpN8: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpNi; else goto cpNW;
       cpNi: // global
           I64[Sp] = block_cpNg_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       cpNW: // global
           _soPR::I64 = -R2;
           if (%MO_S_Le_W64(_soPR::I64, 52)) goto cpND; else goto cpNL;
       cpND: // global
           I64[Sp - 8] = block_cpNu_info;
           R2 = R1;
           I64[Sp] = _soPR::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cpNL: // global
           I64[Sp] = block_cpNK_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpNg() //  [R1]
         { info_tbl: [(cpNg,
                       label: block_cpNg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpNg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpNu() //  [R1]
         { info_tbl: [(cpNu,
                       label: block_cpNu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpNu: // global
           _soPU::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cpNB_info;
           R2 = _soPU::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cpNB() //  [R1]
         { info_tbl: [(cpNB,
                       label: block_cpNB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpNB: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cpNK() //  [R1]
         { info_tbl: [(cpNK,
                       label: block_cpNK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpNK: // global
           if (R1 == 1) goto cpNV; else goto cpNR;
       cpNV: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpNR: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:02.839363271 UTC

[section ""relreadonly" . SoU1_srt" {
     SoU1_srt:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
         const lvl_roLO_closure;
         const GHC.Float.RealFracMethods.truncateFloatInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Float.RealFracMethods.roundDoubleInteger_closure;
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
         const GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
         const sat_soP2_closure;
         const GHC.Float.RealFracMethods.floorFloatInteger_closure;
         const lvl1_roLP_closure;
         const sat_soPg_closure;
         const GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
         const lvl2_roLQ_closure;
         const GHC.Float.RealFracMethods.floorDoubleInteger_closure;
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.624758682 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:03.625910412 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt3_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.627919129 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt2_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt2_closure:
         const GHC.Types.F#_con_info;
         const 0.0 :: W32;
         const 0 :: W32;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.629802507 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt1_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.632142137 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInt_info;
 },
 GHC.Float.RealFracMethods.properFractionFloatInt_entry() //  [R2]
         { info_tbl: [(cpSH,
                       label: GHC.Float.RealFracMethods.properFractionFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpSH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpSI; else goto cpSJ;
       cpSI: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpSJ: // global
           I64[Sp - 8] = block_cpSE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upT7; else goto cpSF;
       upT7: // global
           call _cpSE(R1) args: 0, res: 0, upd: 0;
       cpSF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpSE() //  [R1]
         { info_tbl: [(cpSE,
                       label: block_cpSE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpSE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpSO; else goto cpSN;
       cpSO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpSN: // global
           _spOu::F32 = F32[R1 + 7];
           if (%MO_F_Eq_W32(_spOu::F32,
                            0.0 :: W32)) goto cpT6; else goto cpT5;
       cpT6: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpT5: // global
           I64[Hp - 48] = GHC.Types.F#_con_info;
           _spOw::I64 = %MO_FS_Conv_W32_W64(_spOu::F32);
           F32[Hp - 40] = %MO_F_Sub_W32(_spOu::F32,
                                        %MO_SF_Conv_W64_W32(_spOw::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _spOw::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.63897309 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInt_closure" {
     GHC.Float.RealFracMethods.floorFloatInt_closure:
         const GHC.Float.RealFracMethods.floorFloatInt_info;
 },
 GHC.Float.RealFracMethods.floorFloatInt_entry() //  [R2]
         { info_tbl: [(cpTB,
                       label: GHC.Float.RealFracMethods.floorFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpTB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpTC; else goto cpTD;
       cpTC: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpTD: // global
           I64[Sp - 8] = block_cpTy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upU1; else goto cpTz;
       upU1: // global
           call _cpTy(R1) args: 0, res: 0, upd: 0;
       cpTz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpTy() //  [R1]
         { info_tbl: [(cpTy,
                       label: block_cpTy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpTy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpTI; else goto cpTH;
       cpTI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpTH: // global
           _spOD::F32 = F32[R1 + 7];
           _spOE::I64 = %MO_FS_Conv_W32_W64(_spOD::F32);
           if (%MO_F_Lt_W32(_spOD::F32,
                            %MO_SF_Conv_W64_W32(_spOE::I64))) goto cpU0; else goto cpTU;
       cpU0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOE::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpTU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.645139871 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInt_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInt_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInt_info;
 },
 GHC.Float.RealFracMethods.ceilingFloatInt_entry() //  [R2]
         { info_tbl: [(cpUq,
                       label: GHC.Float.RealFracMethods.ceilingFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpUq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpUr; else goto cpUs;
       cpUr: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpUs: // global
           I64[Sp - 8] = block_cpUn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upUQ; else goto cpUo;
       upUQ: // global
           call _cpUn(R1) args: 0, res: 0, upd: 0;
       cpUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpUn() //  [R1]
         { info_tbl: [(cpUn,
                       label: block_cpUn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpUn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpUx; else goto cpUw;
       cpUx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpUw: // global
           _spOK::F32 = F32[R1 + 7];
           _spOL::I64 = %MO_FS_Conv_W32_W64(_spOK::F32);
           if (%MO_F_Lt_W32(%MO_SF_Conv_W64_W32(_spOL::I64),
                            _spOK::F32)) goto cpUP; else goto cpUJ;
       cpUP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOL::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpUJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.651770684 UTC

[section ""data" . lvl_roLO_closure" {
     lvl_roLO_closure:
         const lvl_roLO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_roLO_entry() //  [R1]
         { info_tbl: [(cpVe,
                       label: lvl_roLO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpVe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpVf; else goto cpVg;
       cpVf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpVg: // global
           (_cpVb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpVb::I64 == 0) goto cpVd; else goto cpVc;
       cpVd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpVc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpVb::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.657349457 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInteger_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_info;
         const 0;
 },
 sat_spOX_entry() //  [R1]
         { info_tbl: [(cpVN,
                       label: sat_spOX_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpVN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpVO; else goto cpVP;
       cpVO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpVP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpVL_info;
           R2 = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpVL() //  [R1]
         { info_tbl: [(cpVL,
                       label: block_cpVL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpVL: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_spP7_entry() //  [R1]
         { info_tbl: [(cpWc,
                       label: sat_spP7_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpWc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpWq; else goto cpWr;
       cpWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpWh_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpWh() //  [R1]
         { info_tbl: [(cpWh,
                       label: block_cpWh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpWh: // global
           _spOU::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpWl_info;
           R3 = _spOU::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpWl() //  [F1]
         { info_tbl: [(cpWl,
                       label: block_cpWl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpWl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpWv; else goto cpWu;
       cpWv: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpWu: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_spP2_entry() //  [R1]
         { info_tbl: [(cpWA,
                       label: sat_spP2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpWA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpWB; else goto cpWC;
       cpWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_spPg_entry() //  [R1]
         { info_tbl: [(cpWT,
                       label: sat_spPg_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpWT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpX7; else goto cpX8;
       cpX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpWY_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpWY() //  [R1]
         { info_tbl: [(cpWY,
                       label: block_cpWY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpWY: // global
           _spOU::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpX2_info;
           R3 = _spOU::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cpX2() //  [F1]
         { info_tbl: [(cpX2,
                       label: block_cpX2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpX2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpXc; else goto cpXb;
       cpXc: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpXb: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_spPb_entry() //  [R1]
         { info_tbl: [(cpXh,
                       label: sat_spPb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpXi; else goto cpXj;
       cpXi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpXj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionFloatInteger_entry() //  [R2]
         { info_tbl: [(cpXk,
                       label: GHC.Float.RealFracMethods.properFractionFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpXk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpXl; else goto cpXm;
       cpXl: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpXm: // global
           I64[Sp - 8] = block_cpVv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upXH; else goto cpVw;
       upXH: // global
           call _cpVv(R1) args: 0, res: 0, upd: 0;
       cpVw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpVv() //  [R1]
         { info_tbl: [(cpVv,
                       label: block_cpVv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpVv: // global
           I64[Sp - 8] = block_cpVA_info;
           F1 = F32[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpVA() //  [R1, R2]
         { info_tbl: [(cpVA,
                       label: block_cpVA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpVA: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cpVB() args: 0, res: 0, upd: 0;
     }
 },
 _cpVB() //  []
         { info_tbl: [(cpVB,
                       label: block_cpVB_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpVB: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpXq; else goto cpXp;
       cpXq: // global
           HpAlloc = 96;
           I64[Sp] = block_cpVB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cpXp: // global
           _spOT::I64 = I64[Sp + 16];
           _spOU::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_spOU::I64, 0)) goto cpXt; else goto cpXE;
       cpXt: // global
           I64[Hp - 88] = sat_spOX_info;
           I64[Hp - 72] = _spOT::I64;
           I64[Hp - 64] = _spOU::I64;
           I64[Hp - 56] = (,)_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
           _cpXr::P64 = Hp - 55;
           Hp = Hp - 40;
           R1 = _cpXr::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpXE: // global
           _spOY::I64 = -_spOU::I64;
           if (%MO_S_Le_W64(_spOY::I64, 23)) goto cpXA; else goto cpXD;
       cpXA: // global
           if (%MO_S_Ge_W64(_spOT::I64, 0)) goto cpXw; else goto cpXy;
       cpXw: // global
           I64[Hp - 88] = sat_spP7_info;
           I64[Hp - 72] = _spOT::I64;
           I64[Hp - 64] = _spOU::I64;
           I64[Hp - 56] = _spOY::I64;
           _spP1::I64 = _spOT::I64 >> _spOY::I64;
           I64[Hp - 48] = _spP1::I64;
           I64[Hp - 40] = sat_spP2_info;
           I64[Hp - 24] = _spP1::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpXy: // global
           I64[Hp - 88] = sat_spPg_info;
           I64[Hp - 72] = _spOT::I64;
           I64[Hp - 64] = _spOU::I64;
           I64[Hp - 56] = _spOY::I64;
           _spP8::I64 = -%MO_S_Shr_W64(-_spOT::I64, _spOY::I64);
           I64[Hp - 48] = _spP8::I64;
           I64[Hp - 40] = sat_spPb_info;
           I64[Hp - 24] = _spP8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpXD: // global
           I64[Hp - 88] = (,)_con_info;
           P64[Hp - 80] = lvl_roLO_closure;
           P64[Hp - 72] = P64[Sp + 24];
           _cpXC::P64 = Hp - 87;
           Hp = Hp - 72;
           R1 = _cpXC::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.68568236 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateFloatInteger_closure" {
     GHC.Float.RealFracMethods.truncateFloatInteger_closure:
         const GHC.Float.RealFracMethods.truncateFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateFloatInteger_entry() //  [R2]
         { info_tbl: [(cpZp,
                       label: GHC.Float.RealFracMethods.truncateFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpZp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpZq; else goto cpZr;
       cpZq: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpZr: // global
           I64[Sp - 8] = block_cpZm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq0a; else goto cpZn;
       uq0a: // global
           call _cpZm(R1) args: 0, res: 0, upd: 0;
       cpZn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cpZm() //  [R1]
         { info_tbl: [(cpZm,
                       label: block_cpZm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpZm: // global
           I64[Sp] = block_cpZu_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cpZu() //  [R1, R2]
         { info_tbl: [(cpZu,
                       label: block_cpZu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpZu: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpZF; else goto cpZZ;
       cpZF: // global
           I64[Sp - 8] = block_cpZD_info;
           _spPm::I64 = R2;
           R2 = R1;
           I64[Sp] = _spPm::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpZZ: // global
           _spPp::I64 = -R2;
           if (%MO_S_Le_W64(_spPp::I64, 23)) goto cpZX; else goto cpZY;
       cpZX: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpZU; else goto cpZV;
       cpZU: // global
           R2 = R1 >> _spPp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpZV: // global
           R2 = -%MO_S_Shr_W64(-R1, _spPp::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpZY: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cpZD() //  [R1]
         { info_tbl: [(cpZD,
                       label: block_cpZD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cpZD: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.694700794 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt2_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt2_closure:
         const GHC.Types.D#_con_info;
         const 0.0 :: W64;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.696445002 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt1_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.69868229 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_info;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInt_entry() //  [R2]
         { info_tbl: [(cq0F,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq0F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq0G; else goto cq0H;
       cq0G: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq0H: // global
           I64[Sp - 8] = block_cq0C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq15; else goto cq0D;
       uq15: // global
           call _cq0C(R1) args: 0, res: 0, upd: 0;
       cq0D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq0C() //  [R1]
         { info_tbl: [(cq0C,
                       label: block_cq0C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq0C: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cq0M; else goto cq0L;
       cq0M: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq0L: // global
           _spPy::F64 = F64[R1 + 7];
           if (%MO_F_Eq_W64(_spPy::F64,
                            0.0 :: W64)) goto cq14; else goto cq13;
       cq14: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cq13: // global
           I64[Hp - 48] = GHC.Types.D#_con_info;
           _spPA::I64 = %MO_FS_Conv_W64_W64(_spPy::F64);
           F64[Hp - 40] = %MO_F_Sub_W64(_spPy::F64,
                                        %MO_SF_Conv_W64_W64(_spPA::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _spPA::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.705167148 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInt_closure" {
     GHC.Float.RealFracMethods.floorDoubleInt_closure:
         const GHC.Float.RealFracMethods.floorDoubleInt_info;
 },
 GHC.Float.RealFracMethods.floorDoubleInt_entry() //  [R2]
         { info_tbl: [(cq1z,
                       label: GHC.Float.RealFracMethods.floorDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq1z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq1A; else goto cq1B;
       cq1A: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq1B: // global
           I64[Sp - 8] = block_cq1w_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq1Z; else goto cq1x;
       uq1Z: // global
           call _cq1w(R1) args: 0, res: 0, upd: 0;
       cq1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq1w() //  [R1]
         { info_tbl: [(cq1w,
                       label: block_cq1w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq1w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq1G; else goto cq1F;
       cq1G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq1F: // global
           _spPH::F64 = F64[R1 + 7];
           _spPI::I64 = %MO_FS_Conv_W64_W64(_spPH::F64);
           if (%MO_F_Lt_W64(_spPH::F64,
                            %MO_SF_Conv_W64_W64(_spPI::I64))) goto cq1Y; else goto cq1S;
       cq1Y: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPI::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cq1S: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.711382272 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInt_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_info;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInt_entry() //  [R2]
         { info_tbl: [(cq2o,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq2o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq2p; else goto cq2q;
       cq2p: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq2q: // global
           I64[Sp - 8] = block_cq2l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq2O; else goto cq2m;
       uq2O: // global
           call _cq2l(R1) args: 0, res: 0, upd: 0;
       cq2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq2l() //  [R1]
         { info_tbl: [(cq2l,
                       label: block_cq2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq2v; else goto cq2u;
       cq2v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq2u: // global
           _spPO::F64 = F64[R1 + 7];
           _spPP::I64 = %MO_FS_Conv_W64_W64(_spPO::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_spPP::I64),
                            _spPO::F64)) goto cq2N; else goto cq2H;
       cq2N: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPP::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cq2H: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.717361413 UTC

[section ""data" . GHC.Float.RealFracMethods.double2Int_closure" {
     GHC.Float.RealFracMethods.double2Int_closure:
         const GHC.Float.RealFracMethods.double2Int_info;
 },
 GHC.Float.RealFracMethods.double2Int_entry() //  [R2]
         { info_tbl: [(cq3d,
                       label: GHC.Float.RealFracMethods.double2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq3d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq3k; else goto cq3l;
       cq3k: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.double2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq3l: // global
           I64[Sp - 8] = block_cq3a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq3p; else goto cq3b;
       uq3p: // global
           call _cq3a(R1) args: 0, res: 0, upd: 0;
       cq3b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq3a() //  [R1]
         { info_tbl: [(cq3a,
                       label: block_cq3a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq3a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq3o; else goto cq3n;
       cq3o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq3n: // global
           _spPW::I64 = %MO_FS_Conv_W64_W64(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.722968466 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Double_closure" {
     GHC.Float.RealFracMethods.int2Double_closure:
         const GHC.Float.RealFracMethods.int2Double_info;
 },
 GHC.Float.RealFracMethods.int2Double_entry() //  [R2]
         { info_tbl: [(cq3J,
                       label: GHC.Float.RealFracMethods.int2Double_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq3J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq3Q; else goto cq3R;
       cq3Q: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Double_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq3R: // global
           I64[Sp - 8] = block_cq3G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq3V; else goto cq3H;
       uq3V: // global
           call _cq3G(R1) args: 0, res: 0, upd: 0;
       cq3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq3G() //  [R1]
         { info_tbl: [(cq3G,
                       label: block_cq3G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq3G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq3U; else goto cq3T;
       cq3U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq3T: // global
           _spQ0::F64 = %MO_SF_Conv_W64_W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _spQ0::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.728677133 UTC

[section ""data" . GHC.Float.RealFracMethods.float2Int_closure" {
     GHC.Float.RealFracMethods.float2Int_closure:
         const GHC.Float.RealFracMethods.float2Int_info;
 },
 GHC.Float.RealFracMethods.float2Int_entry() //  [R2]
         { info_tbl: [(cq4f,
                       label: GHC.Float.RealFracMethods.float2Int_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq4f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq4m; else goto cq4n;
       cq4m: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.float2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq4n: // global
           I64[Sp - 8] = block_cq4c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq4r; else goto cq4d;
       uq4r: // global
           call _cq4c(R1) args: 0, res: 0, upd: 0;
       cq4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq4c() //  [R1]
         { info_tbl: [(cq4c,
                       label: block_cq4c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq4c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq4q; else goto cq4p;
       cq4q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq4p: // global
           _spQ4::I64 = %MO_FS_Conv_W32_W64(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spQ4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.73447449 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Float_closure" {
     GHC.Float.RealFracMethods.int2Float_closure:
         const GHC.Float.RealFracMethods.int2Float_info;
 },
 GHC.Float.RealFracMethods.int2Float_entry() //  [R2]
         { info_tbl: [(cq4L,
                       label: GHC.Float.RealFracMethods.int2Float_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq4L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq4S; else goto cq4T;
       cq4S: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Float_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq4T: // global
           I64[Sp - 8] = block_cq4I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq4X; else goto cq4J;
       uq4X: // global
           call _cq4I(R1) args: 0, res: 0, upd: 0;
       cq4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq4I() //  [R1]
         { info_tbl: [(cq4I,
                       label: block_cq4I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq4I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq4W; else goto cq4V;
       cq4W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq4V: // global
           _spQ8::F32 = %MO_SF_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _spQ8::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.740419426 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule4_bytes" {
     GHC.Float.RealFracMethods.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.742166415 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule3_closure" {
     GHC.Float.RealFracMethods.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.74380122 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule2_bytes" {
     GHC.Float.RealFracMethods.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,82,101,97,108,70,114,97,99,77,101,116,104,111,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.745286415 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule1_closure" {
     GHC.Float.RealFracMethods.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.746962077 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule_closure" {
     GHC.Float.RealFracMethods.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.RealFracMethods.$trModule3_closure+1;
         const GHC.Float.RealFracMethods.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.74911254 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInt_closure" {
     GHC.Float.RealFracMethods.roundDoubleInt_closure:
         const GHC.Float.RealFracMethods.roundDoubleInt_info;
 },
 GHC.Float.RealFracMethods.roundDoubleInt_entry() //  [R2]
         { info_tbl: [(cq5m,
                       label: GHC.Float.RealFracMethods.roundDoubleInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq5m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq5v; else goto cq5w;
       cq5v: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq5w: // global
           I64[Sp - 8] = block_cq5j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq5A; else goto cq5k;
       uq5A: // global
           call _cq5j(R1) args: 0, res: 0, upd: 0;
       cq5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq5j() //  [R1]
         { info_tbl: [(cq5j,
                       label: block_cq5j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq5j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq5z; else goto cq5y;
       cq5z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq5y: // global
           (_spQf::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W64_W64(_spQf::F64);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.756722063 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInteger_closure" {
     GHC.Float.RealFracMethods.roundDoubleInteger_closure:
         const GHC.Float.RealFracMethods.roundDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.roundDoubleInteger_entry() //  [R2]
         { info_tbl: [(cq5V,
                       label: GHC.Float.RealFracMethods.roundDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq5V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq5W; else goto cq5X;
       cq5W: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq5X: // global
           I64[Sp - 8] = block_cq5S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq6o; else goto cq5T;
       uq6o: // global
           call _cq5S(R1) args: 0, res: 0, upd: 0;
       cq5T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq5S() //  [R1]
         { info_tbl: [(cq5S,
                       label: block_cq5S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq5S: // global
           (_spQn::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Sp] = block_cq62_info;
           D1 = _spQn::F64;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cq62() //  [R1, R2]
         { info_tbl: [(cq62,
                       label: block_cq62_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq62: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cq6b; else goto cq6f;
       cq6b: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cq6f: // global
           I64[Sp - 8] = block_cq6e_info;
           _spQq::I64 = R2;
           R2 = R1;
           I64[Sp] = _spQq::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cq6e() //  [R1]
         { info_tbl: [(cq6e,
                       label: block_cq6e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq6e: // global
           R2 = %MO_S_Shr_W64(R1, -I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.765692618 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInteger_closure" {
     GHC.Float.RealFracMethods.roundFloatInteger_closure:
         const GHC.Float.RealFracMethods.roundFloatInteger_info;
 },
 GHC.Float.RealFracMethods.roundFloatInteger_entry() //  [R2]
         { info_tbl: [(cq6P,
                       label: GHC.Float.RealFracMethods.roundFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq6P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq6Q; else goto cq6R;
       cq6Q: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq6R: // global
           I64[Sp - 8] = block_cq6M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq7i; else goto cq6N;
       uq7i: // global
           call _cq6M(R1) args: 0, res: 0, upd: 0;
       cq6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq6M() //  [R1]
         { info_tbl: [(cq6M,
                       label: block_cq6M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq6M: // global
           (_spQB::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Sp] = block_cq6W_info;
           F1 = _spQB::F32;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cq6W() //  [R1, R2]
         { info_tbl: [(cq6W,
                       label: block_cq6W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq6W: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cq77; else goto cq7c;
       cq77: // global
           I64[Sp - 8] = block_cq75_info;
           _spQE::I64 = R2;
           R2 = R1;
           I64[Sp] = _spQE::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cq7c: // global
           R2 = %MO_S_Shr_W64(R1, -R2);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cq75() //  [R1]
         { info_tbl: [(cq75,
                       label: block_cq75_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq75: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.775265496 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInt_closure" {
     GHC.Float.RealFracMethods.roundFloatInt_closure:
         const GHC.Float.RealFracMethods.roundFloatInt_info;
 },
 GHC.Float.RealFracMethods.roundFloatInt_entry() //  [R2]
         { info_tbl: [(cq7J,
                       label: GHC.Float.RealFracMethods.roundFloatInt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq7J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq7S; else goto cq7T;
       cq7S: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq7T: // global
           I64[Sp - 8] = block_cq7G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq7X; else goto cq7H;
       uq7X: // global
           call _cq7G(R1) args: 0, res: 0, upd: 0;
       cq7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq7G() //  [R1]
         { info_tbl: [(cq7G,
                       label: block_cq7G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq7G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq7W; else goto cq7V;
       cq7W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq7V: // global
           (_spQP::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W32_W64(_spQP::F32);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.783174969 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInteger_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_info;
         const 0;
 },
 sat_spQY_entry() //  [R1]
         { info_tbl: [(cq8v,
                       label: sat_spQY_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq8w; else goto cq8x;
       cq8w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq8x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_spR9_entry() //  [R1]
         { info_tbl: [(cq8W,
                       label: sat_spR9_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cq9a; else goto cq9b;
       cq9a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq9b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cq91_info;
           R2 = I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]);
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cq91() //  [R1]
         { info_tbl: [(cq91,
                       label: block_cq91_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq91: // global
           _spQW::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cq95_info;
           R3 = _spQW::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cq95() //  [D1]
         { info_tbl: [(cq95,
                       label: block_cq95_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq95: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq9f; else goto cq9e;
       cq9f: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cq9e: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_spR4_entry() //  [R1]
         { info_tbl: [(cq9k,
                       label: sat_spR4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq9k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq9l; else goto cq9m;
       cq9l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq9m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_spRk_entry() //  [R1]
         { info_tbl: [(cq9G,
                       label: sat_spRk_info
                       rep:HeapRep 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq9G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cq9X; else goto cq9Y;
       cq9X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq9Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cq9O_info;
           R2 = -(I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]));
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cq9O() //  [R1]
         { info_tbl: [(cq9O,
                       label: block_cq9O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq9O: // global
           _spQW::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cq9S_info;
           R3 = _spQW::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cq9S() //  [D1]
         { info_tbl: [(cq9S,
                       label: block_cq9S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq9S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqa2; else goto cqa1;
       cqa2: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cqa1: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_spRe_entry() //  [R1]
         { info_tbl: [(cqa9,
                       label: sat_spRe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqa9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqaa; else goto cqab;
       cqaa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqab: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.RealFracMethods.properFractionDoubleInteger_entry() //  [R2]
         { info_tbl: [(cqac,
                       label: GHC.Float.RealFracMethods.properFractionDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqac: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqad; else goto cqae;
       cqad: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqae: // global
           I64[Sp - 8] = block_cq8f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqaI; else goto cq8g;
       uqaI: // global
           call _cq8f(R1) args: 0, res: 0, upd: 0;
       cq8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cq8f() //  [R1]
         { info_tbl: [(cq8f,
                       label: block_cq8f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8f: // global
           I64[Sp - 8] = block_cq8k_info;
           D1 = F64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cq8k() //  [R1, R2]
         { info_tbl: [(cq8k,
                       label: block_cq8k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8k: // global
           I64[Sp - 8] = R2;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call _cq8l() args: 0, res: 0, upd: 0;
     }
 },
 _cq8l() //  []
         { info_tbl: [(cq8l,
                       label: block_cq8l_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cqai; else goto cqah;
       cqai: // global
           HpAlloc = 56;
           I64[Sp] = block_cq8l_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cqah: // global
           _spQV::P64 = P64[Sp + 16];
           _spQW::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_spQW::I64, 0)) goto cqal; else goto cqaF;
       cqal: // global
           I64[Hp - 48] = sat_spQY_info;
           P64[Hp - 32] = _spQV::P64;
           I64[Hp - 24] = _spQW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cqaF: // global
           _spQZ::I64 = -_spQW::I64;
           if (%MO_S_Le_W64(_spQZ::I64, 52)) goto cqan; else goto cqaE;
       cqan: // global
           Hp = Hp - 56;
           I64[Sp] = block_cq8F_info;
           R3 = lvl_roLO_closure;
           R2 = _spQV::P64;
           I64[Sp + 24] = _spQZ::I64;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cqaE: // global
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = lvl_roLO_closure;
           P64[Hp - 32] = P64[Sp + 24];
           _cqaD::P64 = Hp - 47;
           Hp = Hp - 32;
           R1 = _cqaD::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cq8F() //  [R1]
         { info_tbl: [(cq8F,
                       label: block_cq8F_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8F: // global
           _spQV::P64 = P64[Sp + 16];
           if (R1 == 1) goto cqax; else goto cqar;
       cqax: // global
           I64[Sp] = block_cq9p_info;
           R2 = _spQV::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqar: // global
           I64[Sp] = block_cq8J_info;
           R2 = _spQV::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cq9p() //  [R1]
         { info_tbl: [(cq9p,
                       label: block_cq9p_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq9p: // global
           I64[Sp] = block_cq9t_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cq9t() //  [R1]
         { info_tbl: [(cq9t,
                       label: block_cq9t_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq9t: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cqaB; else goto cqaA;
       cqaB: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cqaA: // global
           I64[Hp - 88] = sat_spRk_info;
           I64[Hp - 72] = I64[Sp + 8];
           _spQZ::I64 = I64[Sp + 24];
           I64[Hp - 64] = _spQZ::I64;
           I64[Hp - 56] = R1;
           _spRc::I64 = %MO_S_Shr_W64(R1, _spQZ::I64);
           I64[Hp - 48] = _spRc::I64;
           I64[Hp - 40] = sat_spRe_info;
           I64[Hp - 24] = _spRc::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cq8J() //  [R1]
         { info_tbl: [(cq8J,
                       label: block_cq8J_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cq8J: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cqau; else goto cqat;
       cqau: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cqat: // global
           I64[Hp - 88] = sat_spR9_info;
           I64[Hp - 72] = I64[Sp + 8];
           _spQZ::I64 = I64[Sp + 24];
           I64[Hp - 64] = _spQZ::I64;
           I64[Hp - 56] = R1;
           _spR3::I64 = %MO_S_Shr_W64(R1, _spQZ::I64);
           I64[Hp - 48] = _spR3::I64;
           I64[Hp - 40] = sat_spR4_info;
           I64[Hp - 24] = _spR3::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.817551278 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateDoubleInteger_closure" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_closure:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateDoubleInteger_entry() //  [R2]
         { info_tbl: [(cqcC,
                       label: GHC.Float.RealFracMethods.truncateDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqcC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cqcD; else goto cqcE;
       cqcD: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqcE: // global
           I64[Sp - 8] = block_cqcz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqdy; else goto cqcA;
       uqdy: // global
           call _cqcz(R1) args: 0, res: 0, upd: 0;
       cqcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqcz() //  [R1]
         { info_tbl: [(cqcz,
                       label: block_cqcz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqcz: // global
           I64[Sp] = block_cqcH_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cqcH() //  [R1, R2]
         { info_tbl: [(cqcH,
                       label: block_cqcH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqcH: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqcQ; else goto cqds;
       cqcQ: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cqds: // global
           _spRs::I64 = -R2;
           if (%MO_S_Le_W64(_spRs::I64, 52)) goto cqd1; else goto cqdr;
       cqd1: // global
           I64[Sp - 16] = block_cqcZ_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           I64[Sp - 8] = _spRs::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cqdr: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cqcZ() //  [R1]
         { info_tbl: [(cqcZ,
                       label: block_cqcZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqcZ: // global
           _spRp::P64 = P64[Sp + 16];
           if (R1 == 1) goto cqdl; else goto cqd8;
       cqdl: // global
           I64[Sp] = block_cqdf_info;
           R2 = _spRp::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqd8: // global
           I64[Sp] = block_cqd5_info;
           R2 = _spRp::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqdf() //  [R1]
         { info_tbl: [(cqdf,
                       label: block_cqdf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqdf: // global
           I64[Sp] = block_cqdj_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqdj() //  [R1]
         { info_tbl: [(cqdj,
                       label: block_cqdj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqdj: // global
           R2 = -%MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cqd5() //  [R1]
         { info_tbl: [(cqd5,
                       label: block_cqd5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqd5: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.831333846 UTC

[section ""data" . sat_spRB_closure" {
     sat_spRB_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.833000918 UTC

[section ""data" . sat_spRC_closure" {
     sat_spRC_closure:
         const :_con_info;
         const sat_spRB_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.835396884 UTC

[section ""data" . lvl1_roLP_closure" {
     lvl1_roLP_closure:
         const lvl1_roLP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_roLP_entry() //  [R1]
         { info_tbl: [(cqee,
                       label: lvl1_roLP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqef; else goto cqeg;
       cqef: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqeg: // global
           (_cqeb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqeb::I64 == 0) goto cqed; else goto cqec;
       cqed: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqec: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqeb::I64;
           R3 = sat_spRC_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.839872013 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInteger_closure" {
     GHC.Float.RealFracMethods.floorFloatInteger_closure:
         const GHC.Float.RealFracMethods.floorFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorFloatInteger_entry() //  [R2]
         { info_tbl: [(cqex,
                       label: GHC.Float.RealFracMethods.floorFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqey; else goto cqez;
       cqey: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqez: // global
           I64[Sp - 8] = block_cqeu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqfa; else goto cqev;
       uqfa: // global
           call _cqeu(R1) args: 0, res: 0, upd: 0;
       cqev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqeu() //  [R1]
         { info_tbl: [(cqeu,
                       label: block_cqeu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqeu: // global
           I64[Sp] = block_cqeC_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cqeC() //  [R1, R2]
         { info_tbl: [(cqeC,
                       label: block_cqeC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqeC: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqeN; else goto cqf8;
       cqeN: // global
           I64[Sp - 8] = block_cqeL_info;
           _spRI::I64 = R2;
           R2 = R1;
           I64[Sp] = _spRI::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqf8: // global
           _spRL::I64 = -R2;
           if (%MO_S_Le_W64(_spRL::I64, 23)) goto cqeZ; else goto cqf7;
       cqeZ: // global
           R2 = %MO_S_Shr_W64(R1, _spRL::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cqf7: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cqf5; else goto cqf6;
       cqf5: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqf6: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cqeL() //  [R1]
         { info_tbl: [(cqeL,
                       label: block_cqeL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqeL: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.849157508 UTC

[section ""data" . sat_spRP_closure" {
     sat_spRP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.850882301 UTC

[section ""data" . sat_spRQ_closure" {
     sat_spRQ_closure:
         const :_con_info;
         const sat_spRP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.852973548 UTC

[section ""data" . lvl2_roLQ_closure" {
     lvl2_roLQ_closure:
         const lvl2_roLQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_roLQ_entry() //  [R1]
         { info_tbl: [(cqfE,
                       label: lvl2_roLQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqfE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqfF; else goto cqfG;
       cqfF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqfG: // global
           (_cqfB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqfB::I64 == 0) goto cqfD; else goto cqfC;
       cqfD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqfC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqfB::I64;
           R3 = sat_spRQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.857796727 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInteger_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingFloatInteger_entry() //  [R2]
         { info_tbl: [(cqfX,
                       label: GHC.Float.RealFracMethods.ceilingFloatInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqfX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqfY; else goto cqfZ;
       cqfY: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqfZ: // global
           I64[Sp - 8] = block_cqfU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqgP; else goto cqfV;
       uqgP: // global
           call _cqfU(R1) args: 0, res: 0, upd: 0;
       cqfV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqfU() //  [R1]
         { info_tbl: [(cqfU,
                       label: block_cqfU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqfU: // global
           I64[Sp] = block_cqg6_info;
           F1 = %MO_F_Neg_W32(F32[R1 + 7]);
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 _cqg6() //  [R1, R2]
         { info_tbl: [(cqg6,
                       label: block_cqg6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqg6: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqgk; else goto cqgO;
       cqgk: // global
           I64[Sp - 8] = block_cqge_info;
           _spRX::I64 = R2;
           R2 = R1;
           I64[Sp] = _spRX::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqgO: // global
           _spS1::I64 = -R2;
           if (%MO_S_Le_W64(_spS1::I64, 23)) goto cqgC; else goto cqgN;
       cqgC: // global
           I64[Sp] = block_cqgA_info;
           R2 = %MO_S_Shr_W64(R1, _spS1::I64);
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqgN: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cqgL; else goto cqgM;
       cqgL: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqgM: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cqge() //  [R1]
         { info_tbl: [(cqge,
                       label: block_cqge_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqge: // global
           _spRX::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cqgi_info;
           R3 = _spRX::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqgi() //  [R1]
         { info_tbl: [(cqgi,
                       label: block_cqgi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqgi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cqgA() //  [R1]
         { info_tbl: [(cqgA,
                       label: block_cqgA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqgA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.870344804 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInteger_closure" {
     GHC.Float.RealFracMethods.floorDoubleInteger_closure:
         const GHC.Float.RealFracMethods.floorDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorDoubleInteger_entry() //  [R2]
         { info_tbl: [(cqhs,
                       label: GHC.Float.RealFracMethods.floorDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqhs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqht; else goto cqhu;
       cqht: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqhu: // global
           I64[Sp - 8] = block_cqhp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqib; else goto cqhq;
       uqib: // global
           call _cqhp(R1) args: 0, res: 0, upd: 0;
       cqhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqhp() //  [R1]
         { info_tbl: [(cqhp,
                       label: block_cqhp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqhp: // global
           I64[Sp] = block_cqhx_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cqhx() //  [R1, R2]
         { info_tbl: [(cqhx,
                       label: block_cqhx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqhx: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqhG; else goto cqi9;
       cqhG: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cqi9: // global
           _spSd::I64 = -R2;
           if (%MO_S_Le_W64(_spSd::I64, 52)) goto cqhR; else goto cqhY;
       cqhR: // global
           I64[Sp - 8] = block_cqhP_info;
           R2 = R1;
           I64[Sp] = _spSd::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cqhY: // global
           I64[Sp] = block_cqhX_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqhP() //  [R1]
         { info_tbl: [(cqhP,
                       label: block_cqhP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqhP: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cqhX() //  [R1]
         { info_tbl: [(cqhX,
                       label: block_cqhX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqhX: // global
           if (R1 == 1) goto cqi8; else goto cqi4;
       cqi8: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqi4: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.881826159 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInteger_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInteger_entry() //  [R2]
         { info_tbl: [(cqiI,
                       label: GHC.Float.RealFracMethods.ceilingDoubleInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqiI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqiJ; else goto cqiK;
       cqiJ: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqiK: // global
           I64[Sp - 8] = block_cqiF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqjG; else goto cqiG;
       uqjG: // global
           call _cqiF(R1) args: 0, res: 0, upd: 0;
       cqiG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqiF() //  [R1]
         { info_tbl: [(cqiF,
                       label: block_cqiF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqiF: // global
           I64[Sp] = block_cqiR_info;
           D1 = %MO_F_Neg_W64(F64[R1 + 7]);
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 _cqiR() //  [R1, R2]
         { info_tbl: [(cqiR,
                       label: block_cqiR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqiR: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqj1; else goto cqjF;
       cqj1: // global
           I64[Sp] = block_cqiZ_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       cqjF: // global
           _spSr::I64 = -R2;
           if (%MO_S_Le_W64(_spSr::I64, 52)) goto cqjm; else goto cqju;
       cqjm: // global
           I64[Sp - 8] = block_cqjd_info;
           R2 = R1;
           I64[Sp] = _spSr::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cqju: // global
           I64[Sp] = block_cqjt_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqiZ() //  [R1]
         { info_tbl: [(cqiZ,
                       label: block_cqiZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqiZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cqjd() //  [R1]
         { info_tbl: [(cqjd,
                       label: block_cqjd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqjd: // global
           _spSu::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cqjk_info;
           R2 = _spSu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqjk() //  [R1]
         { info_tbl: [(cqjk,
                       label: block_cqjk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqjk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cqjt() //  [R1]
         { info_tbl: [(cqjt,
                       label: block_cqjt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqjt: // global
           if (R1 == 1) goto cqjE; else goto cqjA;
       cqjE: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqjA: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.895183066 UTC

[section ""relreadonly" . SpXI_srt" {
     SpXI_srt:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
         const lvl_roLO_closure;
         const GHC.Float.RealFracMethods.truncateFloatInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Float.RealFracMethods.roundDoubleInteger_closure;
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
         const GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
         const sat_spRC_closure;
         const GHC.Float.RealFracMethods.floorFloatInteger_closure;
         const lvl1_roLP_closure;
         const sat_spRQ_closure;
         const GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
         const lvl2_roLQ_closure;
         const GHC.Float.RealFracMethods.floorDoubleInteger_closure;
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
 }]

