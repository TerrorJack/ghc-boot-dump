
==================== Pre unarise: ====================
2018-03-16 15:55:02.406709167 UTC

GHC.Float.RealFracMethods.properFractionDoubleInt3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Float.RealFracMethods.properFractionFloatInt2
  :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

GHC.Float.RealFracMethods.properFractionFloatInt1
  :: (GHC.Types.Int, GHC.Types.Float)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionFloatInt2];

GHC.Float.RealFracMethods.properFractionFloatInt
  :: GHC.Types.Float -> (GHC.Types.Int, GHC.Types.Float)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soLS]
        case ds_soLS of {
          GHC.Types.F# x_soLU ->
              case eqFloat# [x_soLU 0.0#] of {
                __DEFAULT ->
                    case float2Int# [x_soLU] of n_soLW {
                      __DEFAULT ->
                          case int2Float# [n_soLW] of sat_soLY {
                            __DEFAULT ->
                                case minusFloat# [x_soLU sat_soLY] of sat_soLZ {
                                  __DEFAULT ->
                                      let {
                                        sat_soM0 [Occ=Once] :: GHC.Types.Float
                                        [LclId] =
                                            CCCS GHC.Types.F#! [sat_soLZ]; } in
                                      let {
                                        sat_soLX [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_soLW];
                                      } in  (,) [sat_soLX sat_soM0];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionFloatInt1;
              };
        };

GHC.Float.RealFracMethods.floorFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soM1]
        case ds_soM1 of {
          GHC.Types.F# x_soM3 ->
              case float2Int# [x_soM3] of n_soM4 [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_soM4] of sat_soM5 {
                      __DEFAULT ->
                          case ltFloat# [x_soM3 sat_soM5] of {
                            __DEFAULT -> GHC.Types.I# [n_soM4];
                            1# ->
                                case -# [n_soM4 1#] of sat_soM7 {
                                  __DEFAULT -> GHC.Types.I# [sat_soM7];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soM8]
        case ds_soM8 of {
          GHC.Types.F# x_soMa ->
              case float2Int# [x_soMa] of n_soMb [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_soMb] of sat_soMc {
                      __DEFAULT ->
                          case ltFloat# [sat_soMc x_soMa] of {
                            __DEFAULT -> GHC.Types.I# [n_soMb];
                            1# ->
                                case +# [n_soMb 1#] of sat_soMe {
                                  __DEFAULT -> GHC.Types.I# [sat_soMe];
                                };
                          };
                    };
              };
        };

lvl_roLO :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Float.RealFracMethods.properFractionFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> (GHC.Integer.Type.Integer, GHC.Types.Float)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_soMf]
        case v_soMf of wild_soMg {
          GHC.Types.F# x_soMh [Occ=Once] ->
              case decodeFloat_Int# [x_soMh] of {
                (#,#) ipv_soMj ipv1_soMk ->
                    case <# [ipv1_soMk 0#] of {
                      __DEFAULT ->
                          let {
                            sat_soMn [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_soMj ipv1_soMk] \u []
                                    case GHC.Integer.Type.smallInteger ipv_soMj of sat_soMm {
                                      __DEFAULT ->
                                          GHC.Integer.Type.shiftLInteger sat_soMm ipv1_soMk;
                                    };
                          } in 
                            (,) [sat_soMn GHC.Float.RealFracMethods.properFractionFloatInt2];
                      1# ->
                          case negateInt# [ipv1_soMk] of s_soMo [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soMo 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_soMj 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_soMj s_soMo] of k_soMr {
                                              __DEFAULT ->
                                                  let {
                                                    sat_soMx [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        [ipv_soMj ipv1_soMk s_soMo k_soMr] \u []
                                                            case
                                                                uncheckedIShiftL# [k_soMr s_soMo]
                                                            of
                                                            sat_soMt
                                                            { __DEFAULT ->
                                                                  case
                                                                      -# [ipv_soMj sat_soMt]
                                                                  of
                                                                  sat_soMu
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.smallInteger
                                                                                sat_soMu
                                                                        of
                                                                        sat_soMv
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.encodeFloatInteger
                                                                                      sat_soMv
                                                                                      ipv1_soMk
                                                                              of
                                                                              wild1_soMw
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.F# [wild1_soMw];
                                                                              };
                                                                        };
                                                                  };
                                                            }; } in
                                                  let {
                                                    sat_soMs [Occ=Once] :: GHC.Integer.Type.Integer
                                                    [LclId] =
                                                        [k_soMr] \u []
                                                            GHC.Integer.Type.smallInteger k_soMr;
                                                  } in  (,) [sat_soMs sat_soMx];
                                            };
                                        1# ->
                                            case negateInt# [ipv_soMj] of sat_soMz {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_soMz s_soMo]
                                                  of
                                                  sat_soMA
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_soMA] of k_soMy {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_soMG [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    [ipv_soMj
                                                                     ipv1_soMk
                                                                     s_soMo
                                                                     k_soMy] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_soMy
                                                                                               s_soMo]
                                                                        of
                                                                        sat_soMC
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [ipv_soMj
                                                                                      sat_soMC]
                                                                              of
                                                                              sat_soMD
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.smallInteger
                                                                                            sat_soMD
                                                                                    of
                                                                                    sat_soME
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.encodeFloatInteger
                                                                                                  sat_soME
                                                                                                  ipv1_soMk
                                                                                          of
                                                                                          wild1_soMF
                                                                                          { __DEFAULT ->
                                                                                                GHC.Types.F# [wild1_soMF];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_soMB [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_soMy] \u []
                                                                        GHC.Integer.Type.smallInteger
                                                                            k_soMy;
                                                              } in  (,) [sat_soMB sat_soMG];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_soMg];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_soMH]
        case x_soMH of {
          GHC.Types.F# x1_soMJ [Occ=Once] ->
              case decodeFloat_Int# [x1_soMJ] of {
                (#,#) ipv_soML ipv1_soMM ->
                    case <# [ipv1_soMM 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_soML of sat_soMO {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_soMO ipv1_soMM;
                          };
                      1# ->
                          case negateInt# [ipv1_soMM] of s_soMP [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soMP 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_soML 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_soML s_soMP] of sat_soMS {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_soMS;
                                            };
                                        1# ->
                                            case negateInt# [ipv_soML] of sat_soMT {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_soMT s_soMP]
                                                  of
                                                  sat_soMU
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_soMU] of sat_soMV {
                                                          __DEFAULT ->
                                                              GHC.Integer.Type.smallInteger
                                                                  sat_soMV;
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInt2
  :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

GHC.Float.RealFracMethods.properFractionDoubleInt1
  :: (GHC.Types.Int, GHC.Types.Double)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionDoubleInt2];

GHC.Float.RealFracMethods.properFractionDoubleInt
  :: GHC.Types.Double -> (GHC.Types.Int, GHC.Types.Double)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soMW]
        case ds_soMW of {
          GHC.Types.D# x_soMY ->
              case ==## [x_soMY 0.0##] of {
                __DEFAULT ->
                    case double2Int# [x_soMY] of n_soN0 {
                      __DEFAULT ->
                          case int2Double# [n_soN0] of sat_soN2 {
                            __DEFAULT ->
                                case -## [x_soMY sat_soN2] of sat_soN3 {
                                  __DEFAULT ->
                                      let {
                                        sat_soN4 [Occ=Once] :: GHC.Types.Double
                                        [LclId] =
                                            CCCS GHC.Types.D#! [sat_soN3]; } in
                                      let {
                                        sat_soN1 [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_soN0];
                                      } in  (,) [sat_soN1 sat_soN4];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionDoubleInt1;
              };
        };

GHC.Float.RealFracMethods.floorDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soN5]
        case ds_soN5 of {
          GHC.Types.D# x_soN7 ->
              case double2Int# [x_soN7] of n_soN8 [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_soN8] of sat_soN9 {
                      __DEFAULT ->
                          case <## [x_soN7 sat_soN9] of {
                            __DEFAULT -> GHC.Types.I# [n_soN8];
                            1# ->
                                case -# [n_soN8 1#] of sat_soNb {
                                  __DEFAULT -> GHC.Types.I# [sat_soNb];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNc]
        case ds_soNc of {
          GHC.Types.D# x_soNe ->
              case double2Int# [x_soNe] of n_soNf [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_soNf] of sat_soNg {
                      __DEFAULT ->
                          case <## [sat_soNg x_soNe] of {
                            __DEFAULT -> GHC.Types.I# [n_soNf];
                            1# ->
                                case +# [n_soNf 1#] of sat_soNi {
                                  __DEFAULT -> GHC.Types.I# [sat_soNi];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.double2Int
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNj]
        case ds_soNj of {
          GHC.Types.D# x_soNl [Occ=Once] ->
              case double2Int# [x_soNl] of sat_soNm {
                __DEFAULT -> GHC.Types.I# [sat_soNm];
              };
        };

GHC.Float.RealFracMethods.int2Double
  :: GHC.Types.Int -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNn]
        case ds_soNn of {
          GHC.Types.I# i_soNp [Occ=Once] ->
              case int2Double# [i_soNp] of sat_soNq {
                __DEFAULT -> GHC.Types.D# [sat_soNq];
              };
        };

GHC.Float.RealFracMethods.float2Int
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNr]
        case ds_soNr of {
          GHC.Types.F# x_soNt [Occ=Once] ->
              case float2Int# [x_soNt] of sat_soNu {
                __DEFAULT -> GHC.Types.I# [sat_soNu];
              };
        };

GHC.Float.RealFracMethods.int2Float
  :: GHC.Types.Int -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNv]
        case ds_soNv of {
          GHC.Types.I# i_soNx [Occ=Once] ->
              case int2Float# [i_soNx] of sat_soNy {
                __DEFAULT -> GHC.Types.F# [sat_soNy];
              };
        };

GHC.Float.RealFracMethods.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Float.RealFracMethods.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule4];

GHC.Float.RealFracMethods.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Float.RealFracMethods"#;

GHC.Float.RealFracMethods.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule2];

GHC.Float.RealFracMethods.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Float.RealFracMethods.$trModule3
                                     GHC.Float.RealFracMethods.$trModule1];

GHC.Float.RealFracMethods.roundDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_soNz]
        case x_soNz of {
          GHC.Types.D# ds1_soNB [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soNB GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_soNF [Occ=Once] ->
                    case double2Int# [ds3_soNF] of sat_soNG {
                      __DEFAULT -> GHC.Types.I# [sat_soNG];
                    };
              };
        };

GHC.Float.RealFracMethods.roundDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_soNH]
        case x_soNH of {
          GHC.Types.D# ds1_soNJ [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soNJ GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_soNN [Occ=Once] ->
                    case GHC.Integer.Type.decodeDoubleInteger ds3_soNN of {
                      (#,#) ipv_soNP [Occ=Once*] ipv1_soNQ ->
                          case <# [ipv1_soNQ 0#] of {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_soNP ipv1_soNQ;
                            1# ->
                                case GHC.Integer.Type.integerToInt ipv_soNP of n_soNS {
                                  __DEFAULT ->
                                      case negateInt# [ipv1_soNQ] of sat_soNT {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_soNS sat_soNT] of sat_soNU {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_soNU;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_soNV]
        case x_soNV of {
          GHC.Types.F# ds1_soNX [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soNX GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_soO1 [Occ=Once] ->
                    case decodeFloat_Int# [ds3_soO1] of {
                      (#,#) ipv_soO3 [Occ=Once*] ipv1_soO4 ->
                          case <# [ipv1_soO4 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_soO3 of sat_soO6 {
                                  __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_soO6 ipv1_soO4;
                                };
                            1# ->
                                case negateInt# [ipv1_soO4] of sat_soO7 {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_soO3 sat_soO7] of sat_soO8 {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_soO8;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_soO9]
        case x_soO9 of {
          GHC.Types.F# ds1_soOb [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soOb GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_soOf [Occ=Once] ->
                    case float2Int# [ds3_soOf] of sat_soOg {
                      __DEFAULT -> GHC.Types.I# [sat_soOg];
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> (GHC.Integer.Type.Integer, GHC.Types.Double)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_soOh]
        case v_soOh of wild_soOi {
          GHC.Types.D# x_soOj [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_soOj of {
                (#,#) ipv_soOl ipv1_soOm ->
                    case <# [ipv1_soOm 0#] of {
                      __DEFAULT ->
                          let {
                            sat_soOo [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_soOl ipv1_soOm] \u []
                                    GHC.Integer.Type.shiftLInteger ipv_soOl ipv1_soOm;
                          } in 
                            (,) [sat_soOo GHC.Float.RealFracMethods.properFractionDoubleInt2];
                      1# ->
                          case negateInt# [ipv1_soOm] of s_soOp [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soOp 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_soOl lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_soOl of n_soOs {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_soOs s_soOp]
                                                  of
                                                  k_soOt
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_soOz [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              [ipv1_soOm s_soOp n_soOs k_soOt] \u []
                                                                  case
                                                                      uncheckedIShiftL# [k_soOt
                                                                                         s_soOp]
                                                                  of
                                                                  sat_soOv
                                                                  { __DEFAULT ->
                                                                        case
                                                                            -# [n_soOs sat_soOv]
                                                                        of
                                                                        sat_soOw
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.smallInteger
                                                                                      sat_soOw
                                                                              of
                                                                              sat_soOx
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.encodeDoubleInteger
                                                                                            sat_soOx
                                                                                            ipv1_soOm
                                                                                    of
                                                                                    wild2_soOy
                                                                                    { __DEFAULT ->
                                                                                          GHC.Types.D# [wild2_soOy];
                                                                                    };
                                                                              };
                                                                        };
                                                                  }; } in
                                                        let {
                                                          sat_soOu [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [k_soOt] \u []
                                                                  GHC.Integer.Type.smallInteger
                                                                      k_soOt;
                                                        } in  (,) [sat_soOu sat_soOz];
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_soOl
                                            of
                                            sat_soOA
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_soOA
                                                  of
                                                  n_soOB
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_soOB s_soOp]
                                                        of
                                                        k_soOC
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_soOK [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    [ipv1_soOm
                                                                     s_soOp
                                                                     n_soOB
                                                                     k_soOC] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_soOC
                                                                                               s_soOp]
                                                                        of
                                                                        sat_soOF
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [n_soOB
                                                                                      sat_soOF]
                                                                              of
                                                                              sat_soOG
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        negateInt# [sat_soOG]
                                                                                    of
                                                                                    sat_soOH
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_soOH
                                                                                          of
                                                                                          sat_soOI
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    GHC.Integer.Type.encodeDoubleInteger
                                                                                                        sat_soOI
                                                                                                        ipv1_soOm
                                                                                                of
                                                                                                wild2_soOJ
                                                                                                { __DEFAULT ->
                                                                                                      GHC.Types.D# [wild2_soOJ];
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_soOE [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_soOC] \u []
                                                                        case
                                                                            negateInt# [k_soOC]
                                                                        of
                                                                        sat_soOD
                                                                        { __DEFAULT ->
                                                                              GHC.Integer.Type.smallInteger
                                                                                  sat_soOD;
                                                                        };
                                                              } in  (,) [sat_soOE sat_soOK];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_soOi];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_soOL]
        case x_soOL of {
          GHC.Types.D# x1_soON [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x1_soON of {
                (#,#) ipv_soOP ipv1_soOQ ->
                    case <# [ipv1_soOQ 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_soOP ipv1_soOQ;
                      1# ->
                          case negateInt# [ipv1_soOQ] of s_soOS [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soOS 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_soOP lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_soOP of n_soOV {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_soOV s_soOS]
                                                  of
                                                  sat_soOW
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.smallInteger sat_soOW;
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_soOP
                                            of
                                            sat_soOX
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_soOX
                                                  of
                                                  n_soOY
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_soOY s_soOS]
                                                        of
                                                        sat_soOZ
                                                        { __DEFAULT ->
                                                              case
                                                                  negateInt# [sat_soOZ]
                                                              of
                                                              sat_soP0
                                                              { __DEFAULT ->
                                                                    GHC.Integer.Type.smallInteger
                                                                        sat_soP0;
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

sat_soP1 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_soP2 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_soP1 GHC.Types.[]];

lvl1_roLP :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_soP2;

GHC.Float.RealFracMethods.floorFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soP3]
        case ds_soP3 of {
          GHC.Types.F# x_soP5 [Occ=Once] ->
              case decodeFloat_Int# [x_soP5] of {
                (#,#) ipv_soP7 [Occ=Once*] ipv1_soP8 ->
                    case <# [ipv1_soP8 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_soP7 of sat_soPa {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_soPa ipv1_soP8;
                          };
                      1# ->
                          case negateInt# [ipv1_soP8] of s_soPb [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soPb 23#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_soP7 s_soPb] of sat_soPd {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_soPd;
                                      };
                                  1# ->
                                      case <# [ipv_soP7 0#] of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

sat_soPf :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_soPg :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_soPf GHC.Types.[]];

lvl2_roLQ :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_soPg;

GHC.Float.RealFracMethods.ceilingFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soPh]
        case ds_soPh of {
          GHC.Types.F# x_soPj [Occ=Once] ->
              case negateFloat# [x_soPj] of sat_soPk {
                __DEFAULT ->
                    case decodeFloat_Int# [sat_soPk] of {
                      (#,#) ipv_soPm [Occ=Once*] ipv1_soPn ->
                          case <# [ipv1_soPn 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_soPm of sat_soPp {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.shiftLInteger sat_soPp ipv1_soPn
                                      of
                                      sat_soPq
                                      { __DEFAULT -> GHC.Integer.Type.negateInteger sat_soPq;
                                      };
                                };
                            1# ->
                                case negateInt# [ipv1_soPn] of s_soPr [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_soPr 23#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [ipv_soPm s_soPr] of sat_soPt {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.smallInteger sat_soPt
                                                  of
                                                  sat_soPu
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.negateInteger sat_soPu;
                                                  };
                                            };
                                        1# ->
                                            case <# [ipv_soPm 0#] of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.floorDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soPw]
        case ds_soPw of {
          GHC.Types.D# x_soPy [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_soPy of {
                (#,#) ipv_soPA [Occ=Once*] ipv1_soPB ->
                    case <# [ipv1_soPB 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_soPA ipv1_soPB;
                      1# ->
                          case negateInt# [ipv1_soPB] of s_soPD [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soPD 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.integerToInt ipv_soPA of n_soPF {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_soPF s_soPD] of sat_soPG {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_soPG;
                                            };
                                      };
                                  1# ->
                                      case GHC.Integer.Type.ltInteger# ipv_soPA lvl_roLO of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soPI]
        case ds_soPI of {
          GHC.Types.D# x_soPK [Occ=Once] ->
              case negateDouble# [x_soPK] of sat_soPL {
                __DEFAULT ->
                    case GHC.Integer.Type.decodeDoubleInteger sat_soPL of {
                      (#,#) ipv_soPN [Occ=Once*] ipv1_soPO ->
                          case <# [ipv1_soPO 0#] of {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.shiftLInteger ipv_soPN ipv1_soPO
                                of
                                sat_soPQ
                                { __DEFAULT -> GHC.Integer.Type.negateInteger sat_soPQ;
                                };
                            1# ->
                                case negateInt# [ipv1_soPO] of s_soPR [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_soPR 52#] of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_soPN of n_soPT {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_soPT s_soPR]
                                                  of
                                                  sat_soPU
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Integer.Type.smallInteger sat_soPU
                                                        of
                                                        sat_soPV
                                                        { __DEFAULT ->
                                                              GHC.Integer.Type.negateInteger
                                                                  sat_soPV;
                                                        };
                                                  };
                                            };
                                        1# ->
                                            case GHC.Integer.Type.ltInteger# ipv_soPN lvl_roLO of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };


==================== STG syntax: ====================
2018-03-16 15:55:02.420692508 UTC

GHC.Float.RealFracMethods.properFractionDoubleInt3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Float.RealFracMethods.properFractionFloatInt2
  :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

GHC.Float.RealFracMethods.properFractionFloatInt1
  :: (GHC.Types.Int, GHC.Types.Float)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionFloatInt2];

GHC.Float.RealFracMethods.properFractionFloatInt
  :: GHC.Types.Float -> (GHC.Types.Int, GHC.Types.Float)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soLS]
        case ds_soLS of {
          GHC.Types.F# x_soLU ->
              case eqFloat# [x_soLU 0.0#] of {
                __DEFAULT ->
                    case float2Int# [x_soLU] of n_soLW {
                      __DEFAULT ->
                          case int2Float# [n_soLW] of sat_soLY {
                            __DEFAULT ->
                                case minusFloat# [x_soLU sat_soLY] of sat_soLZ {
                                  __DEFAULT ->
                                      let {
                                        sat_soM0 [Occ=Once] :: GHC.Types.Float
                                        [LclId] =
                                            CCCS GHC.Types.F#! [sat_soLZ]; } in
                                      let {
                                        sat_soLX [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_soLW];
                                      } in  (,) [sat_soLX sat_soM0];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionFloatInt1;
              };
        };

GHC.Float.RealFracMethods.floorFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soM1]
        case ds_soM1 of {
          GHC.Types.F# x_soM3 ->
              case float2Int# [x_soM3] of n_soM4 [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_soM4] of sat_soM5 {
                      __DEFAULT ->
                          case ltFloat# [x_soM3 sat_soM5] of {
                            __DEFAULT -> GHC.Types.I# [n_soM4];
                            1# ->
                                case -# [n_soM4 1#] of sat_soM7 {
                                  __DEFAULT -> GHC.Types.I# [sat_soM7];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soM8]
        case ds_soM8 of {
          GHC.Types.F# x_soMa ->
              case float2Int# [x_soMa] of n_soMb [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_soMb] of sat_soMc {
                      __DEFAULT ->
                          case ltFloat# [sat_soMc x_soMa] of {
                            __DEFAULT -> GHC.Types.I# [n_soMb];
                            1# ->
                                case +# [n_soMb 1#] of sat_soMe {
                                  __DEFAULT -> GHC.Types.I# [sat_soMe];
                                };
                          };
                    };
              };
        };

lvl_roLO :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Float.RealFracMethods.properFractionFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> (GHC.Integer.Type.Integer, GHC.Types.Float)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_soMf]
        case v_soMf of wild_soMg {
          GHC.Types.F# x_soMh [Occ=Once] ->
              case decodeFloat_Int# [x_soMh] of {
                (#,#) ipv_soMj ipv1_soMk ->
                    case <# [ipv1_soMk 0#] of {
                      __DEFAULT ->
                          let {
                            sat_soMn [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_soMj ipv1_soMk] \u []
                                    case GHC.Integer.Type.smallInteger ipv_soMj of sat_soMm {
                                      __DEFAULT ->
                                          GHC.Integer.Type.shiftLInteger sat_soMm ipv1_soMk;
                                    };
                          } in 
                            (,) [sat_soMn GHC.Float.RealFracMethods.properFractionFloatInt2];
                      1# ->
                          case negateInt# [ipv1_soMk] of s_soMo [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soMo 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_soMj 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_soMj s_soMo] of k_soMr {
                                              __DEFAULT ->
                                                  let {
                                                    sat_soMx [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        [ipv_soMj ipv1_soMk s_soMo k_soMr] \u []
                                                            case
                                                                uncheckedIShiftL# [k_soMr s_soMo]
                                                            of
                                                            sat_soMt
                                                            { __DEFAULT ->
                                                                  case
                                                                      -# [ipv_soMj sat_soMt]
                                                                  of
                                                                  sat_soMu
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.smallInteger
                                                                                sat_soMu
                                                                        of
                                                                        sat_soMv
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.encodeFloatInteger
                                                                                      sat_soMv
                                                                                      ipv1_soMk
                                                                              of
                                                                              wild1_soMw
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.F# [wild1_soMw];
                                                                              };
                                                                        };
                                                                  };
                                                            }; } in
                                                  let {
                                                    sat_soMs [Occ=Once] :: GHC.Integer.Type.Integer
                                                    [LclId] =
                                                        [k_soMr] \u []
                                                            GHC.Integer.Type.smallInteger k_soMr;
                                                  } in  (,) [sat_soMs sat_soMx];
                                            };
                                        1# ->
                                            case negateInt# [ipv_soMj] of sat_soMz {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_soMz s_soMo]
                                                  of
                                                  sat_soMA
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_soMA] of k_soMy {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_soMG [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    [ipv_soMj
                                                                     ipv1_soMk
                                                                     s_soMo
                                                                     k_soMy] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_soMy
                                                                                               s_soMo]
                                                                        of
                                                                        sat_soMC
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [ipv_soMj
                                                                                      sat_soMC]
                                                                              of
                                                                              sat_soMD
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.smallInteger
                                                                                            sat_soMD
                                                                                    of
                                                                                    sat_soME
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.encodeFloatInteger
                                                                                                  sat_soME
                                                                                                  ipv1_soMk
                                                                                          of
                                                                                          wild1_soMF
                                                                                          { __DEFAULT ->
                                                                                                GHC.Types.F# [wild1_soMF];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_soMB [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_soMy] \u []
                                                                        GHC.Integer.Type.smallInteger
                                                                            k_soMy;
                                                              } in  (,) [sat_soMB sat_soMG];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_soMg];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_soMH]
        case x_soMH of {
          GHC.Types.F# x1_soMJ [Occ=Once] ->
              case decodeFloat_Int# [x1_soMJ] of {
                (#,#) ipv_soML ipv1_soMM ->
                    case <# [ipv1_soMM 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_soML of sat_soMO {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_soMO ipv1_soMM;
                          };
                      1# ->
                          case negateInt# [ipv1_soMM] of s_soMP [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soMP 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_soML 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_soML s_soMP] of sat_soMS {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_soMS;
                                            };
                                        1# ->
                                            case negateInt# [ipv_soML] of sat_soMT {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_soMT s_soMP]
                                                  of
                                                  sat_soMU
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_soMU] of sat_soMV {
                                                          __DEFAULT ->
                                                              GHC.Integer.Type.smallInteger
                                                                  sat_soMV;
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInt2
  :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

GHC.Float.RealFracMethods.properFractionDoubleInt1
  :: (GHC.Types.Int, GHC.Types.Double)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionDoubleInt2];

GHC.Float.RealFracMethods.properFractionDoubleInt
  :: GHC.Types.Double -> (GHC.Types.Int, GHC.Types.Double)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soMW]
        case ds_soMW of {
          GHC.Types.D# x_soMY ->
              case ==## [x_soMY 0.0##] of {
                __DEFAULT ->
                    case double2Int# [x_soMY] of n_soN0 {
                      __DEFAULT ->
                          case int2Double# [n_soN0] of sat_soN2 {
                            __DEFAULT ->
                                case -## [x_soMY sat_soN2] of sat_soN3 {
                                  __DEFAULT ->
                                      let {
                                        sat_soN4 [Occ=Once] :: GHC.Types.Double
                                        [LclId] =
                                            CCCS GHC.Types.D#! [sat_soN3]; } in
                                      let {
                                        sat_soN1 [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_soN0];
                                      } in  (,) [sat_soN1 sat_soN4];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionDoubleInt1;
              };
        };

GHC.Float.RealFracMethods.floorDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soN5]
        case ds_soN5 of {
          GHC.Types.D# x_soN7 ->
              case double2Int# [x_soN7] of n_soN8 [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_soN8] of sat_soN9 {
                      __DEFAULT ->
                          case <## [x_soN7 sat_soN9] of {
                            __DEFAULT -> GHC.Types.I# [n_soN8];
                            1# ->
                                case -# [n_soN8 1#] of sat_soNb {
                                  __DEFAULT -> GHC.Types.I# [sat_soNb];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNc]
        case ds_soNc of {
          GHC.Types.D# x_soNe ->
              case double2Int# [x_soNe] of n_soNf [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_soNf] of sat_soNg {
                      __DEFAULT ->
                          case <## [sat_soNg x_soNe] of {
                            __DEFAULT -> GHC.Types.I# [n_soNf];
                            1# ->
                                case +# [n_soNf 1#] of sat_soNi {
                                  __DEFAULT -> GHC.Types.I# [sat_soNi];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.double2Int
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNj]
        case ds_soNj of {
          GHC.Types.D# x_soNl [Occ=Once] ->
              case double2Int# [x_soNl] of sat_soNm {
                __DEFAULT -> GHC.Types.I# [sat_soNm];
              };
        };

GHC.Float.RealFracMethods.int2Double
  :: GHC.Types.Int -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNn]
        case ds_soNn of {
          GHC.Types.I# i_soNp [Occ=Once] ->
              case int2Double# [i_soNp] of sat_soNq {
                __DEFAULT -> GHC.Types.D# [sat_soNq];
              };
        };

GHC.Float.RealFracMethods.float2Int
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNr]
        case ds_soNr of {
          GHC.Types.F# x_soNt [Occ=Once] ->
              case float2Int# [x_soNt] of sat_soNu {
                __DEFAULT -> GHC.Types.I# [sat_soNu];
              };
        };

GHC.Float.RealFracMethods.int2Float
  :: GHC.Types.Int -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_soNv]
        case ds_soNv of {
          GHC.Types.I# i_soNx [Occ=Once] ->
              case int2Float# [i_soNx] of sat_soNy {
                __DEFAULT -> GHC.Types.F# [sat_soNy];
              };
        };

GHC.Float.RealFracMethods.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Float.RealFracMethods.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule4];

GHC.Float.RealFracMethods.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Float.RealFracMethods"#;

GHC.Float.RealFracMethods.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule2];

GHC.Float.RealFracMethods.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Float.RealFracMethods.$trModule3
                                     GHC.Float.RealFracMethods.$trModule1];

GHC.Float.RealFracMethods.roundDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_soNz]
        case x_soNz of {
          GHC.Types.D# ds1_soNB [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soNB GHC.Prim.realWorld#] of {
                Unit# ds3_soNF [Occ=Once] ->
                    case double2Int# [ds3_soNF] of sat_soNG {
                      __DEFAULT -> GHC.Types.I# [sat_soNG];
                    };
              };
        };

GHC.Float.RealFracMethods.roundDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_soNH]
        case x_soNH of {
          GHC.Types.D# ds1_soNJ [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soNJ GHC.Prim.realWorld#] of {
                Unit# ds3_soNN [Occ=Once] ->
                    case GHC.Integer.Type.decodeDoubleInteger ds3_soNN of {
                      (#,#) ipv_soNP [Occ=Once*] ipv1_soNQ ->
                          case <# [ipv1_soNQ 0#] of {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_soNP ipv1_soNQ;
                            1# ->
                                case GHC.Integer.Type.integerToInt ipv_soNP of n_soNS {
                                  __DEFAULT ->
                                      case negateInt# [ipv1_soNQ] of sat_soNT {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_soNS sat_soNT] of sat_soNU {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_soNU;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_soNV]
        case x_soNV of {
          GHC.Types.F# ds1_soNX [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soNX GHC.Prim.realWorld#] of {
                Unit# ds3_soO1 [Occ=Once] ->
                    case decodeFloat_Int# [ds3_soO1] of {
                      (#,#) ipv_soO3 [Occ=Once*] ipv1_soO4 ->
                          case <# [ipv1_soO4 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_soO3 of sat_soO6 {
                                  __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_soO6 ipv1_soO4;
                                };
                            1# ->
                                case negateInt# [ipv1_soO4] of sat_soO7 {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_soO3 sat_soO7] of sat_soO8 {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_soO8;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_soO9]
        case x_soO9 of {
          GHC.Types.F# ds1_soOb [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_soOb GHC.Prim.realWorld#] of {
                Unit# ds3_soOf [Occ=Once] ->
                    case float2Int# [ds3_soOf] of sat_soOg {
                      __DEFAULT -> GHC.Types.I# [sat_soOg];
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> (GHC.Integer.Type.Integer, GHC.Types.Double)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_soOh]
        case v_soOh of wild_soOi {
          GHC.Types.D# x_soOj [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_soOj of {
                (#,#) ipv_soOl ipv1_soOm ->
                    case <# [ipv1_soOm 0#] of {
                      __DEFAULT ->
                          let {
                            sat_soOo [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_soOl ipv1_soOm] \u []
                                    GHC.Integer.Type.shiftLInteger ipv_soOl ipv1_soOm;
                          } in 
                            (,) [sat_soOo GHC.Float.RealFracMethods.properFractionDoubleInt2];
                      1# ->
                          case negateInt# [ipv1_soOm] of s_soOp [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soOp 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_soOl lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_soOl of n_soOs {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_soOs s_soOp]
                                                  of
                                                  k_soOt
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_soOz [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              [ipv1_soOm s_soOp n_soOs k_soOt] \u []
                                                                  case
                                                                      uncheckedIShiftL# [k_soOt
                                                                                         s_soOp]
                                                                  of
                                                                  sat_soOv
                                                                  { __DEFAULT ->
                                                                        case
                                                                            -# [n_soOs sat_soOv]
                                                                        of
                                                                        sat_soOw
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.smallInteger
                                                                                      sat_soOw
                                                                              of
                                                                              sat_soOx
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.encodeDoubleInteger
                                                                                            sat_soOx
                                                                                            ipv1_soOm
                                                                                    of
                                                                                    wild2_soOy
                                                                                    { __DEFAULT ->
                                                                                          GHC.Types.D# [wild2_soOy];
                                                                                    };
                                                                              };
                                                                        };
                                                                  }; } in
                                                        let {
                                                          sat_soOu [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [k_soOt] \u []
                                                                  GHC.Integer.Type.smallInteger
                                                                      k_soOt;
                                                        } in  (,) [sat_soOu sat_soOz];
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_soOl
                                            of
                                            sat_soOA
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_soOA
                                                  of
                                                  n_soOB
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_soOB s_soOp]
                                                        of
                                                        k_soOC
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_soOK [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    [ipv1_soOm
                                                                     s_soOp
                                                                     n_soOB
                                                                     k_soOC] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_soOC
                                                                                               s_soOp]
                                                                        of
                                                                        sat_soOF
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [n_soOB
                                                                                      sat_soOF]
                                                                              of
                                                                              sat_soOG
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        negateInt# [sat_soOG]
                                                                                    of
                                                                                    sat_soOH
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_soOH
                                                                                          of
                                                                                          sat_soOI
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    GHC.Integer.Type.encodeDoubleInteger
                                                                                                        sat_soOI
                                                                                                        ipv1_soOm
                                                                                                of
                                                                                                wild2_soOJ
                                                                                                { __DEFAULT ->
                                                                                                      GHC.Types.D# [wild2_soOJ];
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_soOE [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_soOC] \u []
                                                                        case
                                                                            negateInt# [k_soOC]
                                                                        of
                                                                        sat_soOD
                                                                        { __DEFAULT ->
                                                                              GHC.Integer.Type.smallInteger
                                                                                  sat_soOD;
                                                                        };
                                                              } in  (,) [sat_soOE sat_soOK];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_soOi];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_soOL]
        case x_soOL of {
          GHC.Types.D# x1_soON [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x1_soON of {
                (#,#) ipv_soOP ipv1_soOQ ->
                    case <# [ipv1_soOQ 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_soOP ipv1_soOQ;
                      1# ->
                          case negateInt# [ipv1_soOQ] of s_soOS [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soOS 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_soOP lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_soOP of n_soOV {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_soOV s_soOS]
                                                  of
                                                  sat_soOW
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.smallInteger sat_soOW;
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_soOP
                                            of
                                            sat_soOX
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_soOX
                                                  of
                                                  n_soOY
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_soOY s_soOS]
                                                        of
                                                        sat_soOZ
                                                        { __DEFAULT ->
                                                              case
                                                                  negateInt# [sat_soOZ]
                                                              of
                                                              sat_soP0
                                                              { __DEFAULT ->
                                                                    GHC.Integer.Type.smallInteger
                                                                        sat_soP0;
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

sat_soP1 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_soP2 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_soP1 GHC.Types.[]];

lvl1_roLP :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_soP2;

GHC.Float.RealFracMethods.floorFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soP3]
        case ds_soP3 of {
          GHC.Types.F# x_soP5 [Occ=Once] ->
              case decodeFloat_Int# [x_soP5] of {
                (#,#) ipv_soP7 [Occ=Once*] ipv1_soP8 ->
                    case <# [ipv1_soP8 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_soP7 of sat_soPa {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_soPa ipv1_soP8;
                          };
                      1# ->
                          case negateInt# [ipv1_soP8] of s_soPb [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soPb 23#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_soP7 s_soPb] of sat_soPd {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_soPd;
                                      };
                                  1# ->
                                      case <# [ipv_soP7 0#] of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

sat_soPf :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_soPg :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_soPf GHC.Types.[]];

lvl2_roLQ :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_soPg;

GHC.Float.RealFracMethods.ceilingFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soPh]
        case ds_soPh of {
          GHC.Types.F# x_soPj [Occ=Once] ->
              case negateFloat# [x_soPj] of sat_soPk {
                __DEFAULT ->
                    case decodeFloat_Int# [sat_soPk] of {
                      (#,#) ipv_soPm [Occ=Once*] ipv1_soPn ->
                          case <# [ipv1_soPn 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_soPm of sat_soPp {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.shiftLInteger sat_soPp ipv1_soPn
                                      of
                                      sat_soPq
                                      { __DEFAULT -> GHC.Integer.Type.negateInteger sat_soPq;
                                      };
                                };
                            1# ->
                                case negateInt# [ipv1_soPn] of s_soPr [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_soPr 23#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [ipv_soPm s_soPr] of sat_soPt {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.smallInteger sat_soPt
                                                  of
                                                  sat_soPu
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.negateInteger sat_soPu;
                                                  };
                                            };
                                        1# ->
                                            case <# [ipv_soPm 0#] of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.floorDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soPw]
        case ds_soPw of {
          GHC.Types.D# x_soPy [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_soPy of {
                (#,#) ipv_soPA [Occ=Once*] ipv1_soPB ->
                    case <# [ipv1_soPB 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_soPA ipv1_soPB;
                      1# ->
                          case negateInt# [ipv1_soPB] of s_soPD [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_soPD 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.integerToInt ipv_soPA of n_soPF {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_soPF s_soPD] of sat_soPG {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_soPG;
                                            };
                                      };
                                  1# ->
                                      case GHC.Integer.Type.ltInteger# ipv_soPA lvl_roLO of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_soPI]
        case ds_soPI of {
          GHC.Types.D# x_soPK [Occ=Once] ->
              case negateDouble# [x_soPK] of sat_soPL {
                __DEFAULT ->
                    case GHC.Integer.Type.decodeDoubleInteger sat_soPL of {
                      (#,#) ipv_soPN [Occ=Once*] ipv1_soPO ->
                          case <# [ipv1_soPO 0#] of {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.shiftLInteger ipv_soPN ipv1_soPO
                                of
                                sat_soPQ
                                { __DEFAULT -> GHC.Integer.Type.negateInteger sat_soPQ;
                                };
                            1# ->
                                case negateInt# [ipv1_soPO] of s_soPR [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_soPR 52#] of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_soPN of n_soPT {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_soPT s_soPR]
                                                  of
                                                  sat_soPU
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Integer.Type.smallInteger sat_soPU
                                                        of
                                                        sat_soPV
                                                        { __DEFAULT ->
                                                              GHC.Integer.Type.negateInteger
                                                                  sat_soPV;
                                                        };
                                                  };
                                            };
                                        1# ->
                                            case GHC.Integer.Type.ltInteger# ipv_soPN lvl_roLO of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };


==================== Pre unarise: ====================
2018-03-16 15:55:03.585450998 UTC

GHC.Float.RealFracMethods.properFractionDoubleInt3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Float.RealFracMethods.properFractionFloatInt2
  :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

GHC.Float.RealFracMethods.properFractionFloatInt1
  :: (GHC.Types.Int, GHC.Types.Float)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionFloatInt2];

GHC.Float.RealFracMethods.properFractionFloatInt
  :: GHC.Types.Float -> (GHC.Types.Int, GHC.Types.Float)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spOs]
        case ds_spOs of {
          GHC.Types.F# x_spOu ->
              case eqFloat# [x_spOu 0.0#] of {
                __DEFAULT ->
                    case float2Int# [x_spOu] of n_spOw {
                      __DEFAULT ->
                          case int2Float# [n_spOw] of sat_spOy {
                            __DEFAULT ->
                                case minusFloat# [x_spOu sat_spOy] of sat_spOz {
                                  __DEFAULT ->
                                      let {
                                        sat_spOA [Occ=Once] :: GHC.Types.Float
                                        [LclId] =
                                            CCCS GHC.Types.F#! [sat_spOz]; } in
                                      let {
                                        sat_spOx [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_spOw];
                                      } in  (,) [sat_spOx sat_spOA];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionFloatInt1;
              };
        };

GHC.Float.RealFracMethods.floorFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spOB]
        case ds_spOB of {
          GHC.Types.F# x_spOD ->
              case float2Int# [x_spOD] of n_spOE [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_spOE] of sat_spOF {
                      __DEFAULT ->
                          case ltFloat# [x_spOD sat_spOF] of {
                            __DEFAULT -> GHC.Types.I# [n_spOE];
                            1# ->
                                case -# [n_spOE 1#] of sat_spOH {
                                  __DEFAULT -> GHC.Types.I# [sat_spOH];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spOI]
        case ds_spOI of {
          GHC.Types.F# x_spOK ->
              case float2Int# [x_spOK] of n_spOL [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_spOL] of sat_spOM {
                      __DEFAULT ->
                          case ltFloat# [sat_spOM x_spOK] of {
                            __DEFAULT -> GHC.Types.I# [n_spOL];
                            1# ->
                                case +# [n_spOL 1#] of sat_spOO {
                                  __DEFAULT -> GHC.Types.I# [sat_spOO];
                                };
                          };
                    };
              };
        };

lvl_roLO :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Float.RealFracMethods.properFractionFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> (GHC.Integer.Type.Integer, GHC.Types.Float)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_spOP]
        case v_spOP of wild_spOQ {
          GHC.Types.F# x_spOR [Occ=Once] ->
              case decodeFloat_Int# [x_spOR] of {
                (#,#) ipv_spOT ipv1_spOU ->
                    case <# [ipv1_spOU 0#] of {
                      __DEFAULT ->
                          let {
                            sat_spOX [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_spOT ipv1_spOU] \u []
                                    case GHC.Integer.Type.smallInteger ipv_spOT of sat_spOW {
                                      __DEFAULT ->
                                          GHC.Integer.Type.shiftLInteger sat_spOW ipv1_spOU;
                                    };
                          } in 
                            (,) [sat_spOX GHC.Float.RealFracMethods.properFractionFloatInt2];
                      1# ->
                          case negateInt# [ipv1_spOU] of s_spOY [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spOY 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_spOT 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_spOT s_spOY] of k_spP1 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_spP7 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        [ipv_spOT ipv1_spOU s_spOY k_spP1] \u []
                                                            case
                                                                uncheckedIShiftL# [k_spP1 s_spOY]
                                                            of
                                                            sat_spP3
                                                            { __DEFAULT ->
                                                                  case
                                                                      -# [ipv_spOT sat_spP3]
                                                                  of
                                                                  sat_spP4
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.smallInteger
                                                                                sat_spP4
                                                                        of
                                                                        sat_spP5
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.encodeFloatInteger
                                                                                      sat_spP5
                                                                                      ipv1_spOU
                                                                              of
                                                                              wild1_spP6
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.F# [wild1_spP6];
                                                                              };
                                                                        };
                                                                  };
                                                            }; } in
                                                  let {
                                                    sat_spP2 [Occ=Once] :: GHC.Integer.Type.Integer
                                                    [LclId] =
                                                        [k_spP1] \u []
                                                            GHC.Integer.Type.smallInteger k_spP1;
                                                  } in  (,) [sat_spP2 sat_spP7];
                                            };
                                        1# ->
                                            case negateInt# [ipv_spOT] of sat_spP9 {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_spP9 s_spOY]
                                                  of
                                                  sat_spPa
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_spPa] of k_spP8 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_spPg [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    [ipv_spOT
                                                                     ipv1_spOU
                                                                     s_spOY
                                                                     k_spP8] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_spP8
                                                                                               s_spOY]
                                                                        of
                                                                        sat_spPc
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [ipv_spOT
                                                                                      sat_spPc]
                                                                              of
                                                                              sat_spPd
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.smallInteger
                                                                                            sat_spPd
                                                                                    of
                                                                                    sat_spPe
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.encodeFloatInteger
                                                                                                  sat_spPe
                                                                                                  ipv1_spOU
                                                                                          of
                                                                                          wild1_spPf
                                                                                          { __DEFAULT ->
                                                                                                GHC.Types.F# [wild1_spPf];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_spPb [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_spP8] \u []
                                                                        GHC.Integer.Type.smallInteger
                                                                            k_spP8;
                                                              } in  (,) [sat_spPb sat_spPg];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_spOQ];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_spPh]
        case x_spPh of {
          GHC.Types.F# x1_spPj [Occ=Once] ->
              case decodeFloat_Int# [x1_spPj] of {
                (#,#) ipv_spPl ipv1_spPm ->
                    case <# [ipv1_spPm 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_spPl of sat_spPo {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_spPo ipv1_spPm;
                          };
                      1# ->
                          case negateInt# [ipv1_spPm] of s_spPp [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spPp 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_spPl 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_spPl s_spPp] of sat_spPs {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_spPs;
                                            };
                                        1# ->
                                            case negateInt# [ipv_spPl] of sat_spPt {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_spPt s_spPp]
                                                  of
                                                  sat_spPu
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_spPu] of sat_spPv {
                                                          __DEFAULT ->
                                                              GHC.Integer.Type.smallInteger
                                                                  sat_spPv;
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInt2
  :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

GHC.Float.RealFracMethods.properFractionDoubleInt1
  :: (GHC.Types.Int, GHC.Types.Double)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionDoubleInt2];

GHC.Float.RealFracMethods.properFractionDoubleInt
  :: GHC.Types.Double -> (GHC.Types.Int, GHC.Types.Double)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPw]
        case ds_spPw of {
          GHC.Types.D# x_spPy ->
              case ==## [x_spPy 0.0##] of {
                __DEFAULT ->
                    case double2Int# [x_spPy] of n_spPA {
                      __DEFAULT ->
                          case int2Double# [n_spPA] of sat_spPC {
                            __DEFAULT ->
                                case -## [x_spPy sat_spPC] of sat_spPD {
                                  __DEFAULT ->
                                      let {
                                        sat_spPE [Occ=Once] :: GHC.Types.Double
                                        [LclId] =
                                            CCCS GHC.Types.D#! [sat_spPD]; } in
                                      let {
                                        sat_spPB [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_spPA];
                                      } in  (,) [sat_spPB sat_spPE];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionDoubleInt1;
              };
        };

GHC.Float.RealFracMethods.floorDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPF]
        case ds_spPF of {
          GHC.Types.D# x_spPH ->
              case double2Int# [x_spPH] of n_spPI [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_spPI] of sat_spPJ {
                      __DEFAULT ->
                          case <## [x_spPH sat_spPJ] of {
                            __DEFAULT -> GHC.Types.I# [n_spPI];
                            1# ->
                                case -# [n_spPI 1#] of sat_spPL {
                                  __DEFAULT -> GHC.Types.I# [sat_spPL];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPM]
        case ds_spPM of {
          GHC.Types.D# x_spPO ->
              case double2Int# [x_spPO] of n_spPP [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_spPP] of sat_spPQ {
                      __DEFAULT ->
                          case <## [sat_spPQ x_spPO] of {
                            __DEFAULT -> GHC.Types.I# [n_spPP];
                            1# ->
                                case +# [n_spPP 1#] of sat_spPS {
                                  __DEFAULT -> GHC.Types.I# [sat_spPS];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.double2Int
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPT]
        case ds_spPT of {
          GHC.Types.D# x_spPV [Occ=Once] ->
              case double2Int# [x_spPV] of sat_spPW {
                __DEFAULT -> GHC.Types.I# [sat_spPW];
              };
        };

GHC.Float.RealFracMethods.int2Double
  :: GHC.Types.Int -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPX]
        case ds_spPX of {
          GHC.Types.I# i_spPZ [Occ=Once] ->
              case int2Double# [i_spPZ] of sat_spQ0 {
                __DEFAULT -> GHC.Types.D# [sat_spQ0];
              };
        };

GHC.Float.RealFracMethods.float2Int
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spQ1]
        case ds_spQ1 of {
          GHC.Types.F# x_spQ3 [Occ=Once] ->
              case float2Int# [x_spQ3] of sat_spQ4 {
                __DEFAULT -> GHC.Types.I# [sat_spQ4];
              };
        };

GHC.Float.RealFracMethods.int2Float
  :: GHC.Types.Int -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spQ5]
        case ds_spQ5 of {
          GHC.Types.I# i_spQ7 [Occ=Once] ->
              case int2Float# [i_spQ7] of sat_spQ8 {
                __DEFAULT -> GHC.Types.F# [sat_spQ8];
              };
        };

GHC.Float.RealFracMethods.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Float.RealFracMethods.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule4];

GHC.Float.RealFracMethods.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Float.RealFracMethods"#;

GHC.Float.RealFracMethods.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule2];

GHC.Float.RealFracMethods.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Float.RealFracMethods.$trModule3
                                     GHC.Float.RealFracMethods.$trModule1];

GHC.Float.RealFracMethods.roundDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_spQ9]
        case x_spQ9 of {
          GHC.Types.D# ds1_spQb [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQb GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_spQf [Occ=Once] ->
                    case double2Int# [ds3_spQf] of sat_spQg {
                      __DEFAULT -> GHC.Types.I# [sat_spQg];
                    };
              };
        };

GHC.Float.RealFracMethods.roundDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_spQh]
        case x_spQh of {
          GHC.Types.D# ds1_spQj [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQj GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_spQn [Occ=Once] ->
                    case GHC.Integer.Type.decodeDoubleInteger ds3_spQn of {
                      (#,#) ipv_spQp [Occ=Once*] ipv1_spQq ->
                          case <# [ipv1_spQq 0#] of {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_spQp ipv1_spQq;
                            1# ->
                                case GHC.Integer.Type.integerToInt ipv_spQp of n_spQs {
                                  __DEFAULT ->
                                      case negateInt# [ipv1_spQq] of sat_spQt {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_spQs sat_spQt] of sat_spQu {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_spQu;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_spQv]
        case x_spQv of {
          GHC.Types.F# ds1_spQx [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQx GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_spQB [Occ=Once] ->
                    case decodeFloat_Int# [ds3_spQB] of {
                      (#,#) ipv_spQD [Occ=Once*] ipv1_spQE ->
                          case <# [ipv1_spQE 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_spQD of sat_spQG {
                                  __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_spQG ipv1_spQE;
                                };
                            1# ->
                                case negateInt# [ipv1_spQE] of sat_spQH {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_spQD sat_spQH] of sat_spQI {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_spQI;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_spQJ]
        case x_spQJ of {
          GHC.Types.F# ds1_spQL [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQL GHC.Prim.realWorld#] of {
                (#,#) _ [Occ=Dead] ds3_spQP [Occ=Once] ->
                    case float2Int# [ds3_spQP] of sat_spQQ {
                      __DEFAULT -> GHC.Types.I# [sat_spQQ];
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> (GHC.Integer.Type.Integer, GHC.Types.Double)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_spQR]
        case v_spQR of wild_spQS {
          GHC.Types.D# x_spQT [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_spQT of {
                (#,#) ipv_spQV ipv1_spQW ->
                    case <# [ipv1_spQW 0#] of {
                      __DEFAULT ->
                          let {
                            sat_spQY [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_spQV ipv1_spQW] \u []
                                    GHC.Integer.Type.shiftLInteger ipv_spQV ipv1_spQW;
                          } in 
                            (,) [sat_spQY GHC.Float.RealFracMethods.properFractionDoubleInt2];
                      1# ->
                          case negateInt# [ipv1_spQW] of s_spQZ [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spQZ 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_spQV lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_spQV of n_spR2 {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_spR2 s_spQZ]
                                                  of
                                                  k_spR3
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_spR9 [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              [ipv1_spQW s_spQZ n_spR2 k_spR3] \u []
                                                                  case
                                                                      uncheckedIShiftL# [k_spR3
                                                                                         s_spQZ]
                                                                  of
                                                                  sat_spR5
                                                                  { __DEFAULT ->
                                                                        case
                                                                            -# [n_spR2 sat_spR5]
                                                                        of
                                                                        sat_spR6
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.smallInteger
                                                                                      sat_spR6
                                                                              of
                                                                              sat_spR7
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.encodeDoubleInteger
                                                                                            sat_spR7
                                                                                            ipv1_spQW
                                                                                    of
                                                                                    wild2_spR8
                                                                                    { __DEFAULT ->
                                                                                          GHC.Types.D# [wild2_spR8];
                                                                                    };
                                                                              };
                                                                        };
                                                                  }; } in
                                                        let {
                                                          sat_spR4 [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [k_spR3] \u []
                                                                  GHC.Integer.Type.smallInteger
                                                                      k_spR3;
                                                        } in  (,) [sat_spR4 sat_spR9];
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_spQV
                                            of
                                            sat_spRa
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_spRa
                                                  of
                                                  n_spRb
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_spRb s_spQZ]
                                                        of
                                                        k_spRc
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_spRk [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    [ipv1_spQW
                                                                     s_spQZ
                                                                     n_spRb
                                                                     k_spRc] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_spRc
                                                                                               s_spQZ]
                                                                        of
                                                                        sat_spRf
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [n_spRb
                                                                                      sat_spRf]
                                                                              of
                                                                              sat_spRg
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        negateInt# [sat_spRg]
                                                                                    of
                                                                                    sat_spRh
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_spRh
                                                                                          of
                                                                                          sat_spRi
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    GHC.Integer.Type.encodeDoubleInteger
                                                                                                        sat_spRi
                                                                                                        ipv1_spQW
                                                                                                of
                                                                                                wild2_spRj
                                                                                                { __DEFAULT ->
                                                                                                      GHC.Types.D# [wild2_spRj];
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_spRe [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_spRc] \u []
                                                                        case
                                                                            negateInt# [k_spRc]
                                                                        of
                                                                        sat_spRd
                                                                        { __DEFAULT ->
                                                                              GHC.Integer.Type.smallInteger
                                                                                  sat_spRd;
                                                                        };
                                                              } in  (,) [sat_spRe sat_spRk];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_spQS];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_spRl]
        case x_spRl of {
          GHC.Types.D# x1_spRn [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x1_spRn of {
                (#,#) ipv_spRp ipv1_spRq ->
                    case <# [ipv1_spRq 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_spRp ipv1_spRq;
                      1# ->
                          case negateInt# [ipv1_spRq] of s_spRs [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spRs 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_spRp lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_spRp of n_spRv {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_spRv s_spRs]
                                                  of
                                                  sat_spRw
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.smallInteger sat_spRw;
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_spRp
                                            of
                                            sat_spRx
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_spRx
                                                  of
                                                  n_spRy
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_spRy s_spRs]
                                                        of
                                                        sat_spRz
                                                        { __DEFAULT ->
                                                              case
                                                                  negateInt# [sat_spRz]
                                                              of
                                                              sat_spRA
                                                              { __DEFAULT ->
                                                                    GHC.Integer.Type.smallInteger
                                                                        sat_spRA;
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

sat_spRB :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_spRC :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_spRB GHC.Types.[]];

lvl1_roLP :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_spRC;

GHC.Float.RealFracMethods.floorFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spRD]
        case ds_spRD of {
          GHC.Types.F# x_spRF [Occ=Once] ->
              case decodeFloat_Int# [x_spRF] of {
                (#,#) ipv_spRH [Occ=Once*] ipv1_spRI ->
                    case <# [ipv1_spRI 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_spRH of sat_spRK {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_spRK ipv1_spRI;
                          };
                      1# ->
                          case negateInt# [ipv1_spRI] of s_spRL [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spRL 23#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_spRH s_spRL] of sat_spRN {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_spRN;
                                      };
                                  1# ->
                                      case <# [ipv_spRH 0#] of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

sat_spRP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_spRQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_spRP GHC.Types.[]];

lvl2_roLQ :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_spRQ;

GHC.Float.RealFracMethods.ceilingFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spRR]
        case ds_spRR of {
          GHC.Types.F# x_spRT [Occ=Once] ->
              case negateFloat# [x_spRT] of sat_spRU {
                __DEFAULT ->
                    case decodeFloat_Int# [sat_spRU] of {
                      (#,#) ipv_spRW [Occ=Once*] ipv1_spRX ->
                          case <# [ipv1_spRX 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_spRW of sat_spRZ {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.shiftLInteger sat_spRZ ipv1_spRX
                                      of
                                      sat_spS0
                                      { __DEFAULT -> GHC.Integer.Type.negateInteger sat_spS0;
                                      };
                                };
                            1# ->
                                case negateInt# [ipv1_spRX] of s_spS1 [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_spS1 23#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [ipv_spRW s_spS1] of sat_spS3 {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.smallInteger sat_spS3
                                                  of
                                                  sat_spS4
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.negateInteger sat_spS4;
                                                  };
                                            };
                                        1# ->
                                            case <# [ipv_spRW 0#] of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.floorDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spS6]
        case ds_spS6 of {
          GHC.Types.D# x_spS8 [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_spS8 of {
                (#,#) ipv_spSa [Occ=Once*] ipv1_spSb ->
                    case <# [ipv1_spSb 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_spSa ipv1_spSb;
                      1# ->
                          case negateInt# [ipv1_spSb] of s_spSd [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spSd 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.integerToInt ipv_spSa of n_spSf {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_spSf s_spSd] of sat_spSg {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_spSg;
                                            };
                                      };
                                  1# ->
                                      case GHC.Integer.Type.ltInteger# ipv_spSa lvl_roLO of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spSi]
        case ds_spSi of {
          GHC.Types.D# x_spSk [Occ=Once] ->
              case negateDouble# [x_spSk] of sat_spSl {
                __DEFAULT ->
                    case GHC.Integer.Type.decodeDoubleInteger sat_spSl of {
                      (#,#) ipv_spSn [Occ=Once*] ipv1_spSo ->
                          case <# [ipv1_spSo 0#] of {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.shiftLInteger ipv_spSn ipv1_spSo
                                of
                                sat_spSq
                                { __DEFAULT -> GHC.Integer.Type.negateInteger sat_spSq;
                                };
                            1# ->
                                case negateInt# [ipv1_spSo] of s_spSr [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_spSr 52#] of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_spSn of n_spSt {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_spSt s_spSr]
                                                  of
                                                  sat_spSu
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Integer.Type.smallInteger sat_spSu
                                                        of
                                                        sat_spSv
                                                        { __DEFAULT ->
                                                              GHC.Integer.Type.negateInteger
                                                                  sat_spSv;
                                                        };
                                                  };
                                            };
                                        1# ->
                                            case GHC.Integer.Type.ltInteger# ipv_spSn lvl_roLO of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };


==================== STG syntax: ====================
2018-03-16 15:55:03.6066886 UTC

GHC.Float.RealFracMethods.properFractionDoubleInt3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

GHC.Float.RealFracMethods.properFractionFloatInt2
  :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

GHC.Float.RealFracMethods.properFractionFloatInt1
  :: (GHC.Types.Int, GHC.Types.Float)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionFloatInt2];

GHC.Float.RealFracMethods.properFractionFloatInt
  :: GHC.Types.Float -> (GHC.Types.Int, GHC.Types.Float)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spOs]
        case ds_spOs of {
          GHC.Types.F# x_spOu ->
              case eqFloat# [x_spOu 0.0#] of {
                __DEFAULT ->
                    case float2Int# [x_spOu] of n_spOw {
                      __DEFAULT ->
                          case int2Float# [n_spOw] of sat_spOy {
                            __DEFAULT ->
                                case minusFloat# [x_spOu sat_spOy] of sat_spOz {
                                  __DEFAULT ->
                                      let {
                                        sat_spOA [Occ=Once] :: GHC.Types.Float
                                        [LclId] =
                                            CCCS GHC.Types.F#! [sat_spOz]; } in
                                      let {
                                        sat_spOx [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_spOw];
                                      } in  (,) [sat_spOx sat_spOA];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionFloatInt1;
              };
        };

GHC.Float.RealFracMethods.floorFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spOB]
        case ds_spOB of {
          GHC.Types.F# x_spOD ->
              case float2Int# [x_spOD] of n_spOE [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_spOE] of sat_spOF {
                      __DEFAULT ->
                          case ltFloat# [x_spOD sat_spOF] of {
                            __DEFAULT -> GHC.Types.I# [n_spOE];
                            1# ->
                                case -# [n_spOE 1#] of sat_spOH {
                                  __DEFAULT -> GHC.Types.I# [sat_spOH];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spOI]
        case ds_spOI of {
          GHC.Types.F# x_spOK ->
              case float2Int# [x_spOK] of n_spOL [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Float# [n_spOL] of sat_spOM {
                      __DEFAULT ->
                          case ltFloat# [sat_spOM x_spOK] of {
                            __DEFAULT -> GHC.Types.I# [n_spOL];
                            1# ->
                                case +# [n_spOL 1#] of sat_spOO {
                                  __DEFAULT -> GHC.Types.I# [sat_spOO];
                                };
                          };
                    };
              };
        };

lvl_roLO :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.Float.RealFracMethods.properFractionFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> (GHC.Integer.Type.Integer, GHC.Types.Float)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_spOP]
        case v_spOP of wild_spOQ {
          GHC.Types.F# x_spOR [Occ=Once] ->
              case decodeFloat_Int# [x_spOR] of {
                (#,#) ipv_spOT ipv1_spOU ->
                    case <# [ipv1_spOU 0#] of {
                      __DEFAULT ->
                          let {
                            sat_spOX [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_spOT ipv1_spOU] \u []
                                    case GHC.Integer.Type.smallInteger ipv_spOT of sat_spOW {
                                      __DEFAULT ->
                                          GHC.Integer.Type.shiftLInteger sat_spOW ipv1_spOU;
                                    };
                          } in 
                            (,) [sat_spOX GHC.Float.RealFracMethods.properFractionFloatInt2];
                      1# ->
                          case negateInt# [ipv1_spOU] of s_spOY [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spOY 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_spOT 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_spOT s_spOY] of k_spP1 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_spP7 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        [ipv_spOT ipv1_spOU s_spOY k_spP1] \u []
                                                            case
                                                                uncheckedIShiftL# [k_spP1 s_spOY]
                                                            of
                                                            sat_spP3
                                                            { __DEFAULT ->
                                                                  case
                                                                      -# [ipv_spOT sat_spP3]
                                                                  of
                                                                  sat_spP4
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Integer.Type.smallInteger
                                                                                sat_spP4
                                                                        of
                                                                        sat_spP5
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.encodeFloatInteger
                                                                                      sat_spP5
                                                                                      ipv1_spOU
                                                                              of
                                                                              wild1_spP6
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.F# [wild1_spP6];
                                                                              };
                                                                        };
                                                                  };
                                                            }; } in
                                                  let {
                                                    sat_spP2 [Occ=Once] :: GHC.Integer.Type.Integer
                                                    [LclId] =
                                                        [k_spP1] \u []
                                                            GHC.Integer.Type.smallInteger k_spP1;
                                                  } in  (,) [sat_spP2 sat_spP7];
                                            };
                                        1# ->
                                            case negateInt# [ipv_spOT] of sat_spP9 {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_spP9 s_spOY]
                                                  of
                                                  sat_spPa
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_spPa] of k_spP8 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_spPg [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    [ipv_spOT
                                                                     ipv1_spOU
                                                                     s_spOY
                                                                     k_spP8] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_spP8
                                                                                               s_spOY]
                                                                        of
                                                                        sat_spPc
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [ipv_spOT
                                                                                      sat_spPc]
                                                                              of
                                                                              sat_spPd
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.smallInteger
                                                                                            sat_spPd
                                                                                    of
                                                                                    sat_spPe
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.encodeFloatInteger
                                                                                                  sat_spPe
                                                                                                  ipv1_spOU
                                                                                          of
                                                                                          wild1_spPf
                                                                                          { __DEFAULT ->
                                                                                                GHC.Types.F# [wild1_spPf];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_spPb [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_spP8] \u []
                                                                        GHC.Integer.Type.smallInteger
                                                                            k_spP8;
                                                              } in  (,) [sat_spPb sat_spPg];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_spOQ];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_spPh]
        case x_spPh of {
          GHC.Types.F# x1_spPj [Occ=Once] ->
              case decodeFloat_Int# [x1_spPj] of {
                (#,#) ipv_spPl ipv1_spPm ->
                    case <# [ipv1_spPm 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_spPl of sat_spPo {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_spPo ipv1_spPm;
                          };
                      1# ->
                          case negateInt# [ipv1_spPm] of s_spPp [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spPp 23#] of {
                                  __DEFAULT ->
                                      case <# [ipv_spPl 0#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRL# [ipv_spPl s_spPp] of sat_spPs {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_spPs;
                                            };
                                        1# ->
                                            case negateInt# [ipv_spPl] of sat_spPt {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [sat_spPt s_spPp]
                                                  of
                                                  sat_spPu
                                                  { __DEFAULT ->
                                                        case negateInt# [sat_spPu] of sat_spPv {
                                                          __DEFAULT ->
                                                              GHC.Integer.Type.smallInteger
                                                                  sat_spPv;
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInt2
  :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

GHC.Float.RealFracMethods.properFractionDoubleInt1
  :: (GHC.Types.Int, GHC.Types.Double)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Float.RealFracMethods.properFractionDoubleInt3
                        GHC.Float.RealFracMethods.properFractionDoubleInt2];

GHC.Float.RealFracMethods.properFractionDoubleInt
  :: GHC.Types.Double -> (GHC.Types.Int, GHC.Types.Double)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPw]
        case ds_spPw of {
          GHC.Types.D# x_spPy ->
              case ==## [x_spPy 0.0##] of {
                __DEFAULT ->
                    case double2Int# [x_spPy] of n_spPA {
                      __DEFAULT ->
                          case int2Double# [n_spPA] of sat_spPC {
                            __DEFAULT ->
                                case -## [x_spPy sat_spPC] of sat_spPD {
                                  __DEFAULT ->
                                      let {
                                        sat_spPE [Occ=Once] :: GHC.Types.Double
                                        [LclId] =
                                            CCCS GHC.Types.D#! [sat_spPD]; } in
                                      let {
                                        sat_spPB [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [n_spPA];
                                      } in  (,) [sat_spPB sat_spPE];
                                };
                          };
                    };
                1# -> GHC.Float.RealFracMethods.properFractionDoubleInt1;
              };
        };

GHC.Float.RealFracMethods.floorDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPF]
        case ds_spPF of {
          GHC.Types.D# x_spPH ->
              case double2Int# [x_spPH] of n_spPI [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_spPI] of sat_spPJ {
                      __DEFAULT ->
                          case <## [x_spPH sat_spPJ] of {
                            __DEFAULT -> GHC.Types.I# [n_spPI];
                            1# ->
                                case -# [n_spPI 1#] of sat_spPL {
                                  __DEFAULT -> GHC.Types.I# [sat_spPL];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPM]
        case ds_spPM of {
          GHC.Types.D# x_spPO ->
              case double2Int# [x_spPO] of n_spPP [Dmd=<S,U>] {
                __DEFAULT ->
                    case int2Double# [n_spPP] of sat_spPQ {
                      __DEFAULT ->
                          case <## [sat_spPQ x_spPO] of {
                            __DEFAULT -> GHC.Types.I# [n_spPP];
                            1# ->
                                case +# [n_spPP 1#] of sat_spPS {
                                  __DEFAULT -> GHC.Types.I# [sat_spPS];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.double2Int
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPT]
        case ds_spPT of {
          GHC.Types.D# x_spPV [Occ=Once] ->
              case double2Int# [x_spPV] of sat_spPW {
                __DEFAULT -> GHC.Types.I# [sat_spPW];
              };
        };

GHC.Float.RealFracMethods.int2Double
  :: GHC.Types.Int -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spPX]
        case ds_spPX of {
          GHC.Types.I# i_spPZ [Occ=Once] ->
              case int2Double# [i_spPZ] of sat_spQ0 {
                __DEFAULT -> GHC.Types.D# [sat_spQ0];
              };
        };

GHC.Float.RealFracMethods.float2Int
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spQ1]
        case ds_spQ1 of {
          GHC.Types.F# x_spQ3 [Occ=Once] ->
              case float2Int# [x_spQ3] of sat_spQ4 {
                __DEFAULT -> GHC.Types.I# [sat_spQ4];
              };
        };

GHC.Float.RealFracMethods.int2Float
  :: GHC.Types.Int -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_spQ5]
        case ds_spQ5 of {
          GHC.Types.I# i_spQ7 [Occ=Once] ->
              case int2Float# [i_spQ7] of sat_spQ8 {
                __DEFAULT -> GHC.Types.F# [sat_spQ8];
              };
        };

GHC.Float.RealFracMethods.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Float.RealFracMethods.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule4];

GHC.Float.RealFracMethods.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Float.RealFracMethods"#;

GHC.Float.RealFracMethods.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Float.RealFracMethods.$trModule2];

GHC.Float.RealFracMethods.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Float.RealFracMethods.$trModule3
                                     GHC.Float.RealFracMethods.$trModule1];

GHC.Float.RealFracMethods.roundDoubleInt
  :: GHC.Types.Double -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_spQ9]
        case x_spQ9 of {
          GHC.Types.D# ds1_spQb [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQb GHC.Prim.realWorld#] of {
                Unit# ds3_spQf [Occ=Once] ->
                    case double2Int# [ds3_spQf] of sat_spQg {
                      __DEFAULT -> GHC.Types.I# [sat_spQg];
                    };
              };
        };

GHC.Float.RealFracMethods.roundDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_spQh]
        case x_spQh of {
          GHC.Types.D# ds1_spQj [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQj GHC.Prim.realWorld#] of {
                Unit# ds3_spQn [Occ=Once] ->
                    case GHC.Integer.Type.decodeDoubleInteger ds3_spQn of {
                      (#,#) ipv_spQp [Occ=Once*] ipv1_spQq ->
                          case <# [ipv1_spQq 0#] of {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_spQp ipv1_spQq;
                            1# ->
                                case GHC.Integer.Type.integerToInt ipv_spQp of n_spQs {
                                  __DEFAULT ->
                                      case negateInt# [ipv1_spQq] of sat_spQt {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_spQs sat_spQt] of sat_spQu {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_spQu;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_spQv]
        case x_spQv of {
          GHC.Types.F# ds1_spQx [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQx GHC.Prim.realWorld#] of {
                Unit# ds3_spQB [Occ=Once] ->
                    case decodeFloat_Int# [ds3_spQB] of {
                      (#,#) ipv_spQD [Occ=Once*] ipv1_spQE ->
                          case <# [ipv1_spQE 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_spQD of sat_spQG {
                                  __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_spQG ipv1_spQE;
                                };
                            1# ->
                                case negateInt# [ipv1_spQE] of sat_spQH {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_spQD sat_spQH] of sat_spQI {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_spQI;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.roundFloatInt
  :: GHC.Types.Float -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_spQJ]
        case x_spQJ of {
          GHC.Types.F# ds1_spQL [Occ=Once] ->
              case __pkg_ccall base-4.11.0.0 [ds1_spQL GHC.Prim.realWorld#] of {
                Unit# ds3_spQP [Occ=Once] ->
                    case float2Int# [ds3_spQP] of sat_spQQ {
                      __DEFAULT -> GHC.Types.I# [sat_spQQ];
                    };
              };
        };

GHC.Float.RealFracMethods.properFractionDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> (GHC.Integer.Type.Integer, GHC.Types.Double)
[GblId, Arity=1, Str=<S(S),1*U(U)>m, Unf=OtherCon []] =
    [] \r [v_spQR]
        case v_spQR of wild_spQS {
          GHC.Types.D# x_spQT [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_spQT of {
                (#,#) ipv_spQV ipv1_spQW ->
                    case <# [ipv1_spQW 0#] of {
                      __DEFAULT ->
                          let {
                            sat_spQY [Occ=Once] :: GHC.Integer.Type.Integer
                            [LclId] =
                                [ipv_spQV ipv1_spQW] \u []
                                    GHC.Integer.Type.shiftLInteger ipv_spQV ipv1_spQW;
                          } in 
                            (,) [sat_spQY GHC.Float.RealFracMethods.properFractionDoubleInt2];
                      1# ->
                          case negateInt# [ipv1_spQW] of s_spQZ [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spQZ 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_spQV lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_spQV of n_spR2 {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_spR2 s_spQZ]
                                                  of
                                                  k_spR3
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_spR9 [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              [ipv1_spQW s_spQZ n_spR2 k_spR3] \u []
                                                                  case
                                                                      uncheckedIShiftL# [k_spR3
                                                                                         s_spQZ]
                                                                  of
                                                                  sat_spR5
                                                                  { __DEFAULT ->
                                                                        case
                                                                            -# [n_spR2 sat_spR5]
                                                                        of
                                                                        sat_spR6
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.smallInteger
                                                                                      sat_spR6
                                                                              of
                                                                              sat_spR7
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Integer.Type.encodeDoubleInteger
                                                                                            sat_spR7
                                                                                            ipv1_spQW
                                                                                    of
                                                                                    wild2_spR8
                                                                                    { __DEFAULT ->
                                                                                          GHC.Types.D# [wild2_spR8];
                                                                                    };
                                                                              };
                                                                        };
                                                                  }; } in
                                                        let {
                                                          sat_spR4 [Occ=Once]
                                                            :: GHC.Integer.Type.Integer
                                                          [LclId] =
                                                              [k_spR3] \u []
                                                                  GHC.Integer.Type.smallInteger
                                                                      k_spR3;
                                                        } in  (,) [sat_spR4 sat_spR9];
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_spQV
                                            of
                                            sat_spRa
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_spRa
                                                  of
                                                  n_spRb
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_spRb s_spQZ]
                                                        of
                                                        k_spRc
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_spRk [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    [ipv1_spQW
                                                                     s_spQZ
                                                                     n_spRb
                                                                     k_spRc] \u []
                                                                        case
                                                                            uncheckedIShiftL# [k_spRc
                                                                                               s_spQZ]
                                                                        of
                                                                        sat_spRf
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  -# [n_spRb
                                                                                      sat_spRf]
                                                                              of
                                                                              sat_spRg
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        negateInt# [sat_spRg]
                                                                                    of
                                                                                    sat_spRh
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_spRh
                                                                                          of
                                                                                          sat_spRi
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    GHC.Integer.Type.encodeDoubleInteger
                                                                                                        sat_spRi
                                                                                                        ipv1_spQW
                                                                                                of
                                                                                                wild2_spRj
                                                                                                { __DEFAULT ->
                                                                                                      GHC.Types.D# [wild2_spRj];
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        }; } in
                                                              let {
                                                                sat_spRe [Occ=Once]
                                                                  :: GHC.Integer.Type.Integer
                                                                [LclId] =
                                                                    [k_spRc] \u []
                                                                        case
                                                                            negateInt# [k_spRc]
                                                                        of
                                                                        sat_spRd
                                                                        { __DEFAULT ->
                                                                              GHC.Integer.Type.smallInteger
                                                                                  sat_spRd;
                                                                        };
                                                              } in  (,) [sat_spRe sat_spRk];
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> (,) [lvl_roLO wild_spQS];
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.truncateDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [x_spRl]
        case x_spRl of {
          GHC.Types.D# x1_spRn [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x1_spRn of {
                (#,#) ipv_spRp ipv1_spRq ->
                    case <# [ipv1_spRq 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_spRp ipv1_spRq;
                      1# ->
                          case negateInt# [ipv1_spRq] of s_spRs [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spRs 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.ltInteger# ipv_spRp lvl_roLO of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_spRp of n_spRv {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_spRv s_spRs]
                                                  of
                                                  sat_spRw
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.smallInteger sat_spRw;
                                                  };
                                            };
                                        1# ->
                                            case
                                                GHC.Integer.Type.negateInteger ipv_spRp
                                            of
                                            sat_spRx
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.integerToInt sat_spRx
                                                  of
                                                  n_spRy
                                                  { __DEFAULT ->
                                                        case
                                                            uncheckedIShiftRA# [n_spRy s_spRs]
                                                        of
                                                        sat_spRz
                                                        { __DEFAULT ->
                                                              case
                                                                  negateInt# [sat_spRz]
                                                              of
                                                              sat_spRA
                                                              { __DEFAULT ->
                                                                    GHC.Integer.Type.smallInteger
                                                                        sat_spRA;
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                  1# -> lvl_roLO;
                                };
                          };
                    };
              };
        };

sat_spRB :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_spRC :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_spRB GHC.Types.[]];

lvl1_roLP :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.False sat_spRC;

GHC.Float.RealFracMethods.floorFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spRD]
        case ds_spRD of {
          GHC.Types.F# x_spRF [Occ=Once] ->
              case decodeFloat_Int# [x_spRF] of {
                (#,#) ipv_spRH [Occ=Once*] ipv1_spRI ->
                    case <# [ipv1_spRI 0#] of {
                      __DEFAULT ->
                          case GHC.Integer.Type.smallInteger ipv_spRH of sat_spRK {
                            __DEFAULT -> GHC.Integer.Type.shiftLInteger sat_spRK ipv1_spRI;
                          };
                      1# ->
                          case negateInt# [ipv1_spRI] of s_spRL [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spRL 23#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [ipv_spRH s_spRL] of sat_spRN {
                                        __DEFAULT -> GHC.Integer.Type.smallInteger sat_spRN;
                                      };
                                  1# ->
                                      case <# [ipv_spRH 0#] of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

sat_spRP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_spRQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_spRP GHC.Types.[]];

lvl2_roLQ :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_spRQ;

GHC.Float.RealFracMethods.ceilingFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Float -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spRR]
        case ds_spRR of {
          GHC.Types.F# x_spRT [Occ=Once] ->
              case negateFloat# [x_spRT] of sat_spRU {
                __DEFAULT ->
                    case decodeFloat_Int# [sat_spRU] of {
                      (#,#) ipv_spRW [Occ=Once*] ipv1_spRX ->
                          case <# [ipv1_spRX 0#] of {
                            __DEFAULT ->
                                case GHC.Integer.Type.smallInteger ipv_spRW of sat_spRZ {
                                  __DEFAULT ->
                                      case
                                          GHC.Integer.Type.shiftLInteger sat_spRZ ipv1_spRX
                                      of
                                      sat_spS0
                                      { __DEFAULT -> GHC.Integer.Type.negateInteger sat_spS0;
                                      };
                                };
                            1# ->
                                case negateInt# [ipv1_spRX] of s_spS1 [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_spS1 23#] of {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [ipv_spRW s_spS1] of sat_spS3 {
                                              __DEFAULT ->
                                                  case
                                                      GHC.Integer.Type.smallInteger sat_spS3
                                                  of
                                                  sat_spS4
                                                  { __DEFAULT ->
                                                        GHC.Integer.Type.negateInteger sat_spS4;
                                                  };
                                            };
                                        1# ->
                                            case <# [ipv_spRW 0#] of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.floorDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spS6]
        case ds_spS6 of {
          GHC.Types.D# x_spS8 [Occ=Once] ->
              case GHC.Integer.Type.decodeDoubleInteger x_spS8 of {
                (#,#) ipv_spSa [Occ=Once*] ipv1_spSb ->
                    case <# [ipv1_spSb 0#] of {
                      __DEFAULT -> GHC.Integer.Type.shiftLInteger ipv_spSa ipv1_spSb;
                      1# ->
                          case negateInt# [ipv1_spSb] of s_spSd [Dmd=<S,U>] {
                            __DEFAULT ->
                                case ># [s_spSd 52#] of {
                                  __DEFAULT ->
                                      case GHC.Integer.Type.integerToInt ipv_spSa of n_spSf {
                                        __DEFAULT ->
                                            case uncheckedIShiftRA# [n_spSf s_spSd] of sat_spSg {
                                              __DEFAULT -> GHC.Integer.Type.smallInteger sat_spSg;
                                            };
                                      };
                                  1# ->
                                      case GHC.Integer.Type.ltInteger# ipv_spSa lvl_roLO of {
                                        __DEFAULT -> lvl_roLO;
                                        1# -> lvl1_roLP;
                                      };
                                };
                          };
                    };
              };
        };

GHC.Float.RealFracMethods.ceilingDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [ds_spSi]
        case ds_spSi of {
          GHC.Types.D# x_spSk [Occ=Once] ->
              case negateDouble# [x_spSk] of sat_spSl {
                __DEFAULT ->
                    case GHC.Integer.Type.decodeDoubleInteger sat_spSl of {
                      (#,#) ipv_spSn [Occ=Once*] ipv1_spSo ->
                          case <# [ipv1_spSo 0#] of {
                            __DEFAULT ->
                                case
                                    GHC.Integer.Type.shiftLInteger ipv_spSn ipv1_spSo
                                of
                                sat_spSq
                                { __DEFAULT -> GHC.Integer.Type.negateInteger sat_spSq;
                                };
                            1# ->
                                case negateInt# [ipv1_spSo] of s_spSr [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case ># [s_spSr 52#] of {
                                        __DEFAULT ->
                                            case GHC.Integer.Type.integerToInt ipv_spSn of n_spSt {
                                              __DEFAULT ->
                                                  case
                                                      uncheckedIShiftRA# [n_spSt s_spSr]
                                                  of
                                                  sat_spSu
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Integer.Type.smallInteger sat_spSu
                                                        of
                                                        sat_spSv
                                                        { __DEFAULT ->
                                                              GHC.Integer.Type.negateInteger
                                                                  sat_spSv;
                                                        };
                                                  };
                                            };
                                        1# ->
                                            case GHC.Integer.Type.ltInteger# ipv_spSn lvl_roLO of {
                                              __DEFAULT -> lvl_roLO;
                                              1# -> lvl2_roLQ;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

