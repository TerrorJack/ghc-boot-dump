
==================== Output Cmm ====================
2018-03-16 15:55:03.956033658 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:03.957606118 UTC

[section ""data" . GHC.Float.ConversionUtils.zeroCountArr_closure" {
     GHC.Float.ConversionUtils.zeroCountArr_closure:
         const GHC.Float.ConversionUtils.zeroCountArr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Float.ConversionUtils.zeroCountArr_entry() //  [R1]
         { info_tbl: [(cqtb,
                       label: GHC.Float.ConversionUtils.zeroCountArr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqtb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqtc; else goto cqtd;
       cqtc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqtd: // global
           (_cqt2::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqt2::I64 == 0) goto cqt4; else goto cqt3;
       cqt4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqt3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqt2::I64;
           I64[Sp - 24] = block_cqt5_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cqt5() //  [R1]
         { info_tbl: [(cqt5,
                       label: block_cqt5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqt5: // global
           I8[R1 + 16] = 8 :: W8;
           _sqs7::P64 = R1;
           _sqsh::I64 = 1;
           _sqsg::I64 = 0;
           _sqsf::I64 = 2;
           goto cqtm;
       cqtm: // global
           if (%MO_S_Ge_W64(_sqsh::I64, 256)) goto cqtz; else goto cqtA;
       cqtz: // global
           if (%MO_S_Ge_W64(_sqsf::I64, 256)) goto uqtJ; else goto cqtx;
       uqtJ: // global
           P64[Sp] = _sqs7::P64;
           Sp = Sp - 8;
           call _cqtg() args: 0, res: 0, upd: 0;
       cqtx: // global
           _sqsh::I64 = _sqsf::I64;
           _sqsg::I64 = _sqsg::I64 + 1;
           _sqsf::I64 = _sqsf::I64 << 1;
           goto cqtm;
       cqtA: // global
           I8[(_sqs7::P64 + 16) + _sqsh::I64] = %MO_UU_Conv_W64_W8(_sqsg::I64);
           _sqsh::I64 = _sqsh::I64 + _sqsf::I64;
           goto cqtm;
     }
 },
 _cqtg() //  []
         { info_tbl: [(cqtg,
                       label: block_cqtg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqtg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqtl; else goto cqtk;
       cqtl: // global
           HpAlloc = 16;
           I64[Sp] = block_cqtg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cqtk: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.960634361 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInt#_closure" {
     GHC.Float.ConversionUtils.elimZerosInt#_closure:
         const GHC.Float.ConversionUtils.elimZerosInt#_info;
         const 0;
 },
 sat_sqsL_entry() //  [R1]
         { info_tbl: [(cquP,
                       label: sat_sqsL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cquP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cquQ; else goto cquR;
       cquQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cquR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsO_entry() //  [R1]
         { info_tbl: [(cquZ,
                       label: sat_sqsO_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cquZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqv0; else goto cqv1;
       cqv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqv1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsS_entry() //  [R1]
         { info_tbl: [(cqvc,
                       label: sat_sqsS_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqvc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqvd; else goto cqve;
       cqvd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqve: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsV_entry() //  [R1]
         { info_tbl: [(cqvm,
                       label: sat_sqsV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqvn; else goto cqvo;
       cqvn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqvo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.ConversionUtils.elimZerosInt#_entry() //  [R2, R3]
         { info_tbl: [(cqvp,
                       label: GHC.Float.ConversionUtils.elimZerosInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqvp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqvq; else goto cqvr;
       cqvq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInt#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqvr: // global
           I64[Sp - 24] = block_cqtP_info;
           R1 = GHC.Float.ConversionUtils.zeroCountArr_closure;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uqvS; else goto cqtQ;
       uqvS: // global
           call _cqtP(R1) args: 0, res: 0, upd: 0;
       cqtQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqtP() //  [R1]
         { info_tbl: [(cqtP,
                       label: block_cqtP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqtP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqvu; else goto cqvt;
       cqvu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cqvt: // global
           _sqsp::I64 = I64[Sp + 8];
           _sqsq::I64 = I64[Sp + 16];
           _sqss::P64 = P64[R1 + 7];
           _sqsw::I64 = %MO_SS_Conv_W8_W64(I8[(_sqss::P64 + 16) + _sqsp::I64 & 255]);
           if (%MO_S_Gt_W64(_sqsq::I64,
                            _sqsw::I64)) goto cqvI; else goto cqvJ;
       cqvI: // global
           if (%MO_S_Ge_W64(_sqsw::I64, 8)) goto cqvF; else goto cqvG;
       cqvF: // global
           Hp = Hp - 32;
           I64[Sp] = _sqsq::I64 - 8;
           I64[Sp + 8] = %MO_S_Shr_W64(_sqsp::I64, 8);
           P64[Sp + 16] = _sqss::P64;
           Sp = Sp - 8;
           call _cquk() args: 0, res: 0, upd: 0;
       cqvG: // global
           I64[Hp - 24] = sat_sqsS_info;
           I64[Hp - 8] = _sqsp::I64;
           I64[Hp] = _sqsw::I64;
           R2 = _sqsq::I64 - _sqsw::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqvJ: // global
           I64[Hp - 24] = sat_sqsV_info;
           I64[Hp - 8] = _sqsp::I64;
           I64[Hp] = _sqsq::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cquk() //  []
         { info_tbl: [(cquk,
                       label: block_cquk_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cquk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqvx; else goto cqvw;
       cqvx: // global
           HpAlloc = 32;
           I64[Sp] = block_cquk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cqvw: // global
           _sqsA::I64 = I64[Sp + 16];
           _sqsB::I64 = I64[Sp + 8];
           _sqsF::I64 = %MO_SS_Conv_W8_W64(I8[P64[Sp + 24] + (_sqsA::I64 & 255 + 16)]);
           if (%MO_S_Gt_W64(_sqsB::I64,
                            _sqsF::I64)) goto cqvC; else goto cqvD;
       cqvC: // global
           if (%MO_S_Ge_W64(_sqsF::I64, 8)) goto cqvz; else goto cqvA;
       cqvz: // global
           Hp = Hp - 32;
           I64[Sp + 16] = %MO_S_Shr_W64(_sqsA::I64, 8);
           I64[Sp + 8] = _sqsB::I64 - 8;
           call _cquk() args: 0, res: 0, upd: 0;
       cqvA: // global
           I64[Hp - 24] = sat_sqsL_info;
           I64[Hp - 8] = _sqsA::I64;
           I64[Hp] = _sqsF::I64;
           R2 = _sqsB::I64 - _sqsF::I64;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqvD: // global
           I64[Hp - 24] = sat_sqsO_info;
           I64[Hp - 8] = _sqsA::I64;
           I64[Hp] = _sqsB::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.964094496 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInteger_closure" {
     GHC.Float.ConversionUtils.elimZerosInteger_closure:
         const GHC.Float.ConversionUtils.elimZerosInteger_info;
         const 0;
 },
 GHC.Float.ConversionUtils.elimZerosInteger_entry() //  [R2, R3]
         { info_tbl: [(cqw0,
                       label: GHC.Float.ConversionUtils.elimZerosInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqw0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqw1; else goto cqw2;
       cqw1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqw2: // global
           I64[Sp - 16] = block_cqvY_info;
           R2 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqvY() //  [R1]
         { info_tbl: [(cqvY,
                       label: block_cqvY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqvY: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Float.ConversionUtils.elimZerosInt#_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.965064656 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule4_bytes" {
     GHC.Float.ConversionUtils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.965751671 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule3_closure" {
     GHC.Float.ConversionUtils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.966385926 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule2_bytes" {
     GHC.Float.ConversionUtils.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.966974859 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule1_closure" {
     GHC.Float.ConversionUtils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.967473949 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule_closure" {
     GHC.Float.ConversionUtils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.ConversionUtils.$trModule3_closure+1;
         const GHC.Float.ConversionUtils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.968128527 UTC

[section ""data" . $krep_rqs2_closure" {
     $krep_rqs2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.968768632 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tcBA2_bytes" {
     GHC.Float.ConversionUtils.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.969417862 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA1_closure" {
     GHC.Float.ConversionUtils.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.97006719 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA_closure" {
     GHC.Float.ConversionUtils.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2744518186030791563;
         const 15983957619153370905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.970592248 UTC

[section ""data" . $krep1_rqs3_closure" {
     $krep1_rqs3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Float.ConversionUtils.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.971194631 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA1_closure" {
     GHC.Float.ConversionUtils.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rqs2_closure+1;
         const $krep1_rqs3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.971838489 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tc'BA3_bytes" {
     GHC.Float.ConversionUtils.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.972444415 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA2_closure" {
     GHC.Float.ConversionUtils.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.973054979 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA_closure" {
     GHC.Float.ConversionUtils.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA2_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA1_closure+4;
         const 2662423355322146026;
         const 17541892848942326139;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.974136291 UTC

[section ""data" . GHC.Float.ConversionUtils.BA_closure" {
     GHC.Float.ConversionUtils.BA_closure:
         const GHC.Float.ConversionUtils.BA_info;
 },
 GHC.Float.ConversionUtils.BA_entry() //  [R2]
         { info_tbl: [(cqwb,
                       label: GHC.Float.ConversionUtils.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqwb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqwf; else goto cqwe;
       cqwf: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqwe: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.975036662 UTC

[GHC.Float.ConversionUtils.BA_con_entry() //  [R1]
         { info_tbl: [(cqwg,
                       label: GHC.Float.ConversionUtils.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqwg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.975774024 UTC

[section ""relreadonly" . SqvT_srt" {
     SqvT_srt:
         const GHC.Float.ConversionUtils.elimZerosInt#_closure;
         const GHC.Float.ConversionUtils.zeroCountArr_closure;
         const GHC.Float.ConversionUtils.elimZerosInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.976272913 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:03.977767837 UTC

[section ""data" . GHC.Float.ConversionUtils.zeroCountArr_closure" {
     GHC.Float.ConversionUtils.zeroCountArr_closure:
         const GHC.Float.ConversionUtils.zeroCountArr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Float.ConversionUtils.zeroCountArr_entry() //  [R1]
         { info_tbl: [(cqwt,
                       label: GHC.Float.ConversionUtils.zeroCountArr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqwt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqwu; else goto cqwv;
       cqwu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqwv: // global
           (_cqwk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqwk::I64 == 0) goto cqwm; else goto cqwl;
       cqwm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqwl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqwk::I64;
           I64[Sp - 24] = block_cqwn_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cqwn() //  [R1]
         { info_tbl: [(cqwn,
                       label: block_cqwn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqwn: // global
           I8[R1 + 16] = 8 :: W8;
           _sqs7::P64 = R1;
           _sqsh::I64 = 1;
           _sqsg::I64 = 0;
           _sqsf::I64 = 2;
           goto cqwE;
       cqwE: // global
           if (%MO_S_Ge_W64(_sqsh::I64, 256)) goto cqwR; else goto cqwS;
       cqwR: // global
           if (%MO_S_Ge_W64(_sqsf::I64, 256)) goto uqx1; else goto cqwP;
       uqx1: // global
           P64[Sp] = _sqs7::P64;
           Sp = Sp - 8;
           call _cqwy() args: 0, res: 0, upd: 0;
       cqwP: // global
           _sqsh::I64 = _sqsf::I64;
           _sqsg::I64 = _sqsg::I64 + 1;
           _sqsf::I64 = _sqsf::I64 << 1;
           goto cqwE;
       cqwS: // global
           I8[(_sqs7::P64 + 16) + _sqsh::I64] = %MO_UU_Conv_W64_W8(_sqsg::I64);
           _sqsh::I64 = _sqsh::I64 + _sqsf::I64;
           goto cqwE;
     }
 },
 _cqwy() //  []
         { info_tbl: [(cqwy,
                       label: block_cqwy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqwy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqwD; else goto cqwC;
       cqwD: // global
           HpAlloc = 16;
           I64[Sp] = block_cqwy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cqwC: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.980655295 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInt#_closure" {
     GHC.Float.ConversionUtils.elimZerosInt#_closure:
         const GHC.Float.ConversionUtils.elimZerosInt#_info;
         const 0;
 },
 sat_sqsL_entry() //  [R1]
         { info_tbl: [(cqy7,
                       label: sat_sqsL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqy7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqy8; else goto cqy9;
       cqy8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqy9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsO_entry() //  [R1]
         { info_tbl: [(cqyh,
                       label: sat_sqsO_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqyh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqyi; else goto cqyj;
       cqyi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqyj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsS_entry() //  [R1]
         { info_tbl: [(cqyu,
                       label: sat_sqsS_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqyu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqyv; else goto cqyw;
       cqyv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqyw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsV_entry() //  [R1]
         { info_tbl: [(cqyE,
                       label: sat_sqsV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqyE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqyF; else goto cqyG;
       cqyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqyG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.ConversionUtils.elimZerosInt#_entry() //  [R2, R3]
         { info_tbl: [(cqyH,
                       label: GHC.Float.ConversionUtils.elimZerosInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqyH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqyI; else goto cqyJ;
       cqyI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInt#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqyJ: // global
           I64[Sp - 24] = block_cqx7_info;
           R1 = GHC.Float.ConversionUtils.zeroCountArr_closure;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uqza; else goto cqx8;
       uqza: // global
           call _cqx7(R1) args: 0, res: 0, upd: 0;
       cqx8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqx7() //  [R1]
         { info_tbl: [(cqx7,
                       label: block_cqx7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqx7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqyM; else goto cqyL;
       cqyM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cqyL: // global
           _sqsp::I64 = I64[Sp + 8];
           _sqsq::I64 = I64[Sp + 16];
           _sqss::P64 = P64[R1 + 7];
           _sqsw::I64 = %MO_SS_Conv_W8_W64(I8[(_sqss::P64 + 16) + _sqsp::I64 & 255]);
           if (%MO_S_Gt_W64(_sqsq::I64,
                            _sqsw::I64)) goto cqz0; else goto cqz1;
       cqz0: // global
           if (%MO_S_Ge_W64(_sqsw::I64, 8)) goto cqyX; else goto cqyY;
       cqyX: // global
           Hp = Hp - 32;
           I64[Sp] = _sqsq::I64 - 8;
           I64[Sp + 8] = %MO_S_Shr_W64(_sqsp::I64, 8);
           P64[Sp + 16] = _sqss::P64;
           Sp = Sp - 8;
           call _cqxC() args: 0, res: 0, upd: 0;
       cqyY: // global
           I64[Hp - 24] = sat_sqsS_info;
           I64[Hp - 8] = _sqsp::I64;
           I64[Hp] = _sqsw::I64;
           R2 = _sqsq::I64 - _sqsw::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqz1: // global
           I64[Hp - 24] = sat_sqsV_info;
           I64[Hp - 8] = _sqsp::I64;
           I64[Hp] = _sqsq::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cqxC() //  []
         { info_tbl: [(cqxC,
                       label: block_cqxC_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqxC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqyP; else goto cqyO;
       cqyP: // global
           HpAlloc = 32;
           I64[Sp] = block_cqxC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cqyO: // global
           _sqsA::I64 = I64[Sp + 16];
           _sqsB::I64 = I64[Sp + 8];
           _sqsF::I64 = %MO_SS_Conv_W8_W64(I8[P64[Sp + 24] + (_sqsA::I64 & 255 + 16)]);
           if (%MO_S_Gt_W64(_sqsB::I64,
                            _sqsF::I64)) goto cqyU; else goto cqyV;
       cqyU: // global
           if (%MO_S_Ge_W64(_sqsF::I64, 8)) goto cqyR; else goto cqyS;
       cqyR: // global
           Hp = Hp - 32;
           I64[Sp + 16] = %MO_S_Shr_W64(_sqsA::I64, 8);
           I64[Sp + 8] = _sqsB::I64 - 8;
           call _cqxC() args: 0, res: 0, upd: 0;
       cqyS: // global
           I64[Hp - 24] = sat_sqsL_info;
           I64[Hp - 8] = _sqsA::I64;
           I64[Hp] = _sqsF::I64;
           R2 = _sqsB::I64 - _sqsF::I64;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqyV: // global
           I64[Hp - 24] = sat_sqsO_info;
           I64[Hp - 8] = _sqsA::I64;
           I64[Hp] = _sqsB::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.984365407 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInteger_closure" {
     GHC.Float.ConversionUtils.elimZerosInteger_closure:
         const GHC.Float.ConversionUtils.elimZerosInteger_info;
         const 0;
 },
 GHC.Float.ConversionUtils.elimZerosInteger_entry() //  [R2, R3]
         { info_tbl: [(cqzh,
                       label: GHC.Float.ConversionUtils.elimZerosInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqzi; else goto cqzj;
       cqzi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqzj: // global
           I64[Sp - 16] = block_cqzf_info;
           R2 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqzf() //  [R1]
         { info_tbl: [(cqzf,
                       label: block_cqzf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzf: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Float.ConversionUtils.elimZerosInt#_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.98537853 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule4_bytes" {
     GHC.Float.ConversionUtils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.98601805 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule3_closure" {
     GHC.Float.ConversionUtils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.986593429 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule2_bytes" {
     GHC.Float.ConversionUtils.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.987233048 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule1_closure" {
     GHC.Float.ConversionUtils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.98780479 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule_closure" {
     GHC.Float.ConversionUtils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.ConversionUtils.$trModule3_closure+1;
         const GHC.Float.ConversionUtils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.988401367 UTC

[section ""data" . $krep_rqs2_closure" {
     $krep_rqs2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.989051755 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tcBA2_bytes" {
     GHC.Float.ConversionUtils.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.989556884 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA1_closure" {
     GHC.Float.ConversionUtils.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.990177802 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA_closure" {
     GHC.Float.ConversionUtils.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2744518186030791563;
         const 15983957619153370905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.990838533 UTC

[section ""data" . $krep1_rqs3_closure" {
     $krep1_rqs3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Float.ConversionUtils.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.991474593 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA1_closure" {
     GHC.Float.ConversionUtils.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rqs2_closure+1;
         const $krep1_rqs3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.992108944 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tc'BA3_bytes" {
     GHC.Float.ConversionUtils.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.992717735 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA2_closure" {
     GHC.Float.ConversionUtils.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.993670959 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA_closure" {
     GHC.Float.ConversionUtils.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA2_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA1_closure+4;
         const 2662423355322146026;
         const 17541892848942326139;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.99446891 UTC

[section ""data" . GHC.Float.ConversionUtils.BA_closure" {
     GHC.Float.ConversionUtils.BA_closure:
         const GHC.Float.ConversionUtils.BA_info;
 },
 GHC.Float.ConversionUtils.BA_entry() //  [R2]
         { info_tbl: [(cqzs,
                       label: GHC.Float.ConversionUtils.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqzw; else goto cqzv;
       cqzw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqzv: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.99535724 UTC

[GHC.Float.ConversionUtils.BA_con_entry() //  [R1]
         { info_tbl: [(cqzx,
                       label: GHC.Float.ConversionUtils.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzx: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.996073332 UTC

[section ""relreadonly" . SqvT_srt" {
     SqvT_srt:
         const GHC.Float.ConversionUtils.elimZerosInt#_closure;
         const GHC.Float.ConversionUtils.zeroCountArr_closure;
         const GHC.Float.ConversionUtils.elimZerosInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:03.996906676 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:03.998865153 UTC

[section ""data" . GHC.Float.ConversionUtils.zeroCountArr_closure" {
     GHC.Float.ConversionUtils.zeroCountArr_closure:
         const GHC.Float.ConversionUtils.zeroCountArr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Float.ConversionUtils.zeroCountArr_entry() //  [R1]
         { info_tbl: [(cqzL,
                       label: GHC.Float.ConversionUtils.zeroCountArr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqzM; else goto cqzN;
       cqzM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqzN: // global
           (_cqzC::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqzC::I64 == 0) goto cqzE; else goto cqzD;
       cqzE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqzD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqzC::I64;
           I64[Sp - 24] = block_cqzF_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cqzF() //  [R1]
         { info_tbl: [(cqzF,
                       label: block_cqzF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzF: // global
           I8[R1 + 16] = 8 :: W8;
           _sqs7::P64 = R1;
           _sqsh::I64 = 1;
           _sqsg::I64 = 0;
           _sqsf::I64 = 2;
           goto cqzW;
       cqzW: // global
           if (%MO_S_Ge_W64(_sqsh::I64, 256)) goto cqA9; else goto cqAa;
       cqA9: // global
           if (%MO_S_Ge_W64(_sqsf::I64, 256)) goto uqAj; else goto cqA7;
       uqAj: // global
           P64[Sp] = _sqs7::P64;
           Sp = Sp - 8;
           call _cqzQ() args: 0, res: 0, upd: 0;
       cqA7: // global
           _sqsh::I64 = _sqsf::I64;
           _sqsg::I64 = _sqsg::I64 + 1;
           _sqsf::I64 = _sqsf::I64 << 1;
           goto cqzW;
       cqAa: // global
           I8[(_sqs7::P64 + 16) + _sqsh::I64] = %MO_UU_Conv_W64_W8(_sqsg::I64);
           _sqsh::I64 = _sqsh::I64 + _sqsf::I64;
           goto cqzW;
     }
 },
 _cqzQ() //  []
         { info_tbl: [(cqzQ,
                       label: block_cqzQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqzQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqzV; else goto cqzU;
       cqzV: // global
           HpAlloc = 16;
           I64[Sp] = block_cqzQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cqzU: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.009903592 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInt#_closure" {
     GHC.Float.ConversionUtils.elimZerosInt#_closure:
         const GHC.Float.ConversionUtils.elimZerosInt#_info;
         const 0;
 },
 sat_sqsL_entry() //  [R1]
         { info_tbl: [(cqBH,
                       label: sat_sqsL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqBH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqBI; else goto cqBJ;
       cqBI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqBJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsO_entry() //  [R1]
         { info_tbl: [(cqBR,
                       label: sat_sqsO_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqBR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqBS; else goto cqBT;
       cqBS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqBT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsS_entry() //  [R1]
         { info_tbl: [(cqC4,
                       label: sat_sqsS_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqC4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqC5; else goto cqC6;
       cqC5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqC6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqsV_entry() //  [R1]
         { info_tbl: [(cqCe,
                       label: sat_sqsV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqCe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqCf; else goto cqCg;
       cqCf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqCg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.ConversionUtils.elimZerosInt#_entry() //  [R2, R3]
         { info_tbl: [(cqCh,
                       label: GHC.Float.ConversionUtils.elimZerosInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqCh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqCi; else goto cqCj;
       cqCi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInt#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqCj: // global
           I64[Sp - 24] = block_cqAH_info;
           R1 = GHC.Float.ConversionUtils.zeroCountArr_closure;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uqCK; else goto cqAI;
       uqCK: // global
           call _cqAH(R1) args: 0, res: 0, upd: 0;
       cqAI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqAH() //  [R1]
         { info_tbl: [(cqAH,
                       label: block_cqAH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqAH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqCm; else goto cqCl;
       cqCm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cqCl: // global
           _sqsp::I64 = I64[Sp + 8];
           _sqsq::I64 = I64[Sp + 16];
           _sqss::P64 = P64[R1 + 7];
           _sqsw::I64 = %MO_SS_Conv_W8_W64(I8[(_sqss::P64 + 16) + _sqsp::I64 & 255]);
           if (%MO_S_Gt_W64(_sqsq::I64,
                            _sqsw::I64)) goto cqCA; else goto cqCB;
       cqCA: // global
           if (%MO_S_Ge_W64(_sqsw::I64, 8)) goto cqCx; else goto cqCy;
       cqCx: // global
           Hp = Hp - 32;
           I64[Sp] = _sqsq::I64 - 8;
           I64[Sp + 8] = %MO_S_Shr_W64(_sqsp::I64, 8);
           P64[Sp + 16] = _sqss::P64;
           Sp = Sp - 8;
           call _cqBc() args: 0, res: 0, upd: 0;
       cqCy: // global
           I64[Hp - 24] = sat_sqsS_info;
           I64[Hp - 8] = _sqsp::I64;
           I64[Hp] = _sqsw::I64;
           R2 = _sqsq::I64 - _sqsw::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqCB: // global
           I64[Hp - 24] = sat_sqsV_info;
           I64[Hp - 8] = _sqsp::I64;
           I64[Hp] = _sqsq::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cqBc() //  []
         { info_tbl: [(cqBc,
                       label: block_cqBc_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqBc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqCp; else goto cqCo;
       cqCp: // global
           HpAlloc = 32;
           I64[Sp] = block_cqBc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cqCo: // global
           _sqsA::I64 = I64[Sp + 16];
           _sqsB::I64 = I64[Sp + 8];
           _sqsF::I64 = %MO_SS_Conv_W8_W64(I8[P64[Sp + 24] + (_sqsA::I64 & 255 + 16)]);
           if (%MO_S_Gt_W64(_sqsB::I64,
                            _sqsF::I64)) goto cqCu; else goto cqCv;
       cqCu: // global
           if (%MO_S_Ge_W64(_sqsF::I64, 8)) goto cqCr; else goto cqCs;
       cqCr: // global
           Hp = Hp - 32;
           I64[Sp + 16] = %MO_S_Shr_W64(_sqsA::I64, 8);
           I64[Sp + 8] = _sqsB::I64 - 8;
           call _cqBc() args: 0, res: 0, upd: 0;
       cqCs: // global
           I64[Hp - 24] = sat_sqsL_info;
           I64[Hp - 8] = _sqsA::I64;
           I64[Hp] = _sqsF::I64;
           R2 = _sqsB::I64 - _sqsF::I64;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqCv: // global
           I64[Hp - 24] = sat_sqsO_info;
           I64[Hp - 8] = _sqsA::I64;
           I64[Hp] = _sqsB::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.029968887 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInteger_closure" {
     GHC.Float.ConversionUtils.elimZerosInteger_closure:
         const GHC.Float.ConversionUtils.elimZerosInteger_info;
         const 0;
 },
 GHC.Float.ConversionUtils.elimZerosInteger_entry() //  [R2, R3]
         { info_tbl: [(cqDE,
                       label: GHC.Float.ConversionUtils.elimZerosInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqDE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqDF; else goto cqDG;
       cqDF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqDG: // global
           I64[Sp - 16] = block_cqDC_info;
           R2 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqDC() //  [R1]
         { info_tbl: [(cqDC,
                       label: block_cqDC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqDC: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Float.ConversionUtils.elimZerosInt#_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.036305771 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule4_bytes" {
     GHC.Float.ConversionUtils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.038327796 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule3_closure" {
     GHC.Float.ConversionUtils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.040222881 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule2_bytes" {
     GHC.Float.ConversionUtils.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.042179331 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule1_closure" {
     GHC.Float.ConversionUtils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.044029167 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule_closure" {
     GHC.Float.ConversionUtils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.ConversionUtils.$trModule3_closure+1;
         const GHC.Float.ConversionUtils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.045972606 UTC

[section ""data" . $krep_rqs2_closure" {
     $krep_rqs2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.048019644 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tcBA2_bytes" {
     GHC.Float.ConversionUtils.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.049964246 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA1_closure" {
     GHC.Float.ConversionUtils.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.052456616 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA_closure" {
     GHC.Float.ConversionUtils.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2744518186030791563;
         const 15983957619153370905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.054660788 UTC

[section ""data" . $krep1_rqs3_closure" {
     $krep1_rqs3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Float.ConversionUtils.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.056612945 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA1_closure" {
     GHC.Float.ConversionUtils.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rqs2_closure+1;
         const $krep1_rqs3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.058666419 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tc'BA3_bytes" {
     GHC.Float.ConversionUtils.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.060636298 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA2_closure" {
     GHC.Float.ConversionUtils.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.062667782 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA_closure" {
     GHC.Float.ConversionUtils.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA2_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA1_closure+4;
         const 2662423355322146026;
         const 17541892848942326139;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.06508843 UTC

[section ""data" . GHC.Float.ConversionUtils.BA_closure" {
     GHC.Float.ConversionUtils.BA_closure:
         const GHC.Float.ConversionUtils.BA_info;
 },
 GHC.Float.ConversionUtils.BA_entry() //  [R2]
         { info_tbl: [(cqEb,
                       label: GHC.Float.ConversionUtils.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqEb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqEf; else goto cqEe;
       cqEf: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqEe: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.069414446 UTC

[GHC.Float.ConversionUtils.BA_con_entry() //  [R1]
         { info_tbl: [(cqEl,
                       label: GHC.Float.ConversionUtils.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqEl: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.118030951 UTC

[section ""relreadonly" . SqvT_srt" {
     SqvT_srt:
         const GHC.Float.ConversionUtils.elimZerosInt#_closure;
         const GHC.Float.ConversionUtils.zeroCountArr_closure;
         const GHC.Float.ConversionUtils.elimZerosInteger_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.244600027 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:04.246507512 UTC

[section ""data" . GHC.Float.ConversionUtils.zeroCountArr_closure" {
     GHC.Float.ConversionUtils.zeroCountArr_closure:
         const GHC.Float.ConversionUtils.zeroCountArr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Float.ConversionUtils.zeroCountArr_entry() //  [R1]
         { info_tbl: [(cqFy,
                       label: GHC.Float.ConversionUtils.zeroCountArr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqFy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqFz; else goto cqFA;
       cqFz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqFA: // global
           (_cqFp::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqFp::I64 == 0) goto cqFr; else goto cqFq;
       cqFr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqFq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqFp::I64;
           I64[Sp - 24] = block_cqFs_info;
           R1 = 256;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cqFs() //  [R1]
         { info_tbl: [(cqFs,
                       label: block_cqFs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqFs: // global
           I8[R1 + 16] = 8 :: W8;
           _sqEu::P64 = R1;
           _sqEE::I64 = 1;
           _sqED::I64 = 0;
           _sqEC::I64 = 2;
           goto cqFJ;
       cqFJ: // global
           if (%MO_S_Ge_W64(_sqEE::I64, 256)) goto cqFW; else goto cqFX;
       cqFW: // global
           if (%MO_S_Ge_W64(_sqEC::I64, 256)) goto uqG6; else goto cqFU;
       uqG6: // global
           P64[Sp] = _sqEu::P64;
           Sp = Sp - 8;
           call _cqFD() args: 0, res: 0, upd: 0;
       cqFU: // global
           _sqEE::I64 = _sqEC::I64;
           _sqED::I64 = _sqED::I64 + 1;
           _sqEC::I64 = _sqEC::I64 << 1;
           goto cqFJ;
       cqFX: // global
           I8[(_sqEu::P64 + 16) + _sqEE::I64] = %MO_UU_Conv_W64_W8(_sqED::I64);
           _sqEE::I64 = _sqEE::I64 + _sqEC::I64;
           goto cqFJ;
     }
 },
 _cqFD() //  []
         { info_tbl: [(cqFD,
                       label: block_cqFD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqFD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqFI; else goto cqFH;
       cqFI: // global
           HpAlloc = 16;
           I64[Sp] = block_cqFD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cqFH: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.256261609 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInt#_closure" {
     GHC.Float.ConversionUtils.elimZerosInt#_closure:
         const GHC.Float.ConversionUtils.elimZerosInt#_info;
         const 0;
 },
 sat_sqF8_entry() //  [R1]
         { info_tbl: [(cqHy,
                       label: sat_sqF8_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqHy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqHz; else goto cqHA;
       cqHz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqHA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqFb_entry() //  [R1]
         { info_tbl: [(cqHI,
                       label: sat_sqFb_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqHI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqHJ; else goto cqHK;
       cqHJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqHK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqFf_entry() //  [R1]
         { info_tbl: [(cqHV,
                       label: sat_sqFf_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqHV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqHW; else goto cqHX;
       cqHW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqHX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sqFi_entry() //  [R1]
         { info_tbl: [(cqI5,
                       label: sat_sqFi_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqI5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqI6; else goto cqI7;
       cqI6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqI7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = %MO_S_Shr_W64(I64[R1 + 16], I64[R1 + 24]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Float.ConversionUtils.elimZerosInt#_entry() //  [R2, R3]
         { info_tbl: [(cqI8,
                       label: GHC.Float.ConversionUtils.elimZerosInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqI8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqI9; else goto cqIa;
       cqI9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInt#_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqIa: // global
           I64[Sp - 24] = block_cqGy_info;
           R1 = GHC.Float.ConversionUtils.zeroCountArr_closure;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uqIB; else goto cqGz;
       uqIB: // global
           call _cqGy(R1) args: 0, res: 0, upd: 0;
       cqGz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cqGy() //  [R1]
         { info_tbl: [(cqGy,
                       label: block_cqGy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqGy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqId; else goto cqIc;
       cqId: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cqIc: // global
           _sqEM::I64 = I64[Sp + 8];
           _sqEN::I64 = I64[Sp + 16];
           _sqEP::P64 = P64[R1 + 7];
           _sqET::I64 = %MO_SS_Conv_W8_W64(I8[(_sqEP::P64 + 16) + _sqEM::I64 & 255]);
           if (%MO_S_Gt_W64(_sqEN::I64,
                            _sqET::I64)) goto cqIr; else goto cqIs;
       cqIr: // global
           if (%MO_S_Ge_W64(_sqET::I64, 8)) goto cqIo; else goto cqIp;
       cqIo: // global
           Hp = Hp - 32;
           I64[Sp] = _sqEN::I64 - 8;
           I64[Sp + 8] = %MO_S_Shr_W64(_sqEM::I64, 8);
           P64[Sp + 16] = _sqEP::P64;
           Sp = Sp - 8;
           call _cqH3() args: 0, res: 0, upd: 0;
       cqIp: // global
           I64[Hp - 24] = sat_sqFf_info;
           I64[Hp - 8] = _sqEM::I64;
           I64[Hp] = _sqET::I64;
           R2 = _sqEN::I64 - _sqET::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqIs: // global
           I64[Hp - 24] = sat_sqFi_info;
           I64[Hp - 8] = _sqEM::I64;
           I64[Hp] = _sqEN::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cqH3() //  []
         { info_tbl: [(cqH3,
                       label: block_cqH3_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqH3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cqIg; else goto cqIf;
       cqIg: // global
           HpAlloc = 32;
           I64[Sp] = block_cqH3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cqIf: // global
           _sqEX::I64 = I64[Sp + 16];
           _sqEY::I64 = I64[Sp + 8];
           _sqF2::I64 = %MO_SS_Conv_W8_W64(I8[P64[Sp + 24] + (_sqEX::I64 & 255 + 16)]);
           if (%MO_S_Gt_W64(_sqEY::I64,
                            _sqF2::I64)) goto cqIl; else goto cqIm;
       cqIl: // global
           if (%MO_S_Ge_W64(_sqF2::I64, 8)) goto cqIi; else goto cqIj;
       cqIi: // global
           Hp = Hp - 32;
           I64[Sp + 16] = %MO_S_Shr_W64(_sqEX::I64, 8);
           I64[Sp + 8] = _sqEY::I64 - 8;
           call _cqH3() args: 0, res: 0, upd: 0;
       cqIj: // global
           I64[Hp - 24] = sat_sqF8_info;
           I64[Hp - 8] = _sqEX::I64;
           I64[Hp] = _sqF2::I64;
           R2 = _sqEY::I64 - _sqF2::I64;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cqIm: // global
           I64[Hp - 24] = sat_sqFb_info;
           I64[Hp - 8] = _sqEX::I64;
           I64[Hp] = _sqEY::I64;
           R2 = 0;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.274987183 UTC

[section ""data" . GHC.Float.ConversionUtils.elimZerosInteger_closure" {
     GHC.Float.ConversionUtils.elimZerosInteger_closure:
         const GHC.Float.ConversionUtils.elimZerosInteger_info;
         const 0;
 },
 GHC.Float.ConversionUtils.elimZerosInteger_entry() //  [R2, R3]
         { info_tbl: [(cqJG,
                       label: GHC.Float.ConversionUtils.elimZerosInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqJG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqJH; else goto cqJI;
       cqJH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.elimZerosInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cqJI: // global
           I64[Sp - 16] = block_cqJE_info;
           R2 = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cqJE() //  [R1]
         { info_tbl: [(cqJE,
                       label: block_cqJE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqJE: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Float.ConversionUtils.elimZerosInt#_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.280540342 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule4_bytes" {
     GHC.Float.ConversionUtils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.282464007 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule3_closure" {
     GHC.Float.ConversionUtils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.284348771 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$trModule2_bytes" {
     GHC.Float.ConversionUtils.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.286517575 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule1_closure" {
     GHC.Float.ConversionUtils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.288245807 UTC

[section ""data" . GHC.Float.ConversionUtils.$trModule_closure" {
     GHC.Float.ConversionUtils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.ConversionUtils.$trModule3_closure+1;
         const GHC.Float.ConversionUtils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.290160898 UTC

[section ""data" . $krep_rqs2_closure" {
     $krep_rqs2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcByteArray#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.292010085 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tcBA2_bytes" {
     GHC.Float.ConversionUtils.$tcBA2_bytes:
         I8[] [66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.293880311 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA1_closure" {
     GHC.Float.ConversionUtils.$tcBA1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tcBA2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.295691851 UTC

[section ""data" . GHC.Float.ConversionUtils.$tcBA_closure" {
     GHC.Float.ConversionUtils.$tcBA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tcBA1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2744518186030791563;
         const 15983957619153370905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.298260605 UTC

[section ""data" . $krep1_rqs3_closure" {
     $krep1_rqs3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Float.ConversionUtils.$tcBA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.300065309 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA1_closure" {
     GHC.Float.ConversionUtils.$tc'BA1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rqs2_closure+1;
         const $krep1_rqs3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.302003797 UTC

[section ""cstring" . GHC.Float.ConversionUtils.$tc'BA3_bytes" {
     GHC.Float.ConversionUtils.$tc'BA3_bytes:
         I8[] [39,66,65]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.303859111 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA2_closure" {
     GHC.Float.ConversionUtils.$tc'BA2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.ConversionUtils.$tc'BA3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.305657658 UTC

[section ""data" . GHC.Float.ConversionUtils.$tc'BA_closure" {
     GHC.Float.ConversionUtils.$tc'BA_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Float.ConversionUtils.$trModule_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA2_closure+1;
         const GHC.Float.ConversionUtils.$tc'BA1_closure+4;
         const 2662423355322146026;
         const 17541892848942326139;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.308654162 UTC

[section ""data" . GHC.Float.ConversionUtils.BA_closure" {
     GHC.Float.ConversionUtils.BA_closure:
         const GHC.Float.ConversionUtils.BA_info;
 },
 GHC.Float.ConversionUtils.BA_entry() //  [R2]
         { info_tbl: [(cqKe,
                       label: GHC.Float.ConversionUtils.BA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqKe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqKi; else goto cqKh;
       cqKi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Float.ConversionUtils.BA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqKh: // global
           I64[Hp - 8] = GHC.Float.ConversionUtils.BA_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.31300215 UTC

[GHC.Float.ConversionUtils.BA_con_entry() //  [R1]
         { info_tbl: [(cqKp,
                       label: GHC.Float.ConversionUtils.BA_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,108,111,97,116,46,67,111,110,118,101,114,115,105,111,110,85,116,105,108,115,46,66,65]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cqKp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:04.316613754 UTC

[section ""relreadonly" . SqIC_srt" {
     SqIC_srt:
         const GHC.Float.ConversionUtils.elimZerosInt#_closure;
         const GHC.Float.ConversionUtils.zeroCountArr_closure;
         const GHC.Float.ConversionUtils.elimZerosInteger_closure;
 }]

