
==================== Output Cmm ====================
2018-03-16 16:05:32.244674429 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:32.246297472 UTC

[section ""data" . GHC.Event.Manager.$WEventManager_closure" {
     GHC.Event.Manager.$WEventManager_closure:
         const GHC.Event.Manager.$WEventManager_info;
 },
 GHC.Event.Manager.$WEventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caAWr,
                       label: GHC.Event.Manager.$WEventManager_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWr: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caAWU; else goto caAWV;
       caAWU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WEventManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caAWV: // global
           I64[Sp - 40] = block_caAWo_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaAX5; else goto caAWp;
       uaAX5: // global
           call _caAWo(R1) args: 0, res: 0, upd: 0;
       caAWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAWo() //  [R1]
         { info_tbl: [(caAWo,
                       label: block_caAWo_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWo: // global
           I64[Sp] = block_caAWu_info;
           _saAuv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saAuv::P64;
           if (R1 & 7 != 0) goto uaAX4; else goto caAWv;
       uaAX4: // global
           call _caAWu(R1) args: 0, res: 0, upd: 0;
       caAWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAWu() //  [R1]
         { info_tbl: [(caAWu,
                       label: block_caAWu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWu: // global
           I64[Sp - 24] = block_caAWz_info;
           _saAux::P64 = P64[R1 + 7];
           _saAuy::P64 = P64[R1 + 15];
           _saAuA::P64 = P64[R1 + 23];
           _saAuz::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           I64[Sp - 16] = _saAuz::I64;
           P64[Sp - 8] = _saAuA::P64;
           P64[Sp] = _saAuy::P64;
           P64[Sp + 16] = _saAux::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaAX6; else goto caAWA;
       uaAX6: // global
           call _caAWz(R1) args: 0, res: 0, upd: 0;
       caAWA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAWz() //  [R1]
         { info_tbl: [(caAWz,
                       label: block_caAWz_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWz: // global
           I64[Sp] = block_caAWE_info;
           _saAuC::P64 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _saAuC::P64;
           if (R1 & 7 != 0) goto uaAX7; else goto caAWF;
       uaAX7: // global
           call _caAWE(R1) args: 0, res: 0, upd: 0;
       caAWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAWE() //  [R1]
         { info_tbl: [(caAWE,
                       label: block_caAWE_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWE: // global
           I64[Sp] = block_caAWJ_info;
           _saAuE::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _saAuE::P64;
           if (R1 & 7 != 0) goto uaAX8; else goto caAWK;
       uaAX8: // global
           call _caAWJ(R1) args: 0, res: 0, upd: 0;
       caAWK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAWJ() //  [R1]
         { info_tbl: [(caAWJ,
                       label: block_caAWJ_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWJ: // global
           I64[Sp - 32] = block_caAWO_info;
           _saAuJ::P64 = P64[R1 + 7];
           _saAuK::P64 = P64[R1 + 15];
           _saAuG::I64 = I64[R1 + 23];
           _saAuH::I64 = I64[R1 + 31];
           _saAuI::I64 = I64[R1 + 39];
           R1 = P64[Sp + 64];
           I64[Sp - 24] = _saAuI::I64;
           P64[Sp - 16] = _saAuJ::P64;
           P64[Sp - 8] = _saAuK::P64;
           I64[Sp] = _saAuH::I64;
           I64[Sp + 64] = _saAuG::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaAX9; else goto caAWP;
       uaAX9: // global
           call _caAWO(R1) args: 0, res: 0, upd: 0;
       caAWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAWO() //  [R1]
         { info_tbl: [(caAWO,
                       label: block_caAWO_info
                       rep:StackRep [True, False, False, True, True, False, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAWO: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caAX3; else goto caAX2;
       caAX3: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caAX2: // global
           _saAuM::P64 = P64[R1 + 7];
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 80];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _saAuM::P64;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 96];
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 103;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.249196453 UTC

[section ""data" . GHC.Event.Manager.$WFdKey_closure" {
     GHC.Event.Manager.$WFdKey_closure:
         const GHC.Event.Manager.$WFdKey_info;
 },
 GHC.Event.Manager.$WFdKey_entry() //  [R2, R3]
         { info_tbl: [(caAXh,
                       label: GHC.Event.Manager.$WFdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAXq; else goto caAXr;
       caAXq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caAXr: // global
           I64[Sp - 16] = block_caAXe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaAXx; else goto caAXf;
       uaAXx: // global
           call _caAXe(R1) args: 0, res: 0, upd: 0;
       caAXf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAXe() //  [R1]
         { info_tbl: [(caAXe,
                       label: block_caAXe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXe: // global
           I64[Sp] = block_caAXk_info;
           _saAuQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saAuQ::I64;
           if (R1 & 7 != 0) goto uaAXw; else goto caAXl;
       uaAXw: // global
           call _caAXk(R1) args: 0, res: 0, upd: 0;
       caAXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAXk() //  [R1]
         { info_tbl: [(caAXk,
                       label: block_caAXk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caAXv; else goto caAXu;
       caAXv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caAXu: // global
           _saAuS::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saAuS::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.250960871 UTC

[section ""data" . GHC.Event.Manager.$WFdData_closure" {
     GHC.Event.Manager.$WFdData_closure:
         const GHC.Event.Manager.$WFdData_info;
 },
 GHC.Event.Manager.$WFdData_entry() //  [R2, R3, R4]
         { info_tbl: [(caAXF,
                       label: GHC.Event.Manager.$WFdData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caAXQ; else goto caAXR;
       caAXQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caAXR: // global
           I64[Sp - 24] = block_caAXC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaAXY; else goto caAXD;
       uaAXY: // global
           call _caAXC(R1) args: 0, res: 0, upd: 0;
       caAXD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAXC() //  [R1]
         { info_tbl: [(caAXC,
                       label: block_caAXC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXC: // global
           I64[Sp - 8] = block_caAXI_info;
           _saAuX::I64 = I64[R1 + 7];
           _saAuY::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAuY::I64;
           I64[Sp + 8] = _saAuX::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaAXX; else goto caAXJ;
       uaAXX: // global
           call _caAXI(R1) args: 0, res: 0, upd: 0;
       caAXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAXI() //  [R1]
         { info_tbl: [(caAXI,
                       label: block_caAXI_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXI: // global
           I64[Sp] = block_caAXN_info;
           _saAv0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saAv0::I64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAXN() //  [R1]
         { info_tbl: [(caAXN,
                       label: block_caAXN_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAXN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caAXW; else goto caAXV;
       caAXW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caAXV: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.252477303 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState10_bytes" {
     GHC.Event.Manager.$fShowState10_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.253217312 UTC

[section ""data" . GHC.Event.Manager.$fShowState9_closure" {
     GHC.Event.Manager.$fShowState9_closure:
         const GHC.Event.Manager.$fShowState9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState9_entry() //  [R1]
         { info_tbl: [(caAY5,
                       label: GHC.Event.Manager.$fShowState9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAY5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAY6; else goto caAY7;
       caAY6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAY7: // global
           (_caAY2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAY2::I64 == 0) goto caAY4; else goto caAY3;
       caAY4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAY3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAY2::I64;
           R2 = GHC.Event.Manager.$fShowState10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.254109129 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState8_bytes" {
     GHC.Event.Manager.$fShowState8_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.254854716 UTC

[section ""data" . GHC.Event.Manager.$fShowState7_closure" {
     GHC.Event.Manager.$fShowState7_closure:
         const GHC.Event.Manager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState7_entry() //  [R1]
         { info_tbl: [(caAYe,
                       label: GHC.Event.Manager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAYe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAYf; else goto caAYg;
       caAYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAYg: // global
           (_caAYb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAYb::I64 == 0) goto caAYd; else goto caAYc;
       caAYd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAYc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAYb::I64;
           R2 = GHC.Event.Manager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.255705241 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState6_bytes" {
     GHC.Event.Manager.$fShowState6_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.256424555 UTC

[section ""data" . GHC.Event.Manager.$fShowState5_closure" {
     GHC.Event.Manager.$fShowState5_closure:
         const GHC.Event.Manager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState5_entry() //  [R1]
         { info_tbl: [(caAYn,
                       label: GHC.Event.Manager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAYo; else goto caAYp;
       caAYo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAYp: // global
           (_caAYk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAYk::I64 == 0) goto caAYm; else goto caAYl;
       caAYm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAYl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAYk::I64;
           R2 = GHC.Event.Manager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.25732458 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState4_bytes" {
     GHC.Event.Manager.$fShowState4_bytes:
         I8[] [82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.258055409 UTC

[section ""data" . GHC.Event.Manager.$fShowState3_closure" {
     GHC.Event.Manager.$fShowState3_closure:
         const GHC.Event.Manager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState3_entry() //  [R1]
         { info_tbl: [(caAYw,
                       label: GHC.Event.Manager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAYw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAYx; else goto caAYy;
       caAYx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAYy: // global
           (_caAYt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAYt::I64 == 0) goto caAYv; else goto caAYu;
       caAYv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAYu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAYt::I64;
           R2 = GHC.Event.Manager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.258910857 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState2_bytes" {
     GHC.Event.Manager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.259668797 UTC

[section ""data" . GHC.Event.Manager.$fShowState1_closure" {
     GHC.Event.Manager.$fShowState1_closure:
         const GHC.Event.Manager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState1_entry() //  [R1]
         { info_tbl: [(caAYF,
                       label: GHC.Event.Manager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAYF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAYG; else goto caAYH;
       caAYG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAYH: // global
           (_caAYC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAYC::I64 == 0) goto caAYE; else goto caAYD;
       caAYE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAYD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAYC::I64;
           R2 = GHC.Event.Manager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.261001868 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec1_closure" {
     GHC.Event.Manager.$w$cshowsPrec1_closure:
         const GHC.Event.Manager.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(caAYW,
                       label: GHC.Event.Manager.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAYW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAYX; else goto caAYY;
       caAYX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caAYY: // global
           I64[Sp - 16] = block_caAYM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaAZh; else goto caAYN;
       uaAZh: // global
           call _caAYM(R1) args: 0, res: 0, upd: 0;
       caAYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAYM() //  [R1]
         { info_tbl: [(caAYM,
                       label: block_caAYM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAYM: // global
           _saAv3::P64 = P64[Sp + 8];
           _caAYV::P64 = R1 & 7;
           if (_caAYV::P64 < 4) goto uaAZe; else goto uaAZg;
       uaAZe: // global
           if (_caAYV::P64 < 3) goto uaAZf; else goto caAYS;
       uaAZf: // global
           if (_caAYV::P64 < 2) goto caAYQ; else goto caAYR;
       caAYQ: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caAYR: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caAYS: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uaAZg: // global
           if (_caAYV::P64 < 5) goto caAYT; else goto caAYU;
       caAYT: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caAYU: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.262640658 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(caAZn,
                       label: GHC.Event.Manager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAZn: // global
           _saAv6::P64 = R3;
           R3 = R4;
           R2 = _saAv6::P64;
           call GHC.Event.Manager.$w$cshowsPrec1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.264309987 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c==_closure" {
     GHC.Event.Manager.$fEqState_$c==_closure:
         const GHC.Event.Manager.$fEqState_$c==_info;
 },
 GHC.Event.Manager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(caAZE,
                       label: GHC.Event.Manager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAZE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAZF; else goto caAZG;
       caAZF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caAZG: // global
           I64[Sp - 16] = block_caAZu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaB1h; else goto caAZv;
       uaB1h: // global
           call _caAZu(R1) args: 0, res: 0, upd: 0;
       caAZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAZu() //  [R1]
         { info_tbl: [(caAZu,
                       label: block_caAZu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAZu: // global
           _saAv9::P64 = P64[Sp + 8];
           _caAZD::P64 = R1 & 7;
           if (_caAZD::P64 < 4) goto uaB0Z; else goto uaB11;
       uaB0Z: // global
           if (_caAZD::P64 < 3) goto uaB10; else goto caAZA;
       uaB10: // global
           if (_caAZD::P64 < 2) goto caAZy; else goto caAZz;
       caAZy: // global
           I64[Sp + 8] = block_caAZJ_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaB1c; else goto caAZL;
       uaB1c: // global
           call _caAZJ(R1) args: 0, res: 0, upd: 0;
       caAZL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caAZz: // global
           I64[Sp + 8] = block_caAZY_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaB1d; else goto caB00;
       uaB1d: // global
           call _caAZY(R1) args: 0, res: 0, upd: 0;
       caB00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caAZA: // global
           I64[Sp + 8] = block_caB0d_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaB1e; else goto caB0f;
       uaB1e: // global
           call _caB0d(R1) args: 0, res: 0, upd: 0;
       caB0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaB11: // global
           if (_caAZD::P64 < 5) goto caAZB; else goto caAZC;
       caAZB: // global
           I64[Sp + 8] = block_caB0s_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaB1f; else goto caB0u;
       uaB1f: // global
           call _caB0s(R1) args: 0, res: 0, upd: 0;
       caB0u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caAZC: // global
           I64[Sp + 8] = block_caB0H_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaB1g; else goto caB0J;
       uaB1g: // global
           call _caB0H(R1) args: 0, res: 0, upd: 0;
       caB0J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAZJ() //  [R1]
         { info_tbl: [(caAZJ,
                       label: block_caAZJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAZJ: // global
           if (R1 & 7 == 1) goto uaB12; else goto uaB13;
       uaB12: // global
           Sp = Sp + 8;
           call _caB0T() args: 0, res: 0, upd: 0;
       uaB13: // global
           Sp = Sp + 8;
           call _caB0P() args: 0, res: 0, upd: 0;
     }
 },
 _caAZY() //  [R1]
         { info_tbl: [(caAZY,
                       label: block_caAZY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAZY: // global
           if (R1 & 7 == 2) goto uaB14; else goto uaB15;
       uaB14: // global
           Sp = Sp + 8;
           call _caB0T() args: 0, res: 0, upd: 0;
       uaB15: // global
           Sp = Sp + 8;
           call _caB0P() args: 0, res: 0, upd: 0;
     }
 },
 _caB0d() //  [R1]
         { info_tbl: [(caB0d,
                       label: block_caB0d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB0d: // global
           if (R1 & 7 == 3) goto uaB16; else goto uaB17;
       uaB16: // global
           Sp = Sp + 8;
           call _caB0T() args: 0, res: 0, upd: 0;
       uaB17: // global
           Sp = Sp + 8;
           call _caB0P() args: 0, res: 0, upd: 0;
     }
 },
 _caB0s() //  [R1]
         { info_tbl: [(caB0s,
                       label: block_caB0s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB0s: // global
           if (R1 & 7 == 4) goto uaB18; else goto uaB19;
       uaB18: // global
           Sp = Sp + 8;
           call _caB0T() args: 0, res: 0, upd: 0;
       uaB19: // global
           Sp = Sp + 8;
           call _caB0P() args: 0, res: 0, upd: 0;
     }
 },
 _caB0H() //  [R1]
         { info_tbl: [(caB0H,
                       label: block_caB0H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB0H: // global
           if (R1 & 7 == 5) goto uaB1a; else goto uaB1b;
       uaB1a: // global
           Sp = Sp + 8;
           call _caB0T() args: 0, res: 0, upd: 0;
       uaB1b: // global
           Sp = Sp + 8;
           call _caB0P() args: 0, res: 0, upd: 0;
     }
 },
 _caB0T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB0T: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caB0P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB0P: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.267009672 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey5_bytes" {
     GHC.Event.Manager.$fShowFdKey5_bytes:
         I8[] [70,100,75,101,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.267576892 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey4_bytes" {
     GHC.Event.Manager.$fShowFdKey4_bytes:
         I8[] [107,101,121,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.26811188 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey3_bytes" {
     GHC.Event.Manager.$fShowFdKey3_bytes:
         I8[] [107,101,121,85,110,105,113,117,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.268632986 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey2_bytes" {
     GHC.Event.Manager.$fShowFdKey2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.271077339 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec_closure" {
     GHC.Event.Manager.$w$cshowsPrec_closure:
         const GHC.Event.Manager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB1t: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvq_entry() //  [R1]
         { info_tbl: [(caB22,
                       label: sat_saAvq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB22: // global
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Manager.$fShowFdKey2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvr_entry() //  [R1]
         { info_tbl: [(caB26,
                       label: sat_saAvr_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB26: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caB27; else goto caB28;
       caB27: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caB28: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caB1W_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caB1W() //  [R1, R2]
         { info_tbl: [(caB1W,
                       label: block_caB1W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB1W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caB2b; else goto caB2a;
       caB2b: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caB2a: // global
           I64[Hp - 40] = sat_saAvq_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvs_entry() //  [R1]
         { info_tbl: [(caB2c,
                       label: sat_saAvs_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caB2g; else goto caB2f;
       caB2g: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caB2f: // global
           _saAvl::P64 = P64[R1 + 16];
           _saAvi::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_saAvr_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Manager.$fShowFdKey3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvt_entry() //  [R1]
         { info_tbl: [(caB2h,
                       label: sat_saAvt_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2h: // global
           _saAvt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caB2i; else goto caB2j;
       caB2j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caB2l; else goto caB2k;
       caB2l: // global
           HpAlloc = 32;
           goto caB2i;
       caB2i: // global
           R1 = _saAvt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caB2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvt::P64;
           _saAvl::P64 = P64[_saAvt::P64 + 16];
           _saAvi::I64 = I64[_saAvt::P64 + 24];
           I64[Hp - 24] = sat_saAvs_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvx_entry() //  [R1]
         { info_tbl: [(caB2p,
                       label: sat_saAvx_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2p: // global
           _saAvx::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caB2q; else goto caB2r;
       caB2r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caB2t; else goto caB2s;
       caB2t: // global
           HpAlloc = 32;
           goto caB2q;
       caB2q: // global
           R1 = _saAvx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caB2s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvx::P64;
           _saAvl::P64 = P64[_saAvx::P64 + 16];
           _saAvh::I64 = I64[_saAvx::P64 + 24];
           _saAvi::I64 = I64[_saAvx::P64 + 32];
           I64[Hp - 24] = sat_saAvt_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           I64[Sp - 24] = block_caB2m_info;
           R4 = Hp - 24;
           R3 = _saAvh::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caB2m() //  [R1, R2]
         { info_tbl: [(caB2m,
                       label: block_caB2m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caB2w; else goto caB2v;
       caB2w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caB2v: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvy_entry() //  [R1]
         { info_tbl: [(caB2x,
                       label: sat_saAvy_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2x: // global
           _saAvy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caB2y; else goto caB2z;
       caB2z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caB2B; else goto caB2A;
       caB2B: // global
           HpAlloc = 40;
           goto caB2y;
       caB2y: // global
           R1 = _saAvy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caB2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvy::P64;
           _saAvl::P64 = P64[_saAvy::P64 + 16];
           _saAvh::I64 = I64[_saAvy::P64 + 24];
           _saAvi::I64 = I64[_saAvy::P64 + 32];
           I64[Hp - 32] = sat_saAvx_info;
           P64[Hp - 16] = _saAvl::P64;
           I64[Hp - 8] = _saAvh::I64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_saAvk_entry() //  [R1, R2]
         { info_tbl: [(caB2C,
                       label: p_saAvk_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2C: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caB2G; else goto caB2F;
       caB2G: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB2F: // global
           _saAvh::I64 = I64[R1 + 7];
           _saAvi::I64 = I64[R1 + 15];
           I64[Hp - 32] = sat_saAvy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = _saAvh::I64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvB_entry() //  [R1]
         { info_tbl: [(caB2Q,
                       label: sat_saAvB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2Q: // global
           _saAvB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caB2R; else goto caB2S;
       caB2S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caB2U; else goto caB2T;
       caB2U: // global
           HpAlloc = 24;
           goto caB2R;
       caB2R: // global
           R1 = _saAvB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caB2T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvB::P64;
           _saAvj::P64 = P64[_saAvB::P64 + 16];
           _saAvk::P64 = P64[_saAvB::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _saAvj::P64;
           R2 = Hp - 14;
           R1 = _saAvk::P64;
           Sp = Sp - 16;
           call p_saAvk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caB2Y,
                       label: GHC.Event.Manager.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB2Y: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caB32; else goto caB31;
       caB32: // global
           HpAlloc = 80;
           R1 = GHC.Event.Manager.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caB31: // global
           I64[Hp - 72] = p_saAvk_info;
           I64[Hp - 64] = R3;
           I64[Hp - 56] = R4;
           _caB1x::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto caB2W; else goto caB2X;
       caB2W: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _caB1x::P64;
           call p_saAvk_entry(R2, R1) args: 8, res: 0, upd: 8;
       caB2X: // global
           I64[Hp - 48] = sat_saAvB_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _caB1x::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.275889332 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caB3b,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caB3f; else goto caB3g;
       caB3f: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caB3g: // global
           I64[Sp - 24] = block_caB38_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaB3o; else goto caB39;
       uaB3o: // global
           call _caB38(R1) args: 0, res: 0, upd: 0;
       caB39: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB38() //  [R1]
         { info_tbl: [(caB38,
                       label: block_caB38_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB38: // global
           I64[Sp] = block_caB3e_info;
           _saAvG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saAvG::I64;
           if (R1 & 7 != 0) goto uaB3n; else goto caB3i;
       uaB3n: // global
           call _caB3e(R1) args: 0, res: 0, upd: 0;
       caB3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB3e() //  [R1]
         { info_tbl: [(caB3e,
                       label: block_caB3e_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3e: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.277263247 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey6_closure" {
     GHC.Event.Manager.$fShowFdKey6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.27958071 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshow_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshow_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshow_entry() //  [R2]
         { info_tbl: [(caB3w,
                       label: GHC.Event.Manager.$fShowFdKey_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB3x; else goto caB3y;
       caB3x: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB3y: // global
           I64[Sp - 8] = block_caB3t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB3C; else goto caB3u;
       uaB3C: // global
           call _caB3t(R1) args: 0, res: 0, upd: 0;
       caB3u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB3t() //  [R1]
         { info_tbl: [(caB3t,
                       label: block_caB3t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3t: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.280812831 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey1_closure" {
     GHC.Event.Manager.$fShowFdKey1_closure:
         const GHC.Event.Manager.$fShowFdKey1_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey1_entry() //  [R2, R3]
         { info_tbl: [(caB3K,
                       label: GHC.Event.Manager.$fShowFdKey1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caB3L; else goto caB3M;
       caB3L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caB3M: // global
           I64[Sp - 16] = block_caB3H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaB3Q; else goto caB3I;
       uaB3Q: // global
           call _caB3H(R1) args: 0, res: 0, upd: 0;
       caB3I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB3H() //  [R1]
         { info_tbl: [(caB3H,
                       label: block_caB3H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3H: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.282084003 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowList_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowList_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caB3V,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB3V: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$fShowFdKey1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.282812106 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_closure" {
     GHC.Event.Manager.$fShowFdKey_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure+1;
         const GHC.Event.Manager.$fShowFdKey_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.283664904 UTC

[section ""data" . GHC.Event.Manager.keyUnique_closure" {
     GHC.Event.Manager.keyUnique_closure:
         const GHC.Event.Manager.keyUnique_info;
 },
 GHC.Event.Manager.keyUnique_entry() //  [R2]
         { info_tbl: [(caB45,
                       label: GHC.Event.Manager.keyUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB45: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB49; else goto caB4a;
       caB49: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB4a: // global
           I64[Sp - 8] = block_caB42_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB4e; else goto caB43;
       uaB4e: // global
           call _caB42(R1) args: 0, res: 0, upd: 0;
       caB43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB42() //  [R1]
         { info_tbl: [(caB42,
                       label: block_caB42_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB42: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caB4d; else goto caB4c;
       caB4d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB4c: // global
           _saAvY::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAvY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.284994571 UTC

[section ""data" . GHC.Event.Manager.keyFd_closure" {
     GHC.Event.Manager.keyFd_closure:
         const GHC.Event.Manager.keyFd_info;
 },
 GHC.Event.Manager.keyFd_entry() //  [R2]
         { info_tbl: [(caB4m,
                       label: GHC.Event.Manager.keyFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB4m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB4q; else goto caB4r;
       caB4q: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB4r: // global
           I64[Sp - 8] = block_caB4j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB4v; else goto caB4k;
       uaB4v: // global
           call _caB4j(R1) args: 0, res: 0, upd: 0;
       caB4k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB4j() //  [R1]
         { info_tbl: [(caB4j,
                       label: block_caB4j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB4j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caB4u; else goto caB4t;
       caB4u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB4t: // global
           _saAw1::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saAw1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.286248392 UTC

[section ""data" . GHC.Event.Manager._fdCallback_closure" {
     GHC.Event.Manager._fdCallback_closure:
         const GHC.Event.Manager._fdCallback_info;
 },
 GHC.Event.Manager._fdCallback_entry() //  [R2]
         { info_tbl: [(caB4D,
                       label: GHC.Event.Manager._fdCallback_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB4D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB4E; else goto caB4F;
       caB4E: // global
           R2 = R2;
           R1 = GHC.Event.Manager._fdCallback_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB4F: // global
           I64[Sp - 8] = block_caB4A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB4J; else goto caB4B;
       uaB4J: // global
           call _caB4A(R1) args: 0, res: 0, upd: 0;
       caB4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB4A() //  [R1]
         { info_tbl: [(caB4A,
                       label: block_caB4A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB4A: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.287434309 UTC

[section ""data" . GHC.Event.Manager.fdEvents_closure" {
     GHC.Event.Manager.fdEvents_closure:
         const GHC.Event.Manager.fdEvents_info;
 },
 GHC.Event.Manager.fdEvents_entry() //  [R2]
         { info_tbl: [(caB4R,
                       label: GHC.Event.Manager.fdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB4R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB4V; else goto caB4W;
       caB4V: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB4W: // global
           I64[Sp - 8] = block_caB4O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB50; else goto caB4P;
       uaB50: // global
           call _caB4O(R1) args: 0, res: 0, upd: 0;
       caB4P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB4O() //  [R1]
         { info_tbl: [(caB4O,
                       label: block_caB4O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB4O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caB4Z; else goto caB4Y;
       caB4Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB4Y: // global
           _saAwd::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAwd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.288738797 UTC

[section ""data" . GHC.Event.Manager.fdKey_closure" {
     GHC.Event.Manager.fdKey_closure:
         const GHC.Event.Manager.fdKey_info;
 },
 GHC.Event.Manager.fdKey_entry() //  [R2]
         { info_tbl: [(caB58,
                       label: GHC.Event.Manager.fdKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB58: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB5c; else goto caB5d;
       caB5c: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB5d: // global
           I64[Sp - 8] = block_caB55_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB5h; else goto caB56;
       uaB5h: // global
           call _caB55(R1) args: 0, res: 0, upd: 0;
       caB56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB55() //  [R1]
         { info_tbl: [(caB55,
                       label: block_caB55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB55: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caB5g; else goto caB5f;
       caB5g: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB5f: // global
           _saAwh::I64 = I64[R1 + 15];
           _saAwi::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAwh::I64;
           I64[Hp] = _saAwi::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.290099447 UTC

[section ""data" . GHC.Event.Manager.emLock_closure" {
     GHC.Event.Manager.emLock_closure:
         const GHC.Event.Manager.emLock_info;
 },
 GHC.Event.Manager.emLock_entry() //  [R2]
         { info_tbl: [(caB5p,
                       label: GHC.Event.Manager.emLock_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB5p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB5t; else goto caB5u;
       caB5t: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emLock_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB5u: // global
           I64[Sp - 8] = block_caB5m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB5y; else goto caB5n;
       uaB5y: // global
           call _caB5m(R1) args: 0, res: 0, upd: 0;
       caB5n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB5m() //  [R1]
         { info_tbl: [(caB5m,
                       label: block_caB5m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB5m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caB5x; else goto caB5w;
       caB5x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB5w: // global
           _saAwz::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _saAwz::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.291426684 UTC

[section ""data" . GHC.Event.Manager.emControl_closure" {
     GHC.Event.Manager.emControl_closure:
         const GHC.Event.Manager.emControl_info;
 },
 GHC.Event.Manager.emControl_entry() //  [R2]
         { info_tbl: [(caB5G,
                       label: GHC.Event.Manager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB5G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB5K; else goto caB5L;
       caB5K: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB5L: // global
           I64[Sp - 8] = block_caB5D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB5P; else goto caB5E;
       uaB5P: // global
           call _caB5D(R1) args: 0, res: 0, upd: 0;
       caB5E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB5D() //  [R1]
         { info_tbl: [(caB5D,
                       label: block_caB5D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB5D: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caB5O; else goto caB5N;
       caB5O: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB5N: // global
           _saAwM::P64 = P64[R1 + 55];
           _saAwN::P64 = P64[R1 + 63];
           _saAwJ::I64 = I64[R1 + 87];
           _saAwK::I64 = I64[R1 + 95];
           _saAwL::I64 = I64[R1 + 103];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _saAwM::P64;
           P64[Hp - 24] = _saAwN::P64;
           I64[Hp - 16] = _saAwJ::I64;
           I64[Hp - 8] = _saAwK::I64;
           I64[Hp] = _saAwL::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.292812513 UTC

[section ""data" . GHC.Event.Manager.emUniqueSource_closure" {
     GHC.Event.Manager.emUniqueSource_closure:
         const GHC.Event.Manager.emUniqueSource_info;
 },
 GHC.Event.Manager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(caB5X,
                       label: GHC.Event.Manager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB5X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB61; else goto caB62;
       caB61: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB62: // global
           I64[Sp - 8] = block_caB5U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB66; else goto caB5V;
       uaB66: // global
           call _caB5U(R1) args: 0, res: 0, upd: 0;
       caB5V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB5U() //  [R1]
         { info_tbl: [(caB5U,
                       label: block_caB5U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB5U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caB65; else goto caB64;
       caB65: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB64: // global
           _saAwX::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _saAwX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.294354009 UTC

[section ""data" . GHC.Event.Manager.emState_closure" {
     GHC.Event.Manager.emState_closure:
         const GHC.Event.Manager.emState_info;
 },
 GHC.Event.Manager.emState_entry() //  [R2]
         { info_tbl: [(caB6e,
                       label: GHC.Event.Manager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB6i; else goto caB6j;
       caB6i: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB6j: // global
           I64[Sp - 8] = block_caB6b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB6n; else goto caB6c;
       uaB6n: // global
           call _caB6b(R1) args: 0, res: 0, upd: 0;
       caB6c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB6b() //  [R1]
         { info_tbl: [(caB6b,
                       label: block_caB6b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caB6m; else goto caB6l;
       caB6m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB6l: // global
           _saAxb::P64 = P64[R1 + 39];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _saAxb::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.295676393 UTC

[section ""data" . GHC.Event.Manager.emFds_closure" {
     GHC.Event.Manager.emFds_closure:
         const GHC.Event.Manager.emFds_info;
 },
 GHC.Event.Manager.emFds_entry() //  [R2]
         { info_tbl: [(caB6v,
                       label: GHC.Event.Manager.emFds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB6z; else goto caB6A;
       caB6z: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emFds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB6A: // global
           I64[Sp - 8] = block_caB6s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB6E; else goto caB6t;
       uaB6E: // global
           call _caB6s(R1) args: 0, res: 0, upd: 0;
       caB6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB6s() //  [R1]
         { info_tbl: [(caB6s,
                       label: block_caB6s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6s: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caB6D; else goto caB6C;
       caB6D: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caB6C: // global
           _saAxm::P64 = P64[R1 + 15];
           _saAxn::P64 = P64[R1 + 23];
           _saAxp::P64 = P64[R1 + 31];
           _saAxo::I64 = I64[R1 + 79];
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = _saAxm::P64;
           P64[Hp - 16] = _saAxn::P64;
           P64[Hp - 8] = _saAxp::P64;
           I64[Hp] = _saAxo::I64;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.297025125 UTC

[section ""data" . GHC.Event.Manager.emBackend_closure" {
     GHC.Event.Manager.emBackend_closure:
         const GHC.Event.Manager.emBackend_info;
 },
 GHC.Event.Manager.emBackend_entry() //  [R2]
         { info_tbl: [(caB6M,
                       label: GHC.Event.Manager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB6N; else goto caB6O;
       caB6N: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB6O: // global
           I64[Sp - 8] = block_caB6J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB6S; else goto caB6K;
       uaB6S: // global
           call _caB6J(R1) args: 0, res: 0, upd: 0;
       caB6K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB6J() //  [R1]
         { info_tbl: [(caB6J,
                       label: block_caB6J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6J: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.298059989 UTC

[section ""data" . GHC.Event.Manager.newDefaultBackend_closure" {
     GHC.Event.Manager.newDefaultBackend_closure:
         const GHC.Event.Manager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.Manager.newDefaultBackend_entry() //  []
         { info_tbl: [(caB6X,
                       label: GHC.Event.Manager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB6X: // global
           call GHC.Event.EPoll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.298782476 UTC

[section ""cstring" . GHC.Event.Manager.$trModule4_bytes" {
     GHC.Event.Manager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.299335168 UTC

[section ""data" . GHC.Event.Manager.$trModule3_closure" {
     GHC.Event.Manager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.29980889 UTC

[section ""cstring" . GHC.Event.Manager.$trModule2_bytes" {
     GHC.Event.Manager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.300374388 UTC

[section ""data" . GHC.Event.Manager.$trModule1_closure" {
     GHC.Event.Manager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.300891431 UTC

[section ""data" . GHC.Event.Manager.$trModule_closure" {
     GHC.Event.Manager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Manager.$trModule3_closure+1;
         const GHC.Event.Manager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.301474361 UTC

[section ""data" . $krep_raAtw_closure" {
     $krep_raAtw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.302029614 UTC

[section ""data" . $krep1_raAtx_closure" {
     $krep1_raAtx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.302610779 UTC

[section ""data" . $krep2_raAty_closure" {
     $krep2_raAty_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEvent_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.303222397 UTC

[section ""data" . $krep3_raAtz_closure" {
     $krep3_raAtz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEventLifetime_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.303777655 UTC

[section ""data" . $krep4_raAtA_closure" {
     $krep4_raAtA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.304347619 UTC

[section ""data" . $krep5_raAtB_closure" {
     $krep5_raAtB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.304893072 UTC

[section ""data" . $krep6_raAtC_closure" {
     $krep6_raAtC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.307266319 UTC

[section ""data" . $krep7_raAtD_closure" {
     $krep7_raAtD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.307880196 UTC

[section ""data" . $krep8_raAtE_closure" {
     $krep8_raAtE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.308447297 UTC

[section ""data" . $krep9_raAtF_closure" {
     $krep9_raAtF_closure:
         const :_con_info;
         const $krep4_raAtA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.309056432 UTC

[section ""data" . $krep10_raAtG_closure" {
     $krep10_raAtG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.309629797 UTC

[section ""data" . $krep11_raAtH_closure" {
     $krep11_raAtH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.310241269 UTC

[section ""data" . $krep12_raAtI_closure" {
     $krep12_raAtI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_raAty_closure+1;
         const $krep10_raAtG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.310799541 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdKey2_bytes" {
     GHC.Event.Manager.$tcFdKey2_bytes:
         I8[] [70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.31136617 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey1_closure" {
     GHC.Event.Manager.$tcFdKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.311971933 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey_closure" {
     GHC.Event.Manager.$tcFdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11469896173097407196;
         const 6069269054622812669;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.312612725 UTC

[section ""data" . $krep13_raAtJ_closure" {
     $krep13_raAtJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.313174271 UTC

[section ""data" . $krep14_raAtK_closure" {
     $krep14_raAtK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep12_raAtI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.313805679 UTC

[section ""data" . $krep15_raAtL_closure" {
     $krep15_raAtL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raAtw_closure+1;
         const $krep13_raAtJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.314423159 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey1_closure" {
     GHC.Event.Manager.$tc'FdKey1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raAtx_closure+1;
         const $krep15_raAtL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.315032637 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdKey3_bytes" {
     GHC.Event.Manager.$tc'FdKey3_bytes:
         I8[] [39,70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.316949473 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey2_closure" {
     GHC.Event.Manager.$tc'FdKey2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdKey3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.317941831 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey_closure" {
     GHC.Event.Manager.$tc'FdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdKey2_closure+1;
         const GHC.Event.Manager.$tc'FdKey1_closure+4;
         const 5122964525573573781;
         const 3523266410810375450;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.318563096 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdData2_bytes" {
     GHC.Event.Manager.$tcFdData2_bytes:
         I8[] [70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.319095807 UTC

[section ""data" . GHC.Event.Manager.$tcFdData1_closure" {
     GHC.Event.Manager.$tcFdData1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdData2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.319652112 UTC

[section ""data" . GHC.Event.Manager.$tcFdData_closure" {
     GHC.Event.Manager.$tcFdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdData1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9572952300930290737;
         const 248149994861342082;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.320251391 UTC

[section ""data" . $krep16_raAtM_closure" {
     $krep16_raAtM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdData_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.320883921 UTC

[section ""data" . $krep17_raAtN_closure" {
     $krep17_raAtN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_raAtK_closure+4;
         const $krep16_raAtM_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.321606215 UTC

[section ""data" . $krep18_raAtO_closure" {
     $krep18_raAtO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_raAtz_closure+1;
         const $krep17_raAtN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.32220327 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData1_closure" {
     GHC.Event.Manager.$tc'FdData1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep18_raAtO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.322819965 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdData3_bytes" {
     GHC.Event.Manager.$tc'FdData3_bytes:
         I8[] [39,70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.323414894 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData2_closure" {
     GHC.Event.Manager.$tc'FdData2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdData3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.324012495 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData_closure" {
     GHC.Event.Manager.$tc'FdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdData2_closure+1;
         const GHC.Event.Manager.$tc'FdData1_closure+4;
         const 13006093439393452327;
         const 3623098721817739111;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.324663043 UTC

[section ""data" . $krep19_raAtP_closure" {
     $krep19_raAtP_closure:
         const :_con_info;
         const $krep16_raAtM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.325293168 UTC

[section ""data" . $krep20_raAtQ_closure" {
     $krep20_raAtQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep19_raAtP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.325873465 UTC

[section ""data" . $krep21_raAtR_closure" {
     $krep21_raAtR_closure:
         const :_con_info;
         const $krep20_raAtQ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.326491417 UTC

[section ""data" . $krep22_raAtS_closure" {
     $krep22_raAtS_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.IntTable.$tcIntTable_closure;
         const $krep21_raAtR_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.327055595 UTC

[section ""data" . $krep23_raAtT_closure" {
     $krep23_raAtT_closure:
         const :_con_info;
         const $krep22_raAtS_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.327632422 UTC

[section ""data" . $krep24_raAtU_closure" {
     $krep24_raAtU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep23_raAtT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.328193409 UTC

[section ""data" . $krep25_raAtV_closure" {
     $krep25_raAtV_closure:
         const :_con_info;
         const $krep24_raAtU_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.32875987 UTC

[section ""data" . $krep26_raAtW_closure" {
     $krep26_raAtW_closure:
         const :_con_info;
         const $krep7_raAtD_closure+1;
         const $krep25_raAtV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.329695404 UTC

[section ""data" . $krep27_raAtX_closure" {
     $krep27_raAtX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Arr.$tcArray_closure;
         const $krep26_raAtW_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.330286337 UTC

[section ""cstring" . GHC.Event.Manager.$tcState2_bytes" {
     GHC.Event.Manager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.330838859 UTC

[section ""data" . GHC.Event.Manager.$tcState1_closure" {
     GHC.Event.Manager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.331411438 UTC

[section ""data" . GHC.Event.Manager.$tcState_closure" {
     GHC.Event.Manager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7442518771887689078;
         const 3049393439281173903;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.331985504 UTC

[section ""data" . GHC.Event.Manager.$tc'Created1_closure" {
     GHC.Event.Manager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.332565336 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Created3_bytes" {
     GHC.Event.Manager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.333090697 UTC

[section ""data" . GHC.Event.Manager.$tc'Created2_closure" {
     GHC.Event.Manager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.333662421 UTC

[section ""data" . GHC.Event.Manager.$tc'Created_closure" {
     GHC.Event.Manager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Created2_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 17846748838152018769;
         const 13865095201560943193;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.334293051 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Running2_bytes" {
     GHC.Event.Manager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.334854605 UTC

[section ""data" . GHC.Event.Manager.$tc'Running1_closure" {
     GHC.Event.Manager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.335424061 UTC

[section ""data" . GHC.Event.Manager.$tc'Running_closure" {
     GHC.Event.Manager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Running1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8784511774161450304;
         const 13551584807303205071;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.336091942 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Dying2_bytes" {
     GHC.Event.Manager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.336697616 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying1_closure" {
     GHC.Event.Manager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.337316833 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying_closure" {
     GHC.Event.Manager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Dying1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 10564881478355389136;
         const 3106847497763432300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.337916587 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Releasing2_bytes" {
     GHC.Event.Manager.$tc'Releasing2_bytes:
         I8[] [39,82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.338468316 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing1_closure" {
     GHC.Event.Manager.$tc'Releasing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Releasing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.339039138 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing_closure" {
     GHC.Event.Manager.$tc'Releasing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Releasing1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 3204716164798465120;
         const 4205553053946559474;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.339664958 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Finished2_bytes" {
     GHC.Event.Manager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.340269805 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished1_closure" {
     GHC.Event.Manager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.340831667 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished_closure" {
     GHC.Event.Manager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Finished1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8866864364616799312;
         const 2451390217632909923;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.341505859 UTC

[section ""data" . $krep28_raAtY_closure" {
     $krep28_raAtY_closure:
         const :_con_info;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.342073823 UTC

[section ""data" . $krep29_raAtZ_closure" {
     $krep29_raAtZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep28_raAtY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.34263446 UTC

[section ""cstring" . GHC.Event.Manager.$tcEventManager2_bytes" {
     GHC.Event.Manager.$tcEventManager2_bytes:
         I8[] [69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.343911789 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager1_closure" {
     GHC.Event.Manager.$tcEventManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcEventManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.344512899 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager_closure" {
     GHC.Event.Manager.$tcEventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcEventManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16777685112477180948;
         const 1210110422135437783;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.345106193 UTC

[section ""data" . $krep30_raAu0_closure" {
     $krep30_raAu0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcEventManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.34578281 UTC

[section ""data" . $krep31_raAu1_closure" {
     $krep31_raAu1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_raAtH_closure+1;
         const $krep30_raAu0_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.346348238 UTC

[section ""data" . $krep32_raAu2_closure" {
     $krep32_raAu2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_raAtB_closure+1;
         const $krep31_raAu1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.346954603 UTC

[section ""data" . $krep33_raAu3_closure" {
     $krep33_raAu3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_raAtC_closure+1;
         const $krep32_raAu2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.34752452 UTC

[section ""data" . $krep34_raAu4_closure" {
     $krep34_raAu4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep29_raAtZ_closure+1;
         const $krep33_raAu3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.348047071 UTC

[section ""data" . $krep35_raAu5_closure" {
     $krep35_raAu5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_raAtX_closure+1;
         const $krep34_raAu4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.348634184 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager1_closure" {
     GHC.Event.Manager.$tc'EventManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_raAtE_closure+1;
         const $krep35_raAu5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.349193954 UTC

[section ""cstring" . GHC.Event.Manager.$tc'EventManager3_bytes" {
     GHC.Event.Manager.$tc'EventManager3_bytes:
         I8[] [39,69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.350241271 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager2_closure" {
     GHC.Event.Manager.$tc'EventManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'EventManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.350816726 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager_closure" {
     GHC.Event.Manager.$tc'EventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'EventManager2_closure+1;
         const GHC.Event.Manager.$tc'EventManager1_closure+4;
         const 13274036699047731538;
         const 394780277405469411;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.351986355 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshow_closure" {
     GHC.Event.Manager.$fShowState_$cshow_closure:
         const GHC.Event.Manager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(caB7e,
                       label: GHC.Event.Manager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB7e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caB7f; else goto caB7g;
       caB7f: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caB7g: // global
           I64[Sp - 8] = block_caB74_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB7z; else goto caB75;
       uaB7z: // global
           call _caB74(R1) args: 0, res: 0, upd: 0;
       caB75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB74() //  [R1]
         { info_tbl: [(caB74,
                       label: block_caB74_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB74: // global
           _caB7d::P64 = R1 & 7;
           if (_caB7d::P64 < 4) goto uaB7w; else goto uaB7y;
       uaB7w: // global
           if (_caB7d::P64 < 3) goto uaB7x; else goto caB7a;
       uaB7x: // global
           if (_caB7d::P64 < 2) goto caB78; else goto caB79;
       caB78: // global
           R1 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caB79: // global
           R1 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caB7a: // global
           R1 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uaB7y: // global
           if (_caB7d::P64 < 5) goto caB7b; else goto caB7c;
       caB7b: // global
           R1 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caB7c: // global
           R1 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.353520224 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowList_closure" {
     GHC.Event.Manager.$fShowState_$cshowList_closure:
         const GHC.Event.Manager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caB7E,
                       label: GHC.Event.Manager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB7E: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.354239558 UTC

[section ""data" . GHC.Event.Manager.$fShowState_closure" {
     GHC.Event.Manager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowState_$cshow_closure+1;
         const GHC.Event.Manager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.355269213 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c==_closure" {
     GHC.Event.Manager.$fEqFdKey_$c==_closure:
         const GHC.Event.Manager.$fEqFdKey_$c==_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c==_entry() //  [R2, R3]
         { info_tbl: [(caB7O,
                       label: GHC.Event.Manager.$fEqFdKey_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB7O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caB7S; else goto caB7T;
       caB7S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caB7T: // global
           I64[Sp - 16] = block_caB7L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaB89; else goto caB7M;
       uaB89: // global
           call _caB7L(R1) args: 0, res: 0, upd: 0;
       caB7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB7L() //  [R1]
         { info_tbl: [(caB7L,
                       label: block_caB7L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB7L: // global
           I64[Sp - 8] = block_caB7R_info;
           _saAxU::I64 = I64[R1 + 7];
           _saAxV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAxV::I64;
           I64[Sp + 8] = _saAxU::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB88; else goto caB7V;
       uaB88: // global
           call _caB7R(R1) args: 0, res: 0, upd: 0;
       caB7V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB7R() //  [R1]
         { info_tbl: [(caB7R,
                       label: block_caB7R_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB7R: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto caB84; else goto caB83;
       caB84: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caB83: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.356991048 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c/=_closure" {
     GHC.Event.Manager.$fEqFdKey_$c/=_closure:
         const GHC.Event.Manager.$fEqFdKey_$c/=_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caB8h,
                       label: GHC.Event.Manager.$fEqFdKey_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB8h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caB8l; else goto caB8m;
       caB8l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caB8m: // global
           I64[Sp - 16] = block_caB8e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaB8G; else goto caB8f;
       uaB8G: // global
           call _caB8e(R1) args: 0, res: 0, upd: 0;
       caB8f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB8e() //  [R1]
         { info_tbl: [(caB8e,
                       label: block_caB8e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB8e: // global
           I64[Sp - 8] = block_caB8k_info;
           _saAy4::I64 = I64[R1 + 7];
           _saAy5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAy5::I64;
           I64[Sp + 8] = _saAy4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaB8F; else goto caB8o;
       uaB8F: // global
           call _caB8k(R1) args: 0, res: 0, upd: 0;
       caB8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB8k() //  [R1]
         { info_tbl: [(caB8k,
                       label: block_caB8k_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB8k: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto caB8C; else goto caB8E;
       caB8E: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto caB8C; else goto caB8D;
       caB8C: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caB8D: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.358322625 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_closure" {
     GHC.Event.Manager.$fEqFdKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqFdKey_$c==_closure+2;
         const GHC.Event.Manager.$fEqFdKey_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.359760604 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c/=_closure" {
     GHC.Event.Manager.$fEqState_$c/=_closure:
         const GHC.Event.Manager.$fEqState_$c/=_info;
 },
 GHC.Event.Manager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caB8V,
                       label: GHC.Event.Manager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB8V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caB8W; else goto caB8X;
       caB8W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caB8X: // global
           I64[Sp - 16] = block_caB8L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBay; else goto caB8M;
       uaBay: // global
           call _caB8L(R1) args: 0, res: 0, upd: 0;
       caB8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB8L() //  [R1]
         { info_tbl: [(caB8L,
                       label: block_caB8L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB8L: // global
           _saAyc::P64 = P64[Sp + 8];
           _caB8U::P64 = R1 & 7;
           if (_caB8U::P64 < 4) goto uaBag; else goto uaBai;
       uaBag: // global
           if (_caB8U::P64 < 3) goto uaBah; else goto caB8R;
       uaBah: // global
           if (_caB8U::P64 < 2) goto caB8P; else goto caB8Q;
       caB8P: // global
           I64[Sp + 8] = block_caB90_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBat; else goto caB92;
       uaBat: // global
           call _caB90(R1) args: 0, res: 0, upd: 0;
       caB92: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caB8Q: // global
           I64[Sp + 8] = block_caB9f_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBau; else goto caB9h;
       uaBau: // global
           call _caB9f(R1) args: 0, res: 0, upd: 0;
       caB9h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caB8R: // global
           I64[Sp + 8] = block_caB9u_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBav; else goto caB9w;
       uaBav: // global
           call _caB9u(R1) args: 0, res: 0, upd: 0;
       caB9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaBai: // global
           if (_caB8U::P64 < 5) goto caB8S; else goto caB8T;
       caB8S: // global
           I64[Sp + 8] = block_caB9J_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBaw; else goto caB9L;
       uaBaw: // global
           call _caB9J(R1) args: 0, res: 0, upd: 0;
       caB9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caB8T: // global
           I64[Sp + 8] = block_caB9Y_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBax; else goto caBa0;
       uaBax: // global
           call _caB9Y(R1) args: 0, res: 0, upd: 0;
       caBa0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caB90() //  [R1]
         { info_tbl: [(caB90,
                       label: block_caB90_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB90: // global
           if (R1 & 7 == 1) goto uaBaj; else goto uaBak;
       uaBaj: // global
           Sp = Sp + 8;
           call _caBaa() args: 0, res: 0, upd: 0;
       uaBak: // global
           Sp = Sp + 8;
           call _caBa6() args: 0, res: 0, upd: 0;
     }
 },
 _caB9f() //  [R1]
         { info_tbl: [(caB9f,
                       label: block_caB9f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB9f: // global
           if (R1 & 7 == 2) goto uaBal; else goto uaBam;
       uaBal: // global
           Sp = Sp + 8;
           call _caBaa() args: 0, res: 0, upd: 0;
       uaBam: // global
           Sp = Sp + 8;
           call _caBa6() args: 0, res: 0, upd: 0;
     }
 },
 _caB9u() //  [R1]
         { info_tbl: [(caB9u,
                       label: block_caB9u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB9u: // global
           if (R1 & 7 == 3) goto uaBan; else goto uaBao;
       uaBan: // global
           Sp = Sp + 8;
           call _caBaa() args: 0, res: 0, upd: 0;
       uaBao: // global
           Sp = Sp + 8;
           call _caBa6() args: 0, res: 0, upd: 0;
     }
 },
 _caB9J() //  [R1]
         { info_tbl: [(caB9J,
                       label: block_caB9J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB9J: // global
           if (R1 & 7 == 4) goto uaBap; else goto uaBaq;
       uaBap: // global
           Sp = Sp + 8;
           call _caBaa() args: 0, res: 0, upd: 0;
       uaBaq: // global
           Sp = Sp + 8;
           call _caBa6() args: 0, res: 0, upd: 0;
     }
 },
 _caB9Y() //  [R1]
         { info_tbl: [(caB9Y,
                       label: block_caB9Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caB9Y: // global
           if (R1 & 7 == 5) goto uaBar; else goto uaBas;
       uaBar: // global
           Sp = Sp + 8;
           call _caBaa() args: 0, res: 0, upd: 0;
       uaBas: // global
           Sp = Sp + 8;
           call _caBa6() args: 0, res: 0, upd: 0;
     }
 },
 _caBaa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBaa: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBa6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBa6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.362901704 UTC

[section ""data" . GHC.Event.Manager.$fEqState_closure" {
     GHC.Event.Manager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqState_$c==_closure+2;
         const GHC.Event.Manager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.363495389 UTC

[section ""cstring" . lvl1_raAu6_bytes" {
     lvl1_raAu6_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.364282548 UTC

[section ""data" . lvl2_raAu7_closure" {
     lvl2_raAu7_closure:
         const lvl2_raAu7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_raAu7_entry() //  [R1]
         { info_tbl: [(caBaP,
                       label: lvl2_raAu7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBaP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBaQ; else goto caBaR;
       caBaQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBaR: // global
           (_caBaM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caBaM::I64 == 0) goto caBaO; else goto caBaN;
       caBaO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caBaN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caBaM::I64;
           R2 = lvl1_raAu6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.365392002 UTC

[section ""data" . lvl3_raAu8_closure" {
     lvl3_raAu8_closure:
         const lvl3_raAu8_info;
         const 0;
 },
 lvl3_raAu8_entry() //  [R2, R3, R4]
         { info_tbl: [(caBaX,
                       label: lvl3_raAu8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBaX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBb1; else goto caBb0;
       caBb1: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl3_raAu8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBb0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl2_raAu7_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.367054638 UTC

[section ""data" . GHC.Event.Manager.callbackTableVar_closure" {
     GHC.Event.Manager.callbackTableVar_closure:
         const GHC.Event.Manager.callbackTableVar_info;
         const 0;
 },
 GHC.Event.Manager.callbackTableVar_entry() //  [R2, R3]
         { info_tbl: [(caBb9,
                       label: GHC.Event.Manager.callbackTableVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBb9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caBbn; else goto caBbo;
       caBbn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.callbackTableVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBbo: // global
           I64[Sp - 16] = block_caBb6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBbQ; else goto caBb7;
       uaBbQ: // global
           call _caBb6(R1) args: 0, res: 0, upd: 0;
       caBb7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBb6() //  [R1]
         { info_tbl: [(caBb6,
                       label: block_caBb6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBb6: // global
           I64[Sp - 16] = block_caBbc_info;
           _saAys::P64 = P64[R1 + 23];
           _saAyu::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saAyu::P64;
           P64[Sp] = _saAys::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBbP; else goto caBbd;
       uaBbP: // global
           call _caBbc(R1) args: 0, res: 0, upd: 0;
       caBbd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBbc() //  [R1]
         { info_tbl: [(caBbc,
                       label: block_caBbc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBbc: // global
           I64[Sp - 8] = block_caBbh_info;
           _saAyD::P64 = R1;
           _saAyE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saAyE::I64;
           P64[Sp + 16] = _saAyD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBbR; else goto caBbi;
       uaBbR: // global
           call _caBbh(R1) args: 0, res: 0, upd: 0;
       caBbi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBbh() //  [R1]
         { info_tbl: [(caBbh,
                       label: block_caBbh_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBbh: // global
           I64[Sp - 8] = block_caBbm_info;
           _saAyF::P64 = R1;
           _saAyG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saAyG::I64;
           P64[Sp + 32] = _saAyF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBbS; else goto caBbs;
       uaBbS: // global
           call _caBbm(R1) args: 0, res: 0, upd: 0;
       caBbs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBbm() //  [R1]
         { info_tbl: [(caBbm,
                       label: block_caBbm_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBbm: // global
           _saAyD::P64 = P64[Sp + 32];
           _saAyE::I64 = I64[Sp + 16];
           _saAyF::P64 = P64[Sp + 40];
           _saAyJ::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saAyE::I64,
                            _saAyJ::I64)) goto caBbJ; else goto caBbL;
       caBbL: // global
           if (%MO_S_Gt_W64(_saAyJ::I64,
                            I64[Sp + 8])) goto caBbJ; else goto caBbK;
       caBbJ: // global
           R4 = _saAyJ::I64;
           R3 = _saAyD::P64;
           R2 = _saAyF::P64;
           Sp = Sp + 48;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caBbK: // global
           R1 = P64[P64[Sp + 24] + ((_saAyJ::I64 - _saAyE::I64 << 3) + 24)] & (-8);
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.369076368 UTC

[section ""data" . GHC.Event.Manager.wakeManager1_closure" {
     GHC.Event.Manager.wakeManager1_closure:
         const GHC.Event.Manager.wakeManager1_info;
 },
 GHC.Event.Manager.wakeManager1_entry() //  []
         { info_tbl: [(caBbX,
                       label: GHC.Event.Manager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBbX: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.36990842 UTC

[section ""data" . GHC.Event.Manager.wakeManager_closure" {
     GHC.Event.Manager.wakeManager_closure:
         const GHC.Event.Manager.wakeManager_info;
 },
 GHC.Event.Manager.wakeManager_entry() //  [R2]
         { info_tbl: [(caBc4,
                       label: GHC.Event.Manager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBc4: // global
           R2 = R2;
           call GHC.Event.Manager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.371378796 UTC

[section ""data" . GHC.Event.Manager.cleanup1_closure" {
     GHC.Event.Manager.cleanup1_closure:
         const GHC.Event.Manager.cleanup1_info;
 },
 GHC.Event.Manager.cleanup1_entry() //  [R2]
         { info_tbl: [(caBce,
                       label: GHC.Event.Manager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBce: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caBci; else goto caBcj;
       caBci: // global
           R2 = R2;
           R1 = GHC.Event.Manager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBcj: // global
           I64[Sp - 8] = block_caBcb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBdc; else goto caBcc;
       uaBdc: // global
           call _caBcb(R1) args: 0, res: 0, upd: 0;
       caBcc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBcb() //  [R1]
         { info_tbl: [(caBcb,
                       label: block_caBcb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBcb: // global
           I64[Sp - 56] = block_caBch_info;
           _saAz1::P64 = P64[R1 + 39];
           _saAz6::P64 = P64[R1 + 55];
           _saAz7::P64 = P64[R1 + 63];
           _saAz8::P64 = P64[R1 + 71];
           _saAz3::I64 = I64[R1 + 87];
           _saAz4::I64 = I64[R1 + 95];
           _saAz5::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           I64[Sp - 48] = _saAz3::I64;
           I64[Sp - 40] = _saAz4::I64;
           I64[Sp - 32] = _saAz5::I64;
           P64[Sp - 24] = _saAz6::P64;
           P64[Sp - 16] = _saAz7::P64;
           P64[Sp - 8] = _saAz8::P64;
           P64[Sp] = _saAz1::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaBdb; else goto caBcl;
       uaBdb: // global
           call _caBch(R1) args: 0, res: 0, upd: 0;
       caBcl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBch() //  [R1]
         { info_tbl: [(caBch,
                       label: block_caBch_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBch: // global
           _saAz1::P64 = P64[Sp + 56];
           _saAz8::P64 = P64[Sp + 48];
           _saAza::P64 = P64[R1 + 7];
           _saAze::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saAz1::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saAz1::P64);
           I64[Sp] = block_caBcs_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saAz8::P64;
           P64[Sp + 48] = _saAze::P64;
           P64[Sp + 56] = _saAza::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBcs() //  []
         { info_tbl: [(caBcs,
                       label: block_caBcs_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBcs: // global
           I64[Sp] = block_caBcu_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBcu() //  []
         { info_tbl: [(caBcu,
                       label: block_caBcu_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBcu: // global
           I64[Sp] = block_caBcw_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBcw() //  []
         { info_tbl: [(caBcw,
                       label: block_caBcw_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBcw: // global
           _saAz4::I64 = I64[Sp + 16];
           _saAz6::P64 = P64[Sp + 32];
           (_saAzt::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saAzy::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz4::I64)));
           I64[Sp + 16] = block_caBcM_info;
           R1 = _saAz6::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBdd; else goto caBcN;
       uaBdd: // global
           call _caBcM(R1) args: 0, res: 0, upd: 0;
       caBcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBcM() //  [R1]
         { info_tbl: [(caBcM,
                       label: block_caBcM_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBcM: // global
           _saAz5::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caBcT; else goto caBcX;
       caBcT: // global
           (_saAzE::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz5::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBcX: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saAzM::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz5::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.37404292 UTC

[section ""data" . GHC.Event.Manager.cleanup_closure" {
     GHC.Event.Manager.cleanup_closure:
         const GHC.Event.Manager.cleanup_info;
 },
 GHC.Event.Manager.cleanup_entry() //  [R2]
         { info_tbl: [(caBdi,
                       label: GHC.Event.Manager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBdi: // global
           R2 = R2;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.375240246 UTC

[section ""data" . GHC.Event.Manager.finished1_closure" {
     GHC.Event.Manager.finished1_closure:
         const GHC.Event.Manager.finished1_info;
 },
 sat_saAA7_entry() //  [R1]
         { info_tbl: [(caBdF,
                       label: sat_saAA7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBdF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBdG; else goto caBdH;
       caBdG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBdH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caBdy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBdO; else goto caBdz;
       uaBdO: // global
           call _caBdy(R1) args: 0, res: 0, upd: 0;
       caBdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caBdy() //  [R1]
         { info_tbl: [(caBdy,
                       label: block_caBdy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBdy: // global
           if (R1 & 7 == 5) goto caBdD; else goto caBdC;
       caBdD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caBdC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.finished1_entry() //  [R2]
         { info_tbl: [(caBdP,
                       label: GHC.Event.Manager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBdP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caBdQ; else goto caBdR;
       caBdQ: // global
           R2 = R2;
           R1 = GHC.Event.Manager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBdR: // global
           I64[Sp - 8] = block_caBdp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBdV; else goto caBdq;
       uaBdV: // global
           call _caBdp(R1) args: 0, res: 0, upd: 0;
       caBdq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBdp() //  [R1]
         { info_tbl: [(caBdp,
                       label: block_caBdp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBdp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBdU; else goto caBdT;
       caBdU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBdT: // global
           _saAA5::P64 = P64[P64[R1 + 39] + 8];
           I64[Hp - 16] = sat_saAA7_info;
           P64[Hp] = _saAA5::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.37688232 UTC

[section ""data" . GHC.Event.Manager.finished_closure" {
     GHC.Event.Manager.finished_closure:
         const GHC.Event.Manager.finished_info;
 },
 GHC.Event.Manager.finished_entry() //  [R2]
         { info_tbl: [(caBe0,
                       label: GHC.Event.Manager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBe0: // global
           R2 = R2;
           call GHC.Event.Manager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.377772032 UTC

[section ""data" . GHC.Event.Manager.release2_closure" {
     GHC.Event.Manager.release2_closure:
         const GHC.Event.Manager.release2_info;
 },
 GHC.Event.Manager.release2_entry() //  [R2]
         { info_tbl: [(caBe8,
                       label: GHC.Event.Manager.release2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBe8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBec; else goto caBeb;
       caBec: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.release2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBeb: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Releasing_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.378958692 UTC

[section ""data" . GHC.Event.Manager.release1_closure" {
     GHC.Event.Manager.release1_closure:
         const GHC.Event.Manager.release1_info;
         const 0;
 },
 GHC.Event.Manager.release1_entry() //  [R2]
         { info_tbl: [(caBek,
                       label: GHC.Event.Manager.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBek: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBel; else goto caBem;
       caBel: // global
           R2 = R2;
           R1 = GHC.Event.Manager.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBem: // global
           I64[Sp - 8] = block_caBeh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBeG; else goto caBei;
       uaBeG: // global
           call _caBeh(R1) args: 0, res: 0, upd: 0;
       caBei: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBeh() //  [R1]
         { info_tbl: [(caBeh,
                       label: block_caBeh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBeh: // global
           I64[Sp - 16] = block_caBep_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saAAn::P64 = P64[R1 + 63];
           _saAAl::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saAAn::P64;
           I64[Sp] = _saAAl::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBep() //  [R1]
         { info_tbl: [(caBep,
                       label: block_caBep_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBep: // global
           I64[Sp] = block_caBer_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBeH; else goto caBeu;
       uaBeH: // global
           call _caBer(R1) args: 0, res: 0, upd: 0;
       caBeu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBer() //  [R1]
         { info_tbl: [(caBer,
                       label: block_caBer_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBer: // global
           if (R1 & 7 == 2) goto caBeE; else goto caBeA;
       caBeE: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       caBeA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.38052513 UTC

[section ""data" . GHC.Event.Manager.release_closure" {
     GHC.Event.Manager.release_closure:
         const GHC.Event.Manager.release_info;
         const 0;
 },
 GHC.Event.Manager.release_entry() //  [R2]
         { info_tbl: [(caBeM,
                       label: GHC.Event.Manager.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBeM: // global
           R2 = R2;
           call GHC.Event.Manager.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.381444783 UTC

[section ""data" . GHC.Event.Manager.shutdown2_closure" {
     GHC.Event.Manager.shutdown2_closure:
         const GHC.Event.Manager.shutdown2_info;
 },
 GHC.Event.Manager.shutdown2_entry() //  [R2]
         { info_tbl: [(caBeU,
                       label: GHC.Event.Manager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBeU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBeY; else goto caBeX;
       caBeY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBeX: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.382694825 UTC

[section ""data" . GHC.Event.Manager.shutdown1_closure" {
     GHC.Event.Manager.shutdown1_closure:
         const GHC.Event.Manager.shutdown1_info;
         const 0;
 },
 GHC.Event.Manager.shutdown1_entry() //  [R2]
         { info_tbl: [(caBf6,
                       label: GHC.Event.Manager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBf6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBf7; else goto caBf8;
       caBf7: // global
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBf8: // global
           I64[Sp - 8] = block_caBf3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBfs; else goto caBf4;
       uaBfs: // global
           call _caBf3(R1) args: 0, res: 0, upd: 0;
       caBf4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBf3() //  [R1]
         { info_tbl: [(caBf3,
                       label: block_caBf3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBf3: // global
           I64[Sp - 16] = block_caBfb_info;
           R2 = GHC.Event.Manager.shutdown2_closure+1;
           _saAAI::P64 = P64[R1 + 63];
           _saAAF::I64 = I64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saAAI::P64;
           I64[Sp] = _saAAF::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBfb() //  [R1]
         { info_tbl: [(caBfb,
                       label: block_caBfb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfb: // global
           I64[Sp] = block_caBfd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBft; else goto caBfg;
       uaBft: // global
           call _caBfd(R1) args: 0, res: 0, upd: 0;
       caBfg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBfd() //  [R1]
         { info_tbl: [(caBfd,
                       label: block_caBfd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfd: // global
           if (R1 & 7 == 2) goto caBfq; else goto caBfm;
       caBfq: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       caBfm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.384234416 UTC

[section ""data" . GHC.Event.Manager.shutdown_closure" {
     GHC.Event.Manager.shutdown_closure:
         const GHC.Event.Manager.shutdown_info;
         const 0;
 },
 GHC.Event.Manager.shutdown_entry() //  [R2]
         { info_tbl: [(caBfy,
                       label: GHC.Event.Manager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfy: // global
           R2 = R2;
           call GHC.Event.Manager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.384938062 UTC

[section ""cstring" . lvl4_raAu9_bytes" {
     lvl4_raAu9_bytes:
         I8[] [70,97,105,108,101,100,32,119,104,105,108,101,32,97,116,116,101,109,112,116,105,110,103,32,116,111,32,109,111,100,105,102,121,32,114,101,103,105,115,116,114,97,116,105,111,110,32,111,102,32,102,105,108,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.385766337 UTC

[section ""cstring" . lvl5_raAua_bytes" {
     lvl5_raAua_bytes:
         I8[] [32,97,116,32,108,111,99,97,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.386977694 UTC

[section ""data" . $wlvl_raAub_closure" {
     $wlvl_raAub_closure:
         const $wlvl_raAub_info;
         const 0;
 },
 sat_saAAU_entry() //  [R1]
         { info_tbl: [(caBfP,
                       label: sat_saAAU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfP: // global
           R3 = P64[R1 + 16];
           R2 = lvl5_raAua_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAAV_entry() //  [R1]
         { info_tbl: [(caBfT,
                       label: sat_saAAV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caBfU; else goto caBfV;
       caBfU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBfV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caBfJ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caBfJ() //  [R1, R2]
         { info_tbl: [(caBfJ,
                       label: block_caBfJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caBfY; else goto caBfX;
       caBfY: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caBfX: // global
           I64[Hp - 40] = sat_saAAU_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_raAub_entry() //  [R2, R3]
         { info_tbl: [(caBg1,
                       label: $wlvl_raAub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBg1: // global
           _saAAP::I64 = R3;
           _saAAO::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caBg2; else goto caBg3;
       caBg3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBg5; else goto caBg4;
       caBg5: // global
           HpAlloc = 32;
           goto caBg2;
       caBg2: // global
           R3 = _saAAP::I64;
           R2 = _saAAO::P64;
           R1 = $wlvl_raAub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBg4: // global
           I64[Hp - 24] = sat_saAAV_info;
           P64[Hp - 8] = _saAAO::P64;
           I64[Hp] = _saAAP::I64;
           I64[Sp - 8] = block_caBfZ_info;
           R3 = Hp - 24;
           R2 = lvl4_raAu9_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBfZ() //  [R1]
         { info_tbl: [(caBfZ,
                       label: block_caBfZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBfZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.3887135 UTC

[section ""cstring" . lvl6_raAuc_bytes" {
     lvl6_raAuc_bytes:
         I8[] [114,101,103,105,115,116,101,114,67,111,110,116,114,111,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.389466227 UTC

[section ""data" . lvl7_raAud_closure" {
     lvl7_raAud_closure:
         const lvl7_raAud_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_raAud_entry() //  [R1]
         { info_tbl: [(caBgf,
                       label: lvl7_raAud_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBgg; else goto caBgh;
       caBgg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBgh: // global
           (_caBgc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caBgc::I64 == 0) goto caBge; else goto caBgd;
       caBge: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caBgd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caBgc::I64;
           R2 = lvl6_raAuc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.390528921 UTC

[section ""data" . GHC.Event.Manager.new5_closure" {
     GHC.Event.Manager.new5_closure:
         const GHC.Event.Manager.new5_info;
 },
 GHC.Event.Manager.new5_entry() //  [R2]
         { info_tbl: [(caBgn,
                       label: GHC.Event.Manager.new5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBgr; else goto caBgq;
       caBgr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.new5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBgq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Finished_closure+5;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.391400906 UTC

[section ""data" . GHC.Event.Manager.new4_closure" {
     GHC.Event.Manager.new4_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.394045144 UTC

[section ""data" . x_raAue_closure" {
     x_raAue_closure:
         const x_raAue_info;
 },
 x_raAue_entry() //  []
         { info_tbl: [(caBgH,
                       label: x_raAue_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBgU; else goto caBgV;
       caBgV: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caBgX; else goto caBgW;
       caBgX: // global
           HpAlloc = 96;
           goto caBgU;
       caBgU: // global
           R1 = x_raAue_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caBgW: // global
           I64[Hp - 88] = stg_MUT_ARR_PTRS_DIRTY_info;
           I64[Hp - 80] = 8;
           I64[Hp - 72] = 9;
           _caBgw::I64 = Hp - 88;
           _caBgx::I64 = _caBgw::I64 + 24;
           goto caBgy;
       caBgy: // global
           if (_caBgx::I64 < (_caBgw::I64 + 88)) goto caBgA; else goto caBgz;
       caBgA: // global
           P64[_caBgx::I64] = GHC.Event.IntTable.Empty_closure+1;
           _caBgx::I64 = _caBgx::I64 + 8;
           goto caBgy;
       caBgz: // global
           I64[Sp - 16] = block_caBgB_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _caBgw::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBgB() //  [R1]
         { info_tbl: [(caBgB,
                       label: block_caBgB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgB: // global
           I64[Sp - 8] = block_caBgD_info;
           R2 = 8;
           _saAB4::P64 = R1;
           R1 = 8;
           P64[Sp] = _saAB4::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBgD() //  [R1]
         { info_tbl: [(caBgD,
                       label: block_caBgD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caBh1; else goto caBh0;
       caBh1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBh0: // global
           _saAB1::P64 = P64[Sp + 16];
           _saAB4::P64 = P64[Sp + 8];
           _saAB8::I64 = R1 + 16;
           I64[_saAB8::I64] = 0;
           I64[Hp - 48] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 40] = R1;
           P64[Hp - 32] = _saAB4::P64;
           _caBgJ::P64 = Hp - 46;
           call MO_Touch(_caBgJ::P64);
           I64[Hp - 24] = GHC.Event.IntTable.IT_con_info;
           P64[Hp - 16] = _saAB1::P64;
           P64[Hp - 8] = _caBgJ::P64;
           I64[Hp] = _saAB8::I64;
           I64[Sp + 16] = block_caBgM_info;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBgM() //  [R1]
         { info_tbl: [(caBgM,
                       label: block_caBgM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgM: // global
           I64[Sp - 8] = block_caBgO_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caBgO() //  [R1]
         { info_tbl: [(caBgO,
                       label: block_caBgO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBh5; else goto caBh4;
       caBh5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBh4: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_caBgR_info;
           R2 = Hp - 7;
           _saABi::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _saABi::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBgR() //  []
         { info_tbl: [(caBgR,
                       label: block_caBgR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBgR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBh8; else goto caBh7;
       caBh8: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caBh7: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.396560647 UTC

[section ""data" . GHC.Event.Manager.$wxs_closure" {
     GHC.Event.Manager.$wxs_closure:
         const GHC.Event.Manager.$wxs_info;
 },
 GHC.Event.Manager.$wxs_entry() //  [R2]
         { info_tbl: [(caBhh,
                       label: GHC.Event.Manager.$wxs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBhi; else goto caBhj;
       caBhi: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$wxs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBhj: // global
           if (R2 == 1) goto caBhg; else goto caBhf;
       caBhg: // global
           I64[Sp - 8] = block_caBhy_info;
           Sp = Sp - 8;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
       caBhf: // global
           I64[Sp - 16] = block_caBhl_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caBhy() //  [R1]
         { info_tbl: [(caBhy,
                       label: block_caBhy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBhD; else goto caBhC;
       caBhD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBhC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBhl() //  [R1]
         { info_tbl: [(caBhl,
                       label: block_caBhl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhl: // global
           I64[Sp] = block_caBhq_info;
           R2 = I64[Sp + 8] - 1;
           P64[Sp + 8] = R1;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBhq() //  [R1]
         { info_tbl: [(caBhq,
                       label: block_caBhq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBhw; else goto caBhv;
       caBhw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBhv: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.398395818 UTC

[section ""data" . GHC.Event.Manager.new3_closure" {
     GHC.Event.Manager.new3_closure:
         const GHC.Event.Manager.new3_info;
         const 0;
 },
 GHC.Event.Manager.new3_entry() //  [R2]
         { info_tbl: [(caBhI,
                       label: GHC.Event.Manager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhI: // global
           R3 = R2;
           R2 = lvl7_raAud_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.401656957 UTC

[section ""data" . GHC.Event.Manager.new2_closure" {
     GHC.Event.Manager.new2_closure:
         const GHC.Event.Manager.new2_info;
         const 0;
 },
 sat_saAC5_entry() //  [R1]
         { info_tbl: [(caBi9,
                       label: sat_saAC5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBi9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBia; else goto caBib;
       caBia: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caBib: // global
           I64[Sp - 24] = block_caBi0_info;
           R2 = GHC.Event.Manager.new5_closure+1;
           _saABC::P64 = P64[R1 + 7];
           _saABJ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _saABC::P64;
           P64[Sp - 8] = _saABJ::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBi0() //  [R1]
         { info_tbl: [(caBi0,
                       label: block_caBi0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBi0: // global
           I64[Sp] = block_caBi2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBis; else goto caBi3;
       uaBis: // global
           call _caBi2(R1) args: 0, res: 0, upd: 0;
       caBi3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBi2() //  [R1]
         { info_tbl: [(caBi2,
                       label: block_caBi2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBi2: // global
           if (R1 & 7 == 5) goto caBi7; else goto caBi6;
       caBi7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBi6: // global
           _saABC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBif_info;
           R1 = _saABC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBit; else goto caBig;
       uaBit: // global
           call _caBif(R1) args: 0, res: 0, upd: 0;
       caBig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBif() //  [R1]
         { info_tbl: [(caBif,
                       label: block_caBif_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBif: // global
           I64[Sp] = block_caBik_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBik() //  []
         { info_tbl: [(caBik,
                       label: block_caBik_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBik: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.new2_entry() //  [R2]
         { info_tbl: [(caBiE,
                       label: GHC.Event.Manager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiE: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caBiW; else goto caBiX;
       caBiW: // global
           R2 = R2;
           R1 = GHC.Event.Manager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBiX: // global
           I64[Sp - 16] = block_caBhP_info;
           _saABC::P64 = R2;
           R2 = 32;
           P64[Sp - 8] = _saABC::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBhP() //  [R1]
         { info_tbl: [(caBhP,
                       label: block_caBhP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhP: // global
           I64[Sp - 8] = block_caBhR_info;
           R2 = GHC.Types.False_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBhR() //  [R1]
         { info_tbl: [(caBhR,
                       label: block_caBhR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhR: // global
           I64[Sp - 8] = block_caBhT_info;
           _saABJ::P64 = R1;
           R1 = GHC.Event.Manager.Created_closure+1;
           P64[Sp] = _saABJ::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBhT() //  [R1]
         { info_tbl: [(caBhT,
                       label: block_caBhT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBhT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caBj2; else goto caBj1;
       caBj2: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBj1: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_saAC5_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_caBiv_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _saABM::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _saABM::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBiv() //  []
         { info_tbl: [(caBiv,
                       label: block_caBiv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiv: // global
           I64[Sp] = block_caBix_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caBix() //  [R1]
         { info_tbl: [(caBix,
                       label: block_caBix_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBix: // global
           I64[Sp - 8] = block_caBiz_info;
           R2 = GHC.Tuple.()_closure+1;
           _saACb::P64 = R1;
           R1 = R1;
           P64[Sp] = _saACb::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBiz() //  []
         { info_tbl: [(caBiz,
                       label: block_caBiz_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiz: // global
           I64[Sp] = block_caBiB_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uaBks; else goto caBiC;
       uaBks: // global
           call _caBiB(R1) args: 0, res: 0, upd: 0;
       caBiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBiB() //  [R1]
         { info_tbl: [(caBiB,
                       label: block_caBiB_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiB: // global
           I64[Sp - 16] = block_caBiH_info;
           R2 = GHC.Arr.arrEleBottom_closure;
           _saACd::P64 = R1;
           _saACe::P64 = P64[R1 + 7];
           _saACg::P64 = P64[R1 + 23];
           R1 = 32;
           P64[Sp - 8] = _saACg::P64;
           P64[Sp] = _saACe::P64;
           P64[Sp + 48] = _saACd::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBiH() //  [R1]
         { info_tbl: [(caBiH,
                       label: block_caBiH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiH: // global
           I64[Sp - 8] = 0;
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 56] = R1;
           Sp = Sp - 8;
           call _caBje() args: 0, res: 0, upd: 0;
     }
 },
 _caBje() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBje: // global
           I64[Sp - 8] = block_caBjh_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBkw; else goto caBjj;
       uaBkw: // global
           call _caBjh(R1) args: 0, res: 0, upd: 0;
       caBjj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBjh() //  [R1]
         { info_tbl: [(caBjh,
                       label: block_caBjh_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBjh: // global
           if (R1 & 7 == 1) goto uaBkp; else goto caBjx;
       uaBkp: // global
           Sp = Sp + 16;
           goto uaBky;
       caBjx: // global
           _saACl::P64 = P64[Sp + 72];
           _saACu::I64 = I64[Sp + 8];
           _saACx::P64 = P64[R1 + 6];
           _saACy::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[(_saACl::P64 + 24) + (_saACu::I64 << 3)] = _saACx::P64;
           I64[_saACl::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saACl::P64 + 24) + ((I64[_saACl::P64 + 8] << 3) + (_saACu::I64 >> 7))] = 1 :: W8;
           if (_saACu::I64 == 31) goto uaBkq; else goto caBjv;
       uaBkq: // global
           Sp = Sp + 16;
           goto uaBky;
       uaBky: // global
           call _caBj9() args: 0, res: 0, upd: 0;
       caBjv: // global
           P64[Sp + 16] = _saACy::P64;
           I64[Sp + 8] = _saACu::I64 + 1;
           Sp = Sp + 8;
           call _caBje() args: 0, res: 0, upd: 0;
     }
 },
 _caBj9() //  []
         { info_tbl: [(caBj9,
                       label: block_caBj9_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBj9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caBjd; else goto caBjc;
       caBjd: // global
           HpAlloc = 40;
           I64[Sp] = block_caBj9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caBjc: // global
           _saACl::P64 = P64[Sp + 56];
           I64[_saACl::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = GHC.Event.Manager.$fShowFdKey6_closure+1;
           P64[Hp - 16] = GHC.Event.Manager.new4_closure+1;
           P64[Hp - 8] = _saACl::P64;
           I64[Hp] = 32;
           I64[Sp] = block_caBiQ_info;
           R1 = Hp - 31;
           if (R1 & 7 != 0) goto uaBkv; else goto caBiR;
       uaBkv: // global
           call _caBiQ(R1) args: 0, res: 0, upd: 0;
       caBiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBiQ() //  [R1]
         { info_tbl: [(caBiQ,
                       label: block_caBiQ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiQ: // global
           I64[Sp - 16] = block_caBiV_info;
           _saACG::P64 = P64[R1 + 7];
           _saACH::P64 = P64[R1 + 15];
           _saACJ::P64 = P64[R1 + 23];
           _saACI::I64 = I64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saACJ::P64;
           I64[Sp] = _saACI::I64;
           P64[Sp + 48] = _saACH::P64;
           P64[Sp + 56] = _saACG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBku; else goto caBjA;
       uaBku: // global
           call _caBiV(R1) args: 0, res: 0, upd: 0;
       caBjA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBiV() //  [R1]
         { info_tbl: [(caBiV,
                       label: block_caBiV_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBiV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBjK; else goto caBjJ;
       caBjK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBjJ: // global
           _saACO::P64 = P64[R1 + 7];
           _saACP::P64 = P64[R1 + 15];
           _saACL::I64 = I64[R1 + 23];
           _saACM::I64 = I64[R1 + 31];
           _saACN::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saACL::I64;
           I64[Sp - 40] = block_caBjF_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           I64[Sp - 48] = stg_ap_v_info;
           I64[Sp - 32] = _saACM::I64;
           I64[Sp - 24] = _saACN::I64;
           P64[Sp - 16] = _saACO::P64;
           P64[Sp - 8] = _saACP::P64;
           I64[Sp] = _saACL::I64;
           Sp = Sp - 48;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caBjF() //  [R1]
         { info_tbl: [(caBjF,
                       label: block_caBjF_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBjF: // global
           I64[Sp] = block_caBjH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBkA; else goto caBjM;
       uaBkA: // global
           call _caBjH(R1) args: 0, res: 0, upd: 0;
       caBjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBjH() //  [R1]
         { info_tbl: [(caBjH,
                       label: block_caBjH_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBjH: // global
           if (R1 & 7 == 1) goto caBjS; else goto caBjZ;
       caBjS: // global
           R2 = I64[Sp + 40];
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caBjZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBk2; else goto caBk1;
       caBk2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBk1: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caBjW_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 72];
           R1 = P64[Sp + 64];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caBjW() //  [R1]
         { info_tbl: [(caBjW,
                       label: block_caBjW_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBjW: // global
           I64[Sp] = block_caBjY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBkB; else goto caBk4;
       uaBkB: // global
           call _caBjY(R1) args: 0, res: 0, upd: 0;
       caBk4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBjY() //  [R1]
         { info_tbl: [(caBjY,
                       label: block_caBjY_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBjY: // global
           _saACN::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto caBka; else goto caBke;
       caBka: // global
           R2 = _saACN::I64;
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caBke: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caBkh; else goto caBkg;
       caBkh: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBkg: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 120];
           P64[Hp - 88] = P64[Sp + 112];
           P64[Hp - 80] = P64[Sp + 104];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 80];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saACN::I64;
           R1 = Hp - 103;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.407980488 UTC

[section ""data" . GHC.Event.Manager.newWith_closure" {
     GHC.Event.Manager.newWith_closure:
         const GHC.Event.Manager.newWith_info;
         const 0;
 },
 GHC.Event.Manager.newWith_entry() //  [R2]
         { info_tbl: [(caBkG,
                       label: GHC.Event.Manager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBkG: // global
           R2 = R2;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.408910097 UTC

[section ""data" . GHC.Event.Manager.new1_closure" {
     GHC.Event.Manager.new1_closure:
         const GHC.Event.Manager.new1_info;
         const 0;
 },
 GHC.Event.Manager.new1_entry() //  []
         { info_tbl: [(caBkP,
                       label: GHC.Event.Manager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBkP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caBkQ; else goto caBkR;
       caBkQ: // global
           R1 = GHC.Event.Manager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caBkR: // global
           I64[Sp - 8] = block_caBkN_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caBkN() //  [R1]
         { info_tbl: [(caBkN,
                       label: block_caBkN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBkN: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.410150631 UTC

[section ""data" . GHC.Event.Manager.new_closure" {
     GHC.Event.Manager.new_closure:
         const GHC.Event.Manager.new_info;
         const 0;
 },
 GHC.Event.Manager.new_entry() //  []
         { info_tbl: [(caBkX,
                       label: GHC.Event.Manager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBkX: // global
           call GHC.Event.Manager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.411257779 UTC

[section ""data" . GHC.Event.Manager.closeFd_3_closure" {
     GHC.Event.Manager.closeFd_3_closure:
         const GHC.Event.Manager.closeFd_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.closeFd_3_entry() //  [R1]
         { info_tbl: [(caBl8,
                       label: GHC.Event.Manager.closeFd_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBl8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBlg; else goto caBlh;
       caBlg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBlh: // global
           (_caBl3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caBl3::I64 == 0) goto caBl5; else goto caBl4;
       caBl5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caBl4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caBl3::I64;
           I64[Sp - 24] = block_caBl6_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp - 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _caBl6() //  [R1]
         { info_tbl: [(caBl6,
                       label: block_caBl6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBl6: // global
           I64[Sp] = block_caBlb_info;
           R2 = R1;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caBlb() //  [R1]
         { info_tbl: [(caBlb,
                       label: block_caBlb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBlb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBll; else goto caBlk;
       caBll: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caBlk: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.413051165 UTC

[section ""data" . GHC.Event.Manager.$weventsOf_closure" {
     GHC.Event.Manager.$weventsOf_closure:
         const GHC.Event.Manager.$weventsOf_info;
         const 0;
 },
 GHC.Event.Manager.$weventsOf_entry() //  [R2]
         { info_tbl: [(caBlx,
                       label: GHC.Event.Manager.$weventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBlx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBly; else goto caBlz;
       caBly: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$weventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBlz: // global
           I64[Sp - 8] = block_caBlq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBmc; else goto caBlr;
       uaBmc: // global
           call _caBlq(R1) args: 0, res: 0, upd: 0;
       caBlr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBlq() //  [R1]
         { info_tbl: [(caBlq,
                       label: block_caBlq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBlq: // global
           if (R1 & 7 == 1) goto caBlu; else goto caBlv;
       caBlu: // global
           I64[Sp] = block_caBlC_info;
           R1 = GHC.Event.Manager.closeFd_3_closure;
           if (R1 & 7 != 0) goto uaBma; else goto caBlE;
       uaBma: // global
           call _caBlC(R1) args: 0, res: 0, upd: 0;
       caBlE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBlv: // global
           I64[Sp - 16] = block_caBlL_info;
           _saADa::P64 = R1;
           _saADd::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 8] = _saADd::P64;
           P64[Sp] = _saADa::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBmb; else goto caBlN;
       uaBmb: // global
           call _caBlL(R1) args: 0, res: 0, upd: 0;
       caBlN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBlC() //  [R1]
         { info_tbl: [(caBlC,
                       label: block_caBlC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBlC: // global
           R1 = I64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBlL() //  [R1]
         { info_tbl: [(caBlL,
                       label: block_caBlL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBlL: // global
           if (R1 & 7 == 1) goto caBlU; else goto caBm4;
       caBlU: // global
           I64[Sp + 16] = block_caBlR_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBmd; else goto caBlV;
       uaBmd: // global
           call _caBlR(R1) args: 0, res: 0, upd: 0;
       caBlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBm4: // global
           _saADa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caBm2_info;
           R3 = _saADa::P64;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBlR() //  [R1]
         { info_tbl: [(caBlR,
                       label: block_caBlR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBlR: // global
           R1 = I64[R1 + 31];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBm2() //  [R1]
         { info_tbl: [(caBm2,
                       label: block_caBm2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBm2: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.415058101 UTC

[section ""data" . GHC.Event.Manager.eventsOf_closure" {
     GHC.Event.Manager.eventsOf_closure:
         const GHC.Event.Manager.eventsOf_info;
         const 0;
 },
 GHC.Event.Manager.eventsOf_entry() //  [R2]
         { info_tbl: [(caBmk,
                       label: GHC.Event.Manager.eventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBmk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caBmo; else goto caBmp;
       caBmo: // global
           R2 = R2;
           R1 = GHC.Event.Manager.eventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBmp: // global
           I64[Sp - 8] = block_caBmi_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBmi() //  [R1]
         { info_tbl: [(caBmi,
                       label: block_caBmi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBmi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBms; else goto caBmr;
       caBms: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caBmr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.416663478 UTC

[section ""data" . GHC.Event.Manager.closeFd_2_closure" {
     GHC.Event.Manager.closeFd_2_closure:
         const GHC.Event.Manager.closeFd_2_info;
 },
 GHC.Event.Manager.closeFd_2_entry() //  [R2]
         { info_tbl: [(caBmE,
                       label: GHC.Event.Manager.closeFd_2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBmE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBmF; else goto uaBn6;
       caBmF: // global
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaBn6: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caBmu() args: 0, res: 0, upd: 0;
     }
 },
 _caBmu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBmu: // global
           _saADq::P64 = P64[Sp];
           I64[Sp] = block_caBmx_info;
           R1 = _saADq::P64;
           if (R1 & 7 != 0) goto uaBn8; else goto caBmy;
       uaBn8: // global
           call _caBmx(R1) args: 0, res: 0, upd: 0;
       caBmy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBmx() //  [R1]
         { info_tbl: [(caBmx,
                       label: block_caBmx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBmx: // global
           if (R1 & 7 == 1) goto caBmB; else goto caBmC;
       caBmB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBmC: // global
           I64[Sp - 8] = block_caBmM_info;
           _saADu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saADu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBn9; else goto caBmO;
       uaBn9: // global
           call _caBmM(R1) args: 0, res: 0, upd: 0;
       caBmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBmM() //  [R1]
         { info_tbl: [(caBmM,
                       label: block_caBmM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBmM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caBmU; else goto caBmT;
       caBmU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBmT: // global
           _saADz::P64 = P64[R1 + 7];
           _saADw::I64 = I64[R1 + 15];
           _saADx::I64 = I64[R1 + 23];
           _saADC::I64 = I64[R1 + 31] & 7 | 4;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _saADC::I64;
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saADw::I64;
           I64[Hp] = _saADx::I64;
           I64[Sp] = block_caBn3_info;
           R3 = Hp - 31;
           R2 = Hp - 15;
           R1 = _saADz::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBn3() //  []
         { info_tbl: [(caBn3,
                       label: block_caBn3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBn3: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caBmu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.42360053 UTC

[section ""data" . GHC.Event.Manager.closeFd1_closure" {
     GHC.Event.Manager.closeFd1_closure:
         const GHC.Event.Manager.closeFd1_info;
         const 0;
 },
 $wgo_saAEy_entry() //  [R1, R2]
         { info_tbl: [(caBoq,
                       label: $wgo_saAEy_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBoq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBor; else goto caBos;
       caBor: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBos: // global
           I64[Sp - 24] = block_caBoj_info;
           _saAEy::P64 = R1;
           _saAE7::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAE7::I64;
           P64[Sp - 8] = _saAEy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBoP; else goto caBok;
       uaBoP: // global
           call _caBoj(R1) args: 0, res: 0, upd: 0;
       caBok: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBoj() //  [R1]
         { info_tbl: [(caBoj,
                       label: block_caBoj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBoj: // global
           if (R1 & 7 == 1) goto caBon; else goto caBoo;
       caBon: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBoo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBoA; else goto caBoz;
       caBoA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBoz: // global
           _saAEC::P64 = P64[R1 + 6];
           _saAED::P64 = P64[R1 + 14];
           _saAEB::I64 = I64[R1 + 22];
           if (_saAEB::I64 == I64[Sp + 8]) goto caBoO; else goto caBoI;
       caBoO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAEC::P64;
           R3 = _saAED::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBoI: // global
           Hp = Hp - 16;
           I64[Sp] = block_caBoE_info;
           R2 = _saAED::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAEC::P64;
           I64[Sp + 16] = _saAEB::I64;
           call $wgo_saAEy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBoE() //  [R1, R2, R3]
         { info_tbl: [(caBoE,
                       label: block_caBoE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBoE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBoL; else goto caBoK;
       caBoL: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBoK: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAEi_entry() //  [R1, R2]
         { info_tbl: [(caBoQ,
                       label: $wio_saAEi_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBoQ: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caBoR; else goto caBoS;
       caBoR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBoS: // global
           I64[Sp - 40] = block_caBo0_info;
           _saADI::P64 = P64[R1 + 6];
           _saADP::P64 = P64[R1 + 14];
           _saAE6::P64 = P64[R1 + 22];
           _saAE7::I64 = I64[R1 + 30];
           R1 = P64[R2 + 8];
           P64[Sp - 32] = _saADI::P64;
           P64[Sp - 24] = _saADP::P64;
           P64[Sp - 16] = _saAE6::P64;
           I64[Sp - 8] = _saAE7::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaBqu; else goto caBo1;
       uaBqu: // global
           call _caBo0(R1) args: 0, res: 0, upd: 0;
       caBo1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBo0() //  [R1]
         { info_tbl: [(caBo0,
                       label: block_caBo0_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBo0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBoV; else goto caBoU;
       caBoV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBoU: // global
           _saAE7::I64 = I64[Sp + 32];
           _saAEp::P64 = P64[R1 + 7];
           _saAEr::P64 = P64[R1 + 15];
           _saAEq::I64 = I64[R1 + 23];
           _saAEs::I64 = _saAE7::I64 & (I64[_saAEp::P64 + 8] - 1);
           _saAEx::P64 = P64[(_saAEp::P64 + 24) + (_saAEs::I64 << 3)];
           I64[Hp - 8] = $wgo_saAEy_info;
           I64[Hp] = _saAE7::I64;
           I64[Sp - 24] = block_caBoW_info;
           R2 = _saAEx::P64;
           R1 = Hp - 7;
           P64[Sp - 16] = _saAEr::P64;
           I64[Sp - 8] = _saAEs::I64;
           I64[Sp] = _saAEq::I64;
           P64[Sp + 32] = _saAEp::P64;
           Sp = Sp - 24;
           call $wgo_saAEy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBoW() //  [R1, R2, R3]
         { info_tbl: [(caBoW,
                       label: block_caBoW_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBoW: // global
           I64[Sp - 16] = block_caBp0_info;
           _saAEM::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAEM::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBqv; else goto caBpX;
       uaBqv: // global
           call _caBp0(R1) args: 0, res: 0, upd: 0;
       caBpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBp0() //  [R1]
         { info_tbl: [(caBp0,
                       label: block_caBp0_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBp0: // global
           if (R1 & 7 == 1) goto caBq3; else goto caBq8;
       caBq3: // global
           P64[Sp + 72] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAEP() args: 0, res: 0, upd: 0;
       caBq8: // global
           _saAEp::P64 = P64[Sp + 72];
           _saAEs::I64 = I64[Sp + 32];
           _saAEM::P64 = P64[Sp + 16];
           _saAEO::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAEp::P64 + 24) + (_saAEs::I64 << 3)] = _saAEO::P64;
           I64[_saAEp::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAEp::P64 + 24) + ((I64[_saAEp::P64 + 8] << 3) + (_saAEs::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caBq6_info;
           _saAFf::P64 = R1;
           R1 = _saAEM::P64;
           P64[Sp + 72] = _saAFf::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBqw; else goto caBq9;
       uaBqw: // global
           call _caBq6(R1) args: 0, res: 0, upd: 0;
       caBq9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBq6() //  [R1]
         { info_tbl: [(caBq6,
                       label: block_caBq6_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBq6: // global
           _saAFf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto caBqf; else goto caBqj;
       caBqf: // global
           P64[Sp + 56] = _saAFf::P64;
           Sp = Sp + 32;
           goto uaBqA;
       caBqj: // global
           _saAEq::I64 = I64[Sp + 24];
           _saAEr::P64 = P64[Sp + 8];
           I64[_saAEq::I64] = I64[_saAEq::I64] - 1;
           call MO_Touch(_saAEr::P64);
           P64[Sp + 56] = _saAFf::P64;
           Sp = Sp + 32;
           goto uaBqA;
       uaBqA: // global
           call _saAEP() args: 0, res: 0, upd: 0;
     }
 },
 _saAEP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAEP: // global
           I64[Sp - 8] = block_caBp5_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBqB; else goto caBp7;
       uaBqB: // global
           call _caBp5(R1) args: 0, res: 0, upd: 0;
       caBp7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBp5() //  [R1]
         { info_tbl: [(caBp5,
                       label: block_caBp5_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBp5: // global
           if (R1 & 7 == 1) goto caBpe; else goto caBpl;
       caBpe: // global
           I64[Sp + 32] = block_caBpb_info;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caBpl: // global
           I64[Sp] = block_caBpj_info;
           _saAEW::P64 = P64[R1 + 6];
           R2 = _saAEW::P64;
           P64[Sp + 32] = _saAEW::P64;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBpb() //  []
         { info_tbl: [(caBpb,
                       label: block_caBpb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBpb: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBpj() //  [R1]
         { info_tbl: [(caBpj,
                       label: block_caBpj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBpj: // global
           _saAEY::I64 = R1 & 7;
           if (_saAEY::I64 != 0) goto caBpG; else goto caBpT;
       caBpG: // global
           I64[Sp] = block_caBpw_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAEY::I64;
           if (R1 & 7 != 0) goto uaBqy; else goto caBpx;
       uaBqy: // global
           call _caBpw(R1) args: 0, res: 0, upd: 0;
       caBpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBpT: // global
           _saAE6::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caBpS_info;
           R2 = _saAE6::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBpw() //  [R1]
         { info_tbl: [(caBpw,
                       label: block_caBpw_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBpw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBpK; else goto caBpJ;
       caBpK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBpJ: // global
           _saAF0::P64 = P64[R1 + 7];
           _saAF2::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caBpC_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 7;
           R3 = P64[Sp + 24];
           R2 = _saAF0::P64;
           R1 = _saAF2::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caBpC() //  []
         { info_tbl: [(caBpC,
                       label: block_caBpC_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBpC: // global
           _saAE6::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caBpE_info;
           R2 = _saAE6::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBpE() //  []
         { info_tbl: [(caBpE,
                       label: block_caBpE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBpE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBpS() //  []
         { info_tbl: [(caBpS,
                       label: block_caBpS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBpS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAFp_entry() //  [R1, R2]
         { info_tbl: [(caBqK,
                       label: io_saAFp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBqL; else goto caBqM;
       caBqL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBqM: // global
           I64[Sp - 16] = block_caBqH_info;
           _saAEi::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAEi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBqQ; else goto caBqI;
       uaBqQ: // global
           call _caBqH(R1) args: 0, res: 0, upd: 0;
       caBqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBqH() //  [R1]
         { info_tbl: [(caBqH,
                       label: block_caBqH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBqH: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAEi_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFD_entry() //  [R1, R2]
         { info_tbl: [(caBr2,
                       label: sat_saAFD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBr2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBr3; else goto caBr4;
       caBr3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBr4: // global
           I64[Sp - 16] = block_caBr0_info;
           _saAFA::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAFA::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBr0() //  []
         { info_tbl: [(caBr0,
                       label: block_caBr0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBr0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFy_entry() //  [R1]
         { info_tbl: [(caBrb,
                       label: sat_saAFy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrb: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFz_entry() //  [R1]
         { info_tbl: [(caBrj,
                       label: sat_saAFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrj: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFR_entry() //  [R1, R2]
         { info_tbl: [(caBrB,
                       label: sat_saAFR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBrC; else goto caBrD;
       caBrC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBrD: // global
           I64[Sp - 16] = block_caBrz_info;
           _saAFO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAFO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBrz() //  []
         { info_tbl: [(caBrz,
                       label: block_caBrz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFM_entry() //  [R1]
         { info_tbl: [(caBrK,
                       label: sat_saAFM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrK: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFN_entry() //  [R1]
         { info_tbl: [(caBrS,
                       label: sat_saAFN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrS: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFW_entry() //  [R1]
         { info_tbl: [(caBrZ,
                       label: sat_saAFW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBs0; else goto caBs1;
       caBs0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caBs1: // global
           I64[Sp - 24] = block_caBrs_info;
           _saAEh::P64 = P64[R1 + 7];
           _saAFp::P64 = P64[R1 + 15];
           R1 = _saAEh::P64;
           P64[Sp - 16] = _saAEh::P64;
           P64[Sp - 8] = _saAFp::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBrs() //  [R1]
         { info_tbl: [(caBrs,
                       label: block_caBrs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBs4; else goto caBs3;
       caBs4: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBs3: // global
           I64[Hp - 56] = sat_saAFR_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAFM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAFN_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBrV_info;
           R2 = Hp - 54;
           _saAFL::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAFL::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBrV() //  [R1]
         { info_tbl: [(caBrV,
                       label: block_caBrV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrV: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBrX_info;
           R2 = P64[Sp + 16];
           _saAFU::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAFU::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBrX() //  []
         { info_tbl: [(caBrX,
                       label: block_caBrX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBrX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG8_entry() //  [R1, R2]
         { info_tbl: [(caBsh,
                       label: sat_saAG8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBsi; else goto caBsj;
       caBsi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBsj: // global
           I64[Sp - 16] = block_caBsf_info;
           _saAG5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAG5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBsf() //  []
         { info_tbl: [(caBsf,
                       label: block_caBsf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG3_entry() //  [R1]
         { info_tbl: [(caBsq,
                       label: sat_saAG3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsq: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG4_entry() //  [R1]
         { info_tbl: [(caBsy,
                       label: sat_saAG4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsy: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.closeFd1_entry() //  [R2, R3, R4]
         { info_tbl: [(caBsB,
                       label: GHC.Event.Manager.closeFd1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsB: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caBsC; else goto caBsD;
       caBsC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBsD: // global
           I64[Sp - 32] = block_caBng_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caBng() //  [R1]
         { info_tbl: [(caBng,
                       label: block_caBng_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBng: // global
           I64[Sp] = block_caBni_info;
           _saADN::I64 = R1;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saADN::I64;
           if (R1 & 7 != 0) goto uaBti; else goto caBnj;
       uaBti: // global
           call _caBni(R1) args: 0, res: 0, upd: 0;
       caBnj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBni() //  [R1]
         { info_tbl: [(caBni,
                       label: block_caBni_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBni: // global
           I64[Sp - 24] = block_caBnn_info;
           _saADP::P64 = P64[R1 + 7];
           _saADR::P64 = P64[R1 + 23];
           _saADT::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saADR::P64;
           P64[Sp - 8] = _saADT::P64;
           P64[Sp] = _saADP::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBtj; else goto caBno;
       uaBtj: // global
           call _caBnn(R1) args: 0, res: 0, upd: 0;
       caBno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBnn() //  [R1]
         { info_tbl: [(caBnn,
                       label: block_caBnn_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBnn: // global
           I64[Sp - 8] = block_caBns_info;
           _saAE2::P64 = R1;
           _saAE3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAE3::I64;
           P64[Sp + 8] = _saAE2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBtk; else goto caBnt;
       uaBtk: // global
           call _caBns(R1) args: 0, res: 0, upd: 0;
       caBnt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBns() //  [R1]
         { info_tbl: [(caBns,
                       label: block_caBns_info
                       rep:StackRep [True, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBns: // global
           I64[Sp - 8] = block_caBnx_info;
           _saAE4::P64 = R1;
           _saAE5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp] = _saAE5::I64;
           P64[Sp + 56] = _saAE4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBtl; else goto caBny;
       uaBtl: // global
           call _caBnx(R1) args: 0, res: 0, upd: 0;
       caBny: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBnx() //  [R1]
         { info_tbl: [(caBnx,
                       label: block_caBnx_info
                       rep:StackRep [True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBnx: // global
           _saAE2::P64 = P64[Sp + 24];
           _saAE3::I64 = I64[Sp + 16];
           _saAE4::P64 = P64[Sp + 64];
           _saAE7::I64 = I64[R1 + 7];
           _saAE8::I64 = _saAE7::I64 & 31;
           if (%MO_S_Gt_W64(_saAE3::I64,
                            _saAE8::I64)) goto caBsM; else goto caBtg;
       caBtg: // global
           if (%MO_S_Gt_W64(_saAE8::I64,
                            I64[Sp + 8])) goto caBsM; else goto caBsN;
       caBsM: // global
           R4 = _saAE8::I64;
           R3 = _saAE2::P64;
           R2 = _saAE4::P64;
           Sp = Sp + 72;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caBsN: // global
           _saAEf::P64 = P64[P64[Sp + 32] + ((_saAE8::I64 - _saAE3::I64 << 3) + 24)];
           I64[Sp + 24] = block_caBnQ_info;
           _saAE6::P64 = R1;
           R1 = _saAEf::P64;
           I64[Sp + 32] = _saAE7::I64;
           P64[Sp + 64] = _saAE6::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaBtm; else goto caBnR;
       uaBtm: // global
           call _caBnQ(R1) args: 0, res: 0, upd: 0;
       caBnR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBnQ() //  [R1]
         { info_tbl: [(caBnQ,
                       label: block_caBnQ_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBnQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caBsQ; else goto caBsP;
       caBsQ: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBsP: // global
           _saAEh::P64 = P64[R1 + 7];
           I64[Hp - 72] = $wio_saAEi_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saAFp_info;
           P64[Hp - 24] = Hp - 70;
           _caBqC::P64 = Hp - 30;
           _saAFu::I64 = I64[Sp + 24];
           if (_saAFu::I64 != 0) goto uaBth; else goto caBt3;
       uaBth: // global
           if (_saAFu::I64 != 1) goto caBsV; else goto caBt9;
       caBsV: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caBqT_info;
           R1 = _saAEh::P64;
           P64[Sp + 32] = _saAEh::P64;
           P64[Sp + 40] = _caBqC::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caBt9: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caBs8_info;
           R1 = _saAEh::P64;
           P64[Sp + 32] = _saAEh::P64;
           P64[Sp + 40] = _caBqC::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caBt3: // global
           I64[Hp - 16] = sat_saAFW_info;
           P64[Hp - 8] = _saAEh::P64;
           P64[Hp] = _caBqC::P64;
           I64[Sp + 40] = block_caBt2_info;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBqT() //  [R1]
         { info_tbl: [(caBqT,
                       label: block_caBqT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBqT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBsY; else goto caBsX;
       caBsY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBsX: // global
           I64[Hp - 56] = sat_saAFD_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAFy_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAFz_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBsR_info;
           R2 = Hp - 54;
           _saAFx::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAFx::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBsR() //  [R1]
         { info_tbl: [(caBsR,
                       label: block_caBsR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsR: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBsT_info;
           R2 = P64[Sp + 16];
           _saAFG::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAFG::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBsT() //  []
         { info_tbl: [(caBsT,
                       label: block_caBsT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBsT: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caBs8() //  [R1]
         { info_tbl: [(caBs8,
                       label: block_caBs8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBs8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBtc; else goto caBtb;
       caBtc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBtb: // global
           I64[Hp - 56] = sat_saAG8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAG3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAG4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBt6_info;
           R2 = Hp - 54;
           _saAG2::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAG2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBt6() //  [R1]
         { info_tbl: [(caBt6,
                       label: block_caBt6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBt6: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBt8_info;
           R2 = P64[Sp + 16];
           _saAGb::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAGb::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBt8() //  []
         { info_tbl: [(caBt8,
                       label: block_caBt8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBt8: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caBt2() //  [R1]
         { info_tbl: [(caBt2,
                       label: block_caBt2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBt2: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.43575061 UTC

[section ""data" . GHC.Event.Manager.closeFd_closure" {
     GHC.Event.Manager.closeFd_closure:
         const GHC.Event.Manager.closeFd_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_entry() //  [R2, R3, R4]
         { info_tbl: [(caBtr,
                       label: GHC.Event.Manager.closeFd_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBtr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.436908293 UTC

[section ""data" . lvl8_raAuf_closure" {
     lvl8_raAuf_closure:
         const lvl8_raAuf_info;
 },
 lvl8_raAuf_entry() //  [R2]
         { info_tbl: [(caBtB,
                       label: lvl8_raAuf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBtB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caBtC; else goto caBtD;
       caBtC: // global
           R2 = R2;
           R1 = lvl8_raAuf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBtD: // global
           I64[Sp - 8] = block_caBty_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBtW; else goto caBtz;
       uaBtW: // global
           call _caBty(R1) args: 0, res: 0, upd: 0;
       caBtz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBty() //  [R1]
         { info_tbl: [(caBty,
                       label: block_caBty_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBty: // global
           if (I64[R1 + 31] & 8 == 0) goto caBtS; else goto caBtM;
       caBtS: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBtM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.447783306 UTC

[section ""data" . GHC.Event.Manager.loop5_closure" {
     GHC.Event.Manager.loop5_closure:
         const GHC.Event.Manager.loop5_info;
         const 0;
 },
 $wgo_saAHp_entry() //  [R1, R2]
         { info_tbl: [(caBvo,
                       label: $wgo_saAHp_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBvo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBvp; else goto caBvq;
       caBvp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBvq: // global
           I64[Sp - 24] = block_caBvh_info;
           _saAHp::P64 = R1;
           _saAGN::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAGN::I64;
           P64[Sp - 8] = _saAHp::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBvN; else goto caBvi;
       uaBvN: // global
           call _caBvh(R1) args: 0, res: 0, upd: 0;
       caBvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBvh() //  [R1]
         { info_tbl: [(caBvh,
                       label: block_caBvh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBvh: // global
           if (R1 & 7 == 1) goto caBvl; else goto caBvm;
       caBvl: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBvm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBvy; else goto caBvx;
       caBvy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBvx: // global
           _saAHt::P64 = P64[R1 + 6];
           _saAHu::P64 = P64[R1 + 14];
           _saAHs::I64 = I64[R1 + 22];
           if (_saAHs::I64 == I64[Sp + 8]) goto caBvM; else goto caBvG;
       caBvM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAHt::P64;
           R3 = _saAHu::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBvG: // global
           Hp = Hp - 16;
           I64[Sp] = block_caBvC_info;
           R2 = _saAHu::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAHt::P64;
           I64[Sp + 16] = _saAHs::I64;
           call $wgo_saAHp_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBvC() //  [R1, R2, R3]
         { info_tbl: [(caBvC,
                       label: block_caBvC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBvC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBvJ; else goto caBvI;
       caBvJ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBvI: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saAHY_entry() //  [R1]
         { info_tbl: [(caBwx,
                       label: w2_saAHY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBwx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBwy; else goto caBwz;
       caBwy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBwz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caBwu_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo1_saAHM_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caBwu() //  [R1, R2]
         { info_tbl: [(caBwu,
                       label: block_caBwu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBwu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBwC; else goto caBwB;
       caBwC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caBwB: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo1_saAHM_entry() //  [R1, R2]
         { info_tbl: [(caBwH,
                       label: $wgo1_saAHM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBwH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caBwI; else goto caBwJ;
       caBwI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBwJ: // global
           I64[Sp - 24] = block_caBwa_info;
           _saAHM::P64 = R1;
           _saAGm::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _saAGm::P64;
           P64[Sp - 8] = _saAHM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBx9; else goto caBwb;
       uaBx9: // global
           call _caBwa(R1) args: 0, res: 0, upd: 0;
       caBwb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBwa() //  [R1]
         { info_tbl: [(caBwa,
                       label: block_caBwa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBwa: // global
           if (R1 & 7 == 1) goto caBwE; else goto caBwF;
       caBwE: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caBwF: // global
           I64[Sp - 8] = block_caBwg_info;
           _saAHP::P64 = P64[R1 + 6];
           _saAHQ::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _saAHQ::P64;
           P64[Sp + 8] = _saAHP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBx7; else goto caBwh;
       uaBx7: // global
           call _caBwg(R1) args: 0, res: 0, upd: 0;
       caBwh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBwg() //  [R1]
         { info_tbl: [(caBwg,
                       label: block_caBwg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBwg: // global
           I64[Sp] = block_caBwl_info;
           _saAHS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAHS::I64;
           if (R1 & 7 != 0) goto uaBx8; else goto caBwm;
       uaBx8: // global
           call _caBwl(R1) args: 0, res: 0, upd: 0;
       caBwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBwl() //  [R1]
         { info_tbl: [(caBwl,
                       label: block_caBwl_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBwl: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caBwQ; else goto caBwP;
       caBwQ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBwP: // global
           _saAHW::I64 = I64[R1 + 31];
           I64[Hp - 96] = w2_saAHY_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           _caBwq::P64 = Hp - 96;
           if (I64[Sp + 16] & _saAHW::I64 & 7 == 0) goto caBx6; else goto caBx1;
       caBx6: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caBwq::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _caBwq::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caBx1: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caBwq::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _caBwq::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds8_saAHL_entry() //  [R1]
         { info_tbl: [(caBxd,
                       label: ds8_saAHL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxd: // global
           _saAHL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caBxe; else goto caBxf;
       caBxf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBxh; else goto caBxg;
       caBxh: // global
           HpAlloc = 16;
           goto caBxe;
       caBxe: // global
           R1 = _saAHL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAHL::P64;
           _saAGm::P64 = P64[_saAHL::P64 + 16];
           _saAHK::P64 = P64[_saAHL::P64 + 24];
           I64[Hp - 8] = $wgo1_saAHM_info;
           P64[Hp] = _saAGm::P64;
           I64[Sp - 24] = block_caBxa_info;
           R2 = _saAHK::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call $wgo1_saAHM_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caBxa() //  [R1, R2]
         { info_tbl: [(caBxa,
                       label: block_caBxa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBxk; else goto caBxj;
       caBxk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caBxj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAIx_entry() //  [R1]
         { info_tbl: [(caBxz,
                       label: sat_saAIx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxz: // global
           R3 = P64[R1 + 16];
           R2 = lvl8_raAuf_closure+1;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 saved_saAIt_entry() //  [R1]
         { info_tbl: [(caBxC,
                       label: saved_saAIt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caBxD; else goto caBxE;
       caBxD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBxE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caBxq_info;
           _saAIp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saAIp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaBxI; else goto caBxr;
       uaBxI: // global
           call _caBxq(R1) args: 0, res: 0, upd: 0;
       caBxr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caBxq() //  [R1]
         { info_tbl: [(caBxq,
                       label: block_caBxq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBxH; else goto caBxG;
       caBxH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caBxG: // global
           _saAIw::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saAIx_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _saAIw::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAIA_entry() //  [R1]
         { info_tbl: [(caBxO,
                       label: sat_saAIA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxO: // global
           R1 = P64[R1 + 6] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAH9_entry() //  [R1, R2]
         { info_tbl: [(caBxR,
                       label: $wio_saAH9_info
                       rep:HeapRep 5 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxR: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caBxS; else goto caBxT;
       caBxS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBxT: // global
           I64[Sp - 64] = block_caBuY_info;
           _saAGm::P64 = P64[R1 + 6];
           _saAGD::P64 = P64[R1 + 14];
           _saAGF::P64 = P64[R1 + 22];
           _saAGG::P64 = P64[R1 + 30];
           _saAGM::P64 = P64[R1 + 38];
           _saAGN::I64 = I64[R1 + 46];
           R1 = P64[R2 + 8];
           P64[Sp - 56] = _saAGm::P64;
           P64[Sp - 48] = _saAGD::P64;
           P64[Sp - 40] = _saAGF::P64;
           P64[Sp - 32] = _saAGG::P64;
           P64[Sp - 24] = _saAGM::P64;
           I64[Sp - 16] = _saAGN::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto uaBAy; else goto caBuZ;
       uaBAy: // global
           call _caBuY(R1) args: 0, res: 0, upd: 0;
       caBuZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBuY() //  [R1]
         { info_tbl: [(caBuY,
                       label: block_caBuY_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBuY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBxW; else goto caBxV;
       caBxW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBxV: // global
           _saAGN::I64 = I64[Sp + 48];
           _saAHg::P64 = P64[R1 + 7];
           _saAHi::P64 = P64[R1 + 15];
           _saAHh::I64 = I64[R1 + 23];
           _saAHj::I64 = _saAGN::I64 & (I64[_saAHg::P64 + 8] - 1);
           _saAHo::P64 = P64[(_saAHg::P64 + 24) + (_saAHj::I64 << 3)];
           I64[Hp - 8] = $wgo_saAHp_info;
           I64[Hp] = _saAGN::I64;
           I64[Sp - 32] = block_caBvO_info;
           R2 = _saAHo::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saAHh::I64;
           P64[Sp - 16] = _saAHi::P64;
           I64[Sp - 8] = _saAHj::I64;
           P64[Sp] = _saAHg::P64;
           Sp = Sp - 32;
           call $wgo_saAHp_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBvO() //  [R1, R2, R3]
         { info_tbl: [(caBvO,
                       label: block_caBvO_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBvO: // global
           I64[Sp - 16] = block_caBxX_info;
           _saAHD::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAHD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBAx; else goto caBzW;
       uaBAx: // global
           call _caBxX(R1) args: 0, res: 0, upd: 0;
       caBzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBxX() //  [R1]
         { info_tbl: [(caBxX,
                       label: block_caBxX_info
                       rep:StackRep [False, False, True, False, True, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBxX: // global
           if (R1 & 7 == 1) goto caBA2; else goto caBA7;
       caBA2: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAHG() args: 0, res: 0, upd: 0;
       caBA7: // global
           _saAHg::P64 = P64[Sp + 48];
           _saAHj::I64 = I64[Sp + 40];
           _saAHD::P64 = P64[Sp + 16];
           _saAHF::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAHg::P64 + 24) + (_saAHj::I64 << 3)] = _saAHF::P64;
           I64[_saAHg::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAHg::P64 + 24) + ((I64[_saAHg::P64 + 8] << 3) + (_saAHj::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caBA5_info;
           _saAJ0::P64 = R1;
           R1 = _saAHD::P64;
           P64[Sp + 48] = _saAJ0::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBAz; else goto caBA8;
       uaBAz: // global
           call _caBA5(R1) args: 0, res: 0, upd: 0;
       caBA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBA5() //  [R1]
         { info_tbl: [(caBA5,
                       label: block_caBA5_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBA5: // global
           _saAJ0::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caBAe; else goto caBAi;
       caBAe: // global
           P64[Sp + 32] = _saAJ0::P64;
           Sp = Sp + 32;
           goto uaBAG;
       caBAi: // global
           _saAHh::I64 = I64[Sp + 8];
           _saAHi::P64 = P64[Sp + 16];
           I64[_saAHh::I64] = I64[_saAHh::I64] - 1;
           call MO_Touch(_saAHi::P64);
           P64[Sp + 32] = _saAJ0::P64;
           Sp = Sp + 32;
           goto uaBAG;
       uaBAG: // global
           call _saAHG() args: 0, res: 0, upd: 0;
     }
 },
 _saAHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAHG: // global
           _saAHI::P64 = P64[Sp];
           I64[Sp] = block_caBvV_info;
           R1 = _saAHI::P64;
           if (R1 & 7 != 0) goto uaBAH; else goto caBvW;
       uaBAH: // global
           call _caBvV(R1) args: 0, res: 0, upd: 0;
       caBvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBvV() //  [R1]
         { info_tbl: [(caBvV,
                       label: block_caBvV_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBvV: // global
           if (R1 & 7 == 1) goto caBy3; else goto caByb;
       caBy3: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caByb: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caBye; else goto caByd;
       caBye: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caByd: // global
           _saAHK::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds8_saAHL_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _saAHK::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           _caBw1::P64 = Hp - 96;
           P64[Hp - 48] = _caBw1::P64;
           I64[Hp - 40] = saved_saAIt_info;
           P64[Hp - 24] = _caBw1::P64;
           _caBxl::P64 = Hp - 64;
           P64[Hp - 16] = _caBxl::P64;
           I64[Hp - 8] = sat_saAIA_info;
           _caBxm::P64 = Hp - 40;
           P64[Hp] = _caBxm::P64;
           I64[Sp] = block_caBy4_info;
           R5 = P64[Sp + 56];
           R4 = _caBxm::P64;
           R3 = I64[Sp + 48];
           R2 = Hp - 6;
           P64[Sp + 8] = _saAHK::P64;
           P64[Sp + 48] = _caBxm::P64;
           P64[Sp + 56] = _caBxl::P64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBy4() //  []
         { info_tbl: [(caBy4,
                       label: block_caBy4_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBy4: // global
           _saAHK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBy6_info;
           R2 = _saAHK::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBy6() //  [R1]
         { info_tbl: [(caBy6,
                       label: block_caBy6_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBy6: // global
           I64[Sp] = block_caBya_info;
           R2 = P64[Sp + 40];
           I64[Sp + 40] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBya() //  [R1]
         { info_tbl: [(caBya,
                       label: block_caBya_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBya: // global
           _caBxl::P64 = P64[Sp + 48];
           _saAIE::I64 = I64[Sp + 40];
           _saAIF::I64 = R1;
           if (_saAIE::I64 & 8 == 0) goto saAIG; else goto caBzH;
       caBzH: // global
           if (_saAIE::I64 == _saAIF::I64) goto caBzP; else goto saAIG;
       saAIG: // global
           _saAII::I64 = _saAIF::I64 & 8;
           if (_saAII::I64 != 0) goto uaBAt; else goto caByP;
       uaBAt: // global
           I64[Sp] = _saAII::I64;
           I64[Sp + 24] = _saAIF::I64;
           call _caByv() args: 0, res: 0, upd: 0;
       caByP: // global
           if (_saAIE::I64 & 8 == 0) goto caBzj; else goto uaBAv;
       caBzj: // global
           if (_saAIF::I64 & 7 == 0) goto caBzP; else goto uaBAw;
       caBzP: // global
           R1 = _caBxl::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaBAw: // global
           I64[Sp + 40] = _saAIF::I64;
           goto uaBAD;
       uaBAv: // global
           I64[Sp + 40] = _saAIF::I64;
           goto uaBAD;
       uaBAD: // global
           call _caByW() args: 0, res: 0, upd: 0;
     }
 },
 _caByv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caByv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caByK; else goto caByJ;
       caByK: // global
           HpAlloc = 32;
           _saAII::I64 = I64[Sp];
           I64[Sp] = block_caByu_info;
           R1 = _saAII::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caByJ: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 24] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caByF_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caByu() //  [R1]
         { info_tbl: [(caByu,
                       label: block_caByu_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caByu: // global
           I64[Sp] = R1;
           call _caByv() args: 0, res: 0, upd: 0;
     }
 },
 _caByF() //  []
         { info_tbl: [(caByF,
                       label: block_caByF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caByF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caByW() //  []
         { info_tbl: [(caByW,
                       label: block_caByW_info
                       rep:StackRep [False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caByW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBz5; else goto caBz4;
       caBz5: // global
           HpAlloc = 16;
           I64[Sp] = block_caByW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caBz4: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caBz2_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBz2() //  []
         { info_tbl: [(caBz2,
                       label: block_caBz2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBz2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAJa_entry() //  [R1, R2]
         { info_tbl: [(caBAQ,
                       label: io_saAJa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBAQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBAR; else goto caBAS;
       caBAR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBAS: // global
           I64[Sp - 16] = block_caBAN_info;
           _saAH9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAH9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBAW; else goto caBAO;
       uaBAW: // global
           call _caBAN(R1) args: 0, res: 0, upd: 0;
       caBAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBAN() //  [R1]
         { info_tbl: [(caBAN,
                       label: block_caBAN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBAN: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAH9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJo_entry() //  [R1, R2]
         { info_tbl: [(caBB8,
                       label: sat_saAJo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBB8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBB9; else goto caBBa;
       caBB9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBBa: // global
           I64[Sp - 16] = block_caBB6_info;
           _saAJl::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAJl::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBB6() //  []
         { info_tbl: [(caBB6,
                       label: block_caBB6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBB6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJj_entry() //  [R1]
         { info_tbl: [(caBBh,
                       label: sat_saAJj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBh: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJk_entry() //  [R1]
         { info_tbl: [(caBBp,
                       label: sat_saAJk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBp: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJR_entry() //  [R1, R2]
         { info_tbl: [(caBBH,
                       label: sat_saAJR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBBI; else goto caBBJ;
       caBBI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBBJ: // global
           I64[Sp - 16] = block_caBBF_info;
           _saAJO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAJO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBBF() //  []
         { info_tbl: [(caBBF,
                       label: block_caBBF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJM_entry() //  [R1]
         { info_tbl: [(caBBQ,
                       label: sat_saAJM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBQ: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJN_entry() //  [R1]
         { info_tbl: [(caBBY,
                       label: sat_saAJN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBY: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJW_entry() //  [R1]
         { info_tbl: [(caBC5,
                       label: sat_saAJW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBC5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBC6; else goto caBC7;
       caBC6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caBC7: // global
           I64[Sp - 24] = block_caBBy_info;
           _saAH8::P64 = P64[R1 + 7];
           _saAJa::P64 = P64[R1 + 15];
           R1 = _saAH8::P64;
           P64[Sp - 16] = _saAH8::P64;
           P64[Sp - 8] = _saAJa::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBBy() //  [R1]
         { info_tbl: [(caBBy,
                       label: block_caBBy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBBy: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBCa; else goto caBC9;
       caBCa: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBC9: // global
           I64[Hp - 56] = sat_saAJR_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAJM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAJN_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBC1_info;
           R2 = Hp - 54;
           _saAJL::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAJL::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBC1() //  [R1]
         { info_tbl: [(caBC1,
                       label: block_caBC1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBC1: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBC3_info;
           R2 = P64[Sp + 16];
           _saAJU::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAJU::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBC3() //  []
         { info_tbl: [(caBC3,
                       label: block_caBC3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBC3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKn_entry() //  [R1, R2]
         { info_tbl: [(caBCn,
                       label: sat_saAKn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBCo; else goto caBCp;
       caBCo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBCp: // global
           I64[Sp - 16] = block_caBCl_info;
           _saAKk::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAKk::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBCl() //  []
         { info_tbl: [(caBCl,
                       label: block_caBCl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKi_entry() //  [R1]
         { info_tbl: [(caBCw,
                       label: sat_saAKi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCw: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKj_entry() //  [R1]
         { info_tbl: [(caBCE,
                       label: sat_saAKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCE: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop5_entry() //  [R2, R3, R4]
         { info_tbl: [(caBCH,
                       label: GHC.Event.Manager.loop5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCH: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caBCI; else goto caBCJ;
       caBCI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.loop5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBCJ: // global
           I64[Sp - 24] = block_caBu1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBFC; else goto caBu2;
       uaBFC: // global
           call _caBu1(R1) args: 0, res: 0, upd: 0;
       caBu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBu1() //  [R1]
         { info_tbl: [(caBu1,
                       label: block_caBu1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBu1: // global
           I64[Sp - 56] = block_caBu6_info;
           _saAGq::P64 = P64[R1 + 15];
           _saAGr::P64 = P64[R1 + 23];
           _saAGt::P64 = P64[R1 + 31];
           _saAGu::P64 = P64[R1 + 39];
           _saAGA::P64 = P64[R1 + 63];
           _saAGw::I64 = I64[R1 + 87];
           _saAGy::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           P64[Sp - 48] = _saAGr::P64;
           P64[Sp - 40] = _saAGt::P64;
           P64[Sp - 32] = _saAGu::P64;
           I64[Sp - 24] = _saAGw::I64;
           I64[Sp - 16] = _saAGy::I64;
           P64[Sp - 8] = _saAGA::P64;
           P64[Sp] = _saAGq::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaBFx; else goto caBu7;
       uaBFx: // global
           call _caBu6(R1) args: 0, res: 0, upd: 0;
       caBu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBu6() //  [R1]
         { info_tbl: [(caBu6,
                       label: block_caBu6_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBu6: // global
           I64[Sp - 16] = block_caBub_info;
           _saAGD::P64 = P64[R1 + 7];
           _saAGF::P64 = P64[R1 + 23];
           _saAGG::P64 = P64[R1 + 31];
           R1 = P64[Sp + 56];
           P64[Sp - 8] = _saAGG::P64;
           P64[Sp] = _saAGF::P64;
           P64[Sp + 56] = _saAGD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBFy; else goto caBuc;
       uaBFy: // global
           call _caBub(R1) args: 0, res: 0, upd: 0;
       caBuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBub() //  [R1]
         { info_tbl: [(caBub,
                       label: block_caBub_info
                       rep:StackRep [False, False, False, False, False, True, True, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBub: // global
           I64[Sp - 8] = block_caBug_info;
           _saAGI::P64 = R1;
           _saAGJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saAGJ::I64;
           P64[Sp + 24] = _saAGI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBFz; else goto caBuh;
       uaBFz: // global
           call _caBug(R1) args: 0, res: 0, upd: 0;
       caBuh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBug() //  [R1]
         { info_tbl: [(caBug,
                       label: block_caBug_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBug: // global
           I64[Sp - 8] = block_caBul_info;
           _saAGK::P64 = R1;
           _saAGL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saAGL::I64;
           P64[Sp + 88] = _saAGK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBFA; else goto caBum;
       uaBFA: // global
           call _caBul(R1) args: 0, res: 0, upd: 0;
       caBum: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBul() //  [R1]
         { info_tbl: [(caBul,
                       label: block_caBul_info
                       rep:StackRep [True, True, False, False, False, False, False, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBul: // global
           _saAGy::I64 = I64[Sp + 72];
           _saAGA::P64 = P64[Sp + 80];
           _saAGN::I64 = I64[R1 + 7];
           if (_saAGN::I64 == I64[Sp + 64]) goto saAGO; else goto caBFd;
       caBFd: // global
           if (_saAGN::I64 == _saAGy::I64) goto saAGO; else goto caBD9;
       saAGO: // global
           I64[Sp + 48] = block_caBCS_info;
           R4 = _saAGN::I64;
           R3 = _saAGA::P64;
           R2 = _saAGy::I64;
           Sp = Sp + 48;
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
       caBD9: // global
           I64[Sp] = block_caBuy_info;
           I64[Sp + 72] = _saAGN::I64;
           P64[Sp + 80] = R1;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caBCS() //  [R1]
         { info_tbl: [(caBCS,
                       label: block_caBCS_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCS: // global
           I64[Sp] = block_caBCU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBFD; else goto caBCX;
       uaBFD: // global
           call _caBCU(R1) args: 0, res: 0, upd: 0;
       caBCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBCU() //  [R1]
         { info_tbl: [(caBCU,
                       label: block_caBCU_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCU: // global
           if (R1 & 7 == 2) goto caBD7; else goto uaBFw;
       caBD7: // global
           _saAGu::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saAGu::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saAGu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaBFw: // global
           Sp = Sp + 64;
           call _caBD3() args: 0, res: 0, upd: 0;
     }
 },
 _caBuy() //  [R1]
         { info_tbl: [(caBuy,
                       label: block_caBuy_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBuy: // global
           _saAGI::P64 = P64[Sp + 40];
           _saAGJ::I64 = I64[Sp + 16];
           _saAGK::P64 = P64[Sp + 96];
           _saAGZ::I64 = I64[Sp + 72] & 31;
           if (%MO_S_Gt_W64(_saAGJ::I64,
                            _saAGZ::I64)) goto caBDe; else goto caBFa;
       caBFa: // global
           if (%MO_S_Gt_W64(_saAGZ::I64,
                            I64[Sp + 8])) goto caBDe; else goto caBDf;
       caBDe: // global
           R4 = _saAGZ::I64;
           R3 = _saAGI::P64;
           R2 = _saAGK::P64;
           Sp = Sp + 112;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caBDf: // global
           _saAH6::P64 = P64[P64[Sp + 48] + ((_saAGZ::I64 - _saAGJ::I64 << 3) + 24)];
           I64[Sp + 16] = block_caBuO_info;
           _saAGY::I64 = R1;
           R1 = _saAH6::P64;
           I64[Sp + 96] = _saAGY::I64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBFB; else goto caBuP;
       uaBFB: // global
           call _caBuO(R1) args: 0, res: 0, upd: 0;
       caBuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBuO() //  [R1]
         { info_tbl: [(caBuO,
                       label: block_caBuO_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBuO: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caBDi; else goto caBDh;
       caBDi: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBDh: // global
           _saAH8::P64 = P64[R1 + 7];
           I64[Hp - 88] = $wio_saAH9_info;
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 72];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 64];
           I64[Hp - 40] = I64[Sp + 56];
           I64[Hp - 32] = io_saAJa_info;
           P64[Hp - 24] = Hp - 86;
           _caBAI::P64 = Hp - 30;
           _saAJf::I64 = I64[Sp + 80];
           if (_saAJf::I64 != 0) goto uaBFm; else goto caBDZ;
       uaBFm: // global
           if (_saAJf::I64 != 1) goto caBDn; else goto caBEz;
       caBDn: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caBAZ_info;
           R1 = _saAH8::P64;
           P64[Sp + 72] = _saAH8::P64;
           P64[Sp + 80] = _caBAI::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caBEz: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caBCe_info;
           R1 = _saAH8::P64;
           P64[Sp + 72] = _saAH8::P64;
           P64[Sp + 80] = _caBAI::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caBDZ: // global
           I64[Hp - 16] = sat_saAJW_info;
           P64[Hp - 8] = _saAH8::P64;
           P64[Hp] = _caBAI::P64;
           I64[Sp + 80] = block_caBDY_info;
           R1 = Hp - 15;
           Sp = Sp + 80;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBAZ() //  [R1]
         { info_tbl: [(caBAZ,
                       label: block_caBAZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBAZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBDq; else goto caBDp;
       caBDq: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBDp: // global
           I64[Hp - 56] = sat_saAJo_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAJj_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAJk_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBDj_info;
           R2 = Hp - 54;
           _saAJi::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAJi::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBDj() //  [R1]
         { info_tbl: [(caBDj,
                       label: block_caBDj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDj: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBDl_info;
           R2 = P64[Sp + 16];
           _saAJr::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAJr::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBDl() //  []
         { info_tbl: [(caBDl,
                       label: block_caBDl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDl: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caBDx() args: 0, res: 0, upd: 0;
     }
 },
 _caBDx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDx: // global
           _saAJu::P64 = P64[Sp];
           I64[Sp] = block_caBDz_info;
           R1 = _saAJu::P64;
           if (R1 & 7 != 0) goto uaBFG; else goto caBDB;
       uaBFG: // global
           call _caBDz(R1) args: 0, res: 0, upd: 0;
       caBDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBDz() //  [R1]
         { info_tbl: [(caBDz,
                       label: block_caBDz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDz: // global
           if (R1 & 7 == 1) goto uaBFo; else goto caBDM;
       uaBFo: // global
           Sp = Sp + 16;
           call _caBD3() args: 0, res: 0, upd: 0;
       caBDM: // global
           I64[Sp - 8] = block_caBDK_info;
           _saAJy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAJy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBFH; else goto caBDN;
       uaBFH: // global
           call _caBDK(R1) args: 0, res: 0, upd: 0;
       caBDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBDK() //  [R1]
         { info_tbl: [(caBDK,
                       label: block_caBDK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBDV; else goto caBDU;
       caBDV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBDU: // global
           _saAJD::P64 = P64[R1 + 7];
           _saAJA::I64 = I64[R1 + 15];
           _saAJB::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAJA::I64;
           I64[Hp] = _saAJB::I64;
           I64[Sp] = block_caBDS_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAJD::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBDS() //  []
         { info_tbl: [(caBDS,
                       label: block_caBDS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDS: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caBDx() args: 0, res: 0, upd: 0;
     }
 },
 _caBCe() //  [R1]
         { info_tbl: [(caBCe,
                       label: block_caBCe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBCe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBEC; else goto caBEB;
       caBEC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBEB: // global
           I64[Hp - 56] = sat_saAKn_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAKi_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAKj_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBEw_info;
           R2 = Hp - 54;
           _saAKh::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAKh::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBEw() //  [R1]
         { info_tbl: [(caBEw,
                       label: block_caBEw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEw: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBEy_info;
           R2 = P64[Sp + 16];
           _saAKq::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAKq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBEy() //  []
         { info_tbl: [(caBEy,
                       label: block_caBEy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEy: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caBEJ() args: 0, res: 0, upd: 0;
     }
 },
 _caBEJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEJ: // global
           _saAKt::P64 = P64[Sp];
           I64[Sp] = block_caBEL_info;
           R1 = _saAKt::P64;
           if (R1 & 7 != 0) goto uaBFQ; else goto caBEN;
       uaBFQ: // global
           call _caBEL(R1) args: 0, res: 0, upd: 0;
       caBEN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBEL() //  [R1]
         { info_tbl: [(caBEL,
                       label: block_caBEL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEL: // global
           if (R1 & 7 == 1) goto uaBFr; else goto caBEY;
       uaBFr: // global
           Sp = Sp + 16;
           call _caBD3() args: 0, res: 0, upd: 0;
       caBEY: // global
           I64[Sp - 8] = block_caBEW_info;
           _saAKx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAKx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBFR; else goto caBEZ;
       uaBFR: // global
           call _caBEW(R1) args: 0, res: 0, upd: 0;
       caBEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBEW() //  [R1]
         { info_tbl: [(caBEW,
                       label: block_caBEW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBF7; else goto caBF6;
       caBF7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBF6: // global
           _saAKC::P64 = P64[R1 + 7];
           _saAKz::I64 = I64[R1 + 15];
           _saAKA::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAKz::I64;
           I64[Hp] = _saAKA::I64;
           I64[Sp] = block_caBF4_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAKC::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBF4() //  []
         { info_tbl: [(caBF4,
                       label: block_caBF4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBF4: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caBEJ() args: 0, res: 0, upd: 0;
     }
 },
 _caBDY() //  [R1]
         { info_tbl: [(caBDY,
                       label: block_caBDY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBDY: // global
           P64[Sp] = R1;
           call _caBE5() args: 0, res: 0, upd: 0;
     }
 },
 _caBE5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBE5: // global
           _saAK1::P64 = P64[Sp];
           I64[Sp] = block_caBE7_info;
           R1 = _saAK1::P64;
           if (R1 & 7 != 0) goto uaBFL; else goto caBE9;
       uaBFL: // global
           call _caBE7(R1) args: 0, res: 0, upd: 0;
       caBE9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBE7() //  [R1]
         { info_tbl: [(caBE7,
                       label: block_caBE7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBE7: // global
           if (R1 & 7 == 1) goto uaBFu; else goto caBEk;
       uaBFu: // global
           Sp = Sp + 16;
           call _caBD3() args: 0, res: 0, upd: 0;
       caBEk: // global
           I64[Sp - 8] = block_caBEi_info;
           _saAK5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAK5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBFM; else goto caBEl;
       uaBFM: // global
           call _caBEi(R1) args: 0, res: 0, upd: 0;
       caBEl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBD3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBD3: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBEi() //  [R1]
         { info_tbl: [(caBEi,
                       label: block_caBEi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBEt; else goto caBEs;
       caBEt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBEs: // global
           _saAKa::P64 = P64[R1 + 7];
           _saAK7::I64 = I64[R1 + 15];
           _saAK8::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAK7::I64;
           I64[Hp] = _saAK8::I64;
           I64[Sp] = block_caBEq_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAKa::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBEq() //  []
         { info_tbl: [(caBEq,
                       label: block_caBEq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBEq: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caBE5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.467807543 UTC

[section ""data" . GHC.Event.Manager.loop4_closure" {
     GHC.Event.Manager.loop4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Event.Internal.Forever_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.47015643 UTC

[section ""data" . GHC.Event.Manager.loop3_closure" {
     GHC.Event.Manager.loop3_closure:
         const GHC.Event.Manager.loop3_info;
         const 0;
 },
 sat_saAL3_entry() //  [R1, R2, R3]
         { info_tbl: [(caBGd,
                       label: sat_saAL3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saALf_entry() //  [R1, R2, R3]
         { info_tbl: [(caBGy,
                       label: sat_saALf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saALq_entry() //  [R1, R2, R3]
         { info_tbl: [(caBGR,
                       label: sat_saALq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop3_entry() //  [R2]
         { info_tbl: [(caBGU,
                       label: GHC.Event.Manager.loop3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caBGV; else goto caBGW;
       caBGV: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBGW: // global
           I64[Sp - 8] = block_caBFY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBHG; else goto caBFZ;
       uaBHG: // global
           call _caBFY(R1) args: 0, res: 0, upd: 0;
       caBFZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBFY() //  [R1]
         { info_tbl: [(caBFY,
                       label: block_caBFY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBFY: // global
           I64[Sp - 16] = block_caBG3_info;
           _saAKJ::P64 = R1;
           _saAKP::P64 = P64[R1 + 39];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saAKP::P64;
           P64[Sp] = _saAKJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBHB; else goto caBG4;
       uaBHB: // global
           call _caBG3(R1) args: 0, res: 0, upd: 0;
       caBG4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBG3() //  [R1]
         { info_tbl: [(caBG3,
                       label: block_caBG3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBG3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBH0; else goto caBGZ;
       caBH0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBGZ: // global
           _saAKY::P64 = P64[R1 + 7];
           _saAKZ::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_saAL3_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_caBGg_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = _saAKY::P64;
           R1 = _saAKZ::P64;
           P64[Sp - 8] = _saAKZ::P64;
           P64[Sp] = _saAKY::P64;
           Sp = Sp - 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBGg() //  [R1]
         { info_tbl: [(caBGg,
                       label: block_caBGg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGg: // global
           I64[Sp] = block_caBGi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBHC; else goto caBGj;
       uaBHC: // global
           call _caBGi(R1) args: 0, res: 0, upd: 0;
       caBGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBGi() //  [R1]
         { info_tbl: [(caBGi,
                       label: block_caBGi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGi: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caBH5; else goto caBHb;
       caBH5: // global
           _saALc::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caBH3_info;
           R1 = _saALc::P64;
           P64[Sp + 32] = _saALc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaBHD; else goto caBH6;
       uaBHD: // global
           call _caBH3() args: 0, res: 0, upd: 0;
       caBH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBHb: // global
           I64[Sp] = block_caBGr_info;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caBH3() //  []
         { info_tbl: [(caBH3,
                       label: block_caBH3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBH3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBGr() //  []
         { info_tbl: [(caBGr,
                       label: block_caBGr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBHe; else goto caBHd;
       caBHe: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caBHd: // global
           I64[Hp - 8] = sat_saALf_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caBGB_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBGB() //  [R1]
         { info_tbl: [(caBGB,
                       label: block_caBGB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGB: // global
           I64[Sp] = block_caBGD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBHE; else goto caBGE;
       uaBHE: // global
           call _caBGD(R1) args: 0, res: 0, upd: 0;
       caBGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBGD() //  [R1]
         { info_tbl: [(caBGD,
                       label: block_caBGD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBGD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBHi; else goto caBHh;
       caBHi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBHh: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caBHl; else goto caBHu;
       caBHl: // global
           Hp = Hp - 16;
           _saALo::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caBHj_info;
           R1 = _saALo::P64;
           P64[Sp + 32] = _saALo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaBHF; else goto caBHm;
       uaBHF: // global
           call _caBHj() args: 0, res: 0, upd: 0;
       caBHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBHu: // global
           I64[Hp - 8] = sat_saALq_info;
           P64[Hp] = P64[Sp + 32];
           _saAKY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caBHr_info;
           R4 = Hp - 5;
           R3 = GHC.Event.Manager.loop4_closure+2;
           R2 = _saAKY::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBHj() //  []
         { info_tbl: [(caBHj,
                       label: block_caBHj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBHj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBHr() //  []
         { info_tbl: [(caBHr,
                       label: block_caBHr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBHr: // global
           _saALw::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_caBHt_info;
           R1 = _saALw::P64;
           P64[Sp + 16] = _saALw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBHH; else goto caBHw;
       uaBHH: // global
           call _caBHt() args: 0, res: 0, upd: 0;
       caBHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBHt() //  []
         { info_tbl: [(caBHt,
                       label: block_caBHt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBHt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.474137764 UTC

[section ""data" . GHC.Event.Manager.step_closure" {
     GHC.Event.Manager.step_closure:
         const GHC.Event.Manager.step_info;
         const 0;
 },
 GHC.Event.Manager.step_entry() //  [R2]
         { info_tbl: [(caBHM,
                       label: GHC.Event.Manager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBHM: // global
           R2 = R2;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.474827803 UTC

[section ""cstring" . lvl9_raAug_bytes" {
     lvl9_raAug_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.475660508 UTC

[section ""data" . GHC.Event.Manager.loop2_closure" {
     GHC.Event.Manager.loop2_closure:
         const GHC.Event.Manager.loop2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.loop2_entry() //  [R1]
         { info_tbl: [(caBHX,
                       label: GHC.Event.Manager.loop2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBHX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBHY; else goto caBHZ;
       caBHY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caBHZ: // global
           (_caBHS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caBHS::I64 == 0) goto caBHU; else goto caBHT;
       caBHU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caBHT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caBHS::I64;
           I64[Sp - 24] = block_caBHV_info;
           R2 = lvl9_raAug_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caBHV() //  [R1]
         { info_tbl: [(caBHV,
                       label: block_caBHV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBHV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.476716882 UTC

[section ""data" . GHC.Event.Manager.loop8_closure" {
     GHC.Event.Manager.loop8_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.477349589 UTC

[section ""data" . GHC.Event.Manager.loop7_closure" {
     GHC.Event.Manager.loop7_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Releasing_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.478323336 UTC

[section ""data" . GHC.Event.Manager.loop6_closure" {
     GHC.Event.Manager.loop6_closure:
         const GHC.Event.Manager.loop6_info;
 },
 GHC.Event.Manager.loop6_entry() //  [R2]
         { info_tbl: [(caBIf,
                       label: GHC.Event.Manager.loop6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caBIg; else goto caBIh;
       caBIg: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBIh: // global
           I64[Sp - 8] = block_caBI7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBIv; else goto caBI8;
       uaBIv: // global
           call _caBI7(R1) args: 0, res: 0, upd: 0;
       caBI8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBI7() //  [R1]
         { info_tbl: [(caBI7,
                       label: block_caBI7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBI7: // global
           _caBIe::P64 = R1 & 7;
           if (_caBIe::P64 == 1) goto caBIc; else goto uaBIu;
       caBIc: // global
           R1 = GHC.Event.Manager.loop8_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaBIu: // global
           if (_caBIe::P64 == 4) goto caBId; else goto caBIb;
       caBId: // global
           R1 = GHC.Event.Manager.loop7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBIb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caBIn; else goto caBIm;
       caBIn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBIm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.481823052 UTC

[section ""data" . GHC.Event.Manager.loop1_closure" {
     GHC.Event.Manager.loop1_closure:
         const GHC.Event.Manager.loop1_info;
         const 0;
 },
 go_saALY_entry() //  [R1]
         { info_tbl: [(caBJ3,
                       label: go_saALY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJ3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caBJ4; else goto uaBJn;
       caBJ4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       uaBJn: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 16;
           call _caBIQ() args: 0, res: 0, upd: 0;
     }
 },
 _caBIQ() //  []
         { info_tbl: [(caBIQ,
                       label: block_caBIQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIQ: // global
           I64[Sp - 16] = block_caBIT_info;
           _saALY::P64 = P64[Sp + 8];
           _saALD::P64 = P64[_saALY::P64 + 7];
           R2 = _saALD::P64;
           P64[Sp - 8] = P64[_saALY::P64 + 15];
           P64[Sp] = _saALD::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBIT() //  [R1]
         { info_tbl: [(caBIT,
                       label: block_caBIT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIT: // global
           I64[Sp] = block_caBIV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBJo; else goto caBIW;
       uaBJo: // global
           call _caBIV(R1) args: 0, res: 0, upd: 0;
       caBIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBIV() //  [R1]
         { info_tbl: [(caBIV,
                       label: block_caBIV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIV: // global
           _caBJ2::P64 = R1 & 7;
           if (_caBJ2::P64 != 2) goto uaBJm; else goto caBJ0;
       uaBJm: // global
           if (_caBJ2::P64 != 4) goto caBIZ; else goto caBJ1;
       caBIZ: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       caBJ1: // global
           I64[Sp + 24] = block_caBJi_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caBJ0: // global
           I64[Sp + 16] = block_caBIQ_info;
           Sp = Sp + 16;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caBJi() //  []
         { info_tbl: [(caBJi,
                       label: block_caBJi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJi: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAMM_entry() //  [R1, R2]
         { info_tbl: [(caBJy,
                       label: sat_saAMM_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJy: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caBJz; else goto caBJA;
       caBJz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBJA: // global
           I64[Sp - 72] = block_caBJv_info;
           _saALJ::P64 = P64[R1 + 14];
           _saALO::P64 = P64[R1 + 22];
           _saALP::P64 = P64[R1 + 30];
           _saALQ::P64 = P64[R1 + 38];
           _saALL::I64 = I64[R1 + 46];
           _saALM::I64 = I64[R1 + 54];
           _saALN::I64 = I64[R1 + 62];
           R1 = P64[R1 + 6];
           P64[Sp - 64] = _saALJ::P64;
           I64[Sp - 56] = _saALL::I64;
           I64[Sp - 48] = _saALM::I64;
           I64[Sp - 40] = _saALN::I64;
           P64[Sp - 32] = _saALO::P64;
           P64[Sp - 24] = _saALP::P64;
           P64[Sp - 16] = _saALQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaBKp; else goto caBJw;
       uaBKp: // global
           call _caBJv(R1) args: 0, res: 0, upd: 0;
       caBJw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBJv() //  [R1]
         { info_tbl: [(caBJv,
                       label: block_caBJv_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJv: // global
           _saALJ::P64 = P64[Sp + 8];
           _saALQ::P64 = P64[Sp + 56];
           _saAM9::P64 = P64[R1 + 7];
           _saAMd::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saALJ::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saALJ::P64);
           I64[Sp] = block_caBJG_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saALQ::P64;
           P64[Sp + 8] = _saAMd::P64;
           P64[Sp + 56] = _saAM9::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBJG() //  []
         { info_tbl: [(caBJG,
                       label: block_caBJG_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJG: // global
           _saAMd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBJI_info;
           R2 = P64[Sp + 56];
           R1 = _saAMd::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBJI() //  []
         { info_tbl: [(caBJI,
                       label: block_caBJI_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJI: // global
           I64[Sp] = block_caBJK_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBJK() //  []
         { info_tbl: [(caBJK,
                       label: block_caBJK_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBJK: // global
           _saALM::I64 = I64[Sp + 16];
           _saALO::P64 = P64[Sp + 32];
           (_saAMs::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saAMx::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALM::I64)));
           I64[Sp + 16] = block_caBK0_info;
           R1 = _saALO::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBKq; else goto caBK1;
       uaBKq: // global
           call _caBK0(R1) args: 0, res: 0, upd: 0;
       caBK1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBK0() //  [R1]
         { info_tbl: [(caBK0,
                       label: block_caBK0_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBK0: // global
           _saALN::I64 = I64[Sp + 8];
           _saAM6::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caBK7; else goto caBKb;
       caBK7: // global
           (_saAMD::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = _saAM6::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caBKb: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saAML::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = _saAM6::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop1_entry() //  [R2]
         { info_tbl: [(caBKr,
                       label: GHC.Event.Manager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBKr: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caBKs; else goto caBKt;
       caBKs: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBKt: // global
           I64[Sp - 8] = block_caBIA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBLL; else goto caBIB;
       uaBLL: // global
           call _caBIA(R1) args: 0, res: 0, upd: 0;
       caBIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBIA() //  [R1]
         { info_tbl: [(caBIA,
                       label: block_caBIA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIA: // global
           I64[Sp - 72] = block_caBIF_info;
           _saALD::P64 = R1;
           _saALE::P64 = P64[R1 + 7];
           _saALJ::P64 = P64[R1 + 39];
           _saALO::P64 = P64[R1 + 55];
           _saALP::P64 = P64[R1 + 63];
           _saALQ::P64 = P64[R1 + 71];
           _saALL::I64 = I64[R1 + 87];
           _saALM::I64 = I64[R1 + 95];
           _saALN::I64 = I64[R1 + 103];
           R1 = _saALQ::P64;
           P64[Sp - 64] = _saALE::P64;
           P64[Sp - 56] = _saALJ::P64;
           I64[Sp - 48] = _saALL::I64;
           I64[Sp - 40] = _saALM::I64;
           I64[Sp - 32] = _saALN::I64;
           P64[Sp - 24] = _saALO::P64;
           P64[Sp - 16] = _saALP::P64;
           P64[Sp - 8] = _saALQ::P64;
           P64[Sp] = _saALD::P64;
           Sp = Sp - 72;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBIF() //  []
         { info_tbl: [(caBIF,
                       label: block_caBIF_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIF: // global
           I64[Sp] = block_caBIH_info;
           R2 = GHC.Event.Manager.loop6_closure+1;
           R1 = P64[Sp + 16];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBIH() //  [R1]
         { info_tbl: [(caBIH,
                       label: block_caBIH_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIH: // global
           I64[Sp] = block_caBIJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBLJ; else goto caBIK;
       uaBLJ: // global
           call _caBIJ(R1) args: 0, res: 0, upd: 0;
       caBIK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBIJ() //  [R1]
         { info_tbl: [(caBIJ,
                       label: block_caBIJ_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBIJ: // global
           _saALD::P64 = P64[Sp + 72];
           _saALE::P64 = P64[Sp + 8];
           _saALJ::P64 = P64[Sp + 16];
           _saALL::I64 = I64[Sp + 24];
           _saALM::I64 = I64[Sp + 32];
           _saALN::I64 = I64[Sp + 40];
           _saALO::P64 = P64[Sp + 48];
           _saALP::P64 = P64[Sp + 56];
           _saALQ::P64 = P64[Sp + 64];
           _caBLs::P64 = R1 & 7;
           if (_caBLs::P64 < 4) goto uaBLG; else goto uaBLI;
       uaBLG: // global
           if (_caBLs::P64 < 3) goto uaBLH; else goto caBLn;
       uaBLH: // global
           _saALX::P64 = R1;
           if (_caBLs::P64 < 2) goto caBKy; else goto caBKG;
       caBKG: // global
           I64[Sp + 8] = block_caBKE_info;
           R1 = _saALE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaBLK; else goto caBKH;
       uaBLK: // global
           call _caBKE(R1) args: 0, res: 0, upd: 0;
       caBKH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBLn: // global
           R2 = _saALD::P64;
           Sp = Sp + 80;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       uaBLI: // global
           _saALX::P64 = R1;
           if (_caBLs::P64 < 5) goto caBKy; else goto caBLr;
       caBKy: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caBKB; else goto caBKA;
       caBKB: // global
           HpAlloc = 96;
           R1 = _saALX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBKA: // global
           I64[Hp - 88] = go_saALY_info;
           P64[Hp - 80] = _saALD::P64;
           P64[Hp - 72] = _saALQ::P64;
           I64[Hp - 64] = sat_saAMM_info;
           P64[Hp - 56] = _saALE::P64;
           P64[Hp - 48] = _saALJ::P64;
           P64[Hp - 40] = _saALO::P64;
           P64[Hp - 32] = _saALP::P64;
           P64[Hp - 24] = _saALQ::P64;
           I64[Hp - 16] = _saALL::I64;
           I64[Hp - 8] = _saALM::I64;
           I64[Hp] = _saALN::I64;
           R2 = Hp - 62;
           R1 = Hp - 87;
           Sp = Sp + 80;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       caBLr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBKE() //  [R1]
         { info_tbl: [(caBKE,
                       label: block_caBKE_info
                       rep:StackRep [False, True, True, True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBKE: // global
           _saALJ::P64 = P64[Sp + 8];
           _saALQ::P64 = P64[Sp + 56];
           _saAMO::P64 = P64[R1 + 7];
           _saAMS::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saALJ::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saALJ::P64);
           I64[Sp + 8] = block_caBKO_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saALQ::P64;
           P64[Sp + 56] = _saAMS::P64;
           P64[Sp + 64] = _saAMO::P64;
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBKO() //  []
         { info_tbl: [(caBKO,
                       label: block_caBKO_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBKO: // global
           I64[Sp] = block_caBKQ_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBKQ() //  []
         { info_tbl: [(caBKQ,
                       label: block_caBKQ_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBKQ: // global
           I64[Sp] = block_caBKS_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBKS() //  []
         { info_tbl: [(caBKS,
                       label: block_caBKS_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBKS: // global
           _saALM::I64 = I64[Sp + 16];
           _saALO::P64 = P64[Sp + 32];
           (_saAN7::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saANc::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALM::I64)));
           I64[Sp + 16] = block_caBL8_info;
           R1 = _saALO::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBLM; else goto caBL9;
       uaBLM: // global
           call _caBL8(R1) args: 0, res: 0, upd: 0;
       caBL9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBL8() //  [R1]
         { info_tbl: [(caBL8,
                       label: block_caBL8_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBL8: // global
           _saALN::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caBLf; else goto caBLj;
       caBLf: // global
           (_saANi::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caBLj: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saANr::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.488495041 UTC

[section ""data" . GHC.Event.Manager.loop_closure" {
     GHC.Event.Manager.loop_closure:
         const GHC.Event.Manager.loop_info;
         const 0;
 },
 GHC.Event.Manager.loop_entry() //  [R2]
         { info_tbl: [(caBLR,
                       label: GHC.Event.Manager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBLR: // global
           R2 = R2;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.492775695 UTC

[section ""data" . GHC.Event.Manager.closeFd_4_closure" {
     GHC.Event.Manager.closeFd_4_closure:
         const GHC.Event.Manager.closeFd_4_info;
 },
 GHC.Event.Manager.closeFd_4_entry() //  []
         { info_tbl: [(caBLY,
                       label: GHC.Event.Manager.closeFd_4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBLY: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.49590336 UTC

[section ""data" . GHC.Event.Manager.$wcloseFd__closure" {
     GHC.Event.Manager.$wcloseFd__closure:
         const GHC.Event.Manager.$wcloseFd__info;
         const 0;
 },
 $wgo_saANL_entry() //  [R1, R2]
         { info_tbl: [(caBMv,
                       label: $wgo_saANL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBMv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBMw; else goto caBMx;
       caBMw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBMx: // global
           I64[Sp - 24] = block_caBMo_info;
           _saANL::P64 = R1;
           _saANw::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saANw::I64;
           P64[Sp - 8] = _saANL::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBMU; else goto caBMp;
       uaBMU: // global
           call _caBMo(R1) args: 0, res: 0, upd: 0;
       caBMp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBMo() //  [R1]
         { info_tbl: [(caBMo,
                       label: block_caBMo_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBMo: // global
           if (R1 & 7 == 1) goto caBMs; else goto caBMt;
       caBMs: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBMt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBMF; else goto caBME;
       caBMF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBME: // global
           _saANP::P64 = P64[R1 + 6];
           _saANQ::P64 = P64[R1 + 14];
           _saANO::I64 = I64[R1 + 22];
           if (_saANO::I64 == I64[Sp + 8]) goto caBMT; else goto caBMN;
       caBMT: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saANP::P64;
           R3 = _saANQ::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBMN: // global
           Hp = Hp - 16;
           I64[Sp] = block_caBMJ_info;
           R2 = _saANQ::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saANP::P64;
           I64[Sp + 16] = _saANO::I64;
           call $wgo_saANL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBMJ() //  [R1, R2, R3]
         { info_tbl: [(caBMJ,
                       label: block_caBMJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBMJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBMQ; else goto caBMP;
       caBMQ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBMP: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAOy_entry() //  [R1]
         { info_tbl: [(caBNy,
                       label: sat_saAOy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNy: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAOz_entry() //  [R1]
         { info_tbl: [(caBNI,
                       label: sat_saAOz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNI: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.$wcloseFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caBNL,
                       label: GHC.Event.Manager.$wcloseFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNL: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caBNM; else goto caBNN;
       caBNM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$wcloseFd__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBNN: // global
           I64[Sp - 24] = block_caBM5_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBOO; else goto caBM6;
       uaBOO: // global
           call _caBM5(R1) args: 0, res: 0, upd: 0;
       caBM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBM5() //  [R1]
         { info_tbl: [(caBM5,
                       label: block_caBM5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBM5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBNQ; else goto caBNP;
       caBNQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBNP: // global
           _saANw::I64 = I64[Sp + 16];
           _saANC::P64 = P64[R1 + 7];
           _saANE::P64 = P64[R1 + 15];
           _saAND::I64 = I64[R1 + 23];
           _saANF::I64 = _saANw::I64 & (I64[_saANC::P64 + 8] - 1);
           _saANK::P64 = P64[(_saANC::P64 + 24) + (_saANF::I64 << 3)];
           I64[Hp - 8] = $wgo_saANL_info;
           I64[Hp] = _saANw::I64;
           I64[Sp - 32] = block_caBMV_info;
           R2 = _saANK::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saAND::I64;
           P64[Sp - 16] = _saANE::P64;
           I64[Sp - 8] = _saANF::I64;
           P64[Sp] = _saANC::P64;
           Sp = Sp - 32;
           call $wgo_saANL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBMV() //  [R1, R2, R3]
         { info_tbl: [(caBMV,
                       label: block_caBMV_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBMV: // global
           I64[Sp - 16] = block_caBNR_info;
           _saANZ::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saANZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBOL; else goto caBOe;
       uaBOL: // global
           call _caBNR(R1) args: 0, res: 0, upd: 0;
       caBOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBNR() //  [R1]
         { info_tbl: [(caBNR,
                       label: block_caBNR_info
                       rep:StackRep [False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNR: // global
           if (R1 & 7 == 1) goto caBOk; else goto caBOp;
       caBOk: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAO2() args: 0, res: 0, upd: 0;
       caBOp: // global
           _saANC::P64 = P64[Sp + 48];
           _saANF::I64 = I64[Sp + 40];
           _saANZ::P64 = P64[Sp + 16];
           _saAO1::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saANC::P64 + 24) + (_saANF::I64 << 3)] = _saAO1::P64;
           I64[_saANC::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saANC::P64 + 24) + ((I64[_saANC::P64 + 8] << 3) + (_saANF::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caBOn_info;
           _saAOA::P64 = R1;
           R1 = _saANZ::P64;
           P64[Sp + 48] = _saAOA::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaBOP; else goto caBOq;
       uaBOP: // global
           call _caBOn(R1) args: 0, res: 0, upd: 0;
       caBOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBOn() //  [R1]
         { info_tbl: [(caBOn,
                       label: block_caBOn_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBOn: // global
           _saAOA::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caBOw; else goto caBOA;
       caBOw: // global
           P64[Sp + 32] = _saAOA::P64;
           Sp = Sp + 32;
           goto uaBOS;
       caBOA: // global
           _saAND::I64 = I64[Sp + 8];
           _saANE::P64 = P64[Sp + 16];
           I64[_saAND::I64] = I64[_saAND::I64] - 1;
           call MO_Touch(_saANE::P64);
           P64[Sp + 32] = _saAOA::P64;
           Sp = Sp + 32;
           goto uaBOS;
       uaBOS: // global
           call _saAO2() args: 0, res: 0, upd: 0;
     }
 },
 _saAO2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAO2: // global
           _saAO4::P64 = P64[Sp];
           I64[Sp] = block_caBN2_info;
           R1 = _saAO4::P64;
           if (R1 & 7 != 0) goto uaBOT; else goto caBN3;
       uaBOT: // global
           call _caBN2(R1) args: 0, res: 0, upd: 0;
       caBN3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBN2() //  [R1]
         { info_tbl: [(caBN2,
                       label: block_caBN2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBN2: // global
           if (R1 & 7 == 1) goto caBNX; else goto caBNZ;
       caBNX: // global
           R1 = GHC.Event.Manager.closeFd_4_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBNZ: // global
           I64[Sp - 8] = block_caBN8_info;
           _saAO6::P64 = P64[R1 + 6];
           R2 = _saAO6::P64;
           P64[Sp] = _saAO6::P64;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBN8() //  [R1]
         { info_tbl: [(caBN8,
                       label: block_caBN8_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBN8: // global
           if (R1 == 0) goto caBOa; else goto caBO2;
       caBOa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBOd; else goto caBOc;
       caBOd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caBOc: // global
           I64[Hp - 8] = sat_saAOz_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBO2: // global
           I64[Sp] = block_caBNc_info;
           _saAO7::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAO7::I64;
           if (R1 & 7 != 0) goto uaBOM; else goto caBNd;
       uaBOM: // global
           call _caBNc(R1) args: 0, res: 0, upd: 0;
       caBNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBNc() //  [R1]
         { info_tbl: [(caBNc,
                       label: block_caBNc_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNc: // global
           I64[Sp] = block_caBNh_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uaBON; else goto caBNi;
       uaBON: // global
           call _caBNh(R1) args: 0, res: 0, upd: 0;
       caBNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBNh() //  [R1]
         { info_tbl: [(caBNh,
                       label: block_caBNh_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBO6; else goto caBO5;
       caBO6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBO5: // global
           _saAOn::P64 = P64[R1 + 7];
           _saAOp::P64 = P64[R1 + 23];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 16] & 7;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_caBNr_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAOn::P64;
           R1 = _saAOp::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caBNr() //  [R1]
         { info_tbl: [(caBNr,
                       label: block_caBNr_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBNr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBO9; else goto caBO8;
       caBO9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBO8: // global
           I64[Hp - 8] = sat_saAOy_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.501164497 UTC

[section ""data" . GHC.Event.Manager.closeFd_1_closure" {
     GHC.Event.Manager.closeFd_1_closure:
         const GHC.Event.Manager.closeFd_1_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_1_entry() //  [R2, R3, R4]
         { info_tbl: [(caBP1,
                       label: GHC.Event.Manager.closeFd_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBP1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBP5; else goto caBP6;
       caBP5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBP6: // global
           I64[Sp - 24] = block_caBOY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBPe; else goto caBOZ;
       uaBPe: // global
           call _caBOY(R1) args: 0, res: 0, upd: 0;
       caBOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBOY() //  [R1]
         { info_tbl: [(caBOY,
                       label: block_caBOY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBOY: // global
           I64[Sp] = block_caBP4_info;
           _saAOP::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _saAOP::P64;
           if (R1 & 7 != 0) goto uaBPd; else goto caBP8;
       uaBPd: // global
           call _caBP4(R1) args: 0, res: 0, upd: 0;
       caBP8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBP4() //  [R1]
         { info_tbl: [(caBP4,
                       label: block_caBP4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBP4: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.502665231 UTC

[section ""data" . GHC.Event.Manager.closeFd__closure" {
     GHC.Event.Manager.closeFd__closure:
         const GHC.Event.Manager.closeFd__info;
         const 0;
 },
 GHC.Event.Manager.closeFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caBPj,
                       label: GHC.Event.Manager.closeFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd_1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.503415148 UTC

[section ""data" . lvl10_raAuh_closure" {
     lvl10_raAuh_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.504010222 UTC

[section ""data" . lvl11_raAui_closure" {
     lvl11_raAui_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.504566053 UTC

[section ""data" . lvl12_raAuj_closure" {
     lvl12_raAuj_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.514561375 UTC

[section ""data" . registerFd1_raAuk_closure" {
     registerFd1_raAuk_closure:
         const registerFd1_raAuk_info;
         const 0;
 },
 $wgo_saAQj_entry() //  [R1, R2]
         { info_tbl: [(caBRA,
                       label: $wgo_saAQj_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBRA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBRB; else goto caBRC;
       caBRB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBRC: // global
           I64[Sp - 24] = block_caBRt_info;
           _saAQj::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAPq::I64;
           P64[Sp - 8] = _saAQj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBRZ; else goto caBRu;
       uaBRZ: // global
           call _caBRt(R1) args: 0, res: 0, upd: 0;
       caBRu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBRt() //  [R1]
         { info_tbl: [(caBRt,
                       label: block_caBRt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBRt: // global
           if (R1 & 7 == 1) goto caBRx; else goto caBRy;
       caBRx: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBRy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBRK; else goto caBRJ;
       caBRK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBRJ: // global
           _saAQn::P64 = P64[R1 + 6];
           _saAQo::P64 = P64[R1 + 14];
           _saAQm::I64 = I64[R1 + 22];
           if (_saAQm::I64 == I64[Sp + 8]) goto caBRY; else goto caBRS;
       caBRY: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAQn::P64;
           R3 = _saAQo::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBRS: // global
           Hp = Hp - 16;
           I64[Sp] = block_caBRO_info;
           R2 = _saAQo::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAQn::P64;
           I64[Sp + 16] = _saAQm::I64;
           call $wgo_saAQj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBRO() //  [R1, R2, R3]
         { info_tbl: [(caBRO,
                       label: block_caBRO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBRO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBRV; else goto caBRU;
       caBRV: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBRU: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saAR8_entry() //  [R1, R2]
         { info_tbl: [(caBSK,
                       label: $wgo_saAR8_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBSK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBSL; else goto caBSM;
       caBSL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBSM: // global
           I64[Sp - 24] = block_caBSD_info;
           _saAR8::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAPq::I64;
           P64[Sp - 8] = _saAR8::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBT9; else goto caBSE;
       uaBT9: // global
           call _caBSD(R1) args: 0, res: 0, upd: 0;
       caBSE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBSD() //  [R1]
         { info_tbl: [(caBSD,
                       label: block_caBSD_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBSD: // global
           if (R1 & 7 == 1) goto caBSH; else goto caBSI;
       caBSH: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBSI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBSU; else goto caBST;
       caBSU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBST: // global
           _saARc::P64 = P64[R1 + 6];
           _saARd::P64 = P64[R1 + 14];
           _saARb::I64 = I64[R1 + 22];
           if (_saARb::I64 == I64[Sp + 8]) goto caBT8; else goto caBT2;
       caBT8: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saARc::P64;
           R3 = _saARd::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caBT2: // global
           Hp = Hp - 16;
           I64[Sp] = block_caBSY_info;
           R2 = _saARd::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saARc::P64;
           I64[Sp + 16] = _saARb::I64;
           call $wgo_saAR8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBSY() //  [R1, R2, R3]
         { info_tbl: [(caBSY,
                       label: block_caBSY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBSY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBT5; else goto caBT4;
       caBT5: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBT4: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAPK_entry() //  [R1, R2]
         { info_tbl: [(caBTh,
                       label: $wio_saAPK_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBTh: // global
           _saAPL::P64 = R2;
           _saAPK::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caBTi; else goto caBTj;
       caBTj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBTl; else goto caBTk;
       caBTl: // global
           HpAlloc = 64;
           goto caBTi;
       caBTi: // global
           R2 = _saAPL::P64;
           R1 = _saAPK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBTk: // global
           _saAPh::P64 = P64[_saAPK::P64 + 6];
           _saAPj::P64 = P64[_saAPK::P64 + 14];
           _saAPk::P64 = P64[_saAPK::P64 + 22];
           _saAPp::P64 = P64[_saAPK::P64 + 30];
           _saAPv::P64 = P64[_saAPK::P64 + 38];
           _saAPo::I64 = I64[_saAPK::P64 + 46];
           _saAPq::I64 = I64[_saAPK::P64 + 54];
           _saAPu::I64 = I64[_saAPK::P64 + 62];
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = _saAPv::P64;
           I64[Hp - 40] = _saAPq::I64;
           I64[Hp - 32] = _saAPo::I64;
           I64[Hp - 24] = _saAPu::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caBQw_info;
           R5 = _saAPL::P64;
           R4 = Hp - 14;
           R3 = _saAPq::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saAPh::P64;
           P64[Sp - 48] = _saAPj::P64;
           P64[Sp - 40] = _saAPk::P64;
           P64[Sp - 32] = _saAPp::P64;
           I64[Sp - 24] = _saAPq::I64;
           I64[Sp - 16] = _saAPu::I64;
           P64[Sp - 8] = _saAPL::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBQw() //  [R1]
         { info_tbl: [(caBQw,
                       label: block_caBQw_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQw: // global
           I64[Sp - 8] = block_caBTa_info;
           _saAPR::P64 = R1;
           R1 = R1;
           P64[Sp] = _saAPR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaBVJ; else goto caBTb;
       uaBVJ: // global
           call _caBTa(R1) args: 0, res: 0, upd: 0;
       caBTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBTa() //  [R1]
         { info_tbl: [(caBTa,
                       label: block_caBTa_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBTa: // global
           if (R1 & 7 == 1) goto caBTe; else goto caBTf;
       caBTe: // global
           I64[Sp] = 0;
           call _saAPS() args: 0, res: 0, upd: 0;
       caBTf: // global
           I64[Sp] = block_caBVd_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBVd() //  [R1]
         { info_tbl: [(caBVd,
                       label: block_caBVd_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBVd: // global
           I64[Sp] = R1;
           call _saAPS() args: 0, res: 0, upd: 0;
     }
 },
 _saAPS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAPS: // global
           _saAPU::I64 = I64[Sp] | I64[Sp + 56];
           _saAPV::I64 = _saAPU::I64 & 8;
           if (_saAPV::I64 != 0) goto uaBVC; else goto uaBVB;
       uaBVC: // global
           I64[Sp + 32] = _saAPV::I64;
           I64[Sp + 56] = _saAPU::I64;
           call _caBQK() args: 0, res: 0, upd: 0;
       uaBVB: // global
           I64[Sp + 24] = _saAPV::I64;
           I64[Sp + 56] = _saAPU::I64;
           Sp = Sp + 8;
           call _caBS2() args: 0, res: 0, upd: 0;
     }
 },
 _caBQK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caBTs; else goto caBTr;
       caBTs: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caBQJ_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caBTr: // global
           _saAPT::I64 = I64[Sp];
           _saAPU::I64 = I64[Sp + 56];
           if (_saAPT::I64 == _saAPU::I64) goto caBTu; else goto caBTv;
       caBTu: // global
           Hp = Hp - 32;
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBTv: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAPU::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAPT::I64 & 7;
           I64[Sp] = block_caBQY_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caBQJ() //  [R1]
         { info_tbl: [(caBQJ,
                       label: block_caBQJ_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQJ: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caBQK() args: 0, res: 0, upd: 0;
     }
 },
 _caBQY() //  [R1]
         { info_tbl: [(caBQY,
                       label: block_caBQY_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQY: // global
           I64[Sp] = block_caBR0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBVL; else goto caBR1;
       uaBVL: // global
           call _caBR0(R1) args: 0, res: 0, upd: 0;
       caBR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBR0() //  [R1]
         { info_tbl: [(caBR0,
                       label: block_caBR0_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBR0: // global
           if (R1 & 7 == 1) goto caBTz; else goto caBUh;
       caBTz: // global
           I64[Sp + 40] = block_caBR5_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaBVM; else goto caBR6;
       uaBVM: // global
           call _caBR5(R1) args: 0, res: 0, upd: 0;
       caBR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBUh: // global
           R1 = lvl12_raAuj_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBR5() //  [R1]
         { info_tbl: [(caBR5,
                       label: block_caBR5_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBR5: // global
           _saAPL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caBTC; else goto caBUb;
       caBTC: // global
           I64[Sp] = block_caBRa_info;
           R1 = P64[_saAPL::P64 + 8];
           if (R1 & 7 != 0) goto uaBVN; else goto caBRb;
       uaBVN: // global
           call _caBRa(R1) args: 0, res: 0, upd: 0;
       caBRb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBUb: // global
           I64[Sp + 24] = block_caBU9_info;
           R5 = _saAPL::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBRa() //  [R1]
         { info_tbl: [(caBRa,
                       label: block_caBRa_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBRa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBTF; else goto caBTE;
       caBTF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBTE: // global
           _saAPq::I64 = I64[Sp + 8];
           _saAQa::P64 = P64[R1 + 7];
           _saAQc::P64 = P64[R1 + 15];
           _saAQb::I64 = I64[R1 + 23];
           _saAQd::I64 = _saAPq::I64 & (I64[_saAQa::P64 + 8] - 1);
           _saAQi::P64 = P64[(_saAQa::P64 + 24) + (_saAQd::I64 << 3)];
           I64[Hp - 8] = $wgo_saAQj_info;
           I64[Hp] = _saAPq::I64;
           I64[Sp - 8] = block_caBTG_info;
           R2 = _saAQi::P64;
           R1 = Hp - 7;
           I64[Sp] = _saAQd::I64;
           P64[Sp + 8] = _saAQc::P64;
           I64[Sp + 16] = _saAQb::I64;
           P64[Sp + 24] = _saAQa::P64;
           Sp = Sp - 8;
           call $wgo_saAQj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBTG() //  [R1, R2, R3]
         { info_tbl: [(caBTG,
                       label: block_caBTG_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBTG: // global
           I64[Sp - 16] = block_caBTI_info;
           _saAQx::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAQx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBVT; else goto caBTK;
       uaBVT: // global
           call _caBTI(R1) args: 0, res: 0, upd: 0;
       caBTK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBTI() //  [R1]
         { info_tbl: [(caBTI,
                       label: block_caBTI_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBTI: // global
           if (R1 & 7 == 1) goto uaBVE; else goto caBTV;
       uaBVE: // global
           Sp = Sp + 56;
           call _caBUS() args: 0, res: 0, upd: 0;
       caBTV: // global
           _saAQa::P64 = P64[Sp + 48];
           _saAQd::I64 = I64[Sp + 24];
           _saAQx::P64 = P64[Sp + 16];
           _saAQz::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAQa::P64 + 24) + (_saAQd::I64 << 3)] = _saAQz::P64;
           I64[_saAQa::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAQa::P64 + 24) + ((I64[_saAQa::P64 + 8] << 3) + (_saAQd::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caBTT_info;
           R1 = _saAQx::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaBVU; else goto caBTW;
       uaBVU: // global
           call _caBTT(R1) args: 0, res: 0, upd: 0;
       caBTW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBTT() //  [R1]
         { info_tbl: [(caBTT,
                       label: block_caBTT_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBTT: // global
           if (R1 & 7 == 1) goto uaBVF; else goto caBU6;
       uaBVF: // global
           Sp = Sp + 32;
           call _caBUS() args: 0, res: 0, upd: 0;
       caBU6: // global
           _saAQb::I64 = I64[Sp + 16];
           _saAQc::P64 = P64[Sp + 8];
           I64[_saAQb::I64] = I64[_saAQb::I64] - 1;
           call MO_Touch(_saAQc::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBU9() //  []
         { info_tbl: [(caBU9,
                       label: block_caBU9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBU9: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBS2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBS2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBUl; else goto caBUk;
       caBUl: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caBS1_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caBUk: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caBS8_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBS1() //  [R1]
         { info_tbl: [(caBS1,
                       label: block_caBS1_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBS1: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caBS2() args: 0, res: 0, upd: 0;
     }
 },
 _caBS8() //  [R1]
         { info_tbl: [(caBS8,
                       label: block_caBS8_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBS8: // global
           I64[Sp] = block_caBSa_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaBVP; else goto caBSb;
       uaBVP: // global
           call _caBSa(R1) args: 0, res: 0, upd: 0;
       caBSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBSa() //  [R1]
         { info_tbl: [(caBSa,
                       label: block_caBSa_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBSa: // global
           if (R1 & 7 == 1) goto caBUp; else goto caBV7;
       caBUp: // global
           I64[Sp + 40] = block_caBSf_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaBVQ; else goto caBSg;
       uaBVQ: // global
           call _caBSf(R1) args: 0, res: 0, upd: 0;
       caBSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBV7: // global
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBSf() //  [R1]
         { info_tbl: [(caBSf,
                       label: block_caBSf_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBSf: // global
           _saAPL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caBUs; else goto caBV1;
       caBUs: // global
           I64[Sp] = block_caBSk_info;
           R1 = P64[_saAPL::P64 + 8];
           if (R1 & 7 != 0) goto uaBVR; else goto caBSl;
       uaBVR: // global
           call _caBSk(R1) args: 0, res: 0, upd: 0;
       caBSl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caBV1: // global
           I64[Sp + 24] = block_caBUZ_info;
           R5 = _saAPL::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caBSk() //  [R1]
         { info_tbl: [(caBSk,
                       label: block_caBSk_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBSk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caBUv; else goto caBUu;
       caBUv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBUu: // global
           _saAPq::I64 = I64[Sp + 8];
           _saAQZ::P64 = P64[R1 + 7];
           _saAR1::P64 = P64[R1 + 15];
           _saAR0::I64 = I64[R1 + 23];
           _saAR2::I64 = _saAPq::I64 & (I64[_saAQZ::P64 + 8] - 1);
           _saAR7::P64 = P64[(_saAQZ::P64 + 24) + (_saAR2::I64 << 3)];
           I64[Hp - 8] = $wgo_saAR8_info;
           I64[Hp] = _saAPq::I64;
           I64[Sp - 8] = block_caBUw_info;
           R2 = _saAR7::P64;
           R1 = Hp - 7;
           I64[Sp] = _saAR2::I64;
           P64[Sp + 8] = _saAR1::P64;
           I64[Sp + 16] = _saAR0::I64;
           P64[Sp + 24] = _saAQZ::P64;
           Sp = Sp - 8;
           call $wgo_saAR8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBUw() //  [R1, R2, R3]
         { info_tbl: [(caBUw,
                       label: block_caBUw_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBUw: // global
           I64[Sp - 16] = block_caBUy_info;
           _saARm::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saARm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBVX; else goto caBUA;
       uaBVX: // global
           call _caBUy(R1) args: 0, res: 0, upd: 0;
       caBUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBUy() //  [R1]
         { info_tbl: [(caBUy,
                       label: block_caBUy_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBUy: // global
           if (R1 & 7 == 1) goto uaBVH; else goto caBUL;
       uaBVH: // global
           Sp = Sp + 56;
           call _caBUS() args: 0, res: 0, upd: 0;
       caBUL: // global
           _saAQZ::P64 = P64[Sp + 48];
           _saAR2::I64 = I64[Sp + 24];
           _saARm::P64 = P64[Sp + 16];
           _saARo::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAQZ::P64 + 24) + (_saAR2::I64 << 3)] = _saARo::P64;
           I64[_saAQZ::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAQZ::P64 + 24) + ((I64[_saAQZ::P64 + 8] << 3) + (_saAR2::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caBUJ_info;
           R1 = _saARm::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaBVY; else goto caBUM;
       uaBVY: // global
           call _caBUJ(R1) args: 0, res: 0, upd: 0;
       caBUM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBUJ() //  [R1]
         { info_tbl: [(caBUJ,
                       label: block_caBUJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBUJ: // global
           if (R1 & 7 == 1) goto uaBVI; else goto caBUW;
       uaBVI: // global
           Sp = Sp + 32;
           call _caBUS() args: 0, res: 0, upd: 0;
       caBUW: // global
           _saAR0::I64 = I64[Sp + 16];
           _saAR1::P64 = P64[Sp + 8];
           I64[_saAR0::I64] = I64[_saAR0::I64] - 1;
           call MO_Touch(_saAR1::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBUS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBUS: // global
           R1 = lvl10_raAuh_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBUZ() //  []
         { info_tbl: [(caBUZ,
                       label: block_caBUZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBUZ: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saARG_entry() //  [R1, R2]
         { info_tbl: [(caBWc,
                       label: io_saARG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBWd; else goto caBWe;
       caBWd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBWe: // global
           I64[Sp - 16] = block_caBW9_info;
           _saAPK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAPK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaBWi; else goto caBWa;
       uaBWi: // global
           call _caBW9(R1) args: 0, res: 0, upd: 0;
       caBWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBW9() //  [R1]
         { info_tbl: [(caBW9,
                       label: block_caBW9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBW9: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAPK_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARU_entry() //  [R1, R2]
         { info_tbl: [(caBWu,
                       label: sat_saARU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBWv; else goto caBWw;
       caBWv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBWw: // global
           I64[Sp - 16] = block_caBWs_info;
           _saARR::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saARR::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBWs() //  []
         { info_tbl: [(caBWs,
                       label: block_caBWs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARP_entry() //  [R1]
         { info_tbl: [(caBWD,
                       label: sat_saARP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWD: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARQ_entry() //  [R1]
         { info_tbl: [(caBWL,
                       label: sat_saARQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWL: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASh_entry() //  [R1, R2]
         { info_tbl: [(caBX3,
                       label: sat_saASh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBX4; else goto caBX5;
       caBX4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBX5: // global
           I64[Sp - 16] = block_caBX1_info;
           _saASe::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saASe::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBX1() //  []
         { info_tbl: [(caBX1,
                       label: block_caBX1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBX1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASc_entry() //  [R1]
         { info_tbl: [(caBXc,
                       label: sat_saASc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXc: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASd_entry() //  [R1]
         { info_tbl: [(caBXk,
                       label: sat_saASd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXk: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASm_entry() //  [R1]
         { info_tbl: [(caBXr,
                       label: sat_saASm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBXs; else goto caBXt;
       caBXs: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caBXt: // global
           I64[Sp - 24] = block_caBWU_info;
           _saAPI::P64 = P64[R1 + 7];
           _saARG::P64 = P64[R1 + 15];
           R1 = _saAPI::P64;
           P64[Sp - 16] = _saAPI::P64;
           P64[Sp - 8] = _saARG::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBWU() //  [R1]
         { info_tbl: [(caBWU,
                       label: block_caBWU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBXw; else goto caBXv;
       caBXw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBXv: // global
           I64[Hp - 56] = sat_saASh_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saASc_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saASd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBXn_info;
           R2 = Hp - 54;
           _saASb::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saASb::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBXn() //  [R1]
         { info_tbl: [(caBXn,
                       label: block_caBXn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXn: // global
           _saAPI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBXp_info;
           R2 = P64[Sp + 16];
           _saASk::P64 = R1;
           R1 = _saAPI::P64;
           P64[Sp + 16] = _saASk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBXp() //  []
         { info_tbl: [(caBXp,
                       label: block_caBXp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASH_entry() //  [R1, R2]
         { info_tbl: [(caBXJ,
                       label: sat_saASH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBXK; else goto caBXL;
       caBXK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caBXL: // global
           I64[Sp - 16] = block_caBXH_info;
           _saASE::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saASE::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBXH() //  []
         { info_tbl: [(caBXH,
                       label: block_caBXH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASC_entry() //  [R1]
         { info_tbl: [(caBXS,
                       label: sat_saASC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXS: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASD_entry() //  [R1]
         { info_tbl: [(caBY0,
                       label: sat_saASD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBY0: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 registerFd1_raAuk_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caBY3,
                       label: registerFd1_raAuk_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBY3: // global
           if ((Sp + -120) < SpLim) (likely: False) goto caBY4; else goto caBY5;
       caBY4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = registerFd1_raAuk_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBY5: // global
           I64[Sp - 40] = block_caBPq_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaC0N; else goto caBPr;
       uaC0N: // global
           call _caBPq(R1) args: 0, res: 0, upd: 0;
       caBPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBPq() //  [R1]
         { info_tbl: [(caBPq,
                       label: block_caBPq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPq: // global
           I64[Sp - 32] = block_caBPv_info;
           _saAOZ::P64 = P64[R1 + 7];
           _saAP1::P64 = P64[R1 + 23];
           _saAP3::P64 = P64[R1 + 31];
           _saAP5::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _saAP1::P64;
           P64[Sp - 16] = _saAP3::P64;
           P64[Sp - 8] = _saAP5::P64;
           P64[Sp] = _saAOZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaC0G; else goto caBPw;
       uaC0G: // global
           call _caBPv(R1) args: 0, res: 0, upd: 0;
       caBPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBPv() //  [R1]
         { info_tbl: [(caBPv,
                       label: block_caBPv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPv: // global
           I64[Sp - 8] = block_caBPA_info;
           _saAPc::P64 = R1;
           _saAPd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAPd::I64;
           P64[Sp + 8] = _saAPc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaC0H; else goto caBPB;
       uaC0H: // global
           call _caBPA(R1) args: 0, res: 0, upd: 0;
       caBPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBPA() //  [R1]
         { info_tbl: [(caBPA,
                       label: block_caBPA_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPA: // global
           I64[Sp - 8] = block_caBPF_info;
           _saAPe::P64 = R1;
           _saAPf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saAPf::I64;
           P64[Sp + 40] = _saAPe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaC0I; else goto caBPG;
       uaC0I: // global
           call _caBPF(R1) args: 0, res: 0, upd: 0;
       caBPG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBPF() //  [R1]
         { info_tbl: [(caBPF,
                       label: block_caBPF_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPF: // global
           _saAOU::P64 = P64[Sp + 64];
           _saAPh::P64 = P64[R1 + 7];
           _saAPj::P64 = P64[R1 + 23];
           _saAPk::P64 = P64[R1 + 31];
           (_saAPo::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 40] + 16, 1);
           I64[Sp - 16] = block_caBPM_info;
           R1 = _saAOU::P64;
           I64[Sp - 8] = _saAPo::I64;
           P64[Sp] = _saAPk::P64;
           P64[Sp + 40] = _saAPj::P64;
           P64[Sp + 64] = _saAPh::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaC0J; else goto caBPN;
       uaC0J: // global
           call _caBPM(R1) args: 0, res: 0, upd: 0;
       caBPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBPM() //  [R1]
         { info_tbl: [(caBPM,
                       label: block_caBPM_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPM: // global
           I64[Sp - 8] = block_caBPR_info;
           _saAPp::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saAPq::I64;
           P64[Sp + 88] = _saAPp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaC0K; else goto caBPS;
       uaC0K: // global
           call _caBPR(R1) args: 0, res: 0, upd: 0;
       caBPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBPR() //  [R1]
         { info_tbl: [(caBPR,
                       label: block_caBPR_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBPR: // global
           I64[Sp - 8] = block_caBYb_info;
           _saAPr::P64 = R1;
           _saAPs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 104];
           I64[Sp] = _saAPs::I64;
           P64[Sp + 104] = _saAPr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaC0L; else goto caC0p;
       uaC0L: // global
           call _caBYb(R1) args: 0, res: 0, upd: 0;
       caC0p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYb() //  [R1]
         { info_tbl: [(caBYb,
                       label: block_caBYb_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYb: // global
           _saAOT::P64 = P64[Sp + 88];
           _saAPs::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caC0v; else goto caC0z;
       caC0v: // global
           _saAPu::I64 = _saAPs::I64;
           goto saAPt;
       caC0z: // global
           _saAPu::I64 = _saAPs::I64 | 8;
           goto saAPt;
       saAPt: // global
           I64[Sp + 8] = block_caBQ1_info;
           R1 = _saAOT::P64;
           I64[Sp + 88] = _saAPu::I64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBQ1() //  [R1]
         { info_tbl: [(caBQ1,
                       label: block_caBQ1_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQ1: // global
           I64[Sp - 8] = block_caBQ3_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caBQ3() //  [R1]
         { info_tbl: [(caBQ3,
                       label: block_caBQ3_info
                       rep:StackRep [False, True, True, False, True, True, False, False,
                                     False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQ3: // global
           _saAPc::P64 = P64[Sp + 56];
           _saAPd::I64 = I64[Sp + 48];
           _saAPe::P64 = P64[Sp + 80];
           _saAPz::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saAPd::I64,
                            _saAPz::I64)) goto caBYj; else goto caC0o;
       caC0o: // global
           if (%MO_S_Gt_W64(_saAPz::I64,
                            I64[Sp + 40])) goto caBYj; else goto caBYk;
       caBYj: // global
           R4 = _saAPz::I64;
           R3 = _saAPc::P64;
           R2 = _saAPe::P64;
           Sp = Sp + 120;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caBYk: // global
           _saAPG::P64 = P64[P64[Sp + 64] + ((_saAPz::I64 - _saAPd::I64 << 3) + 24)];
           I64[Sp] = block_caBQj_info;
           _saAPy::I64 = R1;
           R1 = _saAPG::P64;
           I64[Sp + 80] = _saAPy::I64;
           if (R1 & 7 != 0) goto uaC0M; else goto caBQk;
       uaC0M: // global
           call _caBQj(R1) args: 0, res: 0, upd: 0;
       caBQk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBQj() //  [R1]
         { info_tbl: [(caBQj,
                       label: block_caBQj_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBQj: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto caBYn; else goto caBYm;
       caBYn: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBYm: // global
           _saAPI::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.Event.Manager.FdKey_con_info;
           _saAPq::I64 = I64[Sp + 16];
           I64[Hp - 120] = _saAPq::I64;
           _saAPo::I64 = I64[Sp + 24];
           I64[Hp - 112] = _saAPo::I64;
           I64[Hp - 104] = $wio_saAPK_info;
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = _saAPo::I64;
           I64[Hp - 48] = _saAPq::I64;
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = io_saARG_info;
           P64[Hp - 24] = Hp - 102;
           _caBQo::P64 = Hp - 127;
           _caBW4::P64 = Hp - 30;
           _saARL::I64 = I64[Sp + 80];
           if (_saARL::I64 != 0) goto uaC0F; else goto caBZ9;
       uaC0F: // global
           if (_saARL::I64 != 1) goto caBYu; else goto caBZM;
       caBYu: // global
           Hp = Hp - 24;
           I64[Sp] = block_caBWl_info;
           R1 = _saAPI::P64;
           P64[Sp + 88] = _saAPI::P64;
           P64[Sp + 96] = _caBW4::P64;
           P64[Sp + 104] = _caBQo::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caBZM: // global
           Hp = Hp - 24;
           I64[Sp] = block_caBXA_info;
           R1 = _saAPI::P64;
           P64[Sp + 88] = _saAPI::P64;
           P64[Sp + 96] = _caBW4::P64;
           P64[Sp + 104] = _caBQo::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caBZ9: // global
           I64[Hp - 16] = sat_saASm_info;
           P64[Hp - 8] = _saAPI::P64;
           P64[Hp] = _caBW4::P64;
           I64[Sp] = block_caBZ6_info;
           R1 = Hp - 15;
           P64[Sp + 104] = _caBQo::P64;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBWl() //  [R1]
         { info_tbl: [(caBWl,
                       label: block_caBWl_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBWl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBYx; else goto caBYw;
       caBYx: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBYw: // global
           I64[Hp - 56] = sat_saARU_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saARP_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saARQ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBYo_info;
           R2 = Hp - 54;
           _saARO::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saARO::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYo() //  [R1]
         { info_tbl: [(caBYo,
                       label: block_caBYo_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYo: // global
           I64[Sp] = block_caBYq_info;
           R2 = P64[Sp + 96];
           _saARX::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saARX::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYq() //  []
         { info_tbl: [(caBYq,
                       label: block_caBYq_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYq: // global
           I64[Sp] = block_caBYs_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaC0O; else goto caBYA;
       uaC0O: // global
           call _caBYs(R1) args: 0, res: 0, upd: 0;
       caBYA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYs() //  [R1]
         { info_tbl: [(caBYs,
                       label: block_caBYs_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYs: // global
           I64[Sp] = block_caBYE_info;
           _saAS0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saAS0::P64;
           if (R1 & 7 != 0) goto uaC0P; else goto caBYG;
       uaC0P: // global
           call _caBYE(R1) args: 0, res: 0, upd: 0;
       caBYG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYE() //  [R1]
         { info_tbl: [(caBYE,
                       label: block_caBYE_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYE: // global
           if (R1 & 7 == 1) goto caBYP; else goto caBZ0;
       caBYP: // global
           I64[Sp + 88] = block_caBYK_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBZ0: // global
           _saAS0::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caBYY_info;
           R1 = _saAS0::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaC0Q; else goto caBZ1;
       uaC0Q: // global
           call _caBYY() args: 0, res: 0, upd: 0;
       caBZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYK() //  []
         { info_tbl: [(caBYK,
                       label: block_caBYK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYK: // global
           _saAS0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBYM_info;
           R1 = _saAS0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaC0R; else goto caBYR;
       uaC0R: // global
           call _caBYM() args: 0, res: 0, upd: 0;
       caBYR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBYM() //  []
         { info_tbl: [(caBYM,
                       label: block_caBYM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBYY() //  []
         { info_tbl: [(caBYY,
                       label: block_caBYY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBYY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBXA() //  [R1]
         { info_tbl: [(caBXA,
                       label: block_caBXA_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBXA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caBZP; else goto caBZO;
       caBZP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBZO: // global
           I64[Hp - 56] = sat_saASH_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saASC_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saASD_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caBZH_info;
           R2 = Hp - 54;
           _saASB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saASB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZH() //  [R1]
         { info_tbl: [(caBZH,
                       label: block_caBZH_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZH: // global
           I64[Sp] = block_caBZJ_info;
           R2 = P64[Sp + 96];
           _saASK::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saASK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZJ() //  []
         { info_tbl: [(caBZJ,
                       label: block_caBZJ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZJ: // global
           I64[Sp] = block_caBZL_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaC0W; else goto caBZS;
       uaC0W: // global
           call _caBZL(R1) args: 0, res: 0, upd: 0;
       caBZS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZL() //  [R1]
         { info_tbl: [(caBZL,
                       label: block_caBZL_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZL: // global
           I64[Sp] = block_caBZW_info;
           _saASN::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saASN::P64;
           if (R1 & 7 != 0) goto uaC0X; else goto caBZY;
       uaC0X: // global
           call _caBZW(R1) args: 0, res: 0, upd: 0;
       caBZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZW() //  [R1]
         { info_tbl: [(caBZW,
                       label: block_caBZW_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZW: // global
           if (R1 & 7 == 1) goto caC07; else goto caC0i;
       caC07: // global
           I64[Sp + 88] = block_caC02_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caC0i: // global
           _saASN::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caC0g_info;
           R1 = _saASN::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaC0Y; else goto caC0j;
       uaC0Y: // global
           call _caC0g() args: 0, res: 0, upd: 0;
       caC0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC02() //  []
         { info_tbl: [(caC02,
                       label: block_caC02_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC02: // global
           _saASN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caC04_info;
           R1 = _saASN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaC0Z; else goto caC09;
       uaC0Z: // global
           call _caC04() args: 0, res: 0, upd: 0;
       caC09: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC04() //  []
         { info_tbl: [(caC04,
                       label: block_caC04_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC04: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caC0g() //  []
         { info_tbl: [(caC0g,
                       label: block_caC0g_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC0g: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBZ6() //  [R1]
         { info_tbl: [(caBZ6,
                       label: block_caBZ6_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZ6: // global
           I64[Sp] = block_caBZ8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaC0S; else goto caBZb;
       uaC0S: // global
           call _caBZ8(R1) args: 0, res: 0, upd: 0;
       caBZb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZ8() //  [R1]
         { info_tbl: [(caBZ8,
                       label: block_caBZ8_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZ8: // global
           I64[Sp] = block_caBZf_info;
           _saASr::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saASr::P64;
           if (R1 & 7 != 0) goto uaC0T; else goto caBZh;
       uaC0T: // global
           call _caBZf(R1) args: 0, res: 0, upd: 0;
       caBZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZf() //  [R1]
         { info_tbl: [(caBZf,
                       label: block_caBZf_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZf: // global
           if (R1 & 7 == 1) goto caBZq; else goto caBZB;
       caBZq: // global
           I64[Sp + 88] = block_caBZl_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caBZB: // global
           _saASr::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caBZz_info;
           R1 = _saASr::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaC0U; else goto caBZC;
       uaC0U: // global
           call _caBZz() args: 0, res: 0, upd: 0;
       caBZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZl() //  []
         { info_tbl: [(caBZl,
                       label: block_caBZl_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZl: // global
           _saASr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caBZn_info;
           R1 = _saASr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaC0V; else goto caBZs;
       uaC0V: // global
           call _caBZn() args: 0, res: 0, upd: 0;
       caBZs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBZn() //  []
         { info_tbl: [(caBZn,
                       label: block_caBZn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBZz() //  []
         { info_tbl: [(caBZz,
                       label: block_caBZz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBZz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.535585356 UTC

[section ""data" . GHC.Event.Manager.registerFd_closure" {
     GHC.Event.Manager.registerFd_closure:
         const GHC.Event.Manager.registerFd_info;
         const 0;
 },
 GHC.Event.Manager.registerFd_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caC14,
                       label: GHC.Event.Manager.registerFd_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC14: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call registerFd1_raAuk_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.536453914 UTC

[section ""cstring" . lvl13_raAul_bytes" {
     lvl13_raAul_bytes:
         I8[] [117,110,114,101,103,105,115,116,101,114,70,100,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.537311476 UTC

[section ""data" . lvl14_raAum_closure" {
     lvl14_raAum_closure:
         const lvl14_raAum_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_raAum_entry() //  [R1]
         { info_tbl: [(caC1d,
                       label: lvl14_raAum_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caC1e; else goto caC1f;
       caC1e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caC1f: // global
           (_caC1a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caC1a::I64 == 0) goto caC1c; else goto caC1b;
       caC1c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caC1b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caC1a::I64;
           R2 = lvl13_raAul_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.538258369 UTC

[section ""data" . lvl15_raAun_closure" {
     lvl15_raAun_closure:
         const lvl15_raAun_info;
         const 0;
 },
 lvl15_raAun_entry() //  [R2]
         { info_tbl: [(caC1k,
                       label: lvl15_raAun_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1k: // global
           R3 = R2;
           R2 = lvl14_raAum_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.546447642 UTC

[section ""data" . GHC.Event.Manager.unregisterFd2_closure" {
     GHC.Event.Manager.unregisterFd2_closure:
         const GHC.Event.Manager.unregisterFd2_info;
         const 0;
 },
 g_saATV_entry() //  [R1, R2]
         { info_tbl: [(caC2C,
                       label: g_saATV_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC2C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caC2D; else goto caC2E;
       caC2D: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC2E: // global
           I64[Sp - 16] = block_caC2z_info;
           _saATr::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _saATr::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaC2J; else goto caC2A;
       uaC2J: // global
           call _caC2z(R1) args: 0, res: 0, upd: 0;
       caC2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC2z() //  [R1]
         { info_tbl: [(caC2z,
                       label: block_caC2z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC2z: // global
           R1 = I64[((I64[R1 + 23] != I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saAU3_entry() //  [R1, R2]
         { info_tbl: [(caC2W,
                       label: $wgo_saAU3_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC2W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caC2X; else goto caC2Y;
       caC2X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC2Y: // global
           I64[Sp - 32] = block_caC2P_info;
           _saAU3::P64 = R1;
           _saATV::P64 = P64[R1 + 7];
           _saATq::I64 = I64[R1 + 15];
           R1 = R2;
           I64[Sp - 24] = _saATq::I64;
           P64[Sp - 16] = _saATV::P64;
           P64[Sp - 8] = _saAU3::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaC3B; else goto caC2Q;
       uaC3B: // global
           call _caC2P(R1) args: 0, res: 0, upd: 0;
       caC2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC2P() //  [R1]
         { info_tbl: [(caC2P,
                       label: block_caC2P_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC2P: // global
           if (R1 & 7 == 1) goto caC2T; else goto caC2U;
       caC2T: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caC2U: // global
           _saAU7::P64 = P64[R1 + 6];
           _saAU8::P64 = P64[R1 + 14];
           _saAU6::I64 = I64[R1 + 22];
           if (_saAU6::I64 == I64[Sp + 8]) goto caC3i; else goto caC3c;
       caC3i: // global
           I64[Sp] = block_caC3h_info;
           R3 = _saAU7::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 8] = _saAU8::P64;
           P64[Sp + 16] = _saAU7::P64;
           I64[Sp + 24] = _saAU6::I64;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 8;
       caC3c: // global
           I64[Sp + 8] = block_caC38_info;
           R2 = _saAU8::P64;
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _saAU7::P64;
           I64[Sp + 24] = _saAU6::I64;
           Sp = Sp + 8;
           call $wgo_saAU3_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC3h() //  [R1]
         { info_tbl: [(caC3h,
                       label: block_caC3h_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC3h: // global
           _saAU7::P64 = P64[Sp + 16];
           _saAU8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto caC3o; else goto caC3w;
       caC3o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caC3r; else goto caC3q;
       caC3r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC3q: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU7::P64;
           R3 = _saAU8::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caC3w: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caC3z; else goto caC3y;
       caC3z: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC3y: // global
           I64[Hp - 40] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = _saAU8::P64;
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU7::P64;
           R3 = Hp - 38;
           R2 = Hp - 6;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caC38() //  [R1, R2, R3]
         { info_tbl: [(caC38,
                       label: block_caC38_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC38: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caC3f; else goto caC3e;
       caC3f: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caC3e: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_saAV6_entry() //  [R1, R2]
         { info_tbl: [(caC4h,
                       label: go_saAV6_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC4h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caC4i; else goto uaC4A;
       caC4i: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaC4A: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _caC47() args: 0, res: 0, upd: 0;
     }
 },
 _caC47() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC47: // global
           _saATq::I64 = I64[P64[Sp] + 7];
           I64[Sp - 8] = block_caC4a_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saATq::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaC4C; else goto caC4b;
       uaC4C: // global
           call _caC4a(R1) args: 0, res: 0, upd: 0;
       caC4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC4a() //  [R1]
         { info_tbl: [(caC4a,
                       label: block_caC4a_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC4a: // global
           if (R1 & 7 == 1) goto caC4e; else goto caC4f;
       caC4e: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caC4f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caC4r; else goto caC4q;
       caC4r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC4q: // global
           if (I64[R1 + 22] == I64[Sp + 16]) goto caC4z; else goto caC4v;
       caC4z: // global
           _saAVa::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAVa::P64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caC4v: // global
           _saAVb::P64 = P64[R1 + 14];
           Hp = Hp - 16;
           P64[Sp + 16] = _saAVb::P64;
           Sp = Sp + 8;
           call _caC47() args: 0, res: 0, upd: 0;
     }
 },
 $wio_saATF_entry() //  [R1, R2]
         { info_tbl: [(caC4F,
                       label: $wio_saATF_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC4F: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caC4G; else goto caC4H;
       caC4G: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC4H: // global
           I64[Sp - 56] = block_caC2g_info;
           _saATk::P64 = P64[R1 + 6];
           _saATm::P64 = P64[R1 + 14];
           _saATn::P64 = P64[R1 + 22];
           _saATq::I64 = I64[R1 + 30];
           _saATr::I64 = I64[R1 + 38];
           R1 = P64[R2 + 8];
           P64[Sp - 48] = _saATk::P64;
           P64[Sp - 40] = _saATm::P64;
           P64[Sp - 32] = _saATn::P64;
           I64[Sp - 24] = _saATq::I64;
           I64[Sp - 16] = _saATr::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaC7l; else goto caC2h;
       uaC7l: // global
           call _caC2g(R1) args: 0, res: 0, upd: 0;
       caC2h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC2g() //  [R1]
         { info_tbl: [(caC2g,
                       label: block_caC2g_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC2g: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caC4K; else goto caC4J;
       caC4K: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC4J: // global
           _saATq::I64 = I64[Sp + 32];
           _saATM::P64 = P64[R1 + 7];
           _saATO::P64 = P64[R1 + 15];
           _saATN::I64 = I64[R1 + 23];
           _saATP::I64 = _saATq::I64 & (I64[_saATM::P64 + 8] - 1);
           _saATU::P64 = P64[(_saATM::P64 + 24) + (_saATP::I64 << 3)];
           I64[Hp - 32] = g_saATV_info;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = $wgo_saAU3_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _saATq::I64;
           I64[Sp - 24] = block_caC3C_info;
           R2 = _saATU::P64;
           R1 = Hp - 15;
           P64[Sp - 16] = _saATO::P64;
           I64[Sp - 8] = _saATP::I64;
           I64[Sp] = _saATN::I64;
           P64[Sp + 40] = _saATM::P64;
           Sp = Sp - 24;
           call $wgo_saAU3_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC3C() //  [R1, R2, R3]
         { info_tbl: [(caC3C,
                       label: block_caC3C_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC3C: // global
           I64[Sp - 16] = block_caC4L_info;
           _saAUm::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAUm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaC7i; else goto caC6A;
       uaC7i: // global
           call _caC4L(R1) args: 0, res: 0, upd: 0;
       caC6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC4L() //  [R1]
         { info_tbl: [(caC4L,
                       label: block_caC4L_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC4L: // global
           if (R1 & 7 == 1) goto caC6G; else goto caC6L;
       caC6G: // global
           P64[Sp + 80] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAUp() args: 0, res: 0, upd: 0;
       caC6L: // global
           _saATM::P64 = P64[Sp + 80];
           _saATP::I64 = I64[Sp + 32];
           _saAUm::P64 = P64[Sp + 16];
           _saAUo::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saATM::P64 + 24) + (_saATP::I64 << 3)] = _saAUo::P64;
           I64[_saATM::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saATM::P64 + 24) + ((I64[_saATM::P64 + 8] << 3) + (_saATP::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caC6J_info;
           _saAVi::P64 = R1;
           R1 = _saAUm::P64;
           P64[Sp + 80] = _saAVi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaC7m; else goto caC6M;
       uaC7m: // global
           call _caC6J(R1) args: 0, res: 0, upd: 0;
       caC6M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC6J() //  [R1]
         { info_tbl: [(caC6J,
                       label: block_caC6J_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC6J: // global
           _saAVi::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto caC6S; else goto caC6W;
       caC6S: // global
           P64[Sp + 64] = _saAVi::P64;
           Sp = Sp + 32;
           goto uaC7z;
       caC6W: // global
           _saATN::I64 = I64[Sp + 24];
           _saATO::P64 = P64[Sp + 8];
           I64[_saATN::I64] = I64[_saATN::I64] - 1;
           call MO_Touch(_saATO::P64);
           P64[Sp + 64] = _saAVi::P64;
           Sp = Sp + 32;
           goto uaC7z;
       uaC7z: // global
           call _saAUp() args: 0, res: 0, upd: 0;
     }
 },
 _saAUp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAUp: // global
           I64[Sp - 8] = block_caC3L_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaC7A; else goto caC3M;
       uaC7A: // global
           call _caC3L(R1) args: 0, res: 0, upd: 0;
       caC3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC3L() //  [R1]
         { info_tbl: [(caC3L,
                       label: block_caC3L_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC3L: // global
           if (R1 & 7 == 1) goto caC63; else goto caC6a;
       caC63: // global
           I64[Sp + 48] = 0;
           I64[Sp + 40] = 0;
           call _caC4O() args: 0, res: 0, upd: 0;
       caC6a: // global
           _saAUV::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp] = block_caC3R_info;
           _saAUS::P64 = P64[R1 + 6];
           R1 = _saAUV::P64;
           P64[Sp + 48] = _saAUS::P64;
           if (R1 & 7 != 0) goto uaC7j; else goto caC3S;
       uaC7j: // global
           call _caC3R(R1) args: 0, res: 0, upd: 0;
       caC3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC3R() //  [R1]
         { info_tbl: [(caC3R,
                       label: block_caC3R_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC3R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caC6d; else goto caC6c;
       caC6d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC6c: // global
           _saATq::I64 = I64[Sp + 32];
           _saAUX::P64 = P64[R1 + 7];
           _saAV5::P64 = P64[(_saAUX::P64 + 24) + (_saATq::I64 & (I64[_saAUX::P64 + 8] - 1) << 3)];
           I64[Hp - 8] = go_saAV6_info;
           I64[Hp] = _saATq::I64;
           I64[Sp] = block_caC64_info;
           R2 = _saAV5::P64;
           R1 = Hp - 7;
           call go_saAV6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC64() //  [R1]
         { info_tbl: [(caC64,
                       label: block_caC64_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC64: // global
           I64[Sp] = block_caC68_info;
           R2 = P64[Sp + 48];
           P64[Sp + 48] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caC68() //  [R1]
         { info_tbl: [(caC68,
                       label: block_caC68_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC68: // global
           I64[Sp] = block_caC6i_info;
           _saAVe::I64 = R1;
           R1 = P64[Sp + 48];
           I64[Sp + 48] = _saAVe::I64;
           if (R1 & 7 != 0) goto uaC7v; else goto caC6k;
       uaC7v: // global
           call _caC6i(R1) args: 0, res: 0, upd: 0;
       caC6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC6i() //  [R1]
         { info_tbl: [(caC6i,
                       label: block_caC6i_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC6i: // global
           if (R1 & 7 == 1) goto caC6q; else goto caC6v;
       caC6q: // global
           I64[Sp + 48] = I64[Sp + 48];
           I64[Sp + 40] = 0;
           call _caC4O() args: 0, res: 0, upd: 0;
       caC6v: // global
           I64[Sp] = block_caC6t_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caC6t() //  [R1]
         { info_tbl: [(caC6t,
                       label: block_caC6t_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC6t: // global
           I64[Sp + 40] = R1;
           I64[Sp + 48] = I64[Sp + 48];
           call _caC4O() args: 0, res: 0, upd: 0;
     }
 },
 _caC4O() //  []
         { info_tbl: [(caC4O,
                       label: block_caC4O_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC4O: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caC4T; else goto caC4S;
       caC4T: // global
           HpAlloc = 32;
           I64[Sp] = block_caC4O_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caC4S: // global
           _saAUv::I64 = I64[Sp + 40];
           if (I64[Sp + 48] == _saAUv::I64) goto caC4X; else goto caC5Z;
       caC4X: // global
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caC5Z: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = I64[Sp + 32];
           _caC50::P64 = Hp - 23;
           if (_saAUv::I64 & 8 != 0) goto caC5X; else goto caC5Y;
       caC5Y: // global
           _saAUK::I64 = _saAUv::I64 & 7;
           if (_saAUK::I64 == 0) goto caC5X; else goto caC5K;
       caC5X: // global
           Hp = Hp - 16;
           P64[Sp + 24] = _caC50::P64;
           call _caC54() args: 0, res: 0, upd: 0;
       caC5K: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAUK::I64;
           _saATn::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caC5G_info;
           R4 = Hp - 7;
           R3 = _caC50::P64;
           R2 = P64[Sp + 8];
           R1 = _saATn::P64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC5G() //  [R1]
         { info_tbl: [(caC5G,
                       label: block_caC5G_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC5G: // global
           I64[Sp] = block_caC5I_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaC7s; else goto caC5M;
       uaC7s: // global
           call _caC5I(R1) args: 0, res: 0, upd: 0;
       caC5M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC5I() //  [R1]
         { info_tbl: [(caC5I,
                       label: block_caC5I_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC5I: // global
           if (R1 & 7 == 1) goto uaC7d; else goto uaC7e;
       uaC7d: // global
           Sp = Sp + 8;
           call _caC5S() args: 0, res: 0, upd: 0;
       uaC7e: // global
           Sp = Sp + 32;
           call _caC5W() args: 0, res: 0, upd: 0;
     }
 },
 _caC54() //  []
         { info_tbl: [(caC54,
                       label: block_caC54_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC54: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caC58; else goto caC57;
       caC58: // global
           HpAlloc = 32;
           I64[Sp] = block_caC54_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caC57: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 40] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           _caC50::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caC5h_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _caC50::P64;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_v_info;
           Sp = Sp + 16;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caC5h() //  [R1]
         { info_tbl: [(caC5h,
                       label: block_caC5h_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC5h: // global
           I64[Sp] = block_caC5j_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaC7p; else goto caC5l;
       uaC7p: // global
           call _caC5j(R1) args: 0, res: 0, upd: 0;
       caC5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC5j() //  [R1]
         { info_tbl: [(caC5j,
                       label: block_caC5j_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC5j: // global
           if (R1 & 7 == 1) goto uaC7g; else goto uaC7h;
       uaC7g: // global
           Sp = Sp + 8;
           call _caC5S() args: 0, res: 0, upd: 0;
       uaC7h: // global
           Sp = Sp + 32;
           call _caC5W() args: 0, res: 0, upd: 0;
     }
 },
 _caC5S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC5S: // global
           R2 = I64[Sp];
           Sp = Sp + 24;
           call lvl15_raAun_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caC5W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC5W: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAVs_entry() //  [R1, R2]
         { info_tbl: [(caC7J,
                       label: io_saAVs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC7J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caC7K; else goto caC7L;
       caC7K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC7L: // global
           I64[Sp - 16] = block_caC7G_info;
           _saATF::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saATF::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaC7P; else goto caC7H;
       uaC7P: // global
           call _caC7G(R1) args: 0, res: 0, upd: 0;
       caC7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC7G() //  [R1]
         { info_tbl: [(caC7G,
                       label: block_caC7G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC7G: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saATF_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVG_entry() //  [R1, R2]
         { info_tbl: [(caC81,
                       label: sat_saAVG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC81: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caC82; else goto caC83;
       caC82: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC83: // global
           I64[Sp - 16] = block_caC7Z_info;
           _saAVD::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAVD::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC7Z() //  []
         { info_tbl: [(caC7Z,
                       label: block_caC7Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC7Z: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVB_entry() //  [R1]
         { info_tbl: [(caC8a,
                       label: sat_saAVB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8a: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVC_entry() //  [R1]
         { info_tbl: [(caC8i,
                       label: sat_saAVC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8i: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVU_entry() //  [R1, R2]
         { info_tbl: [(caC8A,
                       label: sat_saAVU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caC8B; else goto caC8C;
       caC8B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC8C: // global
           I64[Sp - 16] = block_caC8y_info;
           _saAVR::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAVR::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC8y() //  []
         { info_tbl: [(caC8y,
                       label: block_caC8y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8y: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVP_entry() //  [R1]
         { info_tbl: [(caC8J,
                       label: sat_saAVP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8J: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVQ_entry() //  [R1]
         { info_tbl: [(caC8R,
                       label: sat_saAVQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8R: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVZ_entry() //  [R1]
         { info_tbl: [(caC8Y,
                       label: sat_saAVZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caC8Z; else goto caC90;
       caC8Z: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caC90: // global
           I64[Sp - 24] = block_caC8r_info;
           _saATE::P64 = P64[R1 + 7];
           _saAVs::P64 = P64[R1 + 15];
           R1 = _saATE::P64;
           P64[Sp - 16] = _saATE::P64;
           P64[Sp - 8] = _saAVs::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC8r() //  [R1]
         { info_tbl: [(caC8r,
                       label: block_caC8r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8r: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caC93; else goto caC92;
       caC93: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC92: // global
           I64[Hp - 56] = sat_saAVU_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAVP_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAVQ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caC8U_info;
           R2 = Hp - 54;
           _saAVO::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAVO::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC8U() //  [R1]
         { info_tbl: [(caC8U,
                       label: block_caC8U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8U: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caC8W_info;
           R2 = P64[Sp + 16];
           _saAVX::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAVX::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC8W() //  []
         { info_tbl: [(caC8W,
                       label: block_caC8W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC8W: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW8_entry() //  [R1, R2]
         { info_tbl: [(caC9g,
                       label: sat_saAW8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caC9h; else goto caC9i;
       caC9h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caC9i: // global
           I64[Sp - 16] = block_caC9e_info;
           _saAW5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAW5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC9e() //  []
         { info_tbl: [(caC9e,
                       label: block_caC9e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9e: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW3_entry() //  [R1]
         { info_tbl: [(caC9p,
                       label: sat_saAW3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9p: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW4_entry() //  [R1]
         { info_tbl: [(caC9x,
                       label: sat_saAW4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9x: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.unregisterFd2_entry() //  [R2, R3]
         { info_tbl: [(caC9A,
                       label: GHC.Event.Manager.unregisterFd2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9A: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caC9B; else goto caC9C;
       caC9B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caC9C: // global
           I64[Sp - 16] = block_caC1r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCak; else goto caC1s;
       uaCak: // global
           call _caC1r(R1) args: 0, res: 0, upd: 0;
       caC1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC1r() //  [R1]
         { info_tbl: [(caC1r,
                       label: block_caC1r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1r: // global
           I64[Sp - 24] = block_caC1w_info;
           _saAT2::P64 = P64[R1 + 7];
           _saAT4::P64 = P64[R1 + 23];
           _saAT6::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saAT4::P64;
           P64[Sp - 8] = _saAT6::P64;
           P64[Sp] = _saAT2::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCaf; else goto caC1x;
       uaCaf: // global
           call _caC1w(R1) args: 0, res: 0, upd: 0;
       caC1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC1w() //  [R1]
         { info_tbl: [(caC1w,
                       label: block_caC1w_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1w: // global
           I64[Sp - 8] = block_caC1B_info;
           _saATf::P64 = R1;
           _saATg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saATg::I64;
           P64[Sp + 8] = _saATf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCag; else goto caC1C;
       uaCag: // global
           call _caC1B(R1) args: 0, res: 0, upd: 0;
       caC1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC1B() //  [R1]
         { info_tbl: [(caC1B,
                       label: block_caC1B_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1B: // global
           I64[Sp - 8] = block_caC1G_info;
           _saATh::P64 = R1;
           _saATi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saATi::I64;
           P64[Sp + 32] = _saATh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCah; else goto caC1H;
       uaCah: // global
           call _caC1G(R1) args: 0, res: 0, upd: 0;
       caC1H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC1G() //  [R1]
         { info_tbl: [(caC1G,
                       label: block_caC1G_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1G: // global
           I64[Sp - 16] = block_caC1L_info;
           _saATk::P64 = P64[R1 + 7];
           _saATm::P64 = P64[R1 + 23];
           _saATn::P64 = P64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saATn::P64;
           P64[Sp] = _saATm::P64;
           P64[Sp + 48] = _saATk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCai; else goto caC1M;
       uaCai: // global
           call _caC1L(R1) args: 0, res: 0, upd: 0;
       caC1M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC1L() //  [R1]
         { info_tbl: [(caC1L,
                       label: block_caC1L_info
                       rep:StackRep [False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1L: // global
           I64[Sp - 16] = block_caC1Q_info;
           I64[Sp - 8] = I64[R1 + 15];
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caC1Q() //  [R1]
         { info_tbl: [(caC1Q,
                       label: block_caC1Q_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC1Q: // global
           _saATf::P64 = P64[Sp + 56];
           _saATg::I64 = I64[Sp + 48];
           _saATh::P64 = P64[Sp + 72];
           _saATv::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saATg::I64,
                            _saATv::I64)) goto caC9M; else goto caCad;
       caCad: // global
           if (%MO_S_Gt_W64(_saATv::I64,
                            I64[Sp + 40])) goto caC9M; else goto caC9N;
       caC9M: // global
           R4 = _saATv::I64;
           R3 = _saATf::P64;
           R2 = _saATh::P64;
           Sp = Sp + 88;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caC9N: // global
           _saATC::P64 = P64[P64[Sp + 64] + ((_saATv::I64 - _saATg::I64 << 3) + 24)];
           I64[Sp] = block_caC26_info;
           _saATu::I64 = R1;
           R1 = _saATC::P64;
           I64[Sp + 72] = _saATu::I64;
           if (R1 & 7 != 0) goto uaCaj; else goto caC27;
       uaCaj: // global
           call _caC26(R1) args: 0, res: 0, upd: 0;
       caC27: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC26() //  [R1]
         { info_tbl: [(caC26,
                       label: block_caC26_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC26: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caC9Q; else goto caC9P;
       caC9Q: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC9P: // global
           _saATE::P64 = P64[R1 + 7];
           I64[Hp - 80] = $wio_saATF_info;
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saAVs_info;
           P64[Hp - 24] = Hp - 78;
           _caC7B::P64 = Hp - 30;
           _saAVx::I64 = I64[Sp + 72];
           if (_saAVx::I64 != 0) goto uaCae; else goto caCa2;
       uaCae: // global
           if (_saAVx::I64 != 1) goto caC9V; else goto caCa6;
       caC9V: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caC7S_info;
           R1 = _saATE::P64;
           P64[Sp + 72] = _saATE::P64;
           P64[Sp + 80] = _caC7B::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caCa6: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caC97_info;
           R1 = _saATE::P64;
           P64[Sp + 72] = _saATE::P64;
           P64[Sp + 80] = _caC7B::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caCa2: // global
           I64[Hp - 16] = sat_saAVZ_info;
           P64[Hp - 8] = _saATE::P64;
           P64[Hp] = _caC7B::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caC7S() //  [R1]
         { info_tbl: [(caC7S,
                       label: block_caC7S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC7S: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caC9Y; else goto caC9X;
       caC9Y: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caC9X: // global
           I64[Hp - 56] = sat_saAVG_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAVB_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAVC_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caC9R_info;
           R2 = Hp - 54;
           _saAVA::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAVA::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC9R() //  [R1]
         { info_tbl: [(caC9R,
                       label: block_caC9R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9R: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caC9T_info;
           R2 = P64[Sp + 16];
           _saAVJ::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAVJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caC9T() //  []
         { info_tbl: [(caC9T,
                       label: block_caC9T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC9T: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caC97() //  [R1]
         { info_tbl: [(caC97,
                       label: block_caC97_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caC97: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCa9; else goto caCa8;
       caCa9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCa8: // global
           I64[Hp - 56] = sat_saAW8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAW3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAW4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCa3_info;
           R2 = Hp - 54;
           _saAW2::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAW2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCa3() //  [R1]
         { info_tbl: [(caCa3,
                       label: block_caCa3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCa3: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCa5_info;
           R2 = P64[Sp + 16];
           _saAWb::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAWb::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCa5() //  []
         { info_tbl: [(caCa5,
                       label: block_caCa5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCa5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.562233563 UTC

[section ""data" . GHC.Event.Manager.unregisterFd__closure" {
     GHC.Event.Manager.unregisterFd__closure:
         const GHC.Event.Manager.unregisterFd__info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd__entry() //  [R2, R3]
         { info_tbl: [(caCap,
                       label: GHC.Event.Manager.unregisterFd__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCap: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.563343544 UTC

[section ""data" . GHC.Event.Manager.unregisterFd1_closure" {
     GHC.Event.Manager.unregisterFd1_closure:
         const GHC.Event.Manager.unregisterFd1_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd1_entry() //  [R2, R3]
         { info_tbl: [(caCaB,
                       label: GHC.Event.Manager.unregisterFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCaB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCaC; else goto caCaD;
       caCaC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCaD: // global
           I64[Sp - 8] = block_caCaw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCaw() //  [R1]
         { info_tbl: [(caCaw,
                       label: block_caCaw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCaw: // global
           I64[Sp] = block_caCay_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCaI; else goto caCaz;
       uaCaI: // global
           call _caCay() args: 0, res: 0, upd: 0;
       caCaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCay() //  []
         { info_tbl: [(caCay,
                       label: block_caCay_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCay: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.564606229 UTC

[section ""data" . GHC.Event.Manager.unregisterFd_closure" {
     GHC.Event.Manager.unregisterFd_closure:
         const GHC.Event.Manager.unregisterFd_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd_entry() //  [R2, R3]
         { info_tbl: [(caCaN,
                       label: GHC.Event.Manager.unregisterFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCaN: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.565881088 UTC

[section ""data" . GHC.Event.Manager.EventManager_closure" {
     GHC.Event.Manager.EventManager_closure:
         const GHC.Event.Manager.EventManager_info;
 },
 GHC.Event.Manager.EventManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCaR: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Manager.EventManager_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 72, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.EventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caCaW,
                       label: GHC.Event.Manager.EventManager_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, False, True, False, False, False,
                                                    True, True, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCaW: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caCb0; else goto caCaZ;
       caCb0: // global
           HpAlloc = 112;
           R1 = GHC.Event.Manager.EventManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 112, res: 0, upd: 8;
       caCaZ: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 56];
           I64[Hp - 24] = R5;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           R1 = Hp - 103;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.56708839 UTC

[section ""data" . GHC.Event.Manager.Created_closure" {
     GHC.Event.Manager.Created_closure:
         const GHC.Event.Manager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.567653399 UTC

[section ""data" . GHC.Event.Manager.Running_closure" {
     GHC.Event.Manager.Running_closure:
         const GHC.Event.Manager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.568183673 UTC

[section ""data" . GHC.Event.Manager.Dying_closure" {
     GHC.Event.Manager.Dying_closure:
         const GHC.Event.Manager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.568752616 UTC

[section ""data" . GHC.Event.Manager.Releasing_closure" {
     GHC.Event.Manager.Releasing_closure:
         const GHC.Event.Manager.Releasing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.569380608 UTC

[section ""data" . GHC.Event.Manager.Finished_closure" {
     GHC.Event.Manager.Finished_closure:
         const GHC.Event.Manager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.570077405 UTC

[section ""data" . GHC.Event.Manager.FdKey_closure" {
     GHC.Event.Manager.FdKey_closure:
         const GHC.Event.Manager.FdKey_info;
 },
 GHC.Event.Manager.FdKey_entry() //  [R2, R3]
         { info_tbl: [(caCb6,
                       label: GHC.Event.Manager.FdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCb6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCba; else goto caCb9;
       caCba: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.FdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCb9: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.571199611 UTC

[section ""data" . GHC.Event.Manager.FdData_closure" {
     GHC.Event.Manager.FdData_closure:
         const GHC.Event.Manager.FdData_info;
 },
 GHC.Event.Manager.FdData_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbc: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.FdData_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.FdData_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caCbh,
                       label: GHC.Event.Manager.FdData_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caCbl; else goto caCbk;
       caCbl: // global
           HpAlloc = 40;
           R1 = GHC.Event.Manager.FdData_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caCbk: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.572295988 UTC

[GHC.Event.Manager.EventManager_con_entry() //  [R1]
         { info_tbl: [(caCbm,
                       label: GHC.Event.Manager.EventManager_con_info
                       rep:HeapRep 9 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,69,118,101,110,116,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.573033442 UTC

[section ""relreadonly" . GHC.Event.Manager.State_closure_tbl" {
     GHC.Event.Manager.State_closure_tbl:
         const GHC.Event.Manager.Created_closure+1;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Dying_closure+3;
         const GHC.Event.Manager.Releasing_closure+4;
         const GHC.Event.Manager.Finished_closure+5;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.57367166 UTC

[GHC.Event.Manager.Created_con_entry() //  [R1]
         { info_tbl: [(caCbn,
                       label: GHC.Event.Manager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.574422778 UTC

[GHC.Event.Manager.Running_con_entry() //  [R1]
         { info_tbl: [(caCbo,
                       label: GHC.Event.Manager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbo: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.575154526 UTC

[GHC.Event.Manager.Dying_con_entry() //  [R1]
         { info_tbl: [(caCbp,
                       label: GHC.Event.Manager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbp: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.575904623 UTC

[GHC.Event.Manager.Releasing_con_entry() //  [R1]
         { info_tbl: [(caCbq,
                       label: GHC.Event.Manager.Releasing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,101,108,101,97,115,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbq: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.576699705 UTC

[GHC.Event.Manager.Finished_con_entry() //  [R1]
         { info_tbl: [(caCbr,
                       label: GHC.Event.Manager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbr: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.577750451 UTC

[GHC.Event.Manager.FdKey_con_entry() //  [R1]
         { info_tbl: [(caCbs,
                       label: GHC.Event.Manager.FdKey_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,75,101,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbs: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.578702827 UTC

[GHC.Event.Manager.FdData_con_entry() //  [R1]
         { info_tbl: [(caCbt,
                       label: GHC.Event.Manager.FdData_con_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,68,97,116,97]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.579567757 UTC

[section ""relreadonly" . SaAZi_srt" {
     SaAZi_srt:
         const GHC.Event.Manager.$w$cshowsPrec1_closure;
         const GHC.Event.Manager.$fShowState1_closure;
         const GHC.Event.Manager.$fShowState3_closure;
         const GHC.Event.Manager.$fShowState5_closure;
         const GHC.Event.Manager.$fShowState7_closure;
         const GHC.Event.Manager.$fShowState9_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Manager.$w$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure;
         const GHC.Event.Manager.$fShowFdKey1_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.$fShowState_$cshow_closure;
         const GHC.Arr.$windexError_closure;
         const lvl2_raAu7_closure;
         const lvl3_raAu8_closure;
         const GHC.Event.Manager.callbackTableVar_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.Manager.release1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.Manager.shutdown1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const $wlvl_raAub_closure;
         const lvl7_raAud_closure;
         const GHC.Arr.arrEleBottom_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Manager.new3_closure;
         const GHC.Event.Manager.new1_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.closeFd_3_closure;
         const GHC.Event.Manager.eventsOf_closure;
         const GHC.Event.Manager.closeFd1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.Manager.loop5_closure;
         const GHC.Event.Manager.loop3_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Event.Manager.loop2_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Manager.closeFd_1_closure;
         const registerFd1_raAuk_closure;
         const lvl14_raAum_closure;
         const lvl15_raAun_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const GHC.Event.Manager.unregisterFd1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.580663709 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:32.582383236 UTC

[section ""data" . GHC.Event.Manager.$WEventManager_closure" {
     GHC.Event.Manager.$WEventManager_closure:
         const GHC.Event.Manager.$WEventManager_info;
 },
 GHC.Event.Manager.$WEventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caCbB,
                       label: GHC.Event.Manager.$WEventManager_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbB: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caCc4; else goto caCc5;
       caCc4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WEventManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caCc5: // global
           I64[Sp - 40] = block_caCby_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaCcf; else goto caCbz;
       uaCcf: // global
           call _caCby(R1) args: 0, res: 0, upd: 0;
       caCbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCby() //  [R1]
         { info_tbl: [(caCby,
                       label: block_caCby_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCby: // global
           I64[Sp] = block_caCbE_info;
           _saAuv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saAuv::P64;
           if (R1 & 7 != 0) goto uaCce; else goto caCbF;
       uaCce: // global
           call _caCbE(R1) args: 0, res: 0, upd: 0;
       caCbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCbE() //  [R1]
         { info_tbl: [(caCbE,
                       label: block_caCbE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbE: // global
           I64[Sp - 24] = block_caCbJ_info;
           _saAux::P64 = P64[R1 + 7];
           _saAuy::P64 = P64[R1 + 15];
           _saAuA::P64 = P64[R1 + 23];
           _saAuz::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           I64[Sp - 16] = _saAuz::I64;
           P64[Sp - 8] = _saAuA::P64;
           P64[Sp] = _saAuy::P64;
           P64[Sp + 16] = _saAux::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCcg; else goto caCbK;
       uaCcg: // global
           call _caCbJ(R1) args: 0, res: 0, upd: 0;
       caCbK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCbJ() //  [R1]
         { info_tbl: [(caCbJ,
                       label: block_caCbJ_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbJ: // global
           I64[Sp] = block_caCbO_info;
           _saAuC::P64 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _saAuC::P64;
           if (R1 & 7 != 0) goto uaCch; else goto caCbP;
       uaCch: // global
           call _caCbO(R1) args: 0, res: 0, upd: 0;
       caCbP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCbO() //  [R1]
         { info_tbl: [(caCbO,
                       label: block_caCbO_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbO: // global
           I64[Sp] = block_caCbT_info;
           _saAuE::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _saAuE::P64;
           if (R1 & 7 != 0) goto uaCci; else goto caCbU;
       uaCci: // global
           call _caCbT(R1) args: 0, res: 0, upd: 0;
       caCbU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCbT() //  [R1]
         { info_tbl: [(caCbT,
                       label: block_caCbT_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbT: // global
           I64[Sp - 32] = block_caCbY_info;
           _saAuJ::P64 = P64[R1 + 7];
           _saAuK::P64 = P64[R1 + 15];
           _saAuG::I64 = I64[R1 + 23];
           _saAuH::I64 = I64[R1 + 31];
           _saAuI::I64 = I64[R1 + 39];
           R1 = P64[Sp + 64];
           I64[Sp - 24] = _saAuI::I64;
           P64[Sp - 16] = _saAuJ::P64;
           P64[Sp - 8] = _saAuK::P64;
           I64[Sp] = _saAuH::I64;
           I64[Sp + 64] = _saAuG::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaCcj; else goto caCbZ;
       uaCcj: // global
           call _caCbY(R1) args: 0, res: 0, upd: 0;
       caCbZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCbY() //  [R1]
         { info_tbl: [(caCbY,
                       label: block_caCbY_info
                       rep:StackRep [True, False, False, True, True, False, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCbY: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caCcd; else goto caCcc;
       caCcd: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCcc: // global
           _saAuM::P64 = P64[R1 + 7];
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 80];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _saAuM::P64;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 96];
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 103;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.590675323 UTC

[section ""data" . GHC.Event.Manager.$WFdKey_closure" {
     GHC.Event.Manager.$WFdKey_closure:
         const GHC.Event.Manager.$WFdKey_info;
 },
 GHC.Event.Manager.$WFdKey_entry() //  [R2, R3]
         { info_tbl: [(caCcr,
                       label: GHC.Event.Manager.$WFdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCcr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCcA; else goto caCcB;
       caCcA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCcB: // global
           I64[Sp - 16] = block_caCco_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCcH; else goto caCcp;
       uaCcH: // global
           call _caCco(R1) args: 0, res: 0, upd: 0;
       caCcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCco() //  [R1]
         { info_tbl: [(caCco,
                       label: block_caCco_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCco: // global
           I64[Sp] = block_caCcu_info;
           _saAuQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saAuQ::I64;
           if (R1 & 7 != 0) goto uaCcG; else goto caCcv;
       uaCcG: // global
           call _caCcu(R1) args: 0, res: 0, upd: 0;
       caCcv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCcu() //  [R1]
         { info_tbl: [(caCcu,
                       label: block_caCcu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCcu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCcF; else goto caCcE;
       caCcF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCcE: // global
           _saAuS::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saAuS::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.5925082 UTC

[section ""data" . GHC.Event.Manager.$WFdData_closure" {
     GHC.Event.Manager.$WFdData_closure:
         const GHC.Event.Manager.$WFdData_info;
 },
 GHC.Event.Manager.$WFdData_entry() //  [R2, R3, R4]
         { info_tbl: [(caCcP,
                       label: GHC.Event.Manager.$WFdData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCcP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caCd0; else goto caCd1;
       caCd0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCd1: // global
           I64[Sp - 24] = block_caCcM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCd8; else goto caCcN;
       uaCd8: // global
           call _caCcM(R1) args: 0, res: 0, upd: 0;
       caCcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCcM() //  [R1]
         { info_tbl: [(caCcM,
                       label: block_caCcM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCcM: // global
           I64[Sp - 8] = block_caCcS_info;
           _saAuX::I64 = I64[R1 + 7];
           _saAuY::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAuY::I64;
           I64[Sp + 8] = _saAuX::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCd7; else goto caCcT;
       uaCd7: // global
           call _caCcS(R1) args: 0, res: 0, upd: 0;
       caCcT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCcS() //  [R1]
         { info_tbl: [(caCcS,
                       label: block_caCcS_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCcS: // global
           I64[Sp] = block_caCcX_info;
           _saAv0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saAv0::I64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCcX() //  [R1]
         { info_tbl: [(caCcX,
                       label: block_caCcX_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCcX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caCd6; else goto caCd5;
       caCd6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCd5: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.594103502 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState10_bytes" {
     GHC.Event.Manager.$fShowState10_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.594899256 UTC

[section ""data" . GHC.Event.Manager.$fShowState9_closure" {
     GHC.Event.Manager.$fShowState9_closure:
         const GHC.Event.Manager.$fShowState9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState9_entry() //  [R1]
         { info_tbl: [(caCdf,
                       label: GHC.Event.Manager.$fShowState9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCdf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCdg; else goto caCdh;
       caCdg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCdh: // global
           (_caCdc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCdc::I64 == 0) goto caCde; else goto caCdd;
       caCde: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCdd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCdc::I64;
           R2 = GHC.Event.Manager.$fShowState10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.595847276 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState8_bytes" {
     GHC.Event.Manager.$fShowState8_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.596625102 UTC

[section ""data" . GHC.Event.Manager.$fShowState7_closure" {
     GHC.Event.Manager.$fShowState7_closure:
         const GHC.Event.Manager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState7_entry() //  [R1]
         { info_tbl: [(caCdo,
                       label: GHC.Event.Manager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCdo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCdp; else goto caCdq;
       caCdp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCdq: // global
           (_caCdl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCdl::I64 == 0) goto caCdn; else goto caCdm;
       caCdn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCdm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCdl::I64;
           R2 = GHC.Event.Manager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.597622304 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState6_bytes" {
     GHC.Event.Manager.$fShowState6_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.598386887 UTC

[section ""data" . GHC.Event.Manager.$fShowState5_closure" {
     GHC.Event.Manager.$fShowState5_closure:
         const GHC.Event.Manager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState5_entry() //  [R1]
         { info_tbl: [(caCdx,
                       label: GHC.Event.Manager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCdx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCdy; else goto caCdz;
       caCdy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCdz: // global
           (_caCdu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCdu::I64 == 0) goto caCdw; else goto caCdv;
       caCdw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCdv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCdu::I64;
           R2 = GHC.Event.Manager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.59934634 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState4_bytes" {
     GHC.Event.Manager.$fShowState4_bytes:
         I8[] [82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.600090092 UTC

[section ""data" . GHC.Event.Manager.$fShowState3_closure" {
     GHC.Event.Manager.$fShowState3_closure:
         const GHC.Event.Manager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState3_entry() //  [R1]
         { info_tbl: [(caCdG,
                       label: GHC.Event.Manager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCdG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCdH; else goto caCdI;
       caCdH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCdI: // global
           (_caCdD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCdD::I64 == 0) goto caCdF; else goto caCdE;
       caCdF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCdE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCdD::I64;
           R2 = GHC.Event.Manager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.601064296 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState2_bytes" {
     GHC.Event.Manager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.601922864 UTC

[section ""data" . GHC.Event.Manager.$fShowState1_closure" {
     GHC.Event.Manager.$fShowState1_closure:
         const GHC.Event.Manager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState1_entry() //  [R1]
         { info_tbl: [(caCdP,
                       label: GHC.Event.Manager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCdP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCdQ; else goto caCdR;
       caCdQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCdR: // global
           (_caCdM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCdM::I64 == 0) goto caCdO; else goto caCdN;
       caCdO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCdN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCdM::I64;
           R2 = GHC.Event.Manager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.603314653 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec1_closure" {
     GHC.Event.Manager.$w$cshowsPrec1_closure:
         const GHC.Event.Manager.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(caCe6,
                       label: GHC.Event.Manager.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCe6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCe7; else goto caCe8;
       caCe7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCe8: // global
           I64[Sp - 16] = block_caCdW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCer; else goto caCdX;
       uaCer: // global
           call _caCdW(R1) args: 0, res: 0, upd: 0;
       caCdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCdW() //  [R1]
         { info_tbl: [(caCdW,
                       label: block_caCdW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCdW: // global
           _saAv3::P64 = P64[Sp + 8];
           _caCe5::P64 = R1 & 7;
           if (_caCe5::P64 < 4) goto uaCeo; else goto uaCeq;
       uaCeo: // global
           if (_caCe5::P64 < 3) goto uaCep; else goto caCe2;
       uaCep: // global
           if (_caCe5::P64 < 2) goto caCe0; else goto caCe1;
       caCe0: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caCe1: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caCe2: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uaCeq: // global
           if (_caCe5::P64 < 5) goto caCe3; else goto caCe4;
       caCe3: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caCe4: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.604902033 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(caCew,
                       label: GHC.Event.Manager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCew: // global
           _saAv6::P64 = R3;
           R3 = R4;
           R2 = _saAv6::P64;
           call GHC.Event.Manager.$w$cshowsPrec1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.606680853 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c==_closure" {
     GHC.Event.Manager.$fEqState_$c==_closure:
         const GHC.Event.Manager.$fEqState_$c==_info;
 },
 GHC.Event.Manager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(caCeN,
                       label: GHC.Event.Manager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCeN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCeO; else goto caCeP;
       caCeO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCeP: // global
           I64[Sp - 16] = block_caCeD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCgq; else goto caCeE;
       uaCgq: // global
           call _caCeD(R1) args: 0, res: 0, upd: 0;
       caCeE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCeD() //  [R1]
         { info_tbl: [(caCeD,
                       label: block_caCeD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCeD: // global
           _saAv9::P64 = P64[Sp + 8];
           _caCeM::P64 = R1 & 7;
           if (_caCeM::P64 < 4) goto uaCg8; else goto uaCga;
       uaCg8: // global
           if (_caCeM::P64 < 3) goto uaCg9; else goto caCeJ;
       uaCg9: // global
           if (_caCeM::P64 < 2) goto caCeH; else goto caCeI;
       caCeH: // global
           I64[Sp + 8] = block_caCeS_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCgl; else goto caCeU;
       uaCgl: // global
           call _caCeS(R1) args: 0, res: 0, upd: 0;
       caCeU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCeI: // global
           I64[Sp + 8] = block_caCf7_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCgm; else goto caCf9;
       uaCgm: // global
           call _caCf7(R1) args: 0, res: 0, upd: 0;
       caCf9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCeJ: // global
           I64[Sp + 8] = block_caCfm_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCgn; else goto caCfo;
       uaCgn: // global
           call _caCfm(R1) args: 0, res: 0, upd: 0;
       caCfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaCga: // global
           if (_caCeM::P64 < 5) goto caCeK; else goto caCeL;
       caCeK: // global
           I64[Sp + 8] = block_caCfB_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCgo; else goto caCfD;
       uaCgo: // global
           call _caCfB(R1) args: 0, res: 0, upd: 0;
       caCfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCeL: // global
           I64[Sp + 8] = block_caCfQ_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCgp; else goto caCfS;
       uaCgp: // global
           call _caCfQ(R1) args: 0, res: 0, upd: 0;
       caCfS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCeS() //  [R1]
         { info_tbl: [(caCeS,
                       label: block_caCeS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCeS: // global
           if (R1 & 7 == 1) goto uaCgb; else goto uaCgc;
       uaCgb: // global
           Sp = Sp + 8;
           call _caCg2() args: 0, res: 0, upd: 0;
       uaCgc: // global
           Sp = Sp + 8;
           call _caCfY() args: 0, res: 0, upd: 0;
     }
 },
 _caCf7() //  [R1]
         { info_tbl: [(caCf7,
                       label: block_caCf7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCf7: // global
           if (R1 & 7 == 2) goto uaCgd; else goto uaCge;
       uaCgd: // global
           Sp = Sp + 8;
           call _caCg2() args: 0, res: 0, upd: 0;
       uaCge: // global
           Sp = Sp + 8;
           call _caCfY() args: 0, res: 0, upd: 0;
     }
 },
 _caCfm() //  [R1]
         { info_tbl: [(caCfm,
                       label: block_caCfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCfm: // global
           if (R1 & 7 == 3) goto uaCgf; else goto uaCgg;
       uaCgf: // global
           Sp = Sp + 8;
           call _caCg2() args: 0, res: 0, upd: 0;
       uaCgg: // global
           Sp = Sp + 8;
           call _caCfY() args: 0, res: 0, upd: 0;
     }
 },
 _caCfB() //  [R1]
         { info_tbl: [(caCfB,
                       label: block_caCfB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCfB: // global
           if (R1 & 7 == 4) goto uaCgh; else goto uaCgi;
       uaCgh: // global
           Sp = Sp + 8;
           call _caCg2() args: 0, res: 0, upd: 0;
       uaCgi: // global
           Sp = Sp + 8;
           call _caCfY() args: 0, res: 0, upd: 0;
     }
 },
 _caCfQ() //  [R1]
         { info_tbl: [(caCfQ,
                       label: block_caCfQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCfQ: // global
           if (R1 & 7 == 5) goto uaCgj; else goto uaCgk;
       uaCgj: // global
           Sp = Sp + 8;
           call _caCg2() args: 0, res: 0, upd: 0;
       uaCgk: // global
           Sp = Sp + 8;
           call _caCfY() args: 0, res: 0, upd: 0;
     }
 },
 _caCg2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCg2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCfY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCfY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.609499506 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey5_bytes" {
     GHC.Event.Manager.$fShowFdKey5_bytes:
         I8[] [70,100,75,101,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.610109902 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey4_bytes" {
     GHC.Event.Manager.$fShowFdKey4_bytes:
         I8[] [107,101,121,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.610717711 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey3_bytes" {
     GHC.Event.Manager.$fShowFdKey3_bytes:
         I8[] [107,101,121,85,110,105,113,117,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.611339651 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey2_bytes" {
     GHC.Event.Manager.$fShowFdKey2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.613908011 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec_closure" {
     GHC.Event.Manager.$w$cshowsPrec_closure:
         const GHC.Event.Manager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCgC: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvq_entry() //  [R1]
         { info_tbl: [(caChb,
                       label: sat_saAvq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChb: // global
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Manager.$fShowFdKey2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvr_entry() //  [R1]
         { info_tbl: [(caChf,
                       label: sat_saAvr_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caChg; else goto caChh;
       caChg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caChh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caCh5_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caCh5() //  [R1, R2]
         { info_tbl: [(caCh5,
                       label: block_caCh5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCh5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caChk; else goto caChj;
       caChk: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caChj: // global
           I64[Hp - 40] = sat_saAvq_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvs_entry() //  [R1]
         { info_tbl: [(caChl,
                       label: sat_saAvs_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caChp; else goto caCho;
       caChp: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCho: // global
           _saAvl::P64 = P64[R1 + 16];
           _saAvi::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_saAvr_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Manager.$fShowFdKey3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvt_entry() //  [R1]
         { info_tbl: [(caChq,
                       label: sat_saAvt_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChq: // global
           _saAvt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caChr; else goto caChs;
       caChs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caChu; else goto caCht;
       caChu: // global
           HpAlloc = 32;
           goto caChr;
       caChr: // global
           R1 = _saAvt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvt::P64;
           _saAvl::P64 = P64[_saAvt::P64 + 16];
           _saAvi::I64 = I64[_saAvt::P64 + 24];
           I64[Hp - 24] = sat_saAvs_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvx_entry() //  [R1]
         { info_tbl: [(caChy,
                       label: sat_saAvx_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChy: // global
           _saAvx::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caChz; else goto caChA;
       caChA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caChC; else goto caChB;
       caChC: // global
           HpAlloc = 32;
           goto caChz;
       caChz: // global
           R1 = _saAvx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caChB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvx::P64;
           _saAvl::P64 = P64[_saAvx::P64 + 16];
           _saAvh::I64 = I64[_saAvx::P64 + 24];
           _saAvi::I64 = I64[_saAvx::P64 + 32];
           I64[Hp - 24] = sat_saAvt_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           I64[Sp - 24] = block_caChv_info;
           R4 = Hp - 24;
           R3 = _saAvh::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caChv() //  [R1, R2]
         { info_tbl: [(caChv,
                       label: block_caChv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caChF; else goto caChE;
       caChF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caChE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvy_entry() //  [R1]
         { info_tbl: [(caChG,
                       label: sat_saAvy_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChG: // global
           _saAvy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caChH; else goto caChI;
       caChI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caChK; else goto caChJ;
       caChK: // global
           HpAlloc = 40;
           goto caChH;
       caChH: // global
           R1 = _saAvy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caChJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvy::P64;
           _saAvl::P64 = P64[_saAvy::P64 + 16];
           _saAvh::I64 = I64[_saAvy::P64 + 24];
           _saAvi::I64 = I64[_saAvy::P64 + 32];
           I64[Hp - 32] = sat_saAvx_info;
           P64[Hp - 16] = _saAvl::P64;
           I64[Hp - 8] = _saAvh::I64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_saAvk_entry() //  [R1, R2]
         { info_tbl: [(caChL,
                       label: p_saAvk_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caChP; else goto caChO;
       caChP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caChO: // global
           _saAvh::I64 = I64[R1 + 7];
           _saAvi::I64 = I64[R1 + 15];
           I64[Hp - 32] = sat_saAvy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = _saAvh::I64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvB_entry() //  [R1]
         { info_tbl: [(caChZ,
                       label: sat_saAvB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caChZ: // global
           _saAvB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caCi0; else goto caCi1;
       caCi1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCi3; else goto caCi2;
       caCi3: // global
           HpAlloc = 24;
           goto caCi0;
       caCi0: // global
           R1 = _saAvB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCi2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvB::P64;
           _saAvj::P64 = P64[_saAvB::P64 + 16];
           _saAvk::P64 = P64[_saAvB::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _saAvj::P64;
           R2 = Hp - 14;
           R1 = _saAvk::P64;
           Sp = Sp - 16;
           call p_saAvk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caCi7,
                       label: GHC.Event.Manager.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCi7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caCib; else goto caCia;
       caCib: // global
           HpAlloc = 80;
           R1 = GHC.Event.Manager.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caCia: // global
           I64[Hp - 72] = p_saAvk_info;
           I64[Hp - 64] = R3;
           I64[Hp - 56] = R4;
           _caCgG::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto caCi5; else goto caCi6;
       caCi5: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _caCgG::P64;
           call p_saAvk_entry(R2, R1) args: 8, res: 0, upd: 8;
       caCi6: // global
           I64[Hp - 48] = sat_saAvB_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _caCgG::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.618784611 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caCik,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCik: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCio; else goto caCip;
       caCio: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCip: // global
           I64[Sp - 24] = block_caCih_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCix; else goto caCii;
       uaCix: // global
           call _caCih(R1) args: 0, res: 0, upd: 0;
       caCii: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCih() //  [R1]
         { info_tbl: [(caCih,
                       label: block_caCih_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCih: // global
           I64[Sp] = block_caCin_info;
           _saAvG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saAvG::I64;
           if (R1 & 7 != 0) goto uaCiw; else goto caCir;
       uaCiw: // global
           call _caCin(R1) args: 0, res: 0, upd: 0;
       caCir: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCin() //  [R1]
         { info_tbl: [(caCin,
                       label: block_caCin_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCin: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.620120957 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey6_closure" {
     GHC.Event.Manager.$fShowFdKey6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.620965952 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshow_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshow_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshow_entry() //  [R2]
         { info_tbl: [(caCiF,
                       label: GHC.Event.Manager.$fShowFdKey_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCiF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCiG; else goto caCiH;
       caCiG: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCiH: // global
           I64[Sp - 8] = block_caCiC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCiL; else goto caCiD;
       uaCiL: // global
           call _caCiC(R1) args: 0, res: 0, upd: 0;
       caCiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCiC() //  [R1]
         { info_tbl: [(caCiC,
                       label: block_caCiC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCiC: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.6224279 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey1_closure" {
     GHC.Event.Manager.$fShowFdKey1_closure:
         const GHC.Event.Manager.$fShowFdKey1_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey1_entry() //  [R2, R3]
         { info_tbl: [(caCiT,
                       label: GHC.Event.Manager.$fShowFdKey1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCiT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCiU; else goto caCiV;
       caCiU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCiV: // global
           I64[Sp - 16] = block_caCiQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCiZ; else goto caCiR;
       uaCiZ: // global
           call _caCiQ(R1) args: 0, res: 0, upd: 0;
       caCiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCiQ() //  [R1]
         { info_tbl: [(caCiQ,
                       label: block_caCiQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCiQ: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.623695947 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowList_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowList_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caCj4,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCj4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$fShowFdKey1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.624520609 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_closure" {
     GHC.Event.Manager.$fShowFdKey_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure+1;
         const GHC.Event.Manager.$fShowFdKey_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.625450567 UTC

[section ""data" . GHC.Event.Manager.keyUnique_closure" {
     GHC.Event.Manager.keyUnique_closure:
         const GHC.Event.Manager.keyUnique_info;
 },
 GHC.Event.Manager.keyUnique_entry() //  [R2]
         { info_tbl: [(caCje,
                       label: GHC.Event.Manager.keyUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCje: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCji; else goto caCjj;
       caCji: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCjj: // global
           I64[Sp - 8] = block_caCjb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCjn; else goto caCjc;
       uaCjn: // global
           call _caCjb(R1) args: 0, res: 0, upd: 0;
       caCjc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCjb() //  [R1]
         { info_tbl: [(caCjb,
                       label: block_caCjb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCjb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCjm; else goto caCjl;
       caCjm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCjl: // global
           _saAvY::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAvY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.626886224 UTC

[section ""data" . GHC.Event.Manager.keyFd_closure" {
     GHC.Event.Manager.keyFd_closure:
         const GHC.Event.Manager.keyFd_info;
 },
 GHC.Event.Manager.keyFd_entry() //  [R2]
         { info_tbl: [(caCjv,
                       label: GHC.Event.Manager.keyFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCjv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCjz; else goto caCjA;
       caCjz: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCjA: // global
           I64[Sp - 8] = block_caCjs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCjE; else goto caCjt;
       uaCjE: // global
           call _caCjs(R1) args: 0, res: 0, upd: 0;
       caCjt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCjs() //  [R1]
         { info_tbl: [(caCjs,
                       label: block_caCjs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCjs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCjD; else goto caCjC;
       caCjD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCjC: // global
           _saAw1::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saAw1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.628226874 UTC

[section ""data" . GHC.Event.Manager._fdCallback_closure" {
     GHC.Event.Manager._fdCallback_closure:
         const GHC.Event.Manager._fdCallback_info;
 },
 GHC.Event.Manager._fdCallback_entry() //  [R2]
         { info_tbl: [(caCjM,
                       label: GHC.Event.Manager._fdCallback_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCjM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCjN; else goto caCjO;
       caCjN: // global
           R2 = R2;
           R1 = GHC.Event.Manager._fdCallback_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCjO: // global
           I64[Sp - 8] = block_caCjJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCjS; else goto caCjK;
       uaCjS: // global
           call _caCjJ(R1) args: 0, res: 0, upd: 0;
       caCjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCjJ() //  [R1]
         { info_tbl: [(caCjJ,
                       label: block_caCjJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCjJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.629555264 UTC

[section ""data" . GHC.Event.Manager.fdEvents_closure" {
     GHC.Event.Manager.fdEvents_closure:
         const GHC.Event.Manager.fdEvents_info;
 },
 GHC.Event.Manager.fdEvents_entry() //  [R2]
         { info_tbl: [(caCk0,
                       label: GHC.Event.Manager.fdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCk0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCk4; else goto caCk5;
       caCk4: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCk5: // global
           I64[Sp - 8] = block_caCjX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCk9; else goto caCjY;
       uaCk9: // global
           call _caCjX(R1) args: 0, res: 0, upd: 0;
       caCjY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCjX() //  [R1]
         { info_tbl: [(caCjX,
                       label: block_caCjX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCjX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCk8; else goto caCk7;
       caCk8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCk7: // global
           _saAwd::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAwd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.630956334 UTC

[section ""data" . GHC.Event.Manager.fdKey_closure" {
     GHC.Event.Manager.fdKey_closure:
         const GHC.Event.Manager.fdKey_info;
 },
 GHC.Event.Manager.fdKey_entry() //  [R2]
         { info_tbl: [(caCkh,
                       label: GHC.Event.Manager.fdKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCkh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCkl; else goto caCkm;
       caCkl: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCkm: // global
           I64[Sp - 8] = block_caCke_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCkq; else goto caCkf;
       uaCkq: // global
           call _caCke(R1) args: 0, res: 0, upd: 0;
       caCkf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCke() //  [R1]
         { info_tbl: [(caCke,
                       label: block_caCke_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCke: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCkp; else goto caCko;
       caCkp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCko: // global
           _saAwh::I64 = I64[R1 + 15];
           _saAwi::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAwh::I64;
           I64[Hp] = _saAwi::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.632410114 UTC

[section ""data" . GHC.Event.Manager.emLock_closure" {
     GHC.Event.Manager.emLock_closure:
         const GHC.Event.Manager.emLock_info;
 },
 GHC.Event.Manager.emLock_entry() //  [R2]
         { info_tbl: [(caCky,
                       label: GHC.Event.Manager.emLock_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCky: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCkC; else goto caCkD;
       caCkC: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emLock_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCkD: // global
           I64[Sp - 8] = block_caCkv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCkH; else goto caCkw;
       uaCkH: // global
           call _caCkv(R1) args: 0, res: 0, upd: 0;
       caCkw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCkv() //  [R1]
         { info_tbl: [(caCkv,
                       label: block_caCkv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCkv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCkG; else goto caCkF;
       caCkG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCkF: // global
           _saAwz::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _saAwz::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.634011084 UTC

[section ""data" . GHC.Event.Manager.emControl_closure" {
     GHC.Event.Manager.emControl_closure:
         const GHC.Event.Manager.emControl_info;
 },
 GHC.Event.Manager.emControl_entry() //  [R2]
         { info_tbl: [(caCkP,
                       label: GHC.Event.Manager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCkP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCkT; else goto caCkU;
       caCkT: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCkU: // global
           I64[Sp - 8] = block_caCkM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCkY; else goto caCkN;
       uaCkY: // global
           call _caCkM(R1) args: 0, res: 0, upd: 0;
       caCkN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCkM() //  [R1]
         { info_tbl: [(caCkM,
                       label: block_caCkM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCkM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caCkX; else goto caCkW;
       caCkX: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCkW: // global
           _saAwM::P64 = P64[R1 + 55];
           _saAwN::P64 = P64[R1 + 63];
           _saAwJ::I64 = I64[R1 + 87];
           _saAwK::I64 = I64[R1 + 95];
           _saAwL::I64 = I64[R1 + 103];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _saAwM::P64;
           P64[Hp - 24] = _saAwN::P64;
           I64[Hp - 16] = _saAwJ::I64;
           I64[Hp - 8] = _saAwK::I64;
           I64[Hp] = _saAwL::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.635472257 UTC

[section ""data" . GHC.Event.Manager.emUniqueSource_closure" {
     GHC.Event.Manager.emUniqueSource_closure:
         const GHC.Event.Manager.emUniqueSource_info;
 },
 GHC.Event.Manager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(caCl6,
                       label: GHC.Event.Manager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCl6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCla; else goto caClb;
       caCla: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caClb: // global
           I64[Sp - 8] = block_caCl3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaClf; else goto caCl4;
       uaClf: // global
           call _caCl3(R1) args: 0, res: 0, upd: 0;
       caCl4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCl3() //  [R1]
         { info_tbl: [(caCl3,
                       label: block_caCl3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCl3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCle; else goto caCld;
       caCle: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCld: // global
           _saAwX::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _saAwX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.636925686 UTC

[section ""data" . GHC.Event.Manager.emState_closure" {
     GHC.Event.Manager.emState_closure:
         const GHC.Event.Manager.emState_info;
 },
 GHC.Event.Manager.emState_entry() //  [R2]
         { info_tbl: [(caCln,
                       label: GHC.Event.Manager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCln: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caClr; else goto caCls;
       caClr: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCls: // global
           I64[Sp - 8] = block_caClk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaClw; else goto caCll;
       uaClw: // global
           call _caClk(R1) args: 0, res: 0, upd: 0;
       caCll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caClk() //  [R1]
         { info_tbl: [(caClk,
                       label: block_caClk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caClk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caClv; else goto caClu;
       caClv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caClu: // global
           _saAxb::P64 = P64[R1 + 39];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _saAxb::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.638401747 UTC

[section ""data" . GHC.Event.Manager.emFds_closure" {
     GHC.Event.Manager.emFds_closure:
         const GHC.Event.Manager.emFds_info;
 },
 GHC.Event.Manager.emFds_entry() //  [R2]
         { info_tbl: [(caClE,
                       label: GHC.Event.Manager.emFds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caClE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caClI; else goto caClJ;
       caClI: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emFds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caClJ: // global
           I64[Sp - 8] = block_caClB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaClN; else goto caClC;
       uaClN: // global
           call _caClB(R1) args: 0, res: 0, upd: 0;
       caClC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caClB() //  [R1]
         { info_tbl: [(caClB,
                       label: block_caClB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caClB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caClM; else goto caClL;
       caClM: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caClL: // global
           _saAxm::P64 = P64[R1 + 15];
           _saAxn::P64 = P64[R1 + 23];
           _saAxp::P64 = P64[R1 + 31];
           _saAxo::I64 = I64[R1 + 79];
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = _saAxm::P64;
           P64[Hp - 16] = _saAxn::P64;
           P64[Hp - 8] = _saAxp::P64;
           I64[Hp] = _saAxo::I64;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.63989667 UTC

[section ""data" . GHC.Event.Manager.emBackend_closure" {
     GHC.Event.Manager.emBackend_closure:
         const GHC.Event.Manager.emBackend_info;
 },
 GHC.Event.Manager.emBackend_entry() //  [R2]
         { info_tbl: [(caClV,
                       label: GHC.Event.Manager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caClV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caClW; else goto caClX;
       caClW: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caClX: // global
           I64[Sp - 8] = block_caClS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCm1; else goto caClT;
       uaCm1: // global
           call _caClS(R1) args: 0, res: 0, upd: 0;
       caClT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caClS() //  [R1]
         { info_tbl: [(caClS,
                       label: block_caClS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caClS: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.641031048 UTC

[section ""data" . GHC.Event.Manager.newDefaultBackend_closure" {
     GHC.Event.Manager.newDefaultBackend_closure:
         const GHC.Event.Manager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.Manager.newDefaultBackend_entry() //  []
         { info_tbl: [(caCm6,
                       label: GHC.Event.Manager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCm6: // global
           call GHC.Event.EPoll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.641839955 UTC

[section ""cstring" . GHC.Event.Manager.$trModule4_bytes" {
     GHC.Event.Manager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.642482102 UTC

[section ""data" . GHC.Event.Manager.$trModule3_closure" {
     GHC.Event.Manager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.643101045 UTC

[section ""cstring" . GHC.Event.Manager.$trModule2_bytes" {
     GHC.Event.Manager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.643712763 UTC

[section ""data" . GHC.Event.Manager.$trModule1_closure" {
     GHC.Event.Manager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.646937506 UTC

[section ""data" . GHC.Event.Manager.$trModule_closure" {
     GHC.Event.Manager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Manager.$trModule3_closure+1;
         const GHC.Event.Manager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.647637767 UTC

[section ""data" . $krep_raAtw_closure" {
     $krep_raAtw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.648269312 UTC

[section ""data" . $krep1_raAtx_closure" {
     $krep1_raAtx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.648826975 UTC

[section ""data" . $krep2_raAty_closure" {
     $krep2_raAty_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEvent_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.64980619 UTC

[section ""data" . $krep3_raAtz_closure" {
     $krep3_raAtz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEventLifetime_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.650426995 UTC

[section ""data" . $krep4_raAtA_closure" {
     $krep4_raAtA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.651084561 UTC

[section ""data" . $krep5_raAtB_closure" {
     $krep5_raAtB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.651730823 UTC

[section ""data" . $krep6_raAtC_closure" {
     $krep6_raAtC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.65240721 UTC

[section ""data" . $krep7_raAtD_closure" {
     $krep7_raAtD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.653044636 UTC

[section ""data" . $krep8_raAtE_closure" {
     $krep8_raAtE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.653681212 UTC

[section ""data" . $krep9_raAtF_closure" {
     $krep9_raAtF_closure:
         const :_con_info;
         const $krep4_raAtA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.654294575 UTC

[section ""data" . $krep10_raAtG_closure" {
     $krep10_raAtG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.654942346 UTC

[section ""data" . $krep11_raAtH_closure" {
     $krep11_raAtH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.655550899 UTC

[section ""data" . $krep12_raAtI_closure" {
     $krep12_raAtI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_raAty_closure+1;
         const $krep10_raAtG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.656187676 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdKey2_bytes" {
     GHC.Event.Manager.$tcFdKey2_bytes:
         I8[] [70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.656753398 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey1_closure" {
     GHC.Event.Manager.$tcFdKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.657402897 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey_closure" {
     GHC.Event.Manager.$tcFdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11469896173097407196;
         const 6069269054622812669;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.65806342 UTC

[section ""data" . $krep13_raAtJ_closure" {
     $krep13_raAtJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.658669056 UTC

[section ""data" . $krep14_raAtK_closure" {
     $krep14_raAtK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep12_raAtI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.659243995 UTC

[section ""data" . $krep15_raAtL_closure" {
     $krep15_raAtL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raAtw_closure+1;
         const $krep13_raAtJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.659853244 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey1_closure" {
     GHC.Event.Manager.$tc'FdKey1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raAtx_closure+1;
         const $krep15_raAtL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.660463373 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdKey3_bytes" {
     GHC.Event.Manager.$tc'FdKey3_bytes:
         I8[] [39,70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.661017545 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey2_closure" {
     GHC.Event.Manager.$tc'FdKey2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdKey3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.661808789 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey_closure" {
     GHC.Event.Manager.$tc'FdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdKey2_closure+1;
         const GHC.Event.Manager.$tc'FdKey1_closure+4;
         const 5122964525573573781;
         const 3523266410810375450;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.662447547 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdData2_bytes" {
     GHC.Event.Manager.$tcFdData2_bytes:
         I8[] [70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.663038802 UTC

[section ""data" . GHC.Event.Manager.$tcFdData1_closure" {
     GHC.Event.Manager.$tcFdData1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdData2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.663648182 UTC

[section ""data" . GHC.Event.Manager.$tcFdData_closure" {
     GHC.Event.Manager.$tcFdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdData1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9572952300930290737;
         const 248149994861342082;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.664312739 UTC

[section ""data" . $krep16_raAtM_closure" {
     $krep16_raAtM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdData_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.664960484 UTC

[section ""data" . $krep17_raAtN_closure" {
     $krep17_raAtN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_raAtK_closure+4;
         const $krep16_raAtM_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.665599479 UTC

[section ""data" . $krep18_raAtO_closure" {
     $krep18_raAtO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_raAtz_closure+1;
         const $krep17_raAtN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.666231885 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData1_closure" {
     GHC.Event.Manager.$tc'FdData1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep18_raAtO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.666829456 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdData3_bytes" {
     GHC.Event.Manager.$tc'FdData3_bytes:
         I8[] [39,70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.667400709 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData2_closure" {
     GHC.Event.Manager.$tc'FdData2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdData3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.66800904 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData_closure" {
     GHC.Event.Manager.$tc'FdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdData2_closure+1;
         const GHC.Event.Manager.$tc'FdData1_closure+4;
         const 13006093439393452327;
         const 3623098721817739111;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.668642137 UTC

[section ""data" . $krep19_raAtP_closure" {
     $krep19_raAtP_closure:
         const :_con_info;
         const $krep16_raAtM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.669293456 UTC

[section ""data" . $krep20_raAtQ_closure" {
     $krep20_raAtQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep19_raAtP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.669863487 UTC

[section ""data" . $krep21_raAtR_closure" {
     $krep21_raAtR_closure:
         const :_con_info;
         const $krep20_raAtQ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.670503982 UTC

[section ""data" . $krep22_raAtS_closure" {
     $krep22_raAtS_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.IntTable.$tcIntTable_closure;
         const $krep21_raAtR_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.67114917 UTC

[section ""data" . $krep23_raAtT_closure" {
     $krep23_raAtT_closure:
         const :_con_info;
         const $krep22_raAtS_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.671752227 UTC

[section ""data" . $krep24_raAtU_closure" {
     $krep24_raAtU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep23_raAtT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.672412579 UTC

[section ""data" . $krep25_raAtV_closure" {
     $krep25_raAtV_closure:
         const :_con_info;
         const $krep24_raAtU_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.672998779 UTC

[section ""data" . $krep26_raAtW_closure" {
     $krep26_raAtW_closure:
         const :_con_info;
         const $krep7_raAtD_closure+1;
         const $krep25_raAtV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.673575282 UTC

[section ""data" . $krep27_raAtX_closure" {
     $krep27_raAtX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Arr.$tcArray_closure;
         const $krep26_raAtW_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.675290229 UTC

[section ""cstring" . GHC.Event.Manager.$tcState2_bytes" {
     GHC.Event.Manager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.67597361 UTC

[section ""data" . GHC.Event.Manager.$tcState1_closure" {
     GHC.Event.Manager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.676600602 UTC

[section ""data" . GHC.Event.Manager.$tcState_closure" {
     GHC.Event.Manager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7442518771887689078;
         const 3049393439281173903;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.677966862 UTC

[section ""data" . GHC.Event.Manager.$tc'Created1_closure" {
     GHC.Event.Manager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.678582815 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Created3_bytes" {
     GHC.Event.Manager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.679137307 UTC

[section ""data" . GHC.Event.Manager.$tc'Created2_closure" {
     GHC.Event.Manager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.679743495 UTC

[section ""data" . GHC.Event.Manager.$tc'Created_closure" {
     GHC.Event.Manager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Created2_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 17846748838152018769;
         const 13865095201560943193;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.680328297 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Running2_bytes" {
     GHC.Event.Manager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.680941044 UTC

[section ""data" . GHC.Event.Manager.$tc'Running1_closure" {
     GHC.Event.Manager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.681572723 UTC

[section ""data" . GHC.Event.Manager.$tc'Running_closure" {
     GHC.Event.Manager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Running1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8784511774161450304;
         const 13551584807303205071;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.682219013 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Dying2_bytes" {
     GHC.Event.Manager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.682829099 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying1_closure" {
     GHC.Event.Manager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.683445679 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying_closure" {
     GHC.Event.Manager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Dying1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 10564881478355389136;
         const 3106847497763432300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.684083307 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Releasing2_bytes" {
     GHC.Event.Manager.$tc'Releasing2_bytes:
         I8[] [39,82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.684717705 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing1_closure" {
     GHC.Event.Manager.$tc'Releasing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Releasing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.685346427 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing_closure" {
     GHC.Event.Manager.$tc'Releasing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Releasing1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 3204716164798465120;
         const 4205553053946559474;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.685964362 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Finished2_bytes" {
     GHC.Event.Manager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.686562133 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished1_closure" {
     GHC.Event.Manager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.687168927 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished_closure" {
     GHC.Event.Manager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Finished1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8866864364616799312;
         const 2451390217632909923;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.687816661 UTC

[section ""data" . $krep28_raAtY_closure" {
     $krep28_raAtY_closure:
         const :_con_info;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.688485981 UTC

[section ""data" . $krep29_raAtZ_closure" {
     $krep29_raAtZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep28_raAtY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.689111112 UTC

[section ""cstring" . GHC.Event.Manager.$tcEventManager2_bytes" {
     GHC.Event.Manager.$tcEventManager2_bytes:
         I8[] [69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.6899867 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager1_closure" {
     GHC.Event.Manager.$tcEventManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcEventManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.69056832 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager_closure" {
     GHC.Event.Manager.$tcEventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcEventManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16777685112477180948;
         const 1210110422135437783;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.691175138 UTC

[section ""data" . $krep30_raAu0_closure" {
     $krep30_raAu0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcEventManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.691796301 UTC

[section ""data" . $krep31_raAu1_closure" {
     $krep31_raAu1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_raAtH_closure+1;
         const $krep30_raAu0_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.69240817 UTC

[section ""data" . $krep32_raAu2_closure" {
     $krep32_raAu2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_raAtB_closure+1;
         const $krep31_raAu1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.692957577 UTC

[section ""data" . $krep33_raAu3_closure" {
     $krep33_raAu3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_raAtC_closure+1;
         const $krep32_raAu2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.693620832 UTC

[section ""data" . $krep34_raAu4_closure" {
     $krep34_raAu4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep29_raAtZ_closure+1;
         const $krep33_raAu3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.694215209 UTC

[section ""data" . $krep35_raAu5_closure" {
     $krep35_raAu5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_raAtX_closure+1;
         const $krep34_raAu4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.694850271 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager1_closure" {
     GHC.Event.Manager.$tc'EventManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_raAtE_closure+1;
         const $krep35_raAu5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.695453511 UTC

[section ""cstring" . GHC.Event.Manager.$tc'EventManager3_bytes" {
     GHC.Event.Manager.$tc'EventManager3_bytes:
         I8[] [39,69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.69605972 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager2_closure" {
     GHC.Event.Manager.$tc'EventManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'EventManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.696672801 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager_closure" {
     GHC.Event.Manager.$tc'EventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'EventManager2_closure+1;
         const GHC.Event.Manager.$tc'EventManager1_closure+4;
         const 13274036699047731538;
         const 394780277405469411;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.697989988 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshow_closure" {
     GHC.Event.Manager.$fShowState_$cshow_closure:
         const GHC.Event.Manager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(caCmn,
                       label: GHC.Event.Manager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCmn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCmo; else goto caCmp;
       caCmo: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCmp: // global
           I64[Sp - 8] = block_caCmd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCmI; else goto caCme;
       uaCmI: // global
           call _caCmd(R1) args: 0, res: 0, upd: 0;
       caCme: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCmd() //  [R1]
         { info_tbl: [(caCmd,
                       label: block_caCmd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCmd: // global
           _caCmm::P64 = R1 & 7;
           if (_caCmm::P64 < 4) goto uaCmF; else goto uaCmH;
       uaCmF: // global
           if (_caCmm::P64 < 3) goto uaCmG; else goto caCmj;
       uaCmG: // global
           if (_caCmm::P64 < 2) goto caCmh; else goto caCmi;
       caCmh: // global
           R1 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caCmi: // global
           R1 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caCmj: // global
           R1 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uaCmH: // global
           if (_caCmm::P64 < 5) goto caCmk; else goto caCml;
       caCmk: // global
           R1 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caCml: // global
           R1 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.699592078 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowList_closure" {
     GHC.Event.Manager.$fShowState_$cshowList_closure:
         const GHC.Event.Manager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caCmN,
                       label: GHC.Event.Manager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCmN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.700401081 UTC

[section ""data" . GHC.Event.Manager.$fShowState_closure" {
     GHC.Event.Manager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowState_$cshow_closure+1;
         const GHC.Event.Manager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.701503052 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c==_closure" {
     GHC.Event.Manager.$fEqFdKey_$c==_closure:
         const GHC.Event.Manager.$fEqFdKey_$c==_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c==_entry() //  [R2, R3]
         { info_tbl: [(caCmX,
                       label: GHC.Event.Manager.$fEqFdKey_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCmX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCn1; else goto caCn2;
       caCn1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCn2: // global
           I64[Sp - 16] = block_caCmU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCni; else goto caCmV;
       uaCni: // global
           call _caCmU(R1) args: 0, res: 0, upd: 0;
       caCmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCmU() //  [R1]
         { info_tbl: [(caCmU,
                       label: block_caCmU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCmU: // global
           I64[Sp - 8] = block_caCn0_info;
           _saAxU::I64 = I64[R1 + 7];
           _saAxV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAxV::I64;
           I64[Sp + 8] = _saAxU::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCnh; else goto caCn4;
       uaCnh: // global
           call _caCn0(R1) args: 0, res: 0, upd: 0;
       caCn4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCn0() //  [R1]
         { info_tbl: [(caCn0,
                       label: block_caCn0_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCn0: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto caCnd; else goto caCnc;
       caCnd: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCnc: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.703372877 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c/=_closure" {
     GHC.Event.Manager.$fEqFdKey_$c/=_closure:
         const GHC.Event.Manager.$fEqFdKey_$c/=_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caCnq,
                       label: GHC.Event.Manager.$fEqFdKey_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCnq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCnu; else goto caCnv;
       caCnu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCnv: // global
           I64[Sp - 16] = block_caCnn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCnP; else goto caCno;
       uaCnP: // global
           call _caCnn(R1) args: 0, res: 0, upd: 0;
       caCno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCnn() //  [R1]
         { info_tbl: [(caCnn,
                       label: block_caCnn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCnn: // global
           I64[Sp - 8] = block_caCnt_info;
           _saAy4::I64 = I64[R1 + 7];
           _saAy5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAy5::I64;
           I64[Sp + 8] = _saAy4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCnO; else goto caCnx;
       uaCnO: // global
           call _caCnt(R1) args: 0, res: 0, upd: 0;
       caCnx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCnt() //  [R1]
         { info_tbl: [(caCnt,
                       label: block_caCnt_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCnt: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto caCnL; else goto caCnN;
       caCnN: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto caCnL; else goto caCnM;
       caCnL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCnM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.70483293 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_closure" {
     GHC.Event.Manager.$fEqFdKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqFdKey_$c==_closure+2;
         const GHC.Event.Manager.$fEqFdKey_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.706439135 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c/=_closure" {
     GHC.Event.Manager.$fEqState_$c/=_closure:
         const GHC.Event.Manager.$fEqState_$c/=_info;
 },
 GHC.Event.Manager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caCo4,
                       label: GHC.Event.Manager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCo4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCo5; else goto caCo6;
       caCo5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCo6: // global
           I64[Sp - 16] = block_caCnU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCpH; else goto caCnV;
       uaCpH: // global
           call _caCnU(R1) args: 0, res: 0, upd: 0;
       caCnV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCnU() //  [R1]
         { info_tbl: [(caCnU,
                       label: block_caCnU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCnU: // global
           _saAyc::P64 = P64[Sp + 8];
           _caCo3::P64 = R1 & 7;
           if (_caCo3::P64 < 4) goto uaCpp; else goto uaCpr;
       uaCpp: // global
           if (_caCo3::P64 < 3) goto uaCpq; else goto caCo0;
       uaCpq: // global
           if (_caCo3::P64 < 2) goto caCnY; else goto caCnZ;
       caCnY: // global
           I64[Sp + 8] = block_caCo9_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCpC; else goto caCob;
       uaCpC: // global
           call _caCo9(R1) args: 0, res: 0, upd: 0;
       caCob: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCnZ: // global
           I64[Sp + 8] = block_caCoo_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCpD; else goto caCoq;
       uaCpD: // global
           call _caCoo(R1) args: 0, res: 0, upd: 0;
       caCoq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCo0: // global
           I64[Sp + 8] = block_caCoD_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCpE; else goto caCoF;
       uaCpE: // global
           call _caCoD(R1) args: 0, res: 0, upd: 0;
       caCoF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaCpr: // global
           if (_caCo3::P64 < 5) goto caCo1; else goto caCo2;
       caCo1: // global
           I64[Sp + 8] = block_caCoS_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCpF; else goto caCoU;
       uaCpF: // global
           call _caCoS(R1) args: 0, res: 0, upd: 0;
       caCoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCo2: // global
           I64[Sp + 8] = block_caCp7_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCpG; else goto caCp9;
       uaCpG: // global
           call _caCp7(R1) args: 0, res: 0, upd: 0;
       caCp9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCo9() //  [R1]
         { info_tbl: [(caCo9,
                       label: block_caCo9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCo9: // global
           if (R1 & 7 == 1) goto uaCps; else goto uaCpt;
       uaCps: // global
           Sp = Sp + 8;
           call _caCpj() args: 0, res: 0, upd: 0;
       uaCpt: // global
           Sp = Sp + 8;
           call _caCpf() args: 0, res: 0, upd: 0;
     }
 },
 _caCoo() //  [R1]
         { info_tbl: [(caCoo,
                       label: block_caCoo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCoo: // global
           if (R1 & 7 == 2) goto uaCpu; else goto uaCpv;
       uaCpu: // global
           Sp = Sp + 8;
           call _caCpj() args: 0, res: 0, upd: 0;
       uaCpv: // global
           Sp = Sp + 8;
           call _caCpf() args: 0, res: 0, upd: 0;
     }
 },
 _caCoD() //  [R1]
         { info_tbl: [(caCoD,
                       label: block_caCoD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCoD: // global
           if (R1 & 7 == 3) goto uaCpw; else goto uaCpx;
       uaCpw: // global
           Sp = Sp + 8;
           call _caCpj() args: 0, res: 0, upd: 0;
       uaCpx: // global
           Sp = Sp + 8;
           call _caCpf() args: 0, res: 0, upd: 0;
     }
 },
 _caCoS() //  [R1]
         { info_tbl: [(caCoS,
                       label: block_caCoS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCoS: // global
           if (R1 & 7 == 4) goto uaCpy; else goto uaCpz;
       uaCpy: // global
           Sp = Sp + 8;
           call _caCpj() args: 0, res: 0, upd: 0;
       uaCpz: // global
           Sp = Sp + 8;
           call _caCpf() args: 0, res: 0, upd: 0;
     }
 },
 _caCp7() //  [R1]
         { info_tbl: [(caCp7,
                       label: block_caCp7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCp7: // global
           if (R1 & 7 == 5) goto uaCpA; else goto uaCpB;
       uaCpA: // global
           Sp = Sp + 8;
           call _caCpj() args: 0, res: 0, upd: 0;
       uaCpB: // global
           Sp = Sp + 8;
           call _caCpf() args: 0, res: 0, upd: 0;
     }
 },
 _caCpj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCpj: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCpf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCpf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.70905227 UTC

[section ""data" . GHC.Event.Manager.$fEqState_closure" {
     GHC.Event.Manager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqState_$c==_closure+2;
         const GHC.Event.Manager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.709694143 UTC

[section ""cstring" . lvl1_raAu6_bytes" {
     lvl1_raAu6_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.711605637 UTC

[section ""data" . lvl2_raAu7_closure" {
     lvl2_raAu7_closure:
         const lvl2_raAu7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_raAu7_entry() //  [R1]
         { info_tbl: [(caCpY,
                       label: lvl2_raAu7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCpY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCpZ; else goto caCq0;
       caCpZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCq0: // global
           (_caCpV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCpV::I64 == 0) goto caCpX; else goto caCpW;
       caCpX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCpW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCpV::I64;
           R2 = lvl1_raAu6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.713112459 UTC

[section ""data" . lvl3_raAu8_closure" {
     lvl3_raAu8_closure:
         const lvl3_raAu8_info;
         const 0;
 },
 lvl3_raAu8_entry() //  [R2, R3, R4]
         { info_tbl: [(caCq6,
                       label: lvl3_raAu8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCq6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCqa; else goto caCq9;
       caCqa: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl3_raAu8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCq9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl2_raAu7_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.714753037 UTC

[section ""data" . GHC.Event.Manager.callbackTableVar_closure" {
     GHC.Event.Manager.callbackTableVar_closure:
         const GHC.Event.Manager.callbackTableVar_info;
         const 0;
 },
 GHC.Event.Manager.callbackTableVar_entry() //  [R2, R3]
         { info_tbl: [(caCqi,
                       label: GHC.Event.Manager.callbackTableVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCqi: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caCqw; else goto caCqx;
       caCqw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.callbackTableVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCqx: // global
           I64[Sp - 16] = block_caCqf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCqZ; else goto caCqg;
       uaCqZ: // global
           call _caCqf(R1) args: 0, res: 0, upd: 0;
       caCqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCqf() //  [R1]
         { info_tbl: [(caCqf,
                       label: block_caCqf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCqf: // global
           I64[Sp - 16] = block_caCql_info;
           _saAys::P64 = P64[R1 + 23];
           _saAyu::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saAyu::P64;
           P64[Sp] = _saAys::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCqY; else goto caCqm;
       uaCqY: // global
           call _caCql(R1) args: 0, res: 0, upd: 0;
       caCqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCql() //  [R1]
         { info_tbl: [(caCql,
                       label: block_caCql_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCql: // global
           I64[Sp - 8] = block_caCqq_info;
           _saAyD::P64 = R1;
           _saAyE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saAyE::I64;
           P64[Sp + 16] = _saAyD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCr0; else goto caCqr;
       uaCr0: // global
           call _caCqq(R1) args: 0, res: 0, upd: 0;
       caCqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCqq() //  [R1]
         { info_tbl: [(caCqq,
                       label: block_caCqq_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCqq: // global
           I64[Sp - 8] = block_caCqv_info;
           _saAyF::P64 = R1;
           _saAyG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saAyG::I64;
           P64[Sp + 32] = _saAyF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCr1; else goto caCqB;
       uaCr1: // global
           call _caCqv(R1) args: 0, res: 0, upd: 0;
       caCqB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCqv() //  [R1]
         { info_tbl: [(caCqv,
                       label: block_caCqv_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCqv: // global
           _saAyD::P64 = P64[Sp + 32];
           _saAyE::I64 = I64[Sp + 16];
           _saAyF::P64 = P64[Sp + 40];
           _saAyJ::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saAyE::I64,
                            _saAyJ::I64)) goto caCqS; else goto caCqU;
       caCqU: // global
           if (%MO_S_Gt_W64(_saAyJ::I64,
                            I64[Sp + 8])) goto caCqS; else goto caCqT;
       caCqS: // global
           R4 = _saAyJ::I64;
           R3 = _saAyD::P64;
           R2 = _saAyF::P64;
           Sp = Sp + 48;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caCqT: // global
           R1 = P64[P64[Sp + 24] + ((_saAyJ::I64 - _saAyE::I64 << 3) + 24)] & (-8);
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.716736844 UTC

[section ""data" . GHC.Event.Manager.wakeManager1_closure" {
     GHC.Event.Manager.wakeManager1_closure:
         const GHC.Event.Manager.wakeManager1_info;
 },
 GHC.Event.Manager.wakeManager1_entry() //  []
         { info_tbl: [(caCr6,
                       label: GHC.Event.Manager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCr6: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.717580295 UTC

[section ""data" . GHC.Event.Manager.wakeManager_closure" {
     GHC.Event.Manager.wakeManager_closure:
         const GHC.Event.Manager.wakeManager_info;
 },
 GHC.Event.Manager.wakeManager_entry() //  [R2]
         { info_tbl: [(caCrd,
                       label: GHC.Event.Manager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrd: // global
           R2 = R2;
           call GHC.Event.Manager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.719024967 UTC

[section ""data" . GHC.Event.Manager.cleanup1_closure" {
     GHC.Event.Manager.cleanup1_closure:
         const GHC.Event.Manager.cleanup1_info;
 },
 GHC.Event.Manager.cleanup1_entry() //  [R2]
         { info_tbl: [(caCrn,
                       label: GHC.Event.Manager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrn: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caCrr; else goto caCrs;
       caCrr: // global
           R2 = R2;
           R1 = GHC.Event.Manager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCrs: // global
           I64[Sp - 8] = block_caCrk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCsl; else goto caCrl;
       uaCsl: // global
           call _caCrk(R1) args: 0, res: 0, upd: 0;
       caCrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCrk() //  [R1]
         { info_tbl: [(caCrk,
                       label: block_caCrk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrk: // global
           I64[Sp - 56] = block_caCrq_info;
           _saAz1::P64 = P64[R1 + 39];
           _saAz6::P64 = P64[R1 + 55];
           _saAz7::P64 = P64[R1 + 63];
           _saAz8::P64 = P64[R1 + 71];
           _saAz3::I64 = I64[R1 + 87];
           _saAz4::I64 = I64[R1 + 95];
           _saAz5::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           I64[Sp - 48] = _saAz3::I64;
           I64[Sp - 40] = _saAz4::I64;
           I64[Sp - 32] = _saAz5::I64;
           P64[Sp - 24] = _saAz6::P64;
           P64[Sp - 16] = _saAz7::P64;
           P64[Sp - 8] = _saAz8::P64;
           P64[Sp] = _saAz1::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaCsk; else goto caCru;
       uaCsk: // global
           call _caCrq(R1) args: 0, res: 0, upd: 0;
       caCru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCrq() //  [R1]
         { info_tbl: [(caCrq,
                       label: block_caCrq_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrq: // global
           _saAz1::P64 = P64[Sp + 56];
           _saAz8::P64 = P64[Sp + 48];
           _saAza::P64 = P64[R1 + 7];
           _saAze::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saAz1::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saAz1::P64);
           I64[Sp] = block_caCrB_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saAz8::P64;
           P64[Sp + 48] = _saAze::P64;
           P64[Sp + 56] = _saAza::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCrB() //  []
         { info_tbl: [(caCrB,
                       label: block_caCrB_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrB: // global
           I64[Sp] = block_caCrD_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCrD() //  []
         { info_tbl: [(caCrD,
                       label: block_caCrD_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrD: // global
           I64[Sp] = block_caCrF_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCrF() //  []
         { info_tbl: [(caCrF,
                       label: block_caCrF_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrF: // global
           _saAz4::I64 = I64[Sp + 16];
           _saAz6::P64 = P64[Sp + 32];
           (_saAzt::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saAzy::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz4::I64)));
           I64[Sp + 16] = block_caCrV_info;
           R1 = _saAz6::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaCsm; else goto caCrW;
       uaCsm: // global
           call _caCrV(R1) args: 0, res: 0, upd: 0;
       caCrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCrV() //  [R1]
         { info_tbl: [(caCrV,
                       label: block_caCrV_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCrV: // global
           _saAz5::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caCs2; else goto caCs6;
       caCs2: // global
           (_saAzE::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz5::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCs6: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saAzM::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz5::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.721500834 UTC

[section ""data" . GHC.Event.Manager.cleanup_closure" {
     GHC.Event.Manager.cleanup_closure:
         const GHC.Event.Manager.cleanup_info;
 },
 GHC.Event.Manager.cleanup_entry() //  [R2]
         { info_tbl: [(caCsr,
                       label: GHC.Event.Manager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCsr: // global
           R2 = R2;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.722725997 UTC

[section ""data" . GHC.Event.Manager.finished1_closure" {
     GHC.Event.Manager.finished1_closure:
         const GHC.Event.Manager.finished1_info;
 },
 sat_saAA7_entry() //  [R1]
         { info_tbl: [(caCsO,
                       label: sat_saAA7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCsO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCsP; else goto caCsQ;
       caCsP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCsQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caCsH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCsX; else goto caCsI;
       uaCsX: // global
           call _caCsH(R1) args: 0, res: 0, upd: 0;
       caCsI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caCsH() //  [R1]
         { info_tbl: [(caCsH,
                       label: block_caCsH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCsH: // global
           if (R1 & 7 == 5) goto caCsM; else goto caCsL;
       caCsM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caCsL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.finished1_entry() //  [R2]
         { info_tbl: [(caCsY,
                       label: GHC.Event.Manager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCsY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCsZ; else goto caCt0;
       caCsZ: // global
           R2 = R2;
           R1 = GHC.Event.Manager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCt0: // global
           I64[Sp - 8] = block_caCsy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCt4; else goto caCsz;
       uaCt4: // global
           call _caCsy(R1) args: 0, res: 0, upd: 0;
       caCsz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCsy() //  [R1]
         { info_tbl: [(caCsy,
                       label: block_caCsy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCsy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCt3; else goto caCt2;
       caCt3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCt2: // global
           _saAA5::P64 = P64[P64[R1 + 39] + 8];
           I64[Hp - 16] = sat_saAA7_info;
           P64[Hp] = _saAA5::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.724389513 UTC

[section ""data" . GHC.Event.Manager.finished_closure" {
     GHC.Event.Manager.finished_closure:
         const GHC.Event.Manager.finished_info;
 },
 GHC.Event.Manager.finished_entry() //  [R2]
         { info_tbl: [(caCt9,
                       label: GHC.Event.Manager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCt9: // global
           R2 = R2;
           call GHC.Event.Manager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.725304106 UTC

[section ""data" . GHC.Event.Manager.release2_closure" {
     GHC.Event.Manager.release2_closure:
         const GHC.Event.Manager.release2_info;
 },
 GHC.Event.Manager.release2_entry() //  [R2]
         { info_tbl: [(caCth,
                       label: GHC.Event.Manager.release2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCth: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCtl; else goto caCtk;
       caCtl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.release2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCtk: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Releasing_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.726526095 UTC

[section ""data" . GHC.Event.Manager.release1_closure" {
     GHC.Event.Manager.release1_closure:
         const GHC.Event.Manager.release1_info;
         const 0;
 },
 GHC.Event.Manager.release1_entry() //  [R2]
         { info_tbl: [(caCtt,
                       label: GHC.Event.Manager.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCtt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCtu; else goto caCtv;
       caCtu: // global
           R2 = R2;
           R1 = GHC.Event.Manager.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCtv: // global
           I64[Sp - 8] = block_caCtq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCtP; else goto caCtr;
       uaCtP: // global
           call _caCtq(R1) args: 0, res: 0, upd: 0;
       caCtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCtq() //  [R1]
         { info_tbl: [(caCtq,
                       label: block_caCtq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCtq: // global
           I64[Sp - 16] = block_caCty_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saAAn::P64 = P64[R1 + 63];
           _saAAl::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saAAn::P64;
           I64[Sp] = _saAAl::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCty() //  [R1]
         { info_tbl: [(caCty,
                       label: block_caCty_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCty: // global
           I64[Sp] = block_caCtA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCtQ; else goto caCtD;
       uaCtQ: // global
           call _caCtA(R1) args: 0, res: 0, upd: 0;
       caCtD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCtA() //  [R1]
         { info_tbl: [(caCtA,
                       label: block_caCtA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCtA: // global
           if (R1 & 7 == 2) goto caCtN; else goto caCtJ;
       caCtN: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       caCtJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.728012187 UTC

[section ""data" . GHC.Event.Manager.release_closure" {
     GHC.Event.Manager.release_closure:
         const GHC.Event.Manager.release_info;
         const 0;
 },
 GHC.Event.Manager.release_entry() //  [R2]
         { info_tbl: [(caCtV,
                       label: GHC.Event.Manager.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCtV: // global
           R2 = R2;
           call GHC.Event.Manager.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.728891348 UTC

[section ""data" . GHC.Event.Manager.shutdown2_closure" {
     GHC.Event.Manager.shutdown2_closure:
         const GHC.Event.Manager.shutdown2_info;
 },
 GHC.Event.Manager.shutdown2_entry() //  [R2]
         { info_tbl: [(caCu3,
                       label: GHC.Event.Manager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCu3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCu7; else goto caCu6;
       caCu7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCu6: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.730143811 UTC

[section ""data" . GHC.Event.Manager.shutdown1_closure" {
     GHC.Event.Manager.shutdown1_closure:
         const GHC.Event.Manager.shutdown1_info;
         const 0;
 },
 GHC.Event.Manager.shutdown1_entry() //  [R2]
         { info_tbl: [(caCuf,
                       label: GHC.Event.Manager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCuf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCug; else goto caCuh;
       caCug: // global
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCuh: // global
           I64[Sp - 8] = block_caCuc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCuB; else goto caCud;
       uaCuB: // global
           call _caCuc(R1) args: 0, res: 0, upd: 0;
       caCud: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCuc() //  [R1]
         { info_tbl: [(caCuc,
                       label: block_caCuc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCuc: // global
           I64[Sp - 16] = block_caCuk_info;
           R2 = GHC.Event.Manager.shutdown2_closure+1;
           _saAAI::P64 = P64[R1 + 63];
           _saAAF::I64 = I64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saAAI::P64;
           I64[Sp] = _saAAF::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCuk() //  [R1]
         { info_tbl: [(caCuk,
                       label: block_caCuk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCuk: // global
           I64[Sp] = block_caCum_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCuC; else goto caCup;
       uaCuC: // global
           call _caCum(R1) args: 0, res: 0, upd: 0;
       caCup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCum() //  [R1]
         { info_tbl: [(caCum,
                       label: block_caCum_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCum: // global
           if (R1 & 7 == 2) goto caCuz; else goto caCuv;
       caCuz: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       caCuv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.73168291 UTC

[section ""data" . GHC.Event.Manager.shutdown_closure" {
     GHC.Event.Manager.shutdown_closure:
         const GHC.Event.Manager.shutdown_info;
         const 0;
 },
 GHC.Event.Manager.shutdown_entry() //  [R2]
         { info_tbl: [(caCuH,
                       label: GHC.Event.Manager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCuH: // global
           R2 = R2;
           call GHC.Event.Manager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.732383778 UTC

[section ""cstring" . lvl4_raAu9_bytes" {
     lvl4_raAu9_bytes:
         I8[] [70,97,105,108,101,100,32,119,104,105,108,101,32,97,116,116,101,109,112,116,105,110,103,32,116,111,32,109,111,100,105,102,121,32,114,101,103,105,115,116,114,97,116,105,111,110,32,111,102,32,102,105,108,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.732949344 UTC

[section ""cstring" . lvl5_raAua_bytes" {
     lvl5_raAua_bytes:
         I8[] [32,97,116,32,108,111,99,97,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.734147476 UTC

[section ""data" . $wlvl_raAub_closure" {
     $wlvl_raAub_closure:
         const $wlvl_raAub_info;
         const 0;
 },
 sat_saAAU_entry() //  [R1]
         { info_tbl: [(caCuY,
                       label: sat_saAAU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCuY: // global
           R3 = P64[R1 + 16];
           R2 = lvl5_raAua_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAAV_entry() //  [R1]
         { info_tbl: [(caCv2,
                       label: sat_saAAV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCv2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caCv3; else goto caCv4;
       caCv3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCv4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caCuS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caCuS() //  [R1, R2]
         { info_tbl: [(caCuS,
                       label: block_caCuS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCuS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caCv7; else goto caCv6;
       caCv7: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caCv6: // global
           I64[Hp - 40] = sat_saAAU_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_raAub_entry() //  [R2, R3]
         { info_tbl: [(caCva,
                       label: $wlvl_raAub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCva: // global
           _saAAP::I64 = R3;
           _saAAO::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caCvb; else goto caCvc;
       caCvc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caCve; else goto caCvd;
       caCve: // global
           HpAlloc = 32;
           goto caCvb;
       caCvb: // global
           R3 = _saAAP::I64;
           R2 = _saAAO::P64;
           R1 = $wlvl_raAub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCvd: // global
           I64[Hp - 24] = sat_saAAV_info;
           P64[Hp - 8] = _saAAO::P64;
           I64[Hp] = _saAAP::I64;
           I64[Sp - 8] = block_caCv8_info;
           R3 = Hp - 24;
           R2 = lvl4_raAu9_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCv8() //  [R1]
         { info_tbl: [(caCv8,
                       label: block_caCv8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCv8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.735863992 UTC

[section ""cstring" . lvl6_raAuc_bytes" {
     lvl6_raAuc_bytes:
         I8[] [114,101,103,105,115,116,101,114,67,111,110,116,114,111,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.736579779 UTC

[section ""data" . lvl7_raAud_closure" {
     lvl7_raAud_closure:
         const lvl7_raAud_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_raAud_entry() //  [R1]
         { info_tbl: [(caCvo,
                       label: lvl7_raAud_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCvp; else goto caCvq;
       caCvp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCvq: // global
           (_caCvl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCvl::I64 == 0) goto caCvn; else goto caCvm;
       caCvn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCvm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCvl::I64;
           R2 = lvl6_raAuc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.737646992 UTC

[section ""data" . GHC.Event.Manager.new5_closure" {
     GHC.Event.Manager.new5_closure:
         const GHC.Event.Manager.new5_info;
 },
 GHC.Event.Manager.new5_entry() //  [R2]
         { info_tbl: [(caCvw,
                       label: GHC.Event.Manager.new5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCvA; else goto caCvz;
       caCvA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.new5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCvz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Finished_closure+5;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.738432756 UTC

[section ""data" . GHC.Event.Manager.new4_closure" {
     GHC.Event.Manager.new4_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.739702073 UTC

[section ""data" . x_raAue_closure" {
     x_raAue_closure:
         const x_raAue_info;
 },
 x_raAue_entry() //  []
         { info_tbl: [(caCvQ,
                       label: x_raAue_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCw3; else goto caCw4;
       caCw4: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caCw6; else goto caCw5;
       caCw6: // global
           HpAlloc = 96;
           goto caCw3;
       caCw3: // global
           R1 = x_raAue_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caCw5: // global
           I64[Hp - 88] = stg_MUT_ARR_PTRS_DIRTY_info;
           I64[Hp - 80] = 8;
           I64[Hp - 72] = 9;
           _caCvF::I64 = Hp - 88;
           _caCvG::I64 = _caCvF::I64 + 24;
           goto caCvH;
       caCvH: // global
           if (_caCvG::I64 < (_caCvF::I64 + 88)) goto caCvJ; else goto caCvI;
       caCvJ: // global
           P64[_caCvG::I64] = GHC.Event.IntTable.Empty_closure+1;
           _caCvG::I64 = _caCvG::I64 + 8;
           goto caCvH;
       caCvI: // global
           I64[Sp - 16] = block_caCvK_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _caCvF::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCvK() //  [R1]
         { info_tbl: [(caCvK,
                       label: block_caCvK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvK: // global
           I64[Sp - 8] = block_caCvM_info;
           R2 = 8;
           _saAB4::P64 = R1;
           R1 = 8;
           P64[Sp] = _saAB4::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCvM() //  [R1]
         { info_tbl: [(caCvM,
                       label: block_caCvM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caCwa; else goto caCw9;
       caCwa: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCw9: // global
           _saAB1::P64 = P64[Sp + 16];
           _saAB4::P64 = P64[Sp + 8];
           _saAB8::I64 = R1 + 16;
           I64[_saAB8::I64] = 0;
           I64[Hp - 48] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 40] = R1;
           P64[Hp - 32] = _saAB4::P64;
           _caCvS::P64 = Hp - 46;
           call MO_Touch(_caCvS::P64);
           I64[Hp - 24] = GHC.Event.IntTable.IT_con_info;
           P64[Hp - 16] = _saAB1::P64;
           P64[Hp - 8] = _caCvS::P64;
           I64[Hp] = _saAB8::I64;
           I64[Sp + 16] = block_caCvV_info;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCvV() //  [R1]
         { info_tbl: [(caCvV,
                       label: block_caCvV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvV: // global
           I64[Sp - 8] = block_caCvX_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caCvX() //  [R1]
         { info_tbl: [(caCvX,
                       label: block_caCvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCvX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCwe; else goto caCwd;
       caCwe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCwd: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_caCw0_info;
           R2 = Hp - 7;
           _saABi::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _saABi::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCw0() //  []
         { info_tbl: [(caCw0,
                       label: block_caCw0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCw0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCwh; else goto caCwg;
       caCwh: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caCwg: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.742170964 UTC

[section ""data" . GHC.Event.Manager.$wxs_closure" {
     GHC.Event.Manager.$wxs_closure:
         const GHC.Event.Manager.$wxs_info;
 },
 GHC.Event.Manager.$wxs_entry() //  [R2]
         { info_tbl: [(caCwq,
                       label: GHC.Event.Manager.$wxs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCwq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCwr; else goto caCws;
       caCwr: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$wxs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCws: // global
           if (R2 == 1) goto caCwp; else goto caCwo;
       caCwp: // global
           I64[Sp - 8] = block_caCwH_info;
           Sp = Sp - 8;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
       caCwo: // global
           I64[Sp - 16] = block_caCwu_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caCwH() //  [R1]
         { info_tbl: [(caCwH,
                       label: block_caCwH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCwH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCwM; else goto caCwL;
       caCwM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCwL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCwu() //  [R1]
         { info_tbl: [(caCwu,
                       label: block_caCwu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCwu: // global
           I64[Sp] = block_caCwz_info;
           R2 = I64[Sp + 8] - 1;
           P64[Sp + 8] = R1;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCwz() //  [R1]
         { info_tbl: [(caCwz,
                       label: block_caCwz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCwz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCwF; else goto caCwE;
       caCwF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCwE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.74367998 UTC

[section ""data" . GHC.Event.Manager.new3_closure" {
     GHC.Event.Manager.new3_closure:
         const GHC.Event.Manager.new3_info;
         const 0;
 },
 GHC.Event.Manager.new3_entry() //  [R2]
         { info_tbl: [(caCwR,
                       label: GHC.Event.Manager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCwR: // global
           R3 = R2;
           R2 = lvl7_raAud_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.747334711 UTC

[section ""data" . GHC.Event.Manager.new2_closure" {
     GHC.Event.Manager.new2_closure:
         const GHC.Event.Manager.new2_info;
         const 0;
 },
 sat_saAC5_entry() //  [R1]
         { info_tbl: [(caCxi,
                       label: sat_saAC5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCxj; else goto caCxk;
       caCxj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caCxk: // global
           I64[Sp - 24] = block_caCx9_info;
           R2 = GHC.Event.Manager.new5_closure+1;
           _saABC::P64 = P64[R1 + 7];
           _saABJ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _saABC::P64;
           P64[Sp - 8] = _saABJ::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCx9() //  [R1]
         { info_tbl: [(caCx9,
                       label: block_caCx9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCx9: // global
           I64[Sp] = block_caCxb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCxB; else goto caCxc;
       uaCxB: // global
           call _caCxb(R1) args: 0, res: 0, upd: 0;
       caCxc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxb() //  [R1]
         { info_tbl: [(caCxb,
                       label: block_caCxb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxb: // global
           if (R1 & 7 == 5) goto caCxg; else goto caCxf;
       caCxg: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCxf: // global
           _saABC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCxo_info;
           R1 = _saABC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCxC; else goto caCxp;
       uaCxC: // global
           call _caCxo(R1) args: 0, res: 0, upd: 0;
       caCxp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxo() //  [R1]
         { info_tbl: [(caCxo,
                       label: block_caCxo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxo: // global
           I64[Sp] = block_caCxt_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxt() //  []
         { info_tbl: [(caCxt,
                       label: block_caCxt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxt: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.new2_entry() //  [R2]
         { info_tbl: [(caCxN,
                       label: GHC.Event.Manager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxN: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caCy5; else goto caCy6;
       caCy5: // global
           R2 = R2;
           R1 = GHC.Event.Manager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCy6: // global
           I64[Sp - 16] = block_caCwY_info;
           _saABC::P64 = R2;
           R2 = 32;
           P64[Sp - 8] = _saABC::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCwY() //  [R1]
         { info_tbl: [(caCwY,
                       label: block_caCwY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCwY: // global
           I64[Sp - 8] = block_caCx0_info;
           R2 = GHC.Types.False_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCx0() //  [R1]
         { info_tbl: [(caCx0,
                       label: block_caCx0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCx0: // global
           I64[Sp - 8] = block_caCx2_info;
           _saABJ::P64 = R1;
           R1 = GHC.Event.Manager.Created_closure+1;
           P64[Sp] = _saABJ::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCx2() //  [R1]
         { info_tbl: [(caCx2,
                       label: block_caCx2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCx2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caCyb; else goto caCya;
       caCyb: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCya: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_saAC5_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_caCxE_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _saABM::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _saABM::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxE() //  []
         { info_tbl: [(caCxE,
                       label: block_caCxE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxE: // global
           I64[Sp] = block_caCxG_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caCxG() //  [R1]
         { info_tbl: [(caCxG,
                       label: block_caCxG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxG: // global
           I64[Sp - 8] = block_caCxI_info;
           R2 = GHC.Tuple.()_closure+1;
           _saACb::P64 = R1;
           R1 = R1;
           P64[Sp] = _saACb::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxI() //  []
         { info_tbl: [(caCxI,
                       label: block_caCxI_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxI: // global
           I64[Sp] = block_caCxK_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uaCzB; else goto caCxL;
       uaCzB: // global
           call _caCxK(R1) args: 0, res: 0, upd: 0;
       caCxL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxK() //  [R1]
         { info_tbl: [(caCxK,
                       label: block_caCxK_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxK: // global
           I64[Sp - 16] = block_caCxQ_info;
           R2 = GHC.Arr.arrEleBottom_closure;
           _saACd::P64 = R1;
           _saACe::P64 = P64[R1 + 7];
           _saACg::P64 = P64[R1 + 23];
           R1 = 32;
           P64[Sp - 8] = _saACg::P64;
           P64[Sp] = _saACe::P64;
           P64[Sp + 48] = _saACd::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxQ() //  [R1]
         { info_tbl: [(caCxQ,
                       label: block_caCxQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxQ: // global
           I64[Sp - 8] = 0;
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 56] = R1;
           Sp = Sp - 8;
           call _caCyn() args: 0, res: 0, upd: 0;
     }
 },
 _caCyn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCyn: // global
           I64[Sp - 8] = block_caCyq_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCzF; else goto caCys;
       uaCzF: // global
           call _caCyq(R1) args: 0, res: 0, upd: 0;
       caCys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCyq() //  [R1]
         { info_tbl: [(caCyq,
                       label: block_caCyq_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCyq: // global
           if (R1 & 7 == 1) goto uaCzy; else goto caCyG;
       uaCzy: // global
           Sp = Sp + 16;
           goto uaCzH;
       caCyG: // global
           _saACl::P64 = P64[Sp + 72];
           _saACu::I64 = I64[Sp + 8];
           _saACx::P64 = P64[R1 + 6];
           _saACy::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[(_saACl::P64 + 24) + (_saACu::I64 << 3)] = _saACx::P64;
           I64[_saACl::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saACl::P64 + 24) + ((I64[_saACl::P64 + 8] << 3) + (_saACu::I64 >> 7))] = 1 :: W8;
           if (_saACu::I64 == 31) goto uaCzz; else goto caCyE;
       uaCzz: // global
           Sp = Sp + 16;
           goto uaCzH;
       uaCzH: // global
           call _caCyi() args: 0, res: 0, upd: 0;
       caCyE: // global
           P64[Sp + 16] = _saACy::P64;
           I64[Sp + 8] = _saACu::I64 + 1;
           Sp = Sp + 8;
           call _caCyn() args: 0, res: 0, upd: 0;
     }
 },
 _caCyi() //  []
         { info_tbl: [(caCyi,
                       label: block_caCyi_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCyi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caCym; else goto caCyl;
       caCym: // global
           HpAlloc = 40;
           I64[Sp] = block_caCyi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caCyl: // global
           _saACl::P64 = P64[Sp + 56];
           I64[_saACl::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = GHC.Event.Manager.$fShowFdKey6_closure+1;
           P64[Hp - 16] = GHC.Event.Manager.new4_closure+1;
           P64[Hp - 8] = _saACl::P64;
           I64[Hp] = 32;
           I64[Sp] = block_caCxZ_info;
           R1 = Hp - 31;
           if (R1 & 7 != 0) goto uaCzE; else goto caCy0;
       uaCzE: // global
           call _caCxZ(R1) args: 0, res: 0, upd: 0;
       caCy0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCxZ() //  [R1]
         { info_tbl: [(caCxZ,
                       label: block_caCxZ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCxZ: // global
           I64[Sp - 16] = block_caCy4_info;
           _saACG::P64 = P64[R1 + 7];
           _saACH::P64 = P64[R1 + 15];
           _saACJ::P64 = P64[R1 + 23];
           _saACI::I64 = I64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saACJ::P64;
           I64[Sp] = _saACI::I64;
           P64[Sp + 48] = _saACH::P64;
           P64[Sp + 56] = _saACG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCzD; else goto caCyJ;
       uaCzD: // global
           call _caCy4(R1) args: 0, res: 0, upd: 0;
       caCyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCy4() //  [R1]
         { info_tbl: [(caCy4,
                       label: block_caCy4_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCy4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCyT; else goto caCyS;
       caCyT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCyS: // global
           _saACO::P64 = P64[R1 + 7];
           _saACP::P64 = P64[R1 + 15];
           _saACL::I64 = I64[R1 + 23];
           _saACM::I64 = I64[R1 + 31];
           _saACN::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saACL::I64;
           I64[Sp - 40] = block_caCyO_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           I64[Sp - 48] = stg_ap_v_info;
           I64[Sp - 32] = _saACM::I64;
           I64[Sp - 24] = _saACN::I64;
           P64[Sp - 16] = _saACO::P64;
           P64[Sp - 8] = _saACP::P64;
           I64[Sp] = _saACL::I64;
           Sp = Sp - 48;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caCyO() //  [R1]
         { info_tbl: [(caCyO,
                       label: block_caCyO_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCyO: // global
           I64[Sp] = block_caCyQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCzJ; else goto caCyV;
       uaCzJ: // global
           call _caCyQ(R1) args: 0, res: 0, upd: 0;
       caCyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCyQ() //  [R1]
         { info_tbl: [(caCyQ,
                       label: block_caCyQ_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCyQ: // global
           if (R1 & 7 == 1) goto caCz1; else goto caCz8;
       caCz1: // global
           R2 = I64[Sp + 40];
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caCz8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCzb; else goto caCza;
       caCzb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCza: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caCz5_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 72];
           R1 = P64[Sp + 64];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caCz5() //  [R1]
         { info_tbl: [(caCz5,
                       label: block_caCz5_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCz5: // global
           I64[Sp] = block_caCz7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCzK; else goto caCzd;
       uaCzK: // global
           call _caCz7(R1) args: 0, res: 0, upd: 0;
       caCzd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCz7() //  [R1]
         { info_tbl: [(caCz7,
                       label: block_caCz7_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCz7: // global
           _saACN::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto caCzj; else goto caCzn;
       caCzj: // global
           R2 = _saACN::I64;
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caCzn: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caCzq; else goto caCzp;
       caCzq: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCzp: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 120];
           P64[Hp - 88] = P64[Sp + 112];
           P64[Hp - 80] = P64[Sp + 104];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 80];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saACN::I64;
           R1 = Hp - 103;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.753535765 UTC

[section ""data" . GHC.Event.Manager.newWith_closure" {
     GHC.Event.Manager.newWith_closure:
         const GHC.Event.Manager.newWith_info;
         const 0;
 },
 GHC.Event.Manager.newWith_entry() //  [R2]
         { info_tbl: [(caCzP,
                       label: GHC.Event.Manager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCzP: // global
           R2 = R2;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.754415604 UTC

[section ""data" . GHC.Event.Manager.new1_closure" {
     GHC.Event.Manager.new1_closure:
         const GHC.Event.Manager.new1_info;
         const 0;
 },
 GHC.Event.Manager.new1_entry() //  []
         { info_tbl: [(caCzY,
                       label: GHC.Event.Manager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCzY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCzZ; else goto caCA0;
       caCzZ: // global
           R1 = GHC.Event.Manager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caCA0: // global
           I64[Sp - 8] = block_caCzW_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caCzW() //  [R1]
         { info_tbl: [(caCzW,
                       label: block_caCzW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCzW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.755355679 UTC

[section ""data" . GHC.Event.Manager.new_closure" {
     GHC.Event.Manager.new_closure:
         const GHC.Event.Manager.new_info;
         const 0;
 },
 GHC.Event.Manager.new_entry() //  []
         { info_tbl: [(caCA6,
                       label: GHC.Event.Manager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCA6: // global
           call GHC.Event.Manager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.756404882 UTC

[section ""data" . GHC.Event.Manager.closeFd_3_closure" {
     GHC.Event.Manager.closeFd_3_closure:
         const GHC.Event.Manager.closeFd_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.closeFd_3_entry() //  [R1]
         { info_tbl: [(caCAh,
                       label: GHC.Event.Manager.closeFd_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCAp; else goto caCAq;
       caCAp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCAq: // global
           (_caCAc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCAc::I64 == 0) goto caCAe; else goto caCAd;
       caCAe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCAd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCAc::I64;
           I64[Sp - 24] = block_caCAf_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp - 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _caCAf() //  [R1]
         { info_tbl: [(caCAf,
                       label: block_caCAf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAf: // global
           I64[Sp] = block_caCAk_info;
           R2 = R1;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caCAk() //  [R1]
         { info_tbl: [(caCAk,
                       label: block_caCAk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCAu; else goto caCAt;
       caCAu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caCAt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.758410714 UTC

[section ""data" . GHC.Event.Manager.$weventsOf_closure" {
     GHC.Event.Manager.$weventsOf_closure:
         const GHC.Event.Manager.$weventsOf_info;
         const 0;
 },
 GHC.Event.Manager.$weventsOf_entry() //  [R2]
         { info_tbl: [(caCAG,
                       label: GHC.Event.Manager.$weventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCAH; else goto caCAI;
       caCAH: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$weventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCAI: // global
           I64[Sp - 8] = block_caCAz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCBl; else goto caCAA;
       uaCBl: // global
           call _caCAz(R1) args: 0, res: 0, upd: 0;
       caCAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCAz() //  [R1]
         { info_tbl: [(caCAz,
                       label: block_caCAz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAz: // global
           if (R1 & 7 == 1) goto caCAD; else goto caCAE;
       caCAD: // global
           I64[Sp] = block_caCAL_info;
           R1 = GHC.Event.Manager.closeFd_3_closure;
           if (R1 & 7 != 0) goto uaCBj; else goto caCAN;
       uaCBj: // global
           call _caCAL(R1) args: 0, res: 0, upd: 0;
       caCAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCAE: // global
           I64[Sp - 16] = block_caCAU_info;
           _saADa::P64 = R1;
           _saADd::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 8] = _saADd::P64;
           P64[Sp] = _saADa::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCBk; else goto caCAW;
       uaCBk: // global
           call _caCAU(R1) args: 0, res: 0, upd: 0;
       caCAW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCAL() //  [R1]
         { info_tbl: [(caCAL,
                       label: block_caCAL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAL: // global
           R1 = I64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCAU() //  [R1]
         { info_tbl: [(caCAU,
                       label: block_caCAU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCAU: // global
           if (R1 & 7 == 1) goto caCB3; else goto caCBd;
       caCB3: // global
           I64[Sp + 16] = block_caCB0_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaCBm; else goto caCB4;
       uaCBm: // global
           call _caCB0(R1) args: 0, res: 0, upd: 0;
       caCB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCBd: // global
           _saADa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caCBb_info;
           R3 = _saADa::P64;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCB0() //  [R1]
         { info_tbl: [(caCB0,
                       label: block_caCB0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCB0: // global
           R1 = I64[R1 + 31];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCBb() //  [R1]
         { info_tbl: [(caCBb,
                       label: block_caCBb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.76040858 UTC

[section ""data" . GHC.Event.Manager.eventsOf_closure" {
     GHC.Event.Manager.eventsOf_closure:
         const GHC.Event.Manager.eventsOf_info;
         const 0;
 },
 GHC.Event.Manager.eventsOf_entry() //  [R2]
         { info_tbl: [(caCBt,
                       label: GHC.Event.Manager.eventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCBx; else goto caCBy;
       caCBx: // global
           R2 = R2;
           R1 = GHC.Event.Manager.eventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCBy: // global
           I64[Sp - 8] = block_caCBr_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCBr() //  [R1]
         { info_tbl: [(caCBr,
                       label: block_caCBr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCBB; else goto caCBA;
       caCBB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caCBA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.762043595 UTC

[section ""data" . GHC.Event.Manager.closeFd_2_closure" {
     GHC.Event.Manager.closeFd_2_closure:
         const GHC.Event.Manager.closeFd_2_info;
 },
 GHC.Event.Manager.closeFd_2_entry() //  [R2]
         { info_tbl: [(caCBN,
                       label: GHC.Event.Manager.closeFd_2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCBO; else goto uaCCf;
       caCBO: // global
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaCCf: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caCBD() args: 0, res: 0, upd: 0;
     }
 },
 _caCBD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBD: // global
           _saADq::P64 = P64[Sp];
           I64[Sp] = block_caCBG_info;
           R1 = _saADq::P64;
           if (R1 & 7 != 0) goto uaCCh; else goto caCBH;
       uaCCh: // global
           call _caCBG(R1) args: 0, res: 0, upd: 0;
       caCBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCBG() //  [R1]
         { info_tbl: [(caCBG,
                       label: block_caCBG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBG: // global
           if (R1 & 7 == 1) goto caCBK; else goto caCBL;
       caCBK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCBL: // global
           I64[Sp - 8] = block_caCBV_info;
           _saADu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saADu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCCi; else goto caCBX;
       uaCCi: // global
           call _caCBV(R1) args: 0, res: 0, upd: 0;
       caCBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCBV() //  [R1]
         { info_tbl: [(caCBV,
                       label: block_caCBV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCBV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caCC3; else goto caCC2;
       caCC3: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCC2: // global
           _saADz::P64 = P64[R1 + 7];
           _saADw::I64 = I64[R1 + 15];
           _saADx::I64 = I64[R1 + 23];
           _saADC::I64 = I64[R1 + 31] & 7 | 4;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _saADC::I64;
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saADw::I64;
           I64[Hp] = _saADx::I64;
           I64[Sp] = block_caCCc_info;
           R3 = Hp - 31;
           R2 = Hp - 15;
           R1 = _saADz::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCCc() //  []
         { info_tbl: [(caCCc,
                       label: block_caCCc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCc: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caCBD() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.768773031 UTC

[section ""data" . GHC.Event.Manager.closeFd1_closure" {
     GHC.Event.Manager.closeFd1_closure:
         const GHC.Event.Manager.closeFd1_info;
         const 0;
 },
 $wgo_saAEy_entry() //  [R1, R2]
         { info_tbl: [(caCDz,
                       label: $wgo_saAEy_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCDz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCDA; else goto caCDB;
       caCDA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCDB: // global
           I64[Sp - 24] = block_caCDs_info;
           _saAEy::P64 = R1;
           _saAE7::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAE7::I64;
           P64[Sp - 8] = _saAEy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCDY; else goto caCDt;
       uaCDY: // global
           call _caCDs(R1) args: 0, res: 0, upd: 0;
       caCDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCDs() //  [R1]
         { info_tbl: [(caCDs,
                       label: block_caCDs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCDs: // global
           if (R1 & 7 == 1) goto caCDw; else goto caCDx;
       caCDw: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCDx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCDJ; else goto caCDI;
       caCDJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCDI: // global
           _saAEC::P64 = P64[R1 + 6];
           _saAED::P64 = P64[R1 + 14];
           _saAEB::I64 = I64[R1 + 22];
           if (_saAEB::I64 == I64[Sp + 8]) goto caCDX; else goto caCDR;
       caCDX: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAEC::P64;
           R3 = _saAED::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCDR: // global
           Hp = Hp - 16;
           I64[Sp] = block_caCDN_info;
           R2 = _saAED::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAEC::P64;
           I64[Sp + 16] = _saAEB::I64;
           call $wgo_saAEy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCDN() //  [R1, R2, R3]
         { info_tbl: [(caCDN,
                       label: block_caCDN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCDN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caCDU; else goto caCDT;
       caCDU: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caCDT: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAEi_entry() //  [R1, R2]
         { info_tbl: [(caCDZ,
                       label: $wio_saAEi_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCDZ: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caCE0; else goto caCE1;
       caCE0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCE1: // global
           I64[Sp - 40] = block_caCD9_info;
           _saADI::P64 = P64[R1 + 6];
           _saADP::P64 = P64[R1 + 14];
           _saAE6::P64 = P64[R1 + 22];
           _saAE7::I64 = I64[R1 + 30];
           R1 = P64[R2 + 8];
           P64[Sp - 32] = _saADI::P64;
           P64[Sp - 24] = _saADP::P64;
           P64[Sp - 16] = _saAE6::P64;
           I64[Sp - 8] = _saAE7::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaCFD; else goto caCDa;
       uaCFD: // global
           call _caCD9(R1) args: 0, res: 0, upd: 0;
       caCDa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCD9() //  [R1]
         { info_tbl: [(caCD9,
                       label: block_caCD9_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCD9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCE4; else goto caCE3;
       caCE4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCE3: // global
           _saAE7::I64 = I64[Sp + 32];
           _saAEp::P64 = P64[R1 + 7];
           _saAEr::P64 = P64[R1 + 15];
           _saAEq::I64 = I64[R1 + 23];
           _saAEs::I64 = _saAE7::I64 & (I64[_saAEp::P64 + 8] - 1);
           _saAEx::P64 = P64[(_saAEp::P64 + 24) + (_saAEs::I64 << 3)];
           I64[Hp - 8] = $wgo_saAEy_info;
           I64[Hp] = _saAE7::I64;
           I64[Sp - 24] = block_caCE5_info;
           R2 = _saAEx::P64;
           R1 = Hp - 7;
           P64[Sp - 16] = _saAEr::P64;
           I64[Sp - 8] = _saAEs::I64;
           I64[Sp] = _saAEq::I64;
           P64[Sp + 32] = _saAEp::P64;
           Sp = Sp - 24;
           call $wgo_saAEy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCE5() //  [R1, R2, R3]
         { info_tbl: [(caCE5,
                       label: block_caCE5_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCE5: // global
           I64[Sp - 16] = block_caCE9_info;
           _saAEM::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAEM::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCFE; else goto caCF6;
       uaCFE: // global
           call _caCE9(R1) args: 0, res: 0, upd: 0;
       caCF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCE9() //  [R1]
         { info_tbl: [(caCE9,
                       label: block_caCE9_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCE9: // global
           if (R1 & 7 == 1) goto caCFc; else goto caCFh;
       caCFc: // global
           P64[Sp + 72] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAEP() args: 0, res: 0, upd: 0;
       caCFh: // global
           _saAEp::P64 = P64[Sp + 72];
           _saAEs::I64 = I64[Sp + 32];
           _saAEM::P64 = P64[Sp + 16];
           _saAEO::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAEp::P64 + 24) + (_saAEs::I64 << 3)] = _saAEO::P64;
           I64[_saAEp::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAEp::P64 + 24) + ((I64[_saAEp::P64 + 8] << 3) + (_saAEs::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caCFf_info;
           _saAFf::P64 = R1;
           R1 = _saAEM::P64;
           P64[Sp + 72] = _saAFf::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaCFF; else goto caCFi;
       uaCFF: // global
           call _caCFf(R1) args: 0, res: 0, upd: 0;
       caCFi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCFf() //  [R1]
         { info_tbl: [(caCFf,
                       label: block_caCFf_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCFf: // global
           _saAFf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto caCFo; else goto caCFs;
       caCFo: // global
           P64[Sp + 56] = _saAFf::P64;
           Sp = Sp + 32;
           goto uaCFJ;
       caCFs: // global
           _saAEq::I64 = I64[Sp + 24];
           _saAEr::P64 = P64[Sp + 8];
           I64[_saAEq::I64] = I64[_saAEq::I64] - 1;
           call MO_Touch(_saAEr::P64);
           P64[Sp + 56] = _saAFf::P64;
           Sp = Sp + 32;
           goto uaCFJ;
       uaCFJ: // global
           call _saAEP() args: 0, res: 0, upd: 0;
     }
 },
 _saAEP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAEP: // global
           I64[Sp - 8] = block_caCEe_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCFK; else goto caCEg;
       uaCFK: // global
           call _caCEe(R1) args: 0, res: 0, upd: 0;
       caCEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCEe() //  [R1]
         { info_tbl: [(caCEe,
                       label: block_caCEe_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCEe: // global
           if (R1 & 7 == 1) goto caCEn; else goto caCEu;
       caCEn: // global
           I64[Sp + 32] = block_caCEk_info;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caCEu: // global
           I64[Sp] = block_caCEs_info;
           _saAEW::P64 = P64[R1 + 6];
           R2 = _saAEW::P64;
           P64[Sp + 32] = _saAEW::P64;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCEk() //  []
         { info_tbl: [(caCEk,
                       label: block_caCEk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCEk: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCEs() //  [R1]
         { info_tbl: [(caCEs,
                       label: block_caCEs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCEs: // global
           _saAEY::I64 = R1 & 7;
           if (_saAEY::I64 != 0) goto caCEP; else goto caCF2;
       caCEP: // global
           I64[Sp] = block_caCEF_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAEY::I64;
           if (R1 & 7 != 0) goto uaCFH; else goto caCEG;
       uaCFH: // global
           call _caCEF(R1) args: 0, res: 0, upd: 0;
       caCEG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCF2: // global
           _saAE6::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caCF1_info;
           R2 = _saAE6::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCEF() //  [R1]
         { info_tbl: [(caCEF,
                       label: block_caCEF_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCEF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCET; else goto caCES;
       caCET: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCES: // global
           _saAF0::P64 = P64[R1 + 7];
           _saAF2::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caCEL_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 7;
           R3 = P64[Sp + 24];
           R2 = _saAF0::P64;
           R1 = _saAF2::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caCEL() //  []
         { info_tbl: [(caCEL,
                       label: block_caCEL_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCEL: // global
           _saAE6::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caCEN_info;
           R2 = _saAE6::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCEN() //  []
         { info_tbl: [(caCEN,
                       label: block_caCEN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCEN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCF1() //  []
         { info_tbl: [(caCF1,
                       label: block_caCF1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCF1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAFp_entry() //  [R1, R2]
         { info_tbl: [(caCFT,
                       label: io_saAFp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCFT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCFU; else goto caCFV;
       caCFU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCFV: // global
           I64[Sp - 16] = block_caCFQ_info;
           _saAEi::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAEi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCFZ; else goto caCFR;
       uaCFZ: // global
           call _caCFQ(R1) args: 0, res: 0, upd: 0;
       caCFR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCFQ() //  [R1]
         { info_tbl: [(caCFQ,
                       label: block_caCFQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCFQ: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAEi_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFD_entry() //  [R1, R2]
         { info_tbl: [(caCGb,
                       label: sat_saAFD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCGc; else goto caCGd;
       caCGc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCGd: // global
           I64[Sp - 16] = block_caCG9_info;
           _saAFA::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAFA::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCG9() //  []
         { info_tbl: [(caCG9,
                       label: block_caCG9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCG9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFy_entry() //  [R1]
         { info_tbl: [(caCGk,
                       label: sat_saAFy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGk: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFz_entry() //  [R1]
         { info_tbl: [(caCGs,
                       label: sat_saAFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGs: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFR_entry() //  [R1, R2]
         { info_tbl: [(caCGK,
                       label: sat_saAFR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCGL; else goto caCGM;
       caCGL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCGM: // global
           I64[Sp - 16] = block_caCGI_info;
           _saAFO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAFO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCGI() //  []
         { info_tbl: [(caCGI,
                       label: block_caCGI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFM_entry() //  [R1]
         { info_tbl: [(caCGT,
                       label: sat_saAFM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGT: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFN_entry() //  [R1]
         { info_tbl: [(caCH1,
                       label: sat_saAFN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCH1: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFW_entry() //  [R1]
         { info_tbl: [(caCH8,
                       label: sat_saAFW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCH8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCH9; else goto caCHa;
       caCH9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caCHa: // global
           I64[Sp - 24] = block_caCGB_info;
           _saAEh::P64 = P64[R1 + 7];
           _saAFp::P64 = P64[R1 + 15];
           R1 = _saAEh::P64;
           P64[Sp - 16] = _saAEh::P64;
           P64[Sp - 8] = _saAFp::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCGB() //  [R1]
         { info_tbl: [(caCGB,
                       label: block_caCGB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCGB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCHd; else goto caCHc;
       caCHd: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCHc: // global
           I64[Hp - 56] = sat_saAFR_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAFM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAFN_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCH4_info;
           R2 = Hp - 54;
           _saAFL::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAFL::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCH4() //  [R1]
         { info_tbl: [(caCH4,
                       label: block_caCH4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCH4: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCH6_info;
           R2 = P64[Sp + 16];
           _saAFU::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAFU::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCH6() //  []
         { info_tbl: [(caCH6,
                       label: block_caCH6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCH6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG8_entry() //  [R1, R2]
         { info_tbl: [(caCHq,
                       label: sat_saAG8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCHq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCHr; else goto caCHs;
       caCHr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCHs: // global
           I64[Sp - 16] = block_caCHo_info;
           _saAG5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAG5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCHo() //  []
         { info_tbl: [(caCHo,
                       label: block_caCHo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCHo: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG3_entry() //  [R1]
         { info_tbl: [(caCHz,
                       label: sat_saAG3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCHz: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG4_entry() //  [R1]
         { info_tbl: [(caCHH,
                       label: sat_saAG4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCHH: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.closeFd1_entry() //  [R2, R3, R4]
         { info_tbl: [(caCHK,
                       label: GHC.Event.Manager.closeFd1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCHK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caCHL; else goto caCHM;
       caCHL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCHM: // global
           I64[Sp - 32] = block_caCCp_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caCCp() //  [R1]
         { info_tbl: [(caCCp,
                       label: block_caCCp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCp: // global
           I64[Sp] = block_caCCr_info;
           _saADN::I64 = R1;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saADN::I64;
           if (R1 & 7 != 0) goto uaCIr; else goto caCCs;
       uaCIr: // global
           call _caCCr(R1) args: 0, res: 0, upd: 0;
       caCCs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCCr() //  [R1]
         { info_tbl: [(caCCr,
                       label: block_caCCr_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCr: // global
           I64[Sp - 24] = block_caCCw_info;
           _saADP::P64 = P64[R1 + 7];
           _saADR::P64 = P64[R1 + 23];
           _saADT::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saADR::P64;
           P64[Sp - 8] = _saADT::P64;
           P64[Sp] = _saADP::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCIs; else goto caCCx;
       uaCIs: // global
           call _caCCw(R1) args: 0, res: 0, upd: 0;
       caCCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCCw() //  [R1]
         { info_tbl: [(caCCw,
                       label: block_caCCw_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCw: // global
           I64[Sp - 8] = block_caCCB_info;
           _saAE2::P64 = R1;
           _saAE3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAE3::I64;
           P64[Sp + 8] = _saAE2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCIt; else goto caCCC;
       uaCIt: // global
           call _caCCB(R1) args: 0, res: 0, upd: 0;
       caCCC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCCB() //  [R1]
         { info_tbl: [(caCCB,
                       label: block_caCCB_info
                       rep:StackRep [True, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCB: // global
           I64[Sp - 8] = block_caCCG_info;
           _saAE4::P64 = R1;
           _saAE5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp] = _saAE5::I64;
           P64[Sp + 56] = _saAE4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCIu; else goto caCCH;
       uaCIu: // global
           call _caCCG(R1) args: 0, res: 0, upd: 0;
       caCCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCCG() //  [R1]
         { info_tbl: [(caCCG,
                       label: block_caCCG_info
                       rep:StackRep [True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCG: // global
           _saAE2::P64 = P64[Sp + 24];
           _saAE3::I64 = I64[Sp + 16];
           _saAE4::P64 = P64[Sp + 64];
           _saAE7::I64 = I64[R1 + 7];
           _saAE8::I64 = _saAE7::I64 & 31;
           if (%MO_S_Gt_W64(_saAE3::I64,
                            _saAE8::I64)) goto caCHV; else goto caCIp;
       caCIp: // global
           if (%MO_S_Gt_W64(_saAE8::I64,
                            I64[Sp + 8])) goto caCHV; else goto caCHW;
       caCHV: // global
           R4 = _saAE8::I64;
           R3 = _saAE2::P64;
           R2 = _saAE4::P64;
           Sp = Sp + 72;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caCHW: // global
           _saAEf::P64 = P64[P64[Sp + 32] + ((_saAE8::I64 - _saAE3::I64 << 3) + 24)];
           I64[Sp + 24] = block_caCCZ_info;
           _saAE6::P64 = R1;
           R1 = _saAEf::P64;
           I64[Sp + 32] = _saAE7::I64;
           P64[Sp + 64] = _saAE6::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaCIv; else goto caCD0;
       uaCIv: // global
           call _caCCZ(R1) args: 0, res: 0, upd: 0;
       caCD0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCCZ() //  [R1]
         { info_tbl: [(caCCZ,
                       label: block_caCCZ_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCCZ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caCHZ; else goto caCHY;
       caCHZ: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCHY: // global
           _saAEh::P64 = P64[R1 + 7];
           I64[Hp - 72] = $wio_saAEi_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saAFp_info;
           P64[Hp - 24] = Hp - 70;
           _caCFL::P64 = Hp - 30;
           _saAFu::I64 = I64[Sp + 24];
           if (_saAFu::I64 != 0) goto uaCIq; else goto caCIc;
       uaCIq: // global
           if (_saAFu::I64 != 1) goto caCI4; else goto caCIi;
       caCI4: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caCG2_info;
           R1 = _saAEh::P64;
           P64[Sp + 32] = _saAEh::P64;
           P64[Sp + 40] = _caCFL::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caCIi: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caCHh_info;
           R1 = _saAEh::P64;
           P64[Sp + 32] = _saAEh::P64;
           P64[Sp + 40] = _caCFL::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caCIc: // global
           I64[Hp - 16] = sat_saAFW_info;
           P64[Hp - 8] = _saAEh::P64;
           P64[Hp] = _caCFL::P64;
           I64[Sp + 40] = block_caCIb_info;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCG2() //  [R1]
         { info_tbl: [(caCG2,
                       label: block_caCG2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCG2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCI7; else goto caCI6;
       caCI7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCI6: // global
           I64[Hp - 56] = sat_saAFD_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAFy_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAFz_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCI0_info;
           R2 = Hp - 54;
           _saAFx::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAFx::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCI0() //  [R1]
         { info_tbl: [(caCI0,
                       label: block_caCI0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCI0: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCI2_info;
           R2 = P64[Sp + 16];
           _saAFG::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAFG::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCI2() //  []
         { info_tbl: [(caCI2,
                       label: block_caCI2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCI2: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caCHh() //  [R1]
         { info_tbl: [(caCHh,
                       label: block_caCHh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCHh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCIl; else goto caCIk;
       caCIl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCIk: // global
           I64[Hp - 56] = sat_saAG8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAG3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAG4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCIf_info;
           R2 = Hp - 54;
           _saAG2::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAG2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCIf() //  [R1]
         { info_tbl: [(caCIf,
                       label: block_caCIf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCIf: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCIh_info;
           R2 = P64[Sp + 16];
           _saAGb::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAGb::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCIh() //  []
         { info_tbl: [(caCIh,
                       label: block_caCIh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCIh: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caCIb() //  [R1]
         { info_tbl: [(caCIb,
                       label: block_caCIb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCIb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.780659328 UTC

[section ""data" . GHC.Event.Manager.closeFd_closure" {
     GHC.Event.Manager.closeFd_closure:
         const GHC.Event.Manager.closeFd_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_entry() //  [R2, R3, R4]
         { info_tbl: [(caCIA,
                       label: GHC.Event.Manager.closeFd_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCIA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.781766904 UTC

[section ""data" . lvl8_raAuf_closure" {
     lvl8_raAuf_closure:
         const lvl8_raAuf_info;
 },
 lvl8_raAuf_entry() //  [R2]
         { info_tbl: [(caCIK,
                       label: lvl8_raAuf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCIK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCIL; else goto caCIM;
       caCIL: // global
           R2 = R2;
           R1 = lvl8_raAuf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCIM: // global
           I64[Sp - 8] = block_caCIH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCJ5; else goto caCII;
       uaCJ5: // global
           call _caCIH(R1) args: 0, res: 0, upd: 0;
       caCII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCIH() //  [R1]
         { info_tbl: [(caCIH,
                       label: block_caCIH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCIH: // global
           if (I64[R1 + 31] & 8 == 0) goto caCJ1; else goto caCIV;
       caCJ1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCIV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.792616315 UTC

[section ""data" . GHC.Event.Manager.loop5_closure" {
     GHC.Event.Manager.loop5_closure:
         const GHC.Event.Manager.loop5_info;
         const 0;
 },
 $wgo_saAHp_entry() //  [R1, R2]
         { info_tbl: [(caCKx,
                       label: $wgo_saAHp_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCKx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCKy; else goto caCKz;
       caCKy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCKz: // global
           I64[Sp - 24] = block_caCKq_info;
           _saAHp::P64 = R1;
           _saAGN::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAGN::I64;
           P64[Sp - 8] = _saAHp::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCKW; else goto caCKr;
       uaCKW: // global
           call _caCKq(R1) args: 0, res: 0, upd: 0;
       caCKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCKq() //  [R1]
         { info_tbl: [(caCKq,
                       label: block_caCKq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCKq: // global
           if (R1 & 7 == 1) goto caCKu; else goto caCKv;
       caCKu: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCKv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCKH; else goto caCKG;
       caCKH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCKG: // global
           _saAHt::P64 = P64[R1 + 6];
           _saAHu::P64 = P64[R1 + 14];
           _saAHs::I64 = I64[R1 + 22];
           if (_saAHs::I64 == I64[Sp + 8]) goto caCKV; else goto caCKP;
       caCKV: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAHt::P64;
           R3 = _saAHu::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCKP: // global
           Hp = Hp - 16;
           I64[Sp] = block_caCKL_info;
           R2 = _saAHu::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAHt::P64;
           I64[Sp + 16] = _saAHs::I64;
           call $wgo_saAHp_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCKL() //  [R1, R2, R3]
         { info_tbl: [(caCKL,
                       label: block_caCKL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCKL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caCKS; else goto caCKR;
       caCKS: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caCKR: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saAHY_entry() //  [R1]
         { info_tbl: [(caCLG,
                       label: w2_saAHY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCLG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCLH; else goto caCLI;
       caCLH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCLI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caCLD_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo1_saAHM_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caCLD() //  [R1, R2]
         { info_tbl: [(caCLD,
                       label: block_caCLD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCLD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCLL; else goto caCLK;
       caCLL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caCLK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo1_saAHM_entry() //  [R1, R2]
         { info_tbl: [(caCLQ,
                       label: $wgo1_saAHM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCLQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caCLR; else goto caCLS;
       caCLR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCLS: // global
           I64[Sp - 24] = block_caCLj_info;
           _saAHM::P64 = R1;
           _saAGm::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _saAGm::P64;
           P64[Sp - 8] = _saAHM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCMi; else goto caCLk;
       uaCMi: // global
           call _caCLj(R1) args: 0, res: 0, upd: 0;
       caCLk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCLj() //  [R1]
         { info_tbl: [(caCLj,
                       label: block_caCLj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCLj: // global
           if (R1 & 7 == 1) goto caCLN; else goto caCLO;
       caCLN: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caCLO: // global
           I64[Sp - 8] = block_caCLp_info;
           _saAHP::P64 = P64[R1 + 6];
           _saAHQ::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _saAHQ::P64;
           P64[Sp + 8] = _saAHP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCMg; else goto caCLq;
       uaCMg: // global
           call _caCLp(R1) args: 0, res: 0, upd: 0;
       caCLq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCLp() //  [R1]
         { info_tbl: [(caCLp,
                       label: block_caCLp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCLp: // global
           I64[Sp] = block_caCLu_info;
           _saAHS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAHS::I64;
           if (R1 & 7 != 0) goto uaCMh; else goto caCLv;
       uaCMh: // global
           call _caCLu(R1) args: 0, res: 0, upd: 0;
       caCLv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCLu() //  [R1]
         { info_tbl: [(caCLu,
                       label: block_caCLu_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCLu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caCLZ; else goto caCLY;
       caCLZ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCLY: // global
           _saAHW::I64 = I64[R1 + 31];
           I64[Hp - 96] = w2_saAHY_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           _caCLz::P64 = Hp - 96;
           if (I64[Sp + 16] & _saAHW::I64 & 7 == 0) goto caCMf; else goto caCMa;
       caCMf: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caCLz::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _caCLz::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caCMa: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caCLz::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _caCLz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds8_saAHL_entry() //  [R1]
         { info_tbl: [(caCMm,
                       label: ds8_saAHL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCMm: // global
           _saAHL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caCMn; else goto caCMo;
       caCMo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCMq; else goto caCMp;
       caCMq: // global
           HpAlloc = 16;
           goto caCMn;
       caCMn: // global
           R1 = _saAHL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAHL::P64;
           _saAGm::P64 = P64[_saAHL::P64 + 16];
           _saAHK::P64 = P64[_saAHL::P64 + 24];
           I64[Hp - 8] = $wgo1_saAHM_info;
           P64[Hp] = _saAGm::P64;
           I64[Sp - 24] = block_caCMj_info;
           R2 = _saAHK::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call $wgo1_saAHM_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caCMj() //  [R1, R2]
         { info_tbl: [(caCMj,
                       label: block_caCMj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCMj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCMt; else goto caCMs;
       caCMt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caCMs: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAIx_entry() //  [R1]
         { info_tbl: [(caCMI,
                       label: sat_saAIx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCMI: // global
           R3 = P64[R1 + 16];
           R2 = lvl8_raAuf_closure+1;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 saved_saAIt_entry() //  [R1]
         { info_tbl: [(caCML,
                       label: saved_saAIt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCML: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caCMM; else goto caCMN;
       caCMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caCMz_info;
           _saAIp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saAIp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaCMR; else goto caCMA;
       uaCMR: // global
           call _caCMz(R1) args: 0, res: 0, upd: 0;
       caCMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caCMz() //  [R1]
         { info_tbl: [(caCMz,
                       label: block_caCMz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCMz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCMQ; else goto caCMP;
       caCMQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caCMP: // global
           _saAIw::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saAIx_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _saAIw::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAIA_entry() //  [R1]
         { info_tbl: [(caCMX,
                       label: sat_saAIA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCMX: // global
           R1 = P64[R1 + 6] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAH9_entry() //  [R1, R2]
         { info_tbl: [(caCN0,
                       label: $wio_saAH9_info
                       rep:HeapRep 5 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCN0: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caCN1; else goto caCN2;
       caCN1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCN2: // global
           I64[Sp - 64] = block_caCK7_info;
           _saAGm::P64 = P64[R1 + 6];
           _saAGD::P64 = P64[R1 + 14];
           _saAGF::P64 = P64[R1 + 22];
           _saAGG::P64 = P64[R1 + 30];
           _saAGM::P64 = P64[R1 + 38];
           _saAGN::I64 = I64[R1 + 46];
           R1 = P64[R2 + 8];
           P64[Sp - 56] = _saAGm::P64;
           P64[Sp - 48] = _saAGD::P64;
           P64[Sp - 40] = _saAGF::P64;
           P64[Sp - 32] = _saAGG::P64;
           P64[Sp - 24] = _saAGM::P64;
           I64[Sp - 16] = _saAGN::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto uaCPH; else goto caCK8;
       uaCPH: // global
           call _caCK7(R1) args: 0, res: 0, upd: 0;
       caCK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCK7() //  [R1]
         { info_tbl: [(caCK7,
                       label: block_caCK7_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCK7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCN5; else goto caCN4;
       caCN5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCN4: // global
           _saAGN::I64 = I64[Sp + 48];
           _saAHg::P64 = P64[R1 + 7];
           _saAHi::P64 = P64[R1 + 15];
           _saAHh::I64 = I64[R1 + 23];
           _saAHj::I64 = _saAGN::I64 & (I64[_saAHg::P64 + 8] - 1);
           _saAHo::P64 = P64[(_saAHg::P64 + 24) + (_saAHj::I64 << 3)];
           I64[Hp - 8] = $wgo_saAHp_info;
           I64[Hp] = _saAGN::I64;
           I64[Sp - 32] = block_caCKX_info;
           R2 = _saAHo::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saAHh::I64;
           P64[Sp - 16] = _saAHi::P64;
           I64[Sp - 8] = _saAHj::I64;
           P64[Sp] = _saAHg::P64;
           Sp = Sp - 32;
           call $wgo_saAHp_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCKX() //  [R1, R2, R3]
         { info_tbl: [(caCKX,
                       label: block_caCKX_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCKX: // global
           I64[Sp - 16] = block_caCN6_info;
           _saAHD::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAHD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCPG; else goto caCP5;
       uaCPG: // global
           call _caCN6(R1) args: 0, res: 0, upd: 0;
       caCP5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCN6() //  [R1]
         { info_tbl: [(caCN6,
                       label: block_caCN6_info
                       rep:StackRep [False, False, True, False, True, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCN6: // global
           if (R1 & 7 == 1) goto caCPb; else goto caCPg;
       caCPb: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAHG() args: 0, res: 0, upd: 0;
       caCPg: // global
           _saAHg::P64 = P64[Sp + 48];
           _saAHj::I64 = I64[Sp + 40];
           _saAHD::P64 = P64[Sp + 16];
           _saAHF::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAHg::P64 + 24) + (_saAHj::I64 << 3)] = _saAHF::P64;
           I64[_saAHg::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAHg::P64 + 24) + ((I64[_saAHg::P64 + 8] << 3) + (_saAHj::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caCPe_info;
           _saAJ0::P64 = R1;
           R1 = _saAHD::P64;
           P64[Sp + 48] = _saAJ0::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaCPI; else goto caCPh;
       uaCPI: // global
           call _caCPe(R1) args: 0, res: 0, upd: 0;
       caCPh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCPe() //  [R1]
         { info_tbl: [(caCPe,
                       label: block_caCPe_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCPe: // global
           _saAJ0::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caCPn; else goto caCPr;
       caCPn: // global
           P64[Sp + 32] = _saAJ0::P64;
           Sp = Sp + 32;
           goto uaCPP;
       caCPr: // global
           _saAHh::I64 = I64[Sp + 8];
           _saAHi::P64 = P64[Sp + 16];
           I64[_saAHh::I64] = I64[_saAHh::I64] - 1;
           call MO_Touch(_saAHi::P64);
           P64[Sp + 32] = _saAJ0::P64;
           Sp = Sp + 32;
           goto uaCPP;
       uaCPP: // global
           call _saAHG() args: 0, res: 0, upd: 0;
     }
 },
 _saAHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAHG: // global
           _saAHI::P64 = P64[Sp];
           I64[Sp] = block_caCL4_info;
           R1 = _saAHI::P64;
           if (R1 & 7 != 0) goto uaCPQ; else goto caCL5;
       uaCPQ: // global
           call _caCL4(R1) args: 0, res: 0, upd: 0;
       caCL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCL4() //  [R1]
         { info_tbl: [(caCL4,
                       label: block_caCL4_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCL4: // global
           if (R1 & 7 == 1) goto caCNc; else goto caCNk;
       caCNc: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCNk: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caCNn; else goto caCNm;
       caCNn: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCNm: // global
           _saAHK::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds8_saAHL_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _saAHK::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           _caCLa::P64 = Hp - 96;
           P64[Hp - 48] = _caCLa::P64;
           I64[Hp - 40] = saved_saAIt_info;
           P64[Hp - 24] = _caCLa::P64;
           _caCMu::P64 = Hp - 64;
           P64[Hp - 16] = _caCMu::P64;
           I64[Hp - 8] = sat_saAIA_info;
           _caCMv::P64 = Hp - 40;
           P64[Hp] = _caCMv::P64;
           I64[Sp] = block_caCNd_info;
           R5 = P64[Sp + 56];
           R4 = _caCMv::P64;
           R3 = I64[Sp + 48];
           R2 = Hp - 6;
           P64[Sp + 8] = _saAHK::P64;
           P64[Sp + 48] = _caCMv::P64;
           P64[Sp + 56] = _caCMu::P64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCNd() //  []
         { info_tbl: [(caCNd,
                       label: block_caCNd_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCNd: // global
           _saAHK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCNf_info;
           R2 = _saAHK::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCNf() //  [R1]
         { info_tbl: [(caCNf,
                       label: block_caCNf_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCNf: // global
           I64[Sp] = block_caCNj_info;
           R2 = P64[Sp + 40];
           I64[Sp + 40] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCNj() //  [R1]
         { info_tbl: [(caCNj,
                       label: block_caCNj_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCNj: // global
           _caCMu::P64 = P64[Sp + 48];
           _saAIE::I64 = I64[Sp + 40];
           _saAIF::I64 = R1;
           if (_saAIE::I64 & 8 == 0) goto saAIG; else goto caCOQ;
       caCOQ: // global
           if (_saAIE::I64 == _saAIF::I64) goto caCOY; else goto saAIG;
       saAIG: // global
           _saAII::I64 = _saAIF::I64 & 8;
           if (_saAII::I64 != 0) goto uaCPC; else goto caCNY;
       uaCPC: // global
           I64[Sp] = _saAII::I64;
           I64[Sp + 24] = _saAIF::I64;
           call _caCNE() args: 0, res: 0, upd: 0;
       caCNY: // global
           if (_saAIE::I64 & 8 == 0) goto caCOs; else goto uaCPE;
       caCOs: // global
           if (_saAIF::I64 & 7 == 0) goto caCOY; else goto uaCPF;
       caCOY: // global
           R1 = _caCMu::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaCPF: // global
           I64[Sp + 40] = _saAIF::I64;
           goto uaCPM;
       uaCPE: // global
           I64[Sp + 40] = _saAIF::I64;
           goto uaCPM;
       uaCPM: // global
           call _caCO5() args: 0, res: 0, upd: 0;
     }
 },
 _caCNE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCNE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caCNT; else goto caCNS;
       caCNT: // global
           HpAlloc = 32;
           _saAII::I64 = I64[Sp];
           I64[Sp] = block_caCND_info;
           R1 = _saAII::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caCNS: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 24] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caCNO_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caCND() //  [R1]
         { info_tbl: [(caCND,
                       label: block_caCND_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCND: // global
           I64[Sp] = R1;
           call _caCNE() args: 0, res: 0, upd: 0;
     }
 },
 _caCNO() //  []
         { info_tbl: [(caCNO,
                       label: block_caCNO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCNO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCO5() //  []
         { info_tbl: [(caCO5,
                       label: block_caCO5_info
                       rep:StackRep [False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCO5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCOe; else goto caCOd;
       caCOe: // global
           HpAlloc = 16;
           I64[Sp] = block_caCO5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caCOd: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caCOb_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCOb() //  []
         { info_tbl: [(caCOb,
                       label: block_caCOb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCOb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAJa_entry() //  [R1, R2]
         { info_tbl: [(caCPZ,
                       label: io_saAJa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCPZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCQ0; else goto caCQ1;
       caCQ0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCQ1: // global
           I64[Sp - 16] = block_caCPW_info;
           _saAH9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAH9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCQ5; else goto caCPX;
       uaCQ5: // global
           call _caCPW(R1) args: 0, res: 0, upd: 0;
       caCPX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCPW() //  [R1]
         { info_tbl: [(caCPW,
                       label: block_caCPW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCPW: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAH9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJo_entry() //  [R1, R2]
         { info_tbl: [(caCQh,
                       label: sat_saAJo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCQi; else goto caCQj;
       caCQi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCQj: // global
           I64[Sp - 16] = block_caCQf_info;
           _saAJl::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAJl::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCQf() //  []
         { info_tbl: [(caCQf,
                       label: block_caCQf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJj_entry() //  [R1]
         { info_tbl: [(caCQq,
                       label: sat_saAJj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQq: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJk_entry() //  [R1]
         { info_tbl: [(caCQy,
                       label: sat_saAJk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQy: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJR_entry() //  [R1, R2]
         { info_tbl: [(caCQQ,
                       label: sat_saAJR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCQR; else goto caCQS;
       caCQR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCQS: // global
           I64[Sp - 16] = block_caCQO_info;
           _saAJO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAJO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCQO() //  []
         { info_tbl: [(caCQO,
                       label: block_caCQO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJM_entry() //  [R1]
         { info_tbl: [(caCQZ,
                       label: sat_saAJM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQZ: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJN_entry() //  [R1]
         { info_tbl: [(caCR7,
                       label: sat_saAJN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCR7: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJW_entry() //  [R1]
         { info_tbl: [(caCRe,
                       label: sat_saAJW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCRf; else goto caCRg;
       caCRf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caCRg: // global
           I64[Sp - 24] = block_caCQH_info;
           _saAH8::P64 = P64[R1 + 7];
           _saAJa::P64 = P64[R1 + 15];
           R1 = _saAH8::P64;
           P64[Sp - 16] = _saAH8::P64;
           P64[Sp - 8] = _saAJa::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCQH() //  [R1]
         { info_tbl: [(caCQH,
                       label: block_caCQH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCRj; else goto caCRi;
       caCRj: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCRi: // global
           I64[Hp - 56] = sat_saAJR_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAJM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAJN_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCRa_info;
           R2 = Hp - 54;
           _saAJL::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAJL::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCRa() //  [R1]
         { info_tbl: [(caCRa,
                       label: block_caCRa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRa: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCRc_info;
           R2 = P64[Sp + 16];
           _saAJU::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAJU::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCRc() //  []
         { info_tbl: [(caCRc,
                       label: block_caCRc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKn_entry() //  [R1, R2]
         { info_tbl: [(caCRw,
                       label: sat_saAKn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCRx; else goto caCRy;
       caCRx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCRy: // global
           I64[Sp - 16] = block_caCRu_info;
           _saAKk::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAKk::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCRu() //  []
         { info_tbl: [(caCRu,
                       label: block_caCRu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKi_entry() //  [R1]
         { info_tbl: [(caCRF,
                       label: sat_saAKi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRF: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKj_entry() //  [R1]
         { info_tbl: [(caCRN,
                       label: sat_saAKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRN: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop5_entry() //  [R2, R3, R4]
         { info_tbl: [(caCRQ,
                       label: GHC.Event.Manager.loop5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRQ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caCRR; else goto caCRS;
       caCRR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.loop5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCRS: // global
           I64[Sp - 24] = block_caCJa_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaCUL; else goto caCJb;
       uaCUL: // global
           call _caCJa(R1) args: 0, res: 0, upd: 0;
       caCJb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCJa() //  [R1]
         { info_tbl: [(caCJa,
                       label: block_caCJa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJa: // global
           I64[Sp - 56] = block_caCJf_info;
           _saAGq::P64 = P64[R1 + 15];
           _saAGr::P64 = P64[R1 + 23];
           _saAGt::P64 = P64[R1 + 31];
           _saAGu::P64 = P64[R1 + 39];
           _saAGA::P64 = P64[R1 + 63];
           _saAGw::I64 = I64[R1 + 87];
           _saAGy::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           P64[Sp - 48] = _saAGr::P64;
           P64[Sp - 40] = _saAGt::P64;
           P64[Sp - 32] = _saAGu::P64;
           I64[Sp - 24] = _saAGw::I64;
           I64[Sp - 16] = _saAGy::I64;
           P64[Sp - 8] = _saAGA::P64;
           P64[Sp] = _saAGq::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaCUG; else goto caCJg;
       uaCUG: // global
           call _caCJf(R1) args: 0, res: 0, upd: 0;
       caCJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCJf() //  [R1]
         { info_tbl: [(caCJf,
                       label: block_caCJf_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJf: // global
           I64[Sp - 16] = block_caCJk_info;
           _saAGD::P64 = P64[R1 + 7];
           _saAGF::P64 = P64[R1 + 23];
           _saAGG::P64 = P64[R1 + 31];
           R1 = P64[Sp + 56];
           P64[Sp - 8] = _saAGG::P64;
           P64[Sp] = _saAGF::P64;
           P64[Sp + 56] = _saAGD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCUH; else goto caCJl;
       uaCUH: // global
           call _caCJk(R1) args: 0, res: 0, upd: 0;
       caCJl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCJk() //  [R1]
         { info_tbl: [(caCJk,
                       label: block_caCJk_info
                       rep:StackRep [False, False, False, False, False, True, True, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJk: // global
           I64[Sp - 8] = block_caCJp_info;
           _saAGI::P64 = R1;
           _saAGJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saAGJ::I64;
           P64[Sp + 24] = _saAGI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCUI; else goto caCJq;
       uaCUI: // global
           call _caCJp(R1) args: 0, res: 0, upd: 0;
       caCJq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCJp() //  [R1]
         { info_tbl: [(caCJp,
                       label: block_caCJp_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJp: // global
           I64[Sp - 8] = block_caCJu_info;
           _saAGK::P64 = R1;
           _saAGL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saAGL::I64;
           P64[Sp + 88] = _saAGK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCUJ; else goto caCJv;
       uaCUJ: // global
           call _caCJu(R1) args: 0, res: 0, upd: 0;
       caCJv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCJu() //  [R1]
         { info_tbl: [(caCJu,
                       label: block_caCJu_info
                       rep:StackRep [True, True, False, False, False, False, False, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJu: // global
           _saAGy::I64 = I64[Sp + 72];
           _saAGA::P64 = P64[Sp + 80];
           _saAGN::I64 = I64[R1 + 7];
           if (_saAGN::I64 == I64[Sp + 64]) goto saAGO; else goto caCUm;
       caCUm: // global
           if (_saAGN::I64 == _saAGy::I64) goto saAGO; else goto caCSi;
       saAGO: // global
           I64[Sp + 48] = block_caCS1_info;
           R4 = _saAGN::I64;
           R3 = _saAGA::P64;
           R2 = _saAGy::I64;
           Sp = Sp + 48;
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
       caCSi: // global
           I64[Sp] = block_caCJH_info;
           I64[Sp + 72] = _saAGN::I64;
           P64[Sp + 80] = R1;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caCS1() //  [R1]
         { info_tbl: [(caCS1,
                       label: block_caCS1_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCS1: // global
           I64[Sp] = block_caCS3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCUM; else goto caCS6;
       uaCUM: // global
           call _caCS3(R1) args: 0, res: 0, upd: 0;
       caCS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCS3() //  [R1]
         { info_tbl: [(caCS3,
                       label: block_caCS3_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCS3: // global
           if (R1 & 7 == 2) goto caCSg; else goto uaCUF;
       caCSg: // global
           _saAGu::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saAGu::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saAGu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaCUF: // global
           Sp = Sp + 64;
           call _caCSc() args: 0, res: 0, upd: 0;
     }
 },
 _caCJH() //  [R1]
         { info_tbl: [(caCJH,
                       label: block_caCJH_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJH: // global
           _saAGI::P64 = P64[Sp + 40];
           _saAGJ::I64 = I64[Sp + 16];
           _saAGK::P64 = P64[Sp + 96];
           _saAGZ::I64 = I64[Sp + 72] & 31;
           if (%MO_S_Gt_W64(_saAGJ::I64,
                            _saAGZ::I64)) goto caCSn; else goto caCUj;
       caCUj: // global
           if (%MO_S_Gt_W64(_saAGZ::I64,
                            I64[Sp + 8])) goto caCSn; else goto caCSo;
       caCSn: // global
           R4 = _saAGZ::I64;
           R3 = _saAGI::P64;
           R2 = _saAGK::P64;
           Sp = Sp + 112;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caCSo: // global
           _saAH6::P64 = P64[P64[Sp + 48] + ((_saAGZ::I64 - _saAGJ::I64 << 3) + 24)];
           I64[Sp + 16] = block_caCJX_info;
           _saAGY::I64 = R1;
           R1 = _saAH6::P64;
           I64[Sp + 96] = _saAGY::I64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaCUK; else goto caCJY;
       uaCUK: // global
           call _caCJX(R1) args: 0, res: 0, upd: 0;
       caCJY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCJX() //  [R1]
         { info_tbl: [(caCJX,
                       label: block_caCJX_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCJX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caCSr; else goto caCSq;
       caCSr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCSq: // global
           _saAH8::P64 = P64[R1 + 7];
           I64[Hp - 88] = $wio_saAH9_info;
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 72];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 64];
           I64[Hp - 40] = I64[Sp + 56];
           I64[Hp - 32] = io_saAJa_info;
           P64[Hp - 24] = Hp - 86;
           _caCPR::P64 = Hp - 30;
           _saAJf::I64 = I64[Sp + 80];
           if (_saAJf::I64 != 0) goto uaCUv; else goto caCT8;
       uaCUv: // global
           if (_saAJf::I64 != 1) goto caCSw; else goto caCTI;
       caCSw: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caCQ8_info;
           R1 = _saAH8::P64;
           P64[Sp + 72] = _saAH8::P64;
           P64[Sp + 80] = _caCPR::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caCTI: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caCRn_info;
           R1 = _saAH8::P64;
           P64[Sp + 72] = _saAH8::P64;
           P64[Sp + 80] = _caCPR::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caCT8: // global
           I64[Hp - 16] = sat_saAJW_info;
           P64[Hp - 8] = _saAH8::P64;
           P64[Hp] = _caCPR::P64;
           I64[Sp + 80] = block_caCT7_info;
           R1 = Hp - 15;
           Sp = Sp + 80;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCQ8() //  [R1]
         { info_tbl: [(caCQ8,
                       label: block_caCQ8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCQ8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCSz; else goto caCSy;
       caCSz: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCSy: // global
           I64[Hp - 56] = sat_saAJo_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAJj_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAJk_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCSs_info;
           R2 = Hp - 54;
           _saAJi::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAJi::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCSs() //  [R1]
         { info_tbl: [(caCSs,
                       label: block_caCSs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCSs: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCSu_info;
           R2 = P64[Sp + 16];
           _saAJr::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAJr::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCSu() //  []
         { info_tbl: [(caCSu,
                       label: block_caCSu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCSu: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caCSG() args: 0, res: 0, upd: 0;
     }
 },
 _caCSG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCSG: // global
           _saAJu::P64 = P64[Sp];
           I64[Sp] = block_caCSI_info;
           R1 = _saAJu::P64;
           if (R1 & 7 != 0) goto uaCUP; else goto caCSK;
       uaCUP: // global
           call _caCSI(R1) args: 0, res: 0, upd: 0;
       caCSK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCSI() //  [R1]
         { info_tbl: [(caCSI,
                       label: block_caCSI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCSI: // global
           if (R1 & 7 == 1) goto uaCUx; else goto caCSV;
       uaCUx: // global
           Sp = Sp + 16;
           call _caCSc() args: 0, res: 0, upd: 0;
       caCSV: // global
           I64[Sp - 8] = block_caCST_info;
           _saAJy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAJy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCUQ; else goto caCSW;
       uaCUQ: // global
           call _caCST(R1) args: 0, res: 0, upd: 0;
       caCSW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCST() //  [R1]
         { info_tbl: [(caCST,
                       label: block_caCST_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCST: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCT4; else goto caCT3;
       caCT4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCT3: // global
           _saAJD::P64 = P64[R1 + 7];
           _saAJA::I64 = I64[R1 + 15];
           _saAJB::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAJA::I64;
           I64[Hp] = _saAJB::I64;
           I64[Sp] = block_caCT1_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAJD::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCT1() //  []
         { info_tbl: [(caCT1,
                       label: block_caCT1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCT1: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caCSG() args: 0, res: 0, upd: 0;
     }
 },
 _caCRn() //  [R1]
         { info_tbl: [(caCRn,
                       label: block_caCRn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCRn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCTL; else goto caCTK;
       caCTL: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCTK: // global
           I64[Hp - 56] = sat_saAKn_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAKi_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAKj_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caCTF_info;
           R2 = Hp - 54;
           _saAKh::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAKh::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCTF() //  [R1]
         { info_tbl: [(caCTF,
                       label: block_caCTF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTF: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCTH_info;
           R2 = P64[Sp + 16];
           _saAKq::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAKq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCTH() //  []
         { info_tbl: [(caCTH,
                       label: block_caCTH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTH: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caCTS() args: 0, res: 0, upd: 0;
     }
 },
 _caCTS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTS: // global
           _saAKt::P64 = P64[Sp];
           I64[Sp] = block_caCTU_info;
           R1 = _saAKt::P64;
           if (R1 & 7 != 0) goto uaCUZ; else goto caCTW;
       uaCUZ: // global
           call _caCTU(R1) args: 0, res: 0, upd: 0;
       caCTW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCTU() //  [R1]
         { info_tbl: [(caCTU,
                       label: block_caCTU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTU: // global
           if (R1 & 7 == 1) goto uaCUA; else goto caCU7;
       uaCUA: // global
           Sp = Sp + 16;
           call _caCSc() args: 0, res: 0, upd: 0;
       caCU7: // global
           I64[Sp - 8] = block_caCU5_info;
           _saAKx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAKx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCV0; else goto caCU8;
       uaCV0: // global
           call _caCU5(R1) args: 0, res: 0, upd: 0;
       caCU8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCU5() //  [R1]
         { info_tbl: [(caCU5,
                       label: block_caCU5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCU5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCUg; else goto caCUf;
       caCUg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCUf: // global
           _saAKC::P64 = P64[R1 + 7];
           _saAKz::I64 = I64[R1 + 15];
           _saAKA::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAKz::I64;
           I64[Hp] = _saAKA::I64;
           I64[Sp] = block_caCUd_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAKC::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCUd() //  []
         { info_tbl: [(caCUd,
                       label: block_caCUd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCUd: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caCTS() args: 0, res: 0, upd: 0;
     }
 },
 _caCT7() //  [R1]
         { info_tbl: [(caCT7,
                       label: block_caCT7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCT7: // global
           P64[Sp] = R1;
           call _caCTe() args: 0, res: 0, upd: 0;
     }
 },
 _caCTe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTe: // global
           _saAK1::P64 = P64[Sp];
           I64[Sp] = block_caCTg_info;
           R1 = _saAK1::P64;
           if (R1 & 7 != 0) goto uaCUU; else goto caCTi;
       uaCUU: // global
           call _caCTg(R1) args: 0, res: 0, upd: 0;
       caCTi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCTg() //  [R1]
         { info_tbl: [(caCTg,
                       label: block_caCTg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTg: // global
           if (R1 & 7 == 1) goto uaCUD; else goto caCTt;
       uaCUD: // global
           Sp = Sp + 16;
           call _caCSc() args: 0, res: 0, upd: 0;
       caCTt: // global
           I64[Sp - 8] = block_caCTr_info;
           _saAK5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAK5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCUV; else goto caCTu;
       uaCUV: // global
           call _caCTr(R1) args: 0, res: 0, upd: 0;
       caCTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCSc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCSc: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCTr() //  [R1]
         { info_tbl: [(caCTr,
                       label: block_caCTr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCTC; else goto caCTB;
       caCTC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCTB: // global
           _saAKa::P64 = P64[R1 + 7];
           _saAK7::I64 = I64[R1 + 15];
           _saAK8::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAK7::I64;
           I64[Hp] = _saAK8::I64;
           I64[Sp] = block_caCTz_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAKa::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCTz() //  []
         { info_tbl: [(caCTz,
                       label: block_caCTz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCTz: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caCTe() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.815701777 UTC

[section ""data" . GHC.Event.Manager.loop4_closure" {
     GHC.Event.Manager.loop4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Event.Internal.Forever_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.817927237 UTC

[section ""data" . GHC.Event.Manager.loop3_closure" {
     GHC.Event.Manager.loop3_closure:
         const GHC.Event.Manager.loop3_info;
         const 0;
 },
 sat_saAL3_entry() //  [R1, R2, R3]
         { info_tbl: [(caCVm,
                       label: sat_saAL3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saALf_entry() //  [R1, R2, R3]
         { info_tbl: [(caCVH,
                       label: sat_saALf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saALq_entry() //  [R1, R2, R3]
         { info_tbl: [(caCW0,
                       label: sat_saALq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCW0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop3_entry() //  [R2]
         { info_tbl: [(caCW3,
                       label: GHC.Event.Manager.loop3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCW3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caCW4; else goto caCW5;
       caCW4: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCW5: // global
           I64[Sp - 8] = block_caCV7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCWP; else goto caCV8;
       uaCWP: // global
           call _caCV7(R1) args: 0, res: 0, upd: 0;
       caCV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCV7() //  [R1]
         { info_tbl: [(caCV7,
                       label: block_caCV7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCV7: // global
           I64[Sp - 16] = block_caCVc_info;
           _saAKJ::P64 = R1;
           _saAKP::P64 = P64[R1 + 39];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saAKP::P64;
           P64[Sp] = _saAKJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCWK; else goto caCVd;
       uaCWK: // global
           call _caCVc(R1) args: 0, res: 0, upd: 0;
       caCVd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCVc() //  [R1]
         { info_tbl: [(caCVc,
                       label: block_caCVc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCW9; else goto caCW8;
       caCW9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCW8: // global
           _saAKY::P64 = P64[R1 + 7];
           _saAKZ::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_saAL3_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_caCVp_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = _saAKY::P64;
           R1 = _saAKZ::P64;
           P64[Sp - 8] = _saAKZ::P64;
           P64[Sp] = _saAKY::P64;
           Sp = Sp - 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCVp() //  [R1]
         { info_tbl: [(caCVp,
                       label: block_caCVp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVp: // global
           I64[Sp] = block_caCVr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCWL; else goto caCVs;
       uaCWL: // global
           call _caCVr(R1) args: 0, res: 0, upd: 0;
       caCVs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCVr() //  [R1]
         { info_tbl: [(caCVr,
                       label: block_caCVr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVr: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caCWe; else goto caCWk;
       caCWe: // global
           _saALc::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caCWc_info;
           R1 = _saALc::P64;
           P64[Sp + 32] = _saALc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaCWM; else goto caCWf;
       uaCWM: // global
           call _caCWc() args: 0, res: 0, upd: 0;
       caCWf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCWk: // global
           I64[Sp] = block_caCVA_info;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caCWc() //  []
         { info_tbl: [(caCWc,
                       label: block_caCWc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCWc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCVA() //  []
         { info_tbl: [(caCVA,
                       label: block_caCVA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCWn; else goto caCWm;
       caCWn: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caCWm: // global
           I64[Hp - 8] = sat_saALf_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caCVK_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCVK() //  [R1]
         { info_tbl: [(caCVK,
                       label: block_caCVK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVK: // global
           I64[Sp] = block_caCVM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCWN; else goto caCVN;
       uaCWN: // global
           call _caCVM(R1) args: 0, res: 0, upd: 0;
       caCVN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCVM() //  [R1]
         { info_tbl: [(caCVM,
                       label: block_caCVM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCVM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caCWr; else goto caCWq;
       caCWr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCWq: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caCWu; else goto caCWD;
       caCWu: // global
           Hp = Hp - 16;
           _saALo::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caCWs_info;
           R1 = _saALo::P64;
           P64[Sp + 32] = _saALo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaCWO; else goto caCWv;
       uaCWO: // global
           call _caCWs() args: 0, res: 0, upd: 0;
       caCWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caCWD: // global
           I64[Hp - 8] = sat_saALq_info;
           P64[Hp] = P64[Sp + 32];
           _saAKY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caCWA_info;
           R4 = Hp - 5;
           R3 = GHC.Event.Manager.loop4_closure+2;
           R2 = _saAKY::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCWs() //  []
         { info_tbl: [(caCWs,
                       label: block_caCWs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCWs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCWA() //  []
         { info_tbl: [(caCWA,
                       label: block_caCWA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCWA: // global
           _saALw::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_caCWC_info;
           R1 = _saALw::P64;
           P64[Sp + 16] = _saALw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaCWQ; else goto caCWF;
       uaCWQ: // global
           call _caCWC() args: 0, res: 0, upd: 0;
       caCWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCWC() //  []
         { info_tbl: [(caCWC,
                       label: block_caCWC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCWC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.821713707 UTC

[section ""data" . GHC.Event.Manager.step_closure" {
     GHC.Event.Manager.step_closure:
         const GHC.Event.Manager.step_info;
         const 0;
 },
 GHC.Event.Manager.step_entry() //  [R2]
         { info_tbl: [(caCWV,
                       label: GHC.Event.Manager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCWV: // global
           R2 = R2;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.822454419 UTC

[section ""cstring" . lvl9_raAug_bytes" {
     lvl9_raAug_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.823271154 UTC

[section ""data" . GHC.Event.Manager.loop2_closure" {
     GHC.Event.Manager.loop2_closure:
         const GHC.Event.Manager.loop2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.loop2_entry() //  [R1]
         { info_tbl: [(caCX6,
                       label: GHC.Event.Manager.loop2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCX6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caCX7; else goto caCX8;
       caCX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caCX8: // global
           (_caCX1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caCX1::I64 == 0) goto caCX3; else goto caCX2;
       caCX3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caCX2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caCX1::I64;
           I64[Sp - 24] = block_caCX4_info;
           R2 = lvl9_raAug_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caCX4() //  [R1]
         { info_tbl: [(caCX4,
                       label: block_caCX4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCX4: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.824333032 UTC

[section ""data" . GHC.Event.Manager.loop8_closure" {
     GHC.Event.Manager.loop8_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.824905631 UTC

[section ""data" . GHC.Event.Manager.loop7_closure" {
     GHC.Event.Manager.loop7_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Releasing_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.825859239 UTC

[section ""data" . GHC.Event.Manager.loop6_closure" {
     GHC.Event.Manager.loop6_closure:
         const GHC.Event.Manager.loop6_info;
 },
 GHC.Event.Manager.loop6_entry() //  [R2]
         { info_tbl: [(caCXo,
                       label: GHC.Event.Manager.loop6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caCXp; else goto caCXq;
       caCXp: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCXq: // global
           I64[Sp - 8] = block_caCXg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaCXE; else goto caCXh;
       uaCXE: // global
           call _caCXg(R1) args: 0, res: 0, upd: 0;
       caCXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCXg() //  [R1]
         { info_tbl: [(caCXg,
                       label: block_caCXg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXg: // global
           _caCXn::P64 = R1 & 7;
           if (_caCXn::P64 == 1) goto caCXl; else goto uaCXD;
       caCXl: // global
           R1 = GHC.Event.Manager.loop8_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaCXD: // global
           if (_caCXn::P64 == 4) goto caCXm; else goto caCXk;
       caCXm: // global
           R1 = GHC.Event.Manager.loop7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCXk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caCXw; else goto caCXv;
       caCXw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCXv: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.829389723 UTC

[section ""data" . GHC.Event.Manager.loop1_closure" {
     GHC.Event.Manager.loop1_closure:
         const GHC.Event.Manager.loop1_info;
         const 0;
 },
 go_saALY_entry() //  [R1]
         { info_tbl: [(caCYc,
                       label: go_saALY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caCYd; else goto uaCYw;
       caCYd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       uaCYw: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 16;
           call _caCXZ() args: 0, res: 0, upd: 0;
     }
 },
 _caCXZ() //  []
         { info_tbl: [(caCXZ,
                       label: block_caCXZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXZ: // global
           I64[Sp - 16] = block_caCY2_info;
           _saALY::P64 = P64[Sp + 8];
           _saALD::P64 = P64[_saALY::P64 + 7];
           R2 = _saALD::P64;
           P64[Sp - 8] = P64[_saALY::P64 + 15];
           P64[Sp] = _saALD::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caCY2() //  [R1]
         { info_tbl: [(caCY2,
                       label: block_caCY2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCY2: // global
           I64[Sp] = block_caCY4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaCYx; else goto caCY5;
       uaCYx: // global
           call _caCY4(R1) args: 0, res: 0, upd: 0;
       caCY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCY4() //  [R1]
         { info_tbl: [(caCY4,
                       label: block_caCY4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCY4: // global
           _caCYb::P64 = R1 & 7;
           if (_caCYb::P64 != 2) goto uaCYv; else goto caCY9;
       uaCYv: // global
           if (_caCYb::P64 != 4) goto caCY8; else goto caCYa;
       caCY8: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       caCYa: // global
           I64[Sp + 24] = block_caCYr_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caCY9: // global
           I64[Sp + 16] = block_caCXZ_info;
           Sp = Sp + 16;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caCYr() //  []
         { info_tbl: [(caCYr,
                       label: block_caCYr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAMM_entry() //  [R1, R2]
         { info_tbl: [(caCYH,
                       label: sat_saAMM_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYH: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caCYI; else goto caCYJ;
       caCYI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCYJ: // global
           I64[Sp - 72] = block_caCYE_info;
           _saALJ::P64 = P64[R1 + 14];
           _saALO::P64 = P64[R1 + 22];
           _saALP::P64 = P64[R1 + 30];
           _saALQ::P64 = P64[R1 + 38];
           _saALL::I64 = I64[R1 + 46];
           _saALM::I64 = I64[R1 + 54];
           _saALN::I64 = I64[R1 + 62];
           R1 = P64[R1 + 6];
           P64[Sp - 64] = _saALJ::P64;
           I64[Sp - 56] = _saALL::I64;
           I64[Sp - 48] = _saALM::I64;
           I64[Sp - 40] = _saALN::I64;
           P64[Sp - 32] = _saALO::P64;
           P64[Sp - 24] = _saALP::P64;
           P64[Sp - 16] = _saALQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaCZy; else goto caCYF;
       uaCZy: // global
           call _caCYE(R1) args: 0, res: 0, upd: 0;
       caCYF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCYE() //  [R1]
         { info_tbl: [(caCYE,
                       label: block_caCYE_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYE: // global
           _saALJ::P64 = P64[Sp + 8];
           _saALQ::P64 = P64[Sp + 56];
           _saAM9::P64 = P64[R1 + 7];
           _saAMd::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saALJ::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saALJ::P64);
           I64[Sp] = block_caCYP_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saALQ::P64;
           P64[Sp + 8] = _saAMd::P64;
           P64[Sp + 56] = _saAM9::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCYP() //  []
         { info_tbl: [(caCYP,
                       label: block_caCYP_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYP: // global
           _saAMd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caCYR_info;
           R2 = P64[Sp + 56];
           R1 = _saAMd::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCYR() //  []
         { info_tbl: [(caCYR,
                       label: block_caCYR_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYR: // global
           I64[Sp] = block_caCYT_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCYT() //  []
         { info_tbl: [(caCYT,
                       label: block_caCYT_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCYT: // global
           _saALM::I64 = I64[Sp + 16];
           _saALO::P64 = P64[Sp + 32];
           (_saAMs::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saAMx::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALM::I64)));
           I64[Sp + 16] = block_caCZ9_info;
           R1 = _saALO::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaCZz; else goto caCZa;
       uaCZz: // global
           call _caCZ9(R1) args: 0, res: 0, upd: 0;
       caCZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCZ9() //  [R1]
         { info_tbl: [(caCZ9,
                       label: block_caCZ9_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCZ9: // global
           _saALN::I64 = I64[Sp + 8];
           _saAM6::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caCZg; else goto caCZk;
       caCZg: // global
           (_saAMD::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = _saAM6::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caCZk: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saAML::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = _saAM6::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop1_entry() //  [R2]
         { info_tbl: [(caCZA,
                       label: GHC.Event.Manager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCZA: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caCZB; else goto caCZC;
       caCZB: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caCZC: // global
           I64[Sp - 8] = block_caCXJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaD0U; else goto caCXK;
       uaD0U: // global
           call _caCXJ(R1) args: 0, res: 0, upd: 0;
       caCXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCXJ() //  [R1]
         { info_tbl: [(caCXJ,
                       label: block_caCXJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXJ: // global
           I64[Sp - 72] = block_caCXO_info;
           _saALD::P64 = R1;
           _saALE::P64 = P64[R1 + 7];
           _saALJ::P64 = P64[R1 + 39];
           _saALO::P64 = P64[R1 + 55];
           _saALP::P64 = P64[R1 + 63];
           _saALQ::P64 = P64[R1 + 71];
           _saALL::I64 = I64[R1 + 87];
           _saALM::I64 = I64[R1 + 95];
           _saALN::I64 = I64[R1 + 103];
           R1 = _saALQ::P64;
           P64[Sp - 64] = _saALE::P64;
           P64[Sp - 56] = _saALJ::P64;
           I64[Sp - 48] = _saALL::I64;
           I64[Sp - 40] = _saALM::I64;
           I64[Sp - 32] = _saALN::I64;
           P64[Sp - 24] = _saALO::P64;
           P64[Sp - 16] = _saALP::P64;
           P64[Sp - 8] = _saALQ::P64;
           P64[Sp] = _saALD::P64;
           Sp = Sp - 72;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCXO() //  []
         { info_tbl: [(caCXO,
                       label: block_caCXO_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXO: // global
           I64[Sp] = block_caCXQ_info;
           R2 = GHC.Event.Manager.loop6_closure+1;
           R1 = P64[Sp + 16];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCXQ() //  [R1]
         { info_tbl: [(caCXQ,
                       label: block_caCXQ_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXQ: // global
           I64[Sp] = block_caCXS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaD0S; else goto caCXT;
       uaD0S: // global
           call _caCXS(R1) args: 0, res: 0, upd: 0;
       caCXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCXS() //  [R1]
         { info_tbl: [(caCXS,
                       label: block_caCXS_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCXS: // global
           _saALD::P64 = P64[Sp + 72];
           _saALE::P64 = P64[Sp + 8];
           _saALJ::P64 = P64[Sp + 16];
           _saALL::I64 = I64[Sp + 24];
           _saALM::I64 = I64[Sp + 32];
           _saALN::I64 = I64[Sp + 40];
           _saALO::P64 = P64[Sp + 48];
           _saALP::P64 = P64[Sp + 56];
           _saALQ::P64 = P64[Sp + 64];
           _caD0B::P64 = R1 & 7;
           if (_caD0B::P64 < 4) goto uaD0P; else goto uaD0R;
       uaD0P: // global
           if (_caD0B::P64 < 3) goto uaD0Q; else goto caD0w;
       uaD0Q: // global
           _saALX::P64 = R1;
           if (_caD0B::P64 < 2) goto caCZH; else goto caCZP;
       caCZP: // global
           I64[Sp + 8] = block_caCZN_info;
           R1 = _saALE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaD0T; else goto caCZQ;
       uaD0T: // global
           call _caCZN(R1) args: 0, res: 0, upd: 0;
       caCZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caD0w: // global
           R2 = _saALD::P64;
           Sp = Sp + 80;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       uaD0R: // global
           _saALX::P64 = R1;
           if (_caD0B::P64 < 5) goto caCZH; else goto caD0A;
       caCZH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caCZK; else goto caCZJ;
       caCZK: // global
           HpAlloc = 96;
           R1 = _saALX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCZJ: // global
           I64[Hp - 88] = go_saALY_info;
           P64[Hp - 80] = _saALD::P64;
           P64[Hp - 72] = _saALQ::P64;
           I64[Hp - 64] = sat_saAMM_info;
           P64[Hp - 56] = _saALE::P64;
           P64[Hp - 48] = _saALJ::P64;
           P64[Hp - 40] = _saALO::P64;
           P64[Hp - 32] = _saALP::P64;
           P64[Hp - 24] = _saALQ::P64;
           I64[Hp - 16] = _saALL::I64;
           I64[Hp - 8] = _saALM::I64;
           I64[Hp] = _saALN::I64;
           R2 = Hp - 62;
           R1 = Hp - 87;
           Sp = Sp + 80;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       caD0A: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caCZN() //  [R1]
         { info_tbl: [(caCZN,
                       label: block_caCZN_info
                       rep:StackRep [False, True, True, True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCZN: // global
           _saALJ::P64 = P64[Sp + 8];
           _saALQ::P64 = P64[Sp + 56];
           _saAMO::P64 = P64[R1 + 7];
           _saAMS::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saALJ::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saALJ::P64);
           I64[Sp + 8] = block_caCZX_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saALQ::P64;
           P64[Sp + 56] = _saAMS::P64;
           P64[Sp + 64] = _saAMO::P64;
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCZX() //  []
         { info_tbl: [(caCZX,
                       label: block_caCZX_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCZX: // global
           I64[Sp] = block_caCZZ_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCZZ() //  []
         { info_tbl: [(caCZZ,
                       label: block_caCZZ_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCZZ: // global
           I64[Sp] = block_caD01_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD01() //  []
         { info_tbl: [(caD01,
                       label: block_caD01_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD01: // global
           _saALM::I64 = I64[Sp + 16];
           _saALO::P64 = P64[Sp + 32];
           (_saAN7::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saANc::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALM::I64)));
           I64[Sp + 16] = block_caD0h_info;
           R1 = _saALO::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaD0V; else goto caD0i;
       uaD0V: // global
           call _caD0h(R1) args: 0, res: 0, upd: 0;
       caD0i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD0h() //  [R1]
         { info_tbl: [(caD0h,
                       label: block_caD0h_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD0h: // global
           _saALN::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caD0o; else goto caD0s;
       caD0o: // global
           (_saANi::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caD0s: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saANr::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.835557182 UTC

[section ""data" . GHC.Event.Manager.loop_closure" {
     GHC.Event.Manager.loop_closure:
         const GHC.Event.Manager.loop_info;
         const 0;
 },
 GHC.Event.Manager.loop_entry() //  [R2]
         { info_tbl: [(caD10,
                       label: GHC.Event.Manager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD10: // global
           R2 = R2;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.836364301 UTC

[section ""data" . GHC.Event.Manager.closeFd_4_closure" {
     GHC.Event.Manager.closeFd_4_closure:
         const GHC.Event.Manager.closeFd_4_info;
 },
 GHC.Event.Manager.closeFd_4_entry() //  []
         { info_tbl: [(caD17,
                       label: GHC.Event.Manager.closeFd_4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD17: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.839404502 UTC

[section ""data" . GHC.Event.Manager.$wcloseFd__closure" {
     GHC.Event.Manager.$wcloseFd__closure:
         const GHC.Event.Manager.$wcloseFd__info;
         const 0;
 },
 $wgo_saANL_entry() //  [R1, R2]
         { info_tbl: [(caD1E,
                       label: $wgo_saANL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD1E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caD1F; else goto caD1G;
       caD1F: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caD1G: // global
           I64[Sp - 24] = block_caD1x_info;
           _saANL::P64 = R1;
           _saANw::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saANw::I64;
           P64[Sp - 8] = _saANL::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaD23; else goto caD1y;
       uaD23: // global
           call _caD1x(R1) args: 0, res: 0, upd: 0;
       caD1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD1x() //  [R1]
         { info_tbl: [(caD1x,
                       label: block_caD1x_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD1x: // global
           if (R1 & 7 == 1) goto caD1B; else goto caD1C;
       caD1B: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caD1C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD1O; else goto caD1N;
       caD1O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD1N: // global
           _saANP::P64 = P64[R1 + 6];
           _saANQ::P64 = P64[R1 + 14];
           _saANO::I64 = I64[R1 + 22];
           if (_saANO::I64 == I64[Sp + 8]) goto caD22; else goto caD1W;
       caD22: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saANP::P64;
           R3 = _saANQ::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caD1W: // global
           Hp = Hp - 16;
           I64[Sp] = block_caD1S_info;
           R2 = _saANQ::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saANP::P64;
           I64[Sp + 16] = _saANO::I64;
           call $wgo_saANL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD1S() //  [R1, R2, R3]
         { info_tbl: [(caD1S,
                       label: block_caD1S_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD1S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caD1Z; else goto caD1Y;
       caD1Z: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caD1Y: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAOy_entry() //  [R1]
         { info_tbl: [(caD2H,
                       label: sat_saAOy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2H: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAOz_entry() //  [R1]
         { info_tbl: [(caD2R,
                       label: sat_saAOz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2R: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.$wcloseFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caD2U,
                       label: GHC.Event.Manager.$wcloseFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2U: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caD2V; else goto caD2W;
       caD2V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$wcloseFd__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caD2W: // global
           I64[Sp - 24] = block_caD1e_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaD3X; else goto caD1f;
       uaD3X: // global
           call _caD1e(R1) args: 0, res: 0, upd: 0;
       caD1f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD1e() //  [R1]
         { info_tbl: [(caD1e,
                       label: block_caD1e_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD1e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD2Z; else goto caD2Y;
       caD2Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD2Y: // global
           _saANw::I64 = I64[Sp + 16];
           _saANC::P64 = P64[R1 + 7];
           _saANE::P64 = P64[R1 + 15];
           _saAND::I64 = I64[R1 + 23];
           _saANF::I64 = _saANw::I64 & (I64[_saANC::P64 + 8] - 1);
           _saANK::P64 = P64[(_saANC::P64 + 24) + (_saANF::I64 << 3)];
           I64[Hp - 8] = $wgo_saANL_info;
           I64[Hp] = _saANw::I64;
           I64[Sp - 32] = block_caD24_info;
           R2 = _saANK::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saAND::I64;
           P64[Sp - 16] = _saANE::P64;
           I64[Sp - 8] = _saANF::I64;
           P64[Sp] = _saANC::P64;
           Sp = Sp - 32;
           call $wgo_saANL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD24() //  [R1, R2, R3]
         { info_tbl: [(caD24,
                       label: block_caD24_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD24: // global
           I64[Sp - 16] = block_caD30_info;
           _saANZ::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saANZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaD3U; else goto caD3n;
       uaD3U: // global
           call _caD30(R1) args: 0, res: 0, upd: 0;
       caD3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD30() //  [R1]
         { info_tbl: [(caD30,
                       label: block_caD30_info
                       rep:StackRep [False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD30: // global
           if (R1 & 7 == 1) goto caD3t; else goto caD3y;
       caD3t: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAO2() args: 0, res: 0, upd: 0;
       caD3y: // global
           _saANC::P64 = P64[Sp + 48];
           _saANF::I64 = I64[Sp + 40];
           _saANZ::P64 = P64[Sp + 16];
           _saAO1::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saANC::P64 + 24) + (_saANF::I64 << 3)] = _saAO1::P64;
           I64[_saANC::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saANC::P64 + 24) + ((I64[_saANC::P64 + 8] << 3) + (_saANF::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caD3w_info;
           _saAOA::P64 = R1;
           R1 = _saANZ::P64;
           P64[Sp + 48] = _saAOA::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaD3Y; else goto caD3z;
       uaD3Y: // global
           call _caD3w(R1) args: 0, res: 0, upd: 0;
       caD3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD3w() //  [R1]
         { info_tbl: [(caD3w,
                       label: block_caD3w_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD3w: // global
           _saAOA::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caD3F; else goto caD3J;
       caD3F: // global
           P64[Sp + 32] = _saAOA::P64;
           Sp = Sp + 32;
           goto uaD41;
       caD3J: // global
           _saAND::I64 = I64[Sp + 8];
           _saANE::P64 = P64[Sp + 16];
           I64[_saAND::I64] = I64[_saAND::I64] - 1;
           call MO_Touch(_saANE::P64);
           P64[Sp + 32] = _saAOA::P64;
           Sp = Sp + 32;
           goto uaD41;
       uaD41: // global
           call _saAO2() args: 0, res: 0, upd: 0;
     }
 },
 _saAO2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAO2: // global
           _saAO4::P64 = P64[Sp];
           I64[Sp] = block_caD2b_info;
           R1 = _saAO4::P64;
           if (R1 & 7 != 0) goto uaD42; else goto caD2c;
       uaD42: // global
           call _caD2b(R1) args: 0, res: 0, upd: 0;
       caD2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD2b() //  [R1]
         { info_tbl: [(caD2b,
                       label: block_caD2b_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2b: // global
           if (R1 & 7 == 1) goto caD36; else goto caD38;
       caD36: // global
           R1 = GHC.Event.Manager.closeFd_4_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caD38: // global
           I64[Sp - 8] = block_caD2h_info;
           _saAO6::P64 = P64[R1 + 6];
           R2 = _saAO6::P64;
           P64[Sp] = _saAO6::P64;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caD2h() //  [R1]
         { info_tbl: [(caD2h,
                       label: block_caD2h_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2h: // global
           if (R1 == 0) goto caD3j; else goto caD3b;
       caD3j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD3m; else goto caD3l;
       caD3m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caD3l: // global
           I64[Hp - 8] = sat_saAOz_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caD3b: // global
           I64[Sp] = block_caD2l_info;
           _saAO7::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAO7::I64;
           if (R1 & 7 != 0) goto uaD3V; else goto caD2m;
       uaD3V: // global
           call _caD2l(R1) args: 0, res: 0, upd: 0;
       caD2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD2l() //  [R1]
         { info_tbl: [(caD2l,
                       label: block_caD2l_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2l: // global
           I64[Sp] = block_caD2q_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uaD3W; else goto caD2r;
       uaD3W: // global
           call _caD2q(R1) args: 0, res: 0, upd: 0;
       caD2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD2q() //  [R1]
         { info_tbl: [(caD2q,
                       label: block_caD2q_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caD3f; else goto caD3e;
       caD3f: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD3e: // global
           _saAOn::P64 = P64[R1 + 7];
           _saAOp::P64 = P64[R1 + 23];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 16] & 7;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_caD2A_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAOn::P64;
           R1 = _saAOp::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caD2A() //  [R1]
         { info_tbl: [(caD2A,
                       label: block_caD2A_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD2A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD3i; else goto caD3h;
       caD3i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD3h: // global
           I64[Hp - 8] = sat_saAOy_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.844721054 UTC

[section ""data" . GHC.Event.Manager.closeFd_1_closure" {
     GHC.Event.Manager.closeFd_1_closure:
         const GHC.Event.Manager.closeFd_1_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_1_entry() //  [R2, R3, R4]
         { info_tbl: [(caD4a,
                       label: GHC.Event.Manager.closeFd_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caD4e; else goto caD4f;
       caD4e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caD4f: // global
           I64[Sp - 24] = block_caD47_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaD4n; else goto caD48;
       uaD4n: // global
           call _caD47(R1) args: 0, res: 0, upd: 0;
       caD48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD47() //  [R1]
         { info_tbl: [(caD47,
                       label: block_caD47_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD47: // global
           I64[Sp] = block_caD4d_info;
           _saAOP::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _saAOP::P64;
           if (R1 & 7 != 0) goto uaD4m; else goto caD4h;
       uaD4m: // global
           call _caD4d(R1) args: 0, res: 0, upd: 0;
       caD4h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD4d() //  [R1]
         { info_tbl: [(caD4d,
                       label: block_caD4d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4d: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.846287825 UTC

[section ""data" . GHC.Event.Manager.closeFd__closure" {
     GHC.Event.Manager.closeFd__closure:
         const GHC.Event.Manager.closeFd__info;
         const 0;
 },
 GHC.Event.Manager.closeFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caD4s,
                       label: GHC.Event.Manager.closeFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd_1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.847030596 UTC

[section ""data" . lvl10_raAuh_closure" {
     lvl10_raAuh_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.847619979 UTC

[section ""data" . lvl11_raAui_closure" {
     lvl11_raAui_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.848182955 UTC

[section ""data" . lvl12_raAuj_closure" {
     lvl12_raAuj_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.85803526 UTC

[section ""data" . registerFd1_raAuk_closure" {
     registerFd1_raAuk_closure:
         const registerFd1_raAuk_info;
         const 0;
 },
 $wgo_saAQj_entry() //  [R1, R2]
         { info_tbl: [(caD6J,
                       label: $wgo_saAQj_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD6J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caD6K; else goto caD6L;
       caD6K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caD6L: // global
           I64[Sp - 24] = block_caD6C_info;
           _saAQj::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAPq::I64;
           P64[Sp - 8] = _saAQj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaD78; else goto caD6D;
       uaD78: // global
           call _caD6C(R1) args: 0, res: 0, upd: 0;
       caD6D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD6C() //  [R1]
         { info_tbl: [(caD6C,
                       label: block_caD6C_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD6C: // global
           if (R1 & 7 == 1) goto caD6G; else goto caD6H;
       caD6G: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caD6H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD6T; else goto caD6S;
       caD6T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD6S: // global
           _saAQn::P64 = P64[R1 + 6];
           _saAQo::P64 = P64[R1 + 14];
           _saAQm::I64 = I64[R1 + 22];
           if (_saAQm::I64 == I64[Sp + 8]) goto caD77; else goto caD71;
       caD77: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAQn::P64;
           R3 = _saAQo::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caD71: // global
           Hp = Hp - 16;
           I64[Sp] = block_caD6X_info;
           R2 = _saAQo::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAQn::P64;
           I64[Sp + 16] = _saAQm::I64;
           call $wgo_saAQj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD6X() //  [R1, R2, R3]
         { info_tbl: [(caD6X,
                       label: block_caD6X_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD6X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caD74; else goto caD73;
       caD74: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caD73: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saAR8_entry() //  [R1, R2]
         { info_tbl: [(caD7T,
                       label: $wgo_saAR8_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caD7U; else goto caD7V;
       caD7U: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caD7V: // global
           I64[Sp - 24] = block_caD7M_info;
           _saAR8::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAPq::I64;
           P64[Sp - 8] = _saAR8::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaD8i; else goto caD7N;
       uaD8i: // global
           call _caD7M(R1) args: 0, res: 0, upd: 0;
       caD7N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD7M() //  [R1]
         { info_tbl: [(caD7M,
                       label: block_caD7M_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7M: // global
           if (R1 & 7 == 1) goto caD7Q; else goto caD7R;
       caD7Q: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caD7R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD83; else goto caD82;
       caD83: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD82: // global
           _saARc::P64 = P64[R1 + 6];
           _saARd::P64 = P64[R1 + 14];
           _saARb::I64 = I64[R1 + 22];
           if (_saARb::I64 == I64[Sp + 8]) goto caD8h; else goto caD8b;
       caD8h: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saARc::P64;
           R3 = _saARd::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caD8b: // global
           Hp = Hp - 16;
           I64[Sp] = block_caD87_info;
           R2 = _saARd::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saARc::P64;
           I64[Sp + 16] = _saARb::I64;
           call $wgo_saAR8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD87() //  [R1, R2, R3]
         { info_tbl: [(caD87,
                       label: block_caD87_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD87: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caD8e; else goto caD8d;
       caD8e: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caD8d: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAPK_entry() //  [R1, R2]
         { info_tbl: [(caD8q,
                       label: $wio_saAPK_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD8q: // global
           _saAPL::P64 = R2;
           _saAPK::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caD8r; else goto caD8s;
       caD8s: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caD8u; else goto caD8t;
       caD8u: // global
           HpAlloc = 64;
           goto caD8r;
       caD8r: // global
           R2 = _saAPL::P64;
           R1 = _saAPK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caD8t: // global
           _saAPh::P64 = P64[_saAPK::P64 + 6];
           _saAPj::P64 = P64[_saAPK::P64 + 14];
           _saAPk::P64 = P64[_saAPK::P64 + 22];
           _saAPp::P64 = P64[_saAPK::P64 + 30];
           _saAPv::P64 = P64[_saAPK::P64 + 38];
           _saAPo::I64 = I64[_saAPK::P64 + 46];
           _saAPq::I64 = I64[_saAPK::P64 + 54];
           _saAPu::I64 = I64[_saAPK::P64 + 62];
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = _saAPv::P64;
           I64[Hp - 40] = _saAPq::I64;
           I64[Hp - 32] = _saAPo::I64;
           I64[Hp - 24] = _saAPu::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caD5F_info;
           R5 = _saAPL::P64;
           R4 = Hp - 14;
           R3 = _saAPq::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saAPh::P64;
           P64[Sp - 48] = _saAPj::P64;
           P64[Sp - 40] = _saAPk::P64;
           P64[Sp - 32] = _saAPp::P64;
           I64[Sp - 24] = _saAPq::I64;
           I64[Sp - 16] = _saAPu::I64;
           P64[Sp - 8] = _saAPL::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caD5F() //  [R1]
         { info_tbl: [(caD5F,
                       label: block_caD5F_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD5F: // global
           I64[Sp - 8] = block_caD8j_info;
           _saAPR::P64 = R1;
           R1 = R1;
           P64[Sp] = _saAPR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDaS; else goto caD8k;
       uaDaS: // global
           call _caD8j(R1) args: 0, res: 0, upd: 0;
       caD8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD8j() //  [R1]
         { info_tbl: [(caD8j,
                       label: block_caD8j_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD8j: // global
           if (R1 & 7 == 1) goto caD8n; else goto caD8o;
       caD8n: // global
           I64[Sp] = 0;
           call _saAPS() args: 0, res: 0, upd: 0;
       caD8o: // global
           I64[Sp] = block_caDam_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDam() //  [R1]
         { info_tbl: [(caDam,
                       label: block_caDam_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDam: // global
           I64[Sp] = R1;
           call _saAPS() args: 0, res: 0, upd: 0;
     }
 },
 _saAPS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAPS: // global
           _saAPU::I64 = I64[Sp] | I64[Sp + 56];
           _saAPV::I64 = _saAPU::I64 & 8;
           if (_saAPV::I64 != 0) goto uaDaL; else goto uaDaK;
       uaDaL: // global
           I64[Sp + 32] = _saAPV::I64;
           I64[Sp + 56] = _saAPU::I64;
           call _caD5T() args: 0, res: 0, upd: 0;
       uaDaK: // global
           I64[Sp + 24] = _saAPV::I64;
           I64[Sp + 56] = _saAPU::I64;
           Sp = Sp + 8;
           call _caD7b() args: 0, res: 0, upd: 0;
     }
 },
 _caD5T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD5T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caD8B; else goto caD8A;
       caD8B: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caD5S_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caD8A: // global
           _saAPT::I64 = I64[Sp];
           _saAPU::I64 = I64[Sp + 56];
           if (_saAPT::I64 == _saAPU::I64) goto caD8D; else goto caD8E;
       caD8D: // global
           Hp = Hp - 32;
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caD8E: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAPU::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAPT::I64 & 7;
           I64[Sp] = block_caD67_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caD5S() //  [R1]
         { info_tbl: [(caD5S,
                       label: block_caD5S_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD5S: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caD5T() args: 0, res: 0, upd: 0;
     }
 },
 _caD67() //  [R1]
         { info_tbl: [(caD67,
                       label: block_caD67_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD67: // global
           I64[Sp] = block_caD69_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDaU; else goto caD6a;
       uaDaU: // global
           call _caD69(R1) args: 0, res: 0, upd: 0;
       caD6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD69() //  [R1]
         { info_tbl: [(caD69,
                       label: block_caD69_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD69: // global
           if (R1 & 7 == 1) goto caD8I; else goto caD9q;
       caD8I: // global
           I64[Sp + 40] = block_caD6e_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaDaV; else goto caD6f;
       uaDaV: // global
           call _caD6e(R1) args: 0, res: 0, upd: 0;
       caD6f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caD9q: // global
           R1 = lvl12_raAuj_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caD6e() //  [R1]
         { info_tbl: [(caD6e,
                       label: block_caD6e_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD6e: // global
           _saAPL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caD8L; else goto caD9k;
       caD8L: // global
           I64[Sp] = block_caD6j_info;
           R1 = P64[_saAPL::P64 + 8];
           if (R1 & 7 != 0) goto uaDaW; else goto caD6k;
       uaDaW: // global
           call _caD6j(R1) args: 0, res: 0, upd: 0;
       caD6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caD9k: // global
           I64[Sp + 24] = block_caD9i_info;
           R5 = _saAPL::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caD6j() //  [R1]
         { info_tbl: [(caD6j,
                       label: block_caD6j_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD6j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD8O; else goto caD8N;
       caD8O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD8N: // global
           _saAPq::I64 = I64[Sp + 8];
           _saAQa::P64 = P64[R1 + 7];
           _saAQc::P64 = P64[R1 + 15];
           _saAQb::I64 = I64[R1 + 23];
           _saAQd::I64 = _saAPq::I64 & (I64[_saAQa::P64 + 8] - 1);
           _saAQi::P64 = P64[(_saAQa::P64 + 24) + (_saAQd::I64 << 3)];
           I64[Hp - 8] = $wgo_saAQj_info;
           I64[Hp] = _saAPq::I64;
           I64[Sp - 8] = block_caD8P_info;
           R2 = _saAQi::P64;
           R1 = Hp - 7;
           I64[Sp] = _saAQd::I64;
           P64[Sp + 8] = _saAQc::P64;
           I64[Sp + 16] = _saAQb::I64;
           P64[Sp + 24] = _saAQa::P64;
           Sp = Sp - 8;
           call $wgo_saAQj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD8P() //  [R1, R2, R3]
         { info_tbl: [(caD8P,
                       label: block_caD8P_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD8P: // global
           I64[Sp - 16] = block_caD8R_info;
           _saAQx::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAQx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDb2; else goto caD8T;
       uaDb2: // global
           call _caD8R(R1) args: 0, res: 0, upd: 0;
       caD8T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD8R() //  [R1]
         { info_tbl: [(caD8R,
                       label: block_caD8R_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD8R: // global
           if (R1 & 7 == 1) goto uaDaN; else goto caD94;
       uaDaN: // global
           Sp = Sp + 56;
           call _caDa1() args: 0, res: 0, upd: 0;
       caD94: // global
           _saAQa::P64 = P64[Sp + 48];
           _saAQd::I64 = I64[Sp + 24];
           _saAQx::P64 = P64[Sp + 16];
           _saAQz::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAQa::P64 + 24) + (_saAQd::I64 << 3)] = _saAQz::P64;
           I64[_saAQa::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAQa::P64 + 24) + ((I64[_saAQa::P64 + 8] << 3) + (_saAQd::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caD92_info;
           R1 = _saAQx::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaDb3; else goto caD95;
       uaDb3: // global
           call _caD92(R1) args: 0, res: 0, upd: 0;
       caD95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD92() //  [R1]
         { info_tbl: [(caD92,
                       label: block_caD92_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD92: // global
           if (R1 & 7 == 1) goto uaDaO; else goto caD9f;
       uaDaO: // global
           Sp = Sp + 32;
           call _caDa1() args: 0, res: 0, upd: 0;
       caD9f: // global
           _saAQb::I64 = I64[Sp + 16];
           _saAQc::P64 = P64[Sp + 8];
           I64[_saAQb::I64] = I64[_saAQb::I64] - 1;
           call MO_Touch(_saAQc::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caD9i() //  []
         { info_tbl: [(caD9i,
                       label: block_caD9i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD9i: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caD7b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD9u; else goto caD9t;
       caD9u: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caD7a_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caD9t: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caD7h_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD7a() //  [R1]
         { info_tbl: [(caD7a,
                       label: block_caD7a_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7a: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caD7b() args: 0, res: 0, upd: 0;
     }
 },
 _caD7h() //  [R1]
         { info_tbl: [(caD7h,
                       label: block_caD7h_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7h: // global
           I64[Sp] = block_caD7j_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDaY; else goto caD7k;
       uaDaY: // global
           call _caD7j(R1) args: 0, res: 0, upd: 0;
       caD7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD7j() //  [R1]
         { info_tbl: [(caD7j,
                       label: block_caD7j_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7j: // global
           if (R1 & 7 == 1) goto caD9y; else goto caDag;
       caD9y: // global
           I64[Sp + 40] = block_caD7o_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaDaZ; else goto caD7p;
       uaDaZ: // global
           call _caD7o(R1) args: 0, res: 0, upd: 0;
       caD7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDag: // global
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caD7o() //  [R1]
         { info_tbl: [(caD7o,
                       label: block_caD7o_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7o: // global
           _saAPL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caD9B; else goto caDaa;
       caD9B: // global
           I64[Sp] = block_caD7t_info;
           R1 = P64[_saAPL::P64 + 8];
           if (R1 & 7 != 0) goto uaDb0; else goto caD7u;
       uaDb0: // global
           call _caD7t(R1) args: 0, res: 0, upd: 0;
       caD7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDaa: // global
           I64[Sp + 24] = block_caDa8_info;
           R5 = _saAPL::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caD7t() //  [R1]
         { info_tbl: [(caD7t,
                       label: block_caD7t_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD7t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caD9E; else goto caD9D;
       caD9E: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caD9D: // global
           _saAPq::I64 = I64[Sp + 8];
           _saAQZ::P64 = P64[R1 + 7];
           _saAR1::P64 = P64[R1 + 15];
           _saAR0::I64 = I64[R1 + 23];
           _saAR2::I64 = _saAPq::I64 & (I64[_saAQZ::P64 + 8] - 1);
           _saAR7::P64 = P64[(_saAQZ::P64 + 24) + (_saAR2::I64 << 3)];
           I64[Hp - 8] = $wgo_saAR8_info;
           I64[Hp] = _saAPq::I64;
           I64[Sp - 8] = block_caD9F_info;
           R2 = _saAR7::P64;
           R1 = Hp - 7;
           I64[Sp] = _saAR2::I64;
           P64[Sp + 8] = _saAR1::P64;
           I64[Sp + 16] = _saAR0::I64;
           P64[Sp + 24] = _saAQZ::P64;
           Sp = Sp - 8;
           call $wgo_saAR8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD9F() //  [R1, R2, R3]
         { info_tbl: [(caD9F,
                       label: block_caD9F_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD9F: // global
           I64[Sp - 16] = block_caD9H_info;
           _saARm::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saARm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDb6; else goto caD9J;
       uaDb6: // global
           call _caD9H(R1) args: 0, res: 0, upd: 0;
       caD9J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD9H() //  [R1]
         { info_tbl: [(caD9H,
                       label: block_caD9H_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD9H: // global
           if (R1 & 7 == 1) goto uaDaQ; else goto caD9U;
       uaDaQ: // global
           Sp = Sp + 56;
           call _caDa1() args: 0, res: 0, upd: 0;
       caD9U: // global
           _saAQZ::P64 = P64[Sp + 48];
           _saAR2::I64 = I64[Sp + 24];
           _saARm::P64 = P64[Sp + 16];
           _saARo::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAQZ::P64 + 24) + (_saAR2::I64 << 3)] = _saARo::P64;
           I64[_saAQZ::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAQZ::P64 + 24) + ((I64[_saAQZ::P64 + 8] << 3) + (_saAR2::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caD9S_info;
           R1 = _saARm::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaDb7; else goto caD9V;
       uaDb7: // global
           call _caD9S(R1) args: 0, res: 0, upd: 0;
       caD9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD9S() //  [R1]
         { info_tbl: [(caD9S,
                       label: block_caD9S_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD9S: // global
           if (R1 & 7 == 1) goto uaDaR; else goto caDa5;
       uaDaR: // global
           Sp = Sp + 32;
           call _caDa1() args: 0, res: 0, upd: 0;
       caDa5: // global
           _saAR0::I64 = I64[Sp + 16];
           _saAR1::P64 = P64[Sp + 8];
           I64[_saAR0::I64] = I64[_saAR0::I64] - 1;
           call MO_Touch(_saAR1::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDa1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDa1: // global
           R1 = lvl10_raAuh_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDa8() //  []
         { info_tbl: [(caDa8,
                       label: block_caDa8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDa8: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saARG_entry() //  [R1, R2]
         { info_tbl: [(caDbl,
                       label: io_saARG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDbm; else goto caDbn;
       caDbm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDbn: // global
           I64[Sp - 16] = block_caDbi_info;
           _saAPK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAPK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDbr; else goto caDbj;
       uaDbr: // global
           call _caDbi(R1) args: 0, res: 0, upd: 0;
       caDbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDbi() //  [R1]
         { info_tbl: [(caDbi,
                       label: block_caDbi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbi: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAPK_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARU_entry() //  [R1, R2]
         { info_tbl: [(caDbD,
                       label: sat_saARU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDbE; else goto caDbF;
       caDbE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDbF: // global
           I64[Sp - 16] = block_caDbB_info;
           _saARR::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saARR::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDbB() //  []
         { info_tbl: [(caDbB,
                       label: block_caDbB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARP_entry() //  [R1]
         { info_tbl: [(caDbM,
                       label: sat_saARP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbM: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARQ_entry() //  [R1]
         { info_tbl: [(caDbU,
                       label: sat_saARQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbU: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASh_entry() //  [R1, R2]
         { info_tbl: [(caDcc,
                       label: sat_saASh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDcd; else goto caDce;
       caDcd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDce: // global
           I64[Sp - 16] = block_caDca_info;
           _saASe::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saASe::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDca() //  []
         { info_tbl: [(caDca,
                       label: block_caDca_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDca: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASc_entry() //  [R1]
         { info_tbl: [(caDcl,
                       label: sat_saASc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcl: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASd_entry() //  [R1]
         { info_tbl: [(caDct,
                       label: sat_saASd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDct: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASm_entry() //  [R1]
         { info_tbl: [(caDcA,
                       label: sat_saASm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDcB; else goto caDcC;
       caDcB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caDcC: // global
           I64[Sp - 24] = block_caDc3_info;
           _saAPI::P64 = P64[R1 + 7];
           _saARG::P64 = P64[R1 + 15];
           R1 = _saAPI::P64;
           P64[Sp - 16] = _saAPI::P64;
           P64[Sp - 8] = _saARG::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDc3() //  [R1]
         { info_tbl: [(caDc3,
                       label: block_caDc3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDc3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caDcF; else goto caDcE;
       caDcF: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDcE: // global
           I64[Hp - 56] = sat_saASh_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saASc_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saASd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caDcw_info;
           R2 = Hp - 54;
           _saASb::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saASb::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDcw() //  [R1]
         { info_tbl: [(caDcw,
                       label: block_caDcw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcw: // global
           _saAPI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDcy_info;
           R2 = P64[Sp + 16];
           _saASk::P64 = R1;
           R1 = _saAPI::P64;
           P64[Sp + 16] = _saASk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDcy() //  []
         { info_tbl: [(caDcy,
                       label: block_caDcy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASH_entry() //  [R1, R2]
         { info_tbl: [(caDcS,
                       label: sat_saASH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDcT; else goto caDcU;
       caDcT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDcU: // global
           I64[Sp - 16] = block_caDcQ_info;
           _saASE::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saASE::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDcQ() //  []
         { info_tbl: [(caDcQ,
                       label: block_caDcQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASC_entry() //  [R1]
         { info_tbl: [(caDd1,
                       label: sat_saASC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDd1: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASD_entry() //  [R1]
         { info_tbl: [(caDd9,
                       label: sat_saASD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDd9: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 registerFd1_raAuk_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caDdc,
                       label: registerFd1_raAuk_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdc: // global
           if ((Sp + -120) < SpLim) (likely: False) goto caDdd; else goto caDde;
       caDdd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = registerFd1_raAuk_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caDde: // global
           I64[Sp - 40] = block_caD4z_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaDfW; else goto caD4A;
       uaDfW: // global
           call _caD4z(R1) args: 0, res: 0, upd: 0;
       caD4A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD4z() //  [R1]
         { info_tbl: [(caD4z,
                       label: block_caD4z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4z: // global
           I64[Sp - 32] = block_caD4E_info;
           _saAOZ::P64 = P64[R1 + 7];
           _saAP1::P64 = P64[R1 + 23];
           _saAP3::P64 = P64[R1 + 31];
           _saAP5::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _saAP1::P64;
           P64[Sp - 16] = _saAP3::P64;
           P64[Sp - 8] = _saAP5::P64;
           P64[Sp] = _saAOZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaDfP; else goto caD4F;
       uaDfP: // global
           call _caD4E(R1) args: 0, res: 0, upd: 0;
       caD4F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD4E() //  [R1]
         { info_tbl: [(caD4E,
                       label: block_caD4E_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4E: // global
           I64[Sp - 8] = block_caD4J_info;
           _saAPc::P64 = R1;
           _saAPd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAPd::I64;
           P64[Sp + 8] = _saAPc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDfQ; else goto caD4K;
       uaDfQ: // global
           call _caD4J(R1) args: 0, res: 0, upd: 0;
       caD4K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD4J() //  [R1]
         { info_tbl: [(caD4J,
                       label: block_caD4J_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4J: // global
           I64[Sp - 8] = block_caD4O_info;
           _saAPe::P64 = R1;
           _saAPf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saAPf::I64;
           P64[Sp + 40] = _saAPe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDfR; else goto caD4P;
       uaDfR: // global
           call _caD4O(R1) args: 0, res: 0, upd: 0;
       caD4P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD4O() //  [R1]
         { info_tbl: [(caD4O,
                       label: block_caD4O_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4O: // global
           _saAOU::P64 = P64[Sp + 64];
           _saAPh::P64 = P64[R1 + 7];
           _saAPj::P64 = P64[R1 + 23];
           _saAPk::P64 = P64[R1 + 31];
           (_saAPo::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 40] + 16, 1);
           I64[Sp - 16] = block_caD4V_info;
           R1 = _saAOU::P64;
           I64[Sp - 8] = _saAPo::I64;
           P64[Sp] = _saAPk::P64;
           P64[Sp + 40] = _saAPj::P64;
           P64[Sp + 64] = _saAPh::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDfS; else goto caD4W;
       uaDfS: // global
           call _caD4V(R1) args: 0, res: 0, upd: 0;
       caD4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD4V() //  [R1]
         { info_tbl: [(caD4V,
                       label: block_caD4V_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD4V: // global
           I64[Sp - 8] = block_caD50_info;
           _saAPp::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saAPq::I64;
           P64[Sp + 88] = _saAPp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDfT; else goto caD51;
       uaDfT: // global
           call _caD50(R1) args: 0, res: 0, upd: 0;
       caD51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD50() //  [R1]
         { info_tbl: [(caD50,
                       label: block_caD50_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD50: // global
           I64[Sp - 8] = block_caDdk_info;
           _saAPr::P64 = R1;
           _saAPs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 104];
           I64[Sp] = _saAPs::I64;
           P64[Sp + 104] = _saAPr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDfU; else goto caDfy;
       uaDfU: // global
           call _caDdk(R1) args: 0, res: 0, upd: 0;
       caDfy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdk() //  [R1]
         { info_tbl: [(caDdk,
                       label: block_caDdk_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdk: // global
           _saAOT::P64 = P64[Sp + 88];
           _saAPs::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caDfE; else goto caDfI;
       caDfE: // global
           _saAPu::I64 = _saAPs::I64;
           goto saAPt;
       caDfI: // global
           _saAPu::I64 = _saAPs::I64 | 8;
           goto saAPt;
       saAPt: // global
           I64[Sp + 8] = block_caD5a_info;
           R1 = _saAOT::P64;
           I64[Sp + 88] = _saAPu::I64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD5a() //  [R1]
         { info_tbl: [(caD5a,
                       label: block_caD5a_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD5a: // global
           I64[Sp - 8] = block_caD5c_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caD5c() //  [R1]
         { info_tbl: [(caD5c,
                       label: block_caD5c_info
                       rep:StackRep [False, True, True, False, True, True, False, False,
                                     False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD5c: // global
           _saAPc::P64 = P64[Sp + 56];
           _saAPd::I64 = I64[Sp + 48];
           _saAPe::P64 = P64[Sp + 80];
           _saAPz::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saAPd::I64,
                            _saAPz::I64)) goto caDds; else goto caDfx;
       caDfx: // global
           if (%MO_S_Gt_W64(_saAPz::I64,
                            I64[Sp + 40])) goto caDds; else goto caDdt;
       caDds: // global
           R4 = _saAPz::I64;
           R3 = _saAPc::P64;
           R2 = _saAPe::P64;
           Sp = Sp + 120;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caDdt: // global
           _saAPG::P64 = P64[P64[Sp + 64] + ((_saAPz::I64 - _saAPd::I64 << 3) + 24)];
           I64[Sp] = block_caD5s_info;
           _saAPy::I64 = R1;
           R1 = _saAPG::P64;
           I64[Sp + 80] = _saAPy::I64;
           if (R1 & 7 != 0) goto uaDfV; else goto caD5t;
       uaDfV: // global
           call _caD5s(R1) args: 0, res: 0, upd: 0;
       caD5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD5s() //  [R1]
         { info_tbl: [(caD5s,
                       label: block_caD5s_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD5s: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto caDdw; else goto caDdv;
       caDdw: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDdv: // global
           _saAPI::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.Event.Manager.FdKey_con_info;
           _saAPq::I64 = I64[Sp + 16];
           I64[Hp - 120] = _saAPq::I64;
           _saAPo::I64 = I64[Sp + 24];
           I64[Hp - 112] = _saAPo::I64;
           I64[Hp - 104] = $wio_saAPK_info;
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = _saAPo::I64;
           I64[Hp - 48] = _saAPq::I64;
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = io_saARG_info;
           P64[Hp - 24] = Hp - 102;
           _caD5x::P64 = Hp - 127;
           _caDbd::P64 = Hp - 30;
           _saARL::I64 = I64[Sp + 80];
           if (_saARL::I64 != 0) goto uaDfO; else goto caDei;
       uaDfO: // global
           if (_saARL::I64 != 1) goto caDdD; else goto caDeV;
       caDdD: // global
           Hp = Hp - 24;
           I64[Sp] = block_caDbu_info;
           R1 = _saAPI::P64;
           P64[Sp + 88] = _saAPI::P64;
           P64[Sp + 96] = _caDbd::P64;
           P64[Sp + 104] = _caD5x::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caDeV: // global
           Hp = Hp - 24;
           I64[Sp] = block_caDcJ_info;
           R1 = _saAPI::P64;
           P64[Sp + 88] = _saAPI::P64;
           P64[Sp + 96] = _caDbd::P64;
           P64[Sp + 104] = _caD5x::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caDei: // global
           I64[Hp - 16] = sat_saASm_info;
           P64[Hp - 8] = _saAPI::P64;
           P64[Hp] = _caDbd::P64;
           I64[Sp] = block_caDef_info;
           R1 = Hp - 15;
           P64[Sp + 104] = _caD5x::P64;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDbu() //  [R1]
         { info_tbl: [(caDbu,
                       label: block_caDbu_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDbu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caDdG; else goto caDdF;
       caDdG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDdF: // global
           I64[Hp - 56] = sat_saARU_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saARP_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saARQ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caDdx_info;
           R2 = Hp - 54;
           _saARO::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saARO::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdx() //  [R1]
         { info_tbl: [(caDdx,
                       label: block_caDdx_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdx: // global
           I64[Sp] = block_caDdz_info;
           R2 = P64[Sp + 96];
           _saARX::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saARX::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdz() //  []
         { info_tbl: [(caDdz,
                       label: block_caDdz_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdz: // global
           I64[Sp] = block_caDdB_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaDfX; else goto caDdJ;
       uaDfX: // global
           call _caDdB(R1) args: 0, res: 0, upd: 0;
       caDdJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdB() //  [R1]
         { info_tbl: [(caDdB,
                       label: block_caDdB_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdB: // global
           I64[Sp] = block_caDdN_info;
           _saAS0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saAS0::P64;
           if (R1 & 7 != 0) goto uaDfY; else goto caDdP;
       uaDfY: // global
           call _caDdN(R1) args: 0, res: 0, upd: 0;
       caDdP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdN() //  [R1]
         { info_tbl: [(caDdN,
                       label: block_caDdN_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdN: // global
           if (R1 & 7 == 1) goto caDdY; else goto caDe9;
       caDdY: // global
           I64[Sp + 88] = block_caDdT_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caDe9: // global
           _saAS0::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caDe7_info;
           R1 = _saAS0::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaDfZ; else goto caDea;
       uaDfZ: // global
           call _caDe7() args: 0, res: 0, upd: 0;
       caDea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdT() //  []
         { info_tbl: [(caDdT,
                       label: block_caDdT_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdT: // global
           _saAS0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDdV_info;
           R1 = _saAS0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDg0; else goto caDe0;
       uaDg0: // global
           call _caDdV() args: 0, res: 0, upd: 0;
       caDe0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDdV() //  []
         { info_tbl: [(caDdV,
                       label: block_caDdV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDdV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDe7() //  []
         { info_tbl: [(caDe7,
                       label: block_caDe7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDe7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDcJ() //  [R1]
         { info_tbl: [(caDcJ,
                       label: block_caDcJ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDcJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caDeY; else goto caDeX;
       caDeY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDeX: // global
           I64[Hp - 56] = sat_saASH_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saASC_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saASD_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caDeQ_info;
           R2 = Hp - 54;
           _saASB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saASB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDeQ() //  [R1]
         { info_tbl: [(caDeQ,
                       label: block_caDeQ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeQ: // global
           I64[Sp] = block_caDeS_info;
           R2 = P64[Sp + 96];
           _saASK::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saASK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDeS() //  []
         { info_tbl: [(caDeS,
                       label: block_caDeS_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeS: // global
           I64[Sp] = block_caDeU_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaDg5; else goto caDf1;
       uaDg5: // global
           call _caDeU(R1) args: 0, res: 0, upd: 0;
       caDf1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDeU() //  [R1]
         { info_tbl: [(caDeU,
                       label: block_caDeU_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeU: // global
           I64[Sp] = block_caDf5_info;
           _saASN::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saASN::P64;
           if (R1 & 7 != 0) goto uaDg6; else goto caDf7;
       uaDg6: // global
           call _caDf5(R1) args: 0, res: 0, upd: 0;
       caDf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDf5() //  [R1]
         { info_tbl: [(caDf5,
                       label: block_caDf5_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDf5: // global
           if (R1 & 7 == 1) goto caDfg; else goto caDfr;
       caDfg: // global
           I64[Sp + 88] = block_caDfb_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caDfr: // global
           _saASN::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caDfp_info;
           R1 = _saASN::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaDg7; else goto caDfs;
       uaDg7: // global
           call _caDfp() args: 0, res: 0, upd: 0;
       caDfs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDfb() //  []
         { info_tbl: [(caDfb,
                       label: block_caDfb_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDfb: // global
           _saASN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDfd_info;
           R1 = _saASN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDg8; else goto caDfi;
       uaDg8: // global
           call _caDfd() args: 0, res: 0, upd: 0;
       caDfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDfd() //  []
         { info_tbl: [(caDfd,
                       label: block_caDfd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDfd: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDfp() //  []
         { info_tbl: [(caDfp,
                       label: block_caDfp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDfp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDef() //  [R1]
         { info_tbl: [(caDef,
                       label: block_caDef_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDef: // global
           I64[Sp] = block_caDeh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDg1; else goto caDek;
       uaDg1: // global
           call _caDeh(R1) args: 0, res: 0, upd: 0;
       caDek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDeh() //  [R1]
         { info_tbl: [(caDeh,
                       label: block_caDeh_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeh: // global
           I64[Sp] = block_caDeo_info;
           _saASr::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saASr::P64;
           if (R1 & 7 != 0) goto uaDg2; else goto caDeq;
       uaDg2: // global
           call _caDeo(R1) args: 0, res: 0, upd: 0;
       caDeq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDeo() //  [R1]
         { info_tbl: [(caDeo,
                       label: block_caDeo_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeo: // global
           if (R1 & 7 == 1) goto caDez; else goto caDeK;
       caDez: // global
           I64[Sp + 88] = block_caDeu_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caDeK: // global
           _saASr::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caDeI_info;
           R1 = _saASr::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaDg3; else goto caDeL;
       uaDg3: // global
           call _caDeI() args: 0, res: 0, upd: 0;
       caDeL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDeu() //  []
         { info_tbl: [(caDeu,
                       label: block_caDeu_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeu: // global
           _saASr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDew_info;
           R1 = _saASr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDg4; else goto caDeB;
       uaDg4: // global
           call _caDew() args: 0, res: 0, upd: 0;
       caDeB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDew() //  []
         { info_tbl: [(caDew,
                       label: block_caDew_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDew: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDeI() //  []
         { info_tbl: [(caDeI,
                       label: block_caDeI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDeI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.878941174 UTC

[section ""data" . GHC.Event.Manager.registerFd_closure" {
     GHC.Event.Manager.registerFd_closure:
         const GHC.Event.Manager.registerFd_info;
         const 0;
 },
 GHC.Event.Manager.registerFd_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caDgd,
                       label: GHC.Event.Manager.registerFd_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call registerFd1_raAuk_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.879813438 UTC

[section ""cstring" . lvl13_raAul_bytes" {
     lvl13_raAul_bytes:
         I8[] [117,110,114,101,103,105,115,116,101,114,70,100,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.880600273 UTC

[section ""data" . lvl14_raAum_closure" {
     lvl14_raAum_closure:
         const lvl14_raAum_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_raAum_entry() //  [R1]
         { info_tbl: [(caDgm,
                       label: lvl14_raAum_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDgn; else goto caDgo;
       caDgn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDgo: // global
           (_caDgj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDgj::I64 == 0) goto caDgl; else goto caDgk;
       caDgl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDgk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDgj::I64;
           R2 = lvl13_raAul_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.881668762 UTC

[section ""data" . lvl15_raAun_closure" {
     lvl15_raAun_closure:
         const lvl15_raAun_info;
         const 0;
 },
 lvl15_raAun_entry() //  [R2]
         { info_tbl: [(caDgt,
                       label: lvl15_raAun_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgt: // global
           R3 = R2;
           R2 = lvl14_raAum_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.889819919 UTC

[section ""data" . GHC.Event.Manager.unregisterFd2_closure" {
     GHC.Event.Manager.unregisterFd2_closure:
         const GHC.Event.Manager.unregisterFd2_info;
         const 0;
 },
 g_saATV_entry() //  [R1, R2]
         { info_tbl: [(caDhL,
                       label: g_saATV_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDhL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDhM; else goto caDhN;
       caDhM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDhN: // global
           I64[Sp - 16] = block_caDhI_info;
           _saATr::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _saATr::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDhS; else goto caDhJ;
       uaDhS: // global
           call _caDhI(R1) args: 0, res: 0, upd: 0;
       caDhJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDhI() //  [R1]
         { info_tbl: [(caDhI,
                       label: block_caDhI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDhI: // global
           R1 = I64[((I64[R1 + 23] != I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saAU3_entry() //  [R1, R2]
         { info_tbl: [(caDi5,
                       label: $wgo_saAU3_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDi5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caDi6; else goto caDi7;
       caDi6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDi7: // global
           I64[Sp - 32] = block_caDhY_info;
           _saAU3::P64 = R1;
           _saATV::P64 = P64[R1 + 7];
           _saATq::I64 = I64[R1 + 15];
           R1 = R2;
           I64[Sp - 24] = _saATq::I64;
           P64[Sp - 16] = _saATV::P64;
           P64[Sp - 8] = _saAU3::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaDiK; else goto caDhZ;
       uaDiK: // global
           call _caDhY(R1) args: 0, res: 0, upd: 0;
       caDhZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDhY() //  [R1]
         { info_tbl: [(caDhY,
                       label: block_caDhY_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDhY: // global
           if (R1 & 7 == 1) goto caDi2; else goto caDi3;
       caDi2: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDi3: // global
           _saAU7::P64 = P64[R1 + 6];
           _saAU8::P64 = P64[R1 + 14];
           _saAU6::I64 = I64[R1 + 22];
           if (_saAU6::I64 == I64[Sp + 8]) goto caDir; else goto caDil;
       caDir: // global
           I64[Sp] = block_caDiq_info;
           R3 = _saAU7::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 8] = _saAU8::P64;
           P64[Sp + 16] = _saAU7::P64;
           I64[Sp + 24] = _saAU6::I64;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 8;
       caDil: // global
           I64[Sp + 8] = block_caDih_info;
           R2 = _saAU8::P64;
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _saAU7::P64;
           I64[Sp + 24] = _saAU6::I64;
           Sp = Sp + 8;
           call $wgo_saAU3_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDiq() //  [R1]
         { info_tbl: [(caDiq,
                       label: block_caDiq_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDiq: // global
           _saAU7::P64 = P64[Sp + 16];
           _saAU8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto caDix; else goto caDiF;
       caDix: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDiA; else goto caDiz;
       caDiA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDiz: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU7::P64;
           R3 = _saAU8::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDiF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caDiI; else goto caDiH;
       caDiI: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDiH: // global
           I64[Hp - 40] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = _saAU8::P64;
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU7::P64;
           R3 = Hp - 38;
           R2 = Hp - 6;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDih() //  [R1, R2, R3]
         { info_tbl: [(caDih,
                       label: block_caDih_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDih: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDio; else goto caDin;
       caDio: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caDin: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_saAV6_entry() //  [R1, R2]
         { info_tbl: [(caDjq,
                       label: go_saAV6_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDjq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDjr; else goto uaDjJ;
       caDjr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaDjJ: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _caDjg() args: 0, res: 0, upd: 0;
     }
 },
 _caDjg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDjg: // global
           _saATq::I64 = I64[P64[Sp] + 7];
           I64[Sp - 8] = block_caDjj_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saATq::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDjL; else goto caDjk;
       uaDjL: // global
           call _caDjj(R1) args: 0, res: 0, upd: 0;
       caDjk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDjj() //  [R1]
         { info_tbl: [(caDjj,
                       label: block_caDjj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDjj: // global
           if (R1 & 7 == 1) goto caDjn; else goto caDjo;
       caDjn: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDjo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDjA; else goto caDjz;
       caDjA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDjz: // global
           if (I64[R1 + 22] == I64[Sp + 16]) goto caDjI; else goto caDjE;
       caDjI: // global
           _saAVa::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAVa::P64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDjE: // global
           _saAVb::P64 = P64[R1 + 14];
           Hp = Hp - 16;
           P64[Sp + 16] = _saAVb::P64;
           Sp = Sp + 8;
           call _caDjg() args: 0, res: 0, upd: 0;
     }
 },
 $wio_saATF_entry() //  [R1, R2]
         { info_tbl: [(caDjO,
                       label: $wio_saATF_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDjO: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caDjP; else goto caDjQ;
       caDjP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDjQ: // global
           I64[Sp - 56] = block_caDhp_info;
           _saATk::P64 = P64[R1 + 6];
           _saATm::P64 = P64[R1 + 14];
           _saATn::P64 = P64[R1 + 22];
           _saATq::I64 = I64[R1 + 30];
           _saATr::I64 = I64[R1 + 38];
           R1 = P64[R2 + 8];
           P64[Sp - 48] = _saATk::P64;
           P64[Sp - 40] = _saATm::P64;
           P64[Sp - 32] = _saATn::P64;
           I64[Sp - 24] = _saATq::I64;
           I64[Sp - 16] = _saATr::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaDmu; else goto caDhq;
       uaDmu: // global
           call _caDhp(R1) args: 0, res: 0, upd: 0;
       caDhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDhp() //  [R1]
         { info_tbl: [(caDhp,
                       label: block_caDhp_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDhp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caDjT; else goto caDjS;
       caDjT: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDjS: // global
           _saATq::I64 = I64[Sp + 32];
           _saATM::P64 = P64[R1 + 7];
           _saATO::P64 = P64[R1 + 15];
           _saATN::I64 = I64[R1 + 23];
           _saATP::I64 = _saATq::I64 & (I64[_saATM::P64 + 8] - 1);
           _saATU::P64 = P64[(_saATM::P64 + 24) + (_saATP::I64 << 3)];
           I64[Hp - 32] = g_saATV_info;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = $wgo_saAU3_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _saATq::I64;
           I64[Sp - 24] = block_caDiL_info;
           R2 = _saATU::P64;
           R1 = Hp - 15;
           P64[Sp - 16] = _saATO::P64;
           I64[Sp - 8] = _saATP::I64;
           I64[Sp] = _saATN::I64;
           P64[Sp + 40] = _saATM::P64;
           Sp = Sp - 24;
           call $wgo_saAU3_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDiL() //  [R1, R2, R3]
         { info_tbl: [(caDiL,
                       label: block_caDiL_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDiL: // global
           I64[Sp - 16] = block_caDjU_info;
           _saAUm::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAUm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDmr; else goto caDlJ;
       uaDmr: // global
           call _caDjU(R1) args: 0, res: 0, upd: 0;
       caDlJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDjU() //  [R1]
         { info_tbl: [(caDjU,
                       label: block_caDjU_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDjU: // global
           if (R1 & 7 == 1) goto caDlP; else goto caDlU;
       caDlP: // global
           P64[Sp + 80] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAUp() args: 0, res: 0, upd: 0;
       caDlU: // global
           _saATM::P64 = P64[Sp + 80];
           _saATP::I64 = I64[Sp + 32];
           _saAUm::P64 = P64[Sp + 16];
           _saAUo::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saATM::P64 + 24) + (_saATP::I64 << 3)] = _saAUo::P64;
           I64[_saATM::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saATM::P64 + 24) + ((I64[_saATM::P64 + 8] << 3) + (_saATP::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caDlS_info;
           _saAVi::P64 = R1;
           R1 = _saAUm::P64;
           P64[Sp + 80] = _saAVi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaDmv; else goto caDlV;
       uaDmv: // global
           call _caDlS(R1) args: 0, res: 0, upd: 0;
       caDlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDlS() //  [R1]
         { info_tbl: [(caDlS,
                       label: block_caDlS_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDlS: // global
           _saAVi::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto caDm1; else goto caDm5;
       caDm1: // global
           P64[Sp + 64] = _saAVi::P64;
           Sp = Sp + 32;
           goto uaDmI;
       caDm5: // global
           _saATN::I64 = I64[Sp + 24];
           _saATO::P64 = P64[Sp + 8];
           I64[_saATN::I64] = I64[_saATN::I64] - 1;
           call MO_Touch(_saATO::P64);
           P64[Sp + 64] = _saAVi::P64;
           Sp = Sp + 32;
           goto uaDmI;
       uaDmI: // global
           call _saAUp() args: 0, res: 0, upd: 0;
     }
 },
 _saAUp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAUp: // global
           I64[Sp - 8] = block_caDiU_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDmJ; else goto caDiV;
       uaDmJ: // global
           call _caDiU(R1) args: 0, res: 0, upd: 0;
       caDiV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDiU() //  [R1]
         { info_tbl: [(caDiU,
                       label: block_caDiU_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDiU: // global
           if (R1 & 7 == 1) goto caDlc; else goto caDlj;
       caDlc: // global
           I64[Sp + 48] = 0;
           I64[Sp + 40] = 0;
           call _caDjX() args: 0, res: 0, upd: 0;
       caDlj: // global
           _saAUV::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp] = block_caDj0_info;
           _saAUS::P64 = P64[R1 + 6];
           R1 = _saAUV::P64;
           P64[Sp + 48] = _saAUS::P64;
           if (R1 & 7 != 0) goto uaDms; else goto caDj1;
       uaDms: // global
           call _caDj0(R1) args: 0, res: 0, upd: 0;
       caDj1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDj0() //  [R1]
         { info_tbl: [(caDj0,
                       label: block_caDj0_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDj0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDlm; else goto caDll;
       caDlm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDll: // global
           _saATq::I64 = I64[Sp + 32];
           _saAUX::P64 = P64[R1 + 7];
           _saAV5::P64 = P64[(_saAUX::P64 + 24) + (_saATq::I64 & (I64[_saAUX::P64 + 8] - 1) << 3)];
           I64[Hp - 8] = go_saAV6_info;
           I64[Hp] = _saATq::I64;
           I64[Sp] = block_caDld_info;
           R2 = _saAV5::P64;
           R1 = Hp - 7;
           call go_saAV6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDld() //  [R1]
         { info_tbl: [(caDld,
                       label: block_caDld_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDld: // global
           I64[Sp] = block_caDlh_info;
           R2 = P64[Sp + 48];
           P64[Sp + 48] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDlh() //  [R1]
         { info_tbl: [(caDlh,
                       label: block_caDlh_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDlh: // global
           I64[Sp] = block_caDlr_info;
           _saAVe::I64 = R1;
           R1 = P64[Sp + 48];
           I64[Sp + 48] = _saAVe::I64;
           if (R1 & 7 != 0) goto uaDmE; else goto caDlt;
       uaDmE: // global
           call _caDlr(R1) args: 0, res: 0, upd: 0;
       caDlt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDlr() //  [R1]
         { info_tbl: [(caDlr,
                       label: block_caDlr_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDlr: // global
           if (R1 & 7 == 1) goto caDlz; else goto caDlE;
       caDlz: // global
           I64[Sp + 48] = I64[Sp + 48];
           I64[Sp + 40] = 0;
           call _caDjX() args: 0, res: 0, upd: 0;
       caDlE: // global
           I64[Sp] = block_caDlC_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDlC() //  [R1]
         { info_tbl: [(caDlC,
                       label: block_caDlC_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDlC: // global
           I64[Sp + 40] = R1;
           I64[Sp + 48] = I64[Sp + 48];
           call _caDjX() args: 0, res: 0, upd: 0;
     }
 },
 _caDjX() //  []
         { info_tbl: [(caDjX,
                       label: block_caDjX_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDjX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDk2; else goto caDk1;
       caDk2: // global
           HpAlloc = 32;
           I64[Sp] = block_caDjX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caDk1: // global
           _saAUv::I64 = I64[Sp + 40];
           if (I64[Sp + 48] == _saAUv::I64) goto caDk6; else goto caDl8;
       caDk6: // global
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDl8: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = I64[Sp + 32];
           _caDk9::P64 = Hp - 23;
           if (_saAUv::I64 & 8 != 0) goto caDl6; else goto caDl7;
       caDl7: // global
           _saAUK::I64 = _saAUv::I64 & 7;
           if (_saAUK::I64 == 0) goto caDl6; else goto caDkT;
       caDl6: // global
           Hp = Hp - 16;
           P64[Sp + 24] = _caDk9::P64;
           call _caDkd() args: 0, res: 0, upd: 0;
       caDkT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAUK::I64;
           _saATn::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caDkP_info;
           R4 = Hp - 7;
           R3 = _caDk9::P64;
           R2 = P64[Sp + 8];
           R1 = _saATn::P64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDkP() //  [R1]
         { info_tbl: [(caDkP,
                       label: block_caDkP_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDkP: // global
           I64[Sp] = block_caDkR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDmB; else goto caDkV;
       uaDmB: // global
           call _caDkR(R1) args: 0, res: 0, upd: 0;
       caDkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDkR() //  [R1]
         { info_tbl: [(caDkR,
                       label: block_caDkR_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDkR: // global
           if (R1 & 7 == 1) goto uaDmm; else goto uaDmn;
       uaDmm: // global
           Sp = Sp + 8;
           call _caDl1() args: 0, res: 0, upd: 0;
       uaDmn: // global
           Sp = Sp + 32;
           call _caDl5() args: 0, res: 0, upd: 0;
     }
 },
 _caDkd() //  []
         { info_tbl: [(caDkd,
                       label: block_caDkd_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDkd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDkh; else goto caDkg;
       caDkh: // global
           HpAlloc = 32;
           I64[Sp] = block_caDkd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caDkg: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 40] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           _caDk9::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caDkq_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _caDk9::P64;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_v_info;
           Sp = Sp + 16;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caDkq() //  [R1]
         { info_tbl: [(caDkq,
                       label: block_caDkq_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDkq: // global
           I64[Sp] = block_caDks_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDmy; else goto caDku;
       uaDmy: // global
           call _caDks(R1) args: 0, res: 0, upd: 0;
       caDku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDks() //  [R1]
         { info_tbl: [(caDks,
                       label: block_caDks_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDks: // global
           if (R1 & 7 == 1) goto uaDmp; else goto uaDmq;
       uaDmp: // global
           Sp = Sp + 8;
           call _caDl1() args: 0, res: 0, upd: 0;
       uaDmq: // global
           Sp = Sp + 32;
           call _caDl5() args: 0, res: 0, upd: 0;
     }
 },
 _caDl1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDl1: // global
           R2 = I64[Sp];
           Sp = Sp + 24;
           call lvl15_raAun_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caDl5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDl5: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAVs_entry() //  [R1, R2]
         { info_tbl: [(caDmS,
                       label: io_saAVs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDmS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDmT; else goto caDmU;
       caDmT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDmU: // global
           I64[Sp - 16] = block_caDmP_info;
           _saATF::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saATF::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDmY; else goto caDmQ;
       uaDmY: // global
           call _caDmP(R1) args: 0, res: 0, upd: 0;
       caDmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDmP() //  [R1]
         { info_tbl: [(caDmP,
                       label: block_caDmP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDmP: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saATF_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVG_entry() //  [R1, R2]
         { info_tbl: [(caDna,
                       label: sat_saAVG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDna: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDnb; else goto caDnc;
       caDnb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDnc: // global
           I64[Sp - 16] = block_caDn8_info;
           _saAVD::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAVD::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDn8() //  []
         { info_tbl: [(caDn8,
                       label: block_caDn8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDn8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVB_entry() //  [R1]
         { info_tbl: [(caDnj,
                       label: sat_saAVB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDnj: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVC_entry() //  [R1]
         { info_tbl: [(caDnr,
                       label: sat_saAVC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDnr: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVU_entry() //  [R1, R2]
         { info_tbl: [(caDnJ,
                       label: sat_saAVU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDnK; else goto caDnL;
       caDnK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDnL: // global
           I64[Sp - 16] = block_caDnH_info;
           _saAVR::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAVR::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDnH() //  []
         { info_tbl: [(caDnH,
                       label: block_caDnH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDnH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVP_entry() //  [R1]
         { info_tbl: [(caDnS,
                       label: sat_saAVP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDnS: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVQ_entry() //  [R1]
         { info_tbl: [(caDo0,
                       label: sat_saAVQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDo0: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVZ_entry() //  [R1]
         { info_tbl: [(caDo7,
                       label: sat_saAVZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDo7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDo8; else goto caDo9;
       caDo8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caDo9: // global
           I64[Sp - 24] = block_caDnA_info;
           _saATE::P64 = P64[R1 + 7];
           _saAVs::P64 = P64[R1 + 15];
           R1 = _saATE::P64;
           P64[Sp - 16] = _saATE::P64;
           P64[Sp - 8] = _saAVs::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDnA() //  [R1]
         { info_tbl: [(caDnA,
                       label: block_caDnA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDnA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caDoc; else goto caDob;
       caDoc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDob: // global
           I64[Hp - 56] = sat_saAVU_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAVP_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAVQ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caDo3_info;
           R2 = Hp - 54;
           _saAVO::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAVO::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDo3() //  [R1]
         { info_tbl: [(caDo3,
                       label: block_caDo3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDo3: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDo5_info;
           R2 = P64[Sp + 16];
           _saAVX::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAVX::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDo5() //  []
         { info_tbl: [(caDo5,
                       label: block_caDo5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDo5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW8_entry() //  [R1, R2]
         { info_tbl: [(caDop,
                       label: sat_saAW8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDop: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDoq; else goto caDor;
       caDoq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDor: // global
           I64[Sp - 16] = block_caDon_info;
           _saAW5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAW5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDon() //  []
         { info_tbl: [(caDon,
                       label: block_caDon_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDon: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW3_entry() //  [R1]
         { info_tbl: [(caDoy,
                       label: sat_saAW3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDoy: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW4_entry() //  [R1]
         { info_tbl: [(caDoG,
                       label: sat_saAW4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDoG: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.unregisterFd2_entry() //  [R2, R3]
         { info_tbl: [(caDoJ,
                       label: GHC.Event.Manager.unregisterFd2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDoJ: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caDoK; else goto caDoL;
       caDoK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDoL: // global
           I64[Sp - 16] = block_caDgA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDpt; else goto caDgB;
       uaDpt: // global
           call _caDgA(R1) args: 0, res: 0, upd: 0;
       caDgB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDgA() //  [R1]
         { info_tbl: [(caDgA,
                       label: block_caDgA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgA: // global
           I64[Sp - 24] = block_caDgF_info;
           _saAT2::P64 = P64[R1 + 7];
           _saAT4::P64 = P64[R1 + 23];
           _saAT6::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saAT4::P64;
           P64[Sp - 8] = _saAT6::P64;
           P64[Sp] = _saAT2::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaDpo; else goto caDgG;
       uaDpo: // global
           call _caDgF(R1) args: 0, res: 0, upd: 0;
       caDgG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDgF() //  [R1]
         { info_tbl: [(caDgF,
                       label: block_caDgF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgF: // global
           I64[Sp - 8] = block_caDgK_info;
           _saATf::P64 = R1;
           _saATg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saATg::I64;
           P64[Sp + 8] = _saATf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDpp; else goto caDgL;
       uaDpp: // global
           call _caDgK(R1) args: 0, res: 0, upd: 0;
       caDgL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDgK() //  [R1]
         { info_tbl: [(caDgK,
                       label: block_caDgK_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgK: // global
           I64[Sp - 8] = block_caDgP_info;
           _saATh::P64 = R1;
           _saATi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saATi::I64;
           P64[Sp + 32] = _saATh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDpq; else goto caDgQ;
       uaDpq: // global
           call _caDgP(R1) args: 0, res: 0, upd: 0;
       caDgQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDgP() //  [R1]
         { info_tbl: [(caDgP,
                       label: block_caDgP_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgP: // global
           I64[Sp - 16] = block_caDgU_info;
           _saATk::P64 = P64[R1 + 7];
           _saATm::P64 = P64[R1 + 23];
           _saATn::P64 = P64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saATn::P64;
           P64[Sp] = _saATm::P64;
           P64[Sp + 48] = _saATk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDpr; else goto caDgV;
       uaDpr: // global
           call _caDgU(R1) args: 0, res: 0, upd: 0;
       caDgV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDgU() //  [R1]
         { info_tbl: [(caDgU,
                       label: block_caDgU_info
                       rep:StackRep [False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgU: // global
           I64[Sp - 16] = block_caDgZ_info;
           I64[Sp - 8] = I64[R1 + 15];
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caDgZ() //  [R1]
         { info_tbl: [(caDgZ,
                       label: block_caDgZ_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDgZ: // global
           _saATf::P64 = P64[Sp + 56];
           _saATg::I64 = I64[Sp + 48];
           _saATh::P64 = P64[Sp + 72];
           _saATv::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saATg::I64,
                            _saATv::I64)) goto caDoV; else goto caDpm;
       caDpm: // global
           if (%MO_S_Gt_W64(_saATv::I64,
                            I64[Sp + 40])) goto caDoV; else goto caDoW;
       caDoV: // global
           R4 = _saATv::I64;
           R3 = _saATf::P64;
           R2 = _saATh::P64;
           Sp = Sp + 88;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caDoW: // global
           _saATC::P64 = P64[P64[Sp + 64] + ((_saATv::I64 - _saATg::I64 << 3) + 24)];
           I64[Sp] = block_caDhf_info;
           _saATu::I64 = R1;
           R1 = _saATC::P64;
           I64[Sp + 72] = _saATu::I64;
           if (R1 & 7 != 0) goto uaDps; else goto caDhg;
       uaDps: // global
           call _caDhf(R1) args: 0, res: 0, upd: 0;
       caDhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDhf() //  [R1]
         { info_tbl: [(caDhf,
                       label: block_caDhf_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDhf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caDoZ; else goto caDoY;
       caDoZ: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDoY: // global
           _saATE::P64 = P64[R1 + 7];
           I64[Hp - 80] = $wio_saATF_info;
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saAVs_info;
           P64[Hp - 24] = Hp - 78;
           _caDmK::P64 = Hp - 30;
           _saAVx::I64 = I64[Sp + 72];
           if (_saAVx::I64 != 0) goto uaDpn; else goto caDpb;
       uaDpn: // global
           if (_saAVx::I64 != 1) goto caDp4; else goto caDpf;
       caDp4: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caDn1_info;
           R1 = _saATE::P64;
           P64[Sp + 72] = _saATE::P64;
           P64[Sp + 80] = _caDmK::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caDpf: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caDog_info;
           R1 = _saATE::P64;
           P64[Sp + 72] = _saATE::P64;
           P64[Sp + 80] = _caDmK::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caDpb: // global
           I64[Hp - 16] = sat_saAVZ_info;
           P64[Hp - 8] = _saATE::P64;
           P64[Hp] = _caDmK::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDn1() //  [R1]
         { info_tbl: [(caDn1,
                       label: block_caDn1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDn1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caDp7; else goto caDp6;
       caDp7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDp6: // global
           I64[Hp - 56] = sat_saAVG_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAVB_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAVC_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caDp0_info;
           R2 = Hp - 54;
           _saAVA::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAVA::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDp0() //  [R1]
         { info_tbl: [(caDp0,
                       label: block_caDp0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDp0: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDp2_info;
           R2 = P64[Sp + 16];
           _saAVJ::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAVJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDp2() //  []
         { info_tbl: [(caDp2,
                       label: block_caDp2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDp2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDog() //  [R1]
         { info_tbl: [(caDog,
                       label: block_caDog_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDog: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caDpi; else goto caDph;
       caDpi: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDph: // global
           I64[Hp - 56] = sat_saAW8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAW3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAW4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caDpc_info;
           R2 = Hp - 54;
           _saAW2::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAW2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDpc() //  [R1]
         { info_tbl: [(caDpc,
                       label: block_caDpc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpc: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDpe_info;
           R2 = P64[Sp + 16];
           _saAWb::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAWb::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDpe() //  []
         { info_tbl: [(caDpe,
                       label: block_caDpe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.909941737 UTC

[section ""data" . GHC.Event.Manager.unregisterFd__closure" {
     GHC.Event.Manager.unregisterFd__closure:
         const GHC.Event.Manager.unregisterFd__info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd__entry() //  [R2, R3]
         { info_tbl: [(caDpy,
                       label: GHC.Event.Manager.unregisterFd__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpy: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.911043762 UTC

[section ""data" . GHC.Event.Manager.unregisterFd1_closure" {
     GHC.Event.Manager.unregisterFd1_closure:
         const GHC.Event.Manager.unregisterFd1_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd1_entry() //  [R2, R3]
         { info_tbl: [(caDpK,
                       label: GHC.Event.Manager.unregisterFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDpL; else goto caDpM;
       caDpL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDpM: // global
           I64[Sp - 8] = block_caDpF_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDpF() //  [R1]
         { info_tbl: [(caDpF,
                       label: block_caDpF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpF: // global
           I64[Sp] = block_caDpH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDpR; else goto caDpI;
       uaDpR: // global
           call _caDpH() args: 0, res: 0, upd: 0;
       caDpI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDpH() //  []
         { info_tbl: [(caDpH,
                       label: block_caDpH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.912287962 UTC

[section ""data" . GHC.Event.Manager.unregisterFd_closure" {
     GHC.Event.Manager.unregisterFd_closure:
         const GHC.Event.Manager.unregisterFd_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd_entry() //  [R2, R3]
         { info_tbl: [(caDpW,
                       label: GHC.Event.Manager.unregisterFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDpW: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.913491568 UTC

[section ""data" . GHC.Event.Manager.EventManager_closure" {
     GHC.Event.Manager.EventManager_closure:
         const GHC.Event.Manager.EventManager_info;
 },
 GHC.Event.Manager.EventManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDq0: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Manager.EventManager_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 72, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.EventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caDq5,
                       label: GHC.Event.Manager.EventManager_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, False, True, False, False, False,
                                                    True, True, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDq5: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caDq9; else goto caDq8;
       caDq9: // global
           HpAlloc = 112;
           R1 = GHC.Event.Manager.EventManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 112, res: 0, upd: 8;
       caDq8: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 56];
           I64[Hp - 24] = R5;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           R1 = Hp - 103;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.914710809 UTC

[section ""data" . GHC.Event.Manager.Created_closure" {
     GHC.Event.Manager.Created_closure:
         const GHC.Event.Manager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.915305589 UTC

[section ""data" . GHC.Event.Manager.Running_closure" {
     GHC.Event.Manager.Running_closure:
         const GHC.Event.Manager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.915868255 UTC

[section ""data" . GHC.Event.Manager.Dying_closure" {
     GHC.Event.Manager.Dying_closure:
         const GHC.Event.Manager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.91642747 UTC

[section ""data" . GHC.Event.Manager.Releasing_closure" {
     GHC.Event.Manager.Releasing_closure:
         const GHC.Event.Manager.Releasing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.916970148 UTC

[section ""data" . GHC.Event.Manager.Finished_closure" {
     GHC.Event.Manager.Finished_closure:
         const GHC.Event.Manager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.917699871 UTC

[section ""data" . GHC.Event.Manager.FdKey_closure" {
     GHC.Event.Manager.FdKey_closure:
         const GHC.Event.Manager.FdKey_info;
 },
 GHC.Event.Manager.FdKey_entry() //  [R2, R3]
         { info_tbl: [(caDqf,
                       label: GHC.Event.Manager.FdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDqj; else goto caDqi;
       caDqj: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.FdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDqi: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.918799309 UTC

[section ""data" . GHC.Event.Manager.FdData_closure" {
     GHC.Event.Manager.FdData_closure:
         const GHC.Event.Manager.FdData_info;
 },
 GHC.Event.Manager.FdData_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDql: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.FdData_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.FdData_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caDqq,
                       label: GHC.Event.Manager.FdData_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caDqu; else goto caDqt;
       caDqu: // global
           HpAlloc = 40;
           R1 = GHC.Event.Manager.FdData_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caDqt: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.919883661 UTC

[GHC.Event.Manager.EventManager_con_entry() //  [R1]
         { info_tbl: [(caDqv,
                       label: GHC.Event.Manager.EventManager_con_info
                       rep:HeapRep 9 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,69,118,101,110,116,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqv: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.920600795 UTC

[section ""relreadonly" . GHC.Event.Manager.State_closure_tbl" {
     GHC.Event.Manager.State_closure_tbl:
         const GHC.Event.Manager.Created_closure+1;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Dying_closure+3;
         const GHC.Event.Manager.Releasing_closure+4;
         const GHC.Event.Manager.Finished_closure+5;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.921211005 UTC

[GHC.Event.Manager.Created_con_entry() //  [R1]
         { info_tbl: [(caDqx,
                       label: GHC.Event.Manager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqx: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.921940461 UTC

[GHC.Event.Manager.Running_con_entry() //  [R1]
         { info_tbl: [(caDqz,
                       label: GHC.Event.Manager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqz: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.922697848 UTC

[GHC.Event.Manager.Dying_con_entry() //  [R1]
         { info_tbl: [(caDqB,
                       label: GHC.Event.Manager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqB: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.92340908 UTC

[GHC.Event.Manager.Releasing_con_entry() //  [R1]
         { info_tbl: [(caDqD,
                       label: GHC.Event.Manager.Releasing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,101,108,101,97,115,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqD: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.924113668 UTC

[GHC.Event.Manager.Finished_con_entry() //  [R1]
         { info_tbl: [(caDqF,
                       label: GHC.Event.Manager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqF: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.924825847 UTC

[GHC.Event.Manager.FdKey_con_entry() //  [R1]
         { info_tbl: [(caDqH,
                       label: GHC.Event.Manager.FdKey_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,75,101,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqH: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.925634864 UTC

[GHC.Event.Manager.FdData_con_entry() //  [R1]
         { info_tbl: [(caDqJ,
                       label: GHC.Event.Manager.FdData_con_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,68,97,116,97]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.926297587 UTC

[section ""relreadonly" . SaAZi_srt" {
     SaAZi_srt:
         const GHC.Event.Manager.$w$cshowsPrec1_closure;
         const GHC.Event.Manager.$fShowState1_closure;
         const GHC.Event.Manager.$fShowState3_closure;
         const GHC.Event.Manager.$fShowState5_closure;
         const GHC.Event.Manager.$fShowState7_closure;
         const GHC.Event.Manager.$fShowState9_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Manager.$w$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure;
         const GHC.Event.Manager.$fShowFdKey1_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.$fShowState_$cshow_closure;
         const GHC.Arr.$windexError_closure;
         const lvl2_raAu7_closure;
         const lvl3_raAu8_closure;
         const GHC.Event.Manager.callbackTableVar_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.Manager.release1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.Manager.shutdown1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const $wlvl_raAub_closure;
         const lvl7_raAud_closure;
         const GHC.Arr.arrEleBottom_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Manager.new3_closure;
         const GHC.Event.Manager.new1_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.closeFd_3_closure;
         const GHC.Event.Manager.eventsOf_closure;
         const GHC.Event.Manager.closeFd1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.Manager.loop5_closure;
         const GHC.Event.Manager.loop3_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Event.Manager.loop2_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Manager.closeFd_1_closure;
         const registerFd1_raAuk_closure;
         const lvl14_raAum_closure;
         const lvl15_raAun_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const GHC.Event.Manager.unregisterFd1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.927382095 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:32.929388279 UTC

[section ""data" . GHC.Event.Manager.$WEventManager_closure" {
     GHC.Event.Manager.$WEventManager_closure:
         const GHC.Event.Manager.$WEventManager_info;
 },
 GHC.Event.Manager.$WEventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caDqS,
                       label: GHC.Event.Manager.$WEventManager_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqS: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caDrl; else goto caDrm;
       caDrl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WEventManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caDrm: // global
           I64[Sp - 40] = block_caDqP_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaDrw; else goto caDqQ;
       uaDrw: // global
           call _caDqP(R1) args: 0, res: 0, upd: 0;
       caDqQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDqP() //  [R1]
         { info_tbl: [(caDqP,
                       label: block_caDqP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqP: // global
           I64[Sp] = block_caDqV_info;
           _saAuv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saAuv::P64;
           if (R1 & 7 != 0) goto uaDrv; else goto caDqW;
       uaDrv: // global
           call _caDqV(R1) args: 0, res: 0, upd: 0;
       caDqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDqV() //  [R1]
         { info_tbl: [(caDqV,
                       label: block_caDqV_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDqV: // global
           I64[Sp - 24] = block_caDr0_info;
           _saAux::P64 = P64[R1 + 7];
           _saAuy::P64 = P64[R1 + 15];
           _saAuA::P64 = P64[R1 + 23];
           _saAuz::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           I64[Sp - 16] = _saAuz::I64;
           P64[Sp - 8] = _saAuA::P64;
           P64[Sp] = _saAuy::P64;
           P64[Sp + 16] = _saAux::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaDrx; else goto caDr1;
       uaDrx: // global
           call _caDr0(R1) args: 0, res: 0, upd: 0;
       caDr1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDr0() //  [R1]
         { info_tbl: [(caDr0,
                       label: block_caDr0_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDr0: // global
           I64[Sp] = block_caDr5_info;
           _saAuC::P64 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _saAuC::P64;
           if (R1 & 7 != 0) goto uaDry; else goto caDr6;
       uaDry: // global
           call _caDr5(R1) args: 0, res: 0, upd: 0;
       caDr6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDr5() //  [R1]
         { info_tbl: [(caDr5,
                       label: block_caDr5_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDr5: // global
           I64[Sp] = block_caDra_info;
           _saAuE::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _saAuE::P64;
           if (R1 & 7 != 0) goto uaDrz; else goto caDrb;
       uaDrz: // global
           call _caDra(R1) args: 0, res: 0, upd: 0;
       caDrb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDra() //  [R1]
         { info_tbl: [(caDra,
                       label: block_caDra_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDra: // global
           I64[Sp - 32] = block_caDrf_info;
           _saAuJ::P64 = P64[R1 + 7];
           _saAuK::P64 = P64[R1 + 15];
           _saAuG::I64 = I64[R1 + 23];
           _saAuH::I64 = I64[R1 + 31];
           _saAuI::I64 = I64[R1 + 39];
           R1 = P64[Sp + 64];
           I64[Sp - 24] = _saAuI::I64;
           P64[Sp - 16] = _saAuJ::P64;
           P64[Sp - 8] = _saAuK::P64;
           I64[Sp] = _saAuH::I64;
           I64[Sp + 64] = _saAuG::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaDrA; else goto caDrg;
       uaDrA: // global
           call _caDrf(R1) args: 0, res: 0, upd: 0;
       caDrg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDrf() //  [R1]
         { info_tbl: [(caDrf,
                       label: block_caDrf_info
                       rep:StackRep [True, False, False, True, True, False, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDrf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caDru; else goto caDrt;
       caDru: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDrt: // global
           _saAuM::P64 = P64[R1 + 7];
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 80];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _saAuM::P64;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 96];
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 103;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.945726448 UTC

[section ""data" . GHC.Event.Manager.$WFdKey_closure" {
     GHC.Event.Manager.$WFdKey_closure:
         const GHC.Event.Manager.$WFdKey_info;
 },
 GHC.Event.Manager.$WFdKey_entry() //  [R2, R3]
         { info_tbl: [(caDso,
                       label: GHC.Event.Manager.$WFdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDso: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDsx; else goto caDsy;
       caDsx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDsy: // global
           I64[Sp - 16] = block_caDsl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDsE; else goto caDsm;
       uaDsE: // global
           call _caDsl(R1) args: 0, res: 0, upd: 0;
       caDsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDsl() //  [R1]
         { info_tbl: [(caDsl,
                       label: block_caDsl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDsl: // global
           I64[Sp] = block_caDsr_info;
           _saAuQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saAuQ::I64;
           if (R1 & 7 != 0) goto uaDsD; else goto caDss;
       uaDsD: // global
           call _caDsr(R1) args: 0, res: 0, upd: 0;
       caDss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDsr() //  [R1]
         { info_tbl: [(caDsr,
                       label: block_caDsr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDsr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDsC; else goto caDsB;
       caDsC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDsB: // global
           _saAuS::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saAuS::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.955679376 UTC

[section ""data" . GHC.Event.Manager.$WFdData_closure" {
     GHC.Event.Manager.$WFdData_closure:
         const GHC.Event.Manager.$WFdData_info;
 },
 GHC.Event.Manager.$WFdData_entry() //  [R2, R3, R4]
         { info_tbl: [(caDt1,
                       label: GHC.Event.Manager.$WFdData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDt1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caDtc; else goto caDtd;
       caDtc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caDtd: // global
           I64[Sp - 24] = block_caDsY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaDtk; else goto caDsZ;
       uaDtk: // global
           call _caDsY(R1) args: 0, res: 0, upd: 0;
       caDsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDsY() //  [R1]
         { info_tbl: [(caDsY,
                       label: block_caDsY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDsY: // global
           I64[Sp - 8] = block_caDt4_info;
           _saAuX::I64 = I64[R1 + 7];
           _saAuY::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAuY::I64;
           I64[Sp + 8] = _saAuX::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDtj; else goto caDt5;
       uaDtj: // global
           call _caDt4(R1) args: 0, res: 0, upd: 0;
       caDt5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDt4() //  [R1]
         { info_tbl: [(caDt4,
                       label: block_caDt4_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDt4: // global
           I64[Sp] = block_caDt9_info;
           _saAv0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saAv0::I64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDt9() //  [R1]
         { info_tbl: [(caDt9,
                       label: block_caDt9_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDt9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caDti; else goto caDth;
       caDti: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDth: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.964690763 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState10_bytes" {
     GHC.Event.Manager.$fShowState10_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.966521934 UTC

[section ""data" . GHC.Event.Manager.$fShowState9_closure" {
     GHC.Event.Manager.$fShowState9_closure:
         const GHC.Event.Manager.$fShowState9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState9_entry() //  [R1]
         { info_tbl: [(caDtM,
                       label: GHC.Event.Manager.$fShowState9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDtM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDtN; else goto caDtO;
       caDtN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDtO: // global
           (_caDtJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDtJ::I64 == 0) goto caDtL; else goto caDtK;
       caDtL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDtK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDtJ::I64;
           R2 = GHC.Event.Manager.$fShowState10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.970385813 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState8_bytes" {
     GHC.Event.Manager.$fShowState8_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.972211571 UTC

[section ""data" . GHC.Event.Manager.$fShowState7_closure" {
     GHC.Event.Manager.$fShowState7_closure:
         const GHC.Event.Manager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState7_entry() //  [R1]
         { info_tbl: [(caDu3,
                       label: GHC.Event.Manager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDu3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDu4; else goto caDu5;
       caDu4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDu5: // global
           (_caDu0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDu0::I64 == 0) goto caDu2; else goto caDu1;
       caDu2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDu1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDu0::I64;
           R2 = GHC.Event.Manager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.976337909 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState6_bytes" {
     GHC.Event.Manager.$fShowState6_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.978243304 UTC

[section ""data" . GHC.Event.Manager.$fShowState5_closure" {
     GHC.Event.Manager.$fShowState5_closure:
         const GHC.Event.Manager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState5_entry() //  [R1]
         { info_tbl: [(caDuk,
                       label: GHC.Event.Manager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDuk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDul; else goto caDum;
       caDul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDum: // global
           (_caDuh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDuh::I64 == 0) goto caDuj; else goto caDui;
       caDuj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDui: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDuh::I64;
           R2 = GHC.Event.Manager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.982721391 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState4_bytes" {
     GHC.Event.Manager.$fShowState4_bytes:
         I8[] [82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.984608299 UTC

[section ""data" . GHC.Event.Manager.$fShowState3_closure" {
     GHC.Event.Manager.$fShowState3_closure:
         const GHC.Event.Manager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState3_entry() //  [R1]
         { info_tbl: [(caDuB,
                       label: GHC.Event.Manager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDuB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDuC; else goto caDuD;
       caDuC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDuD: // global
           (_caDuy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDuy::I64 == 0) goto caDuA; else goto caDuz;
       caDuA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDuz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDuy::I64;
           R2 = GHC.Event.Manager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.988721567 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState2_bytes" {
     GHC.Event.Manager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.990530566 UTC

[section ""data" . GHC.Event.Manager.$fShowState1_closure" {
     GHC.Event.Manager.$fShowState1_closure:
         const GHC.Event.Manager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState1_entry() //  [R1]
         { info_tbl: [(caDuS,
                       label: GHC.Event.Manager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDuS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDuT; else goto caDuU;
       caDuT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDuU: // global
           (_caDuP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDuP::I64 == 0) goto caDuR; else goto caDuQ;
       caDuR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDuQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDuP::I64;
           R2 = GHC.Event.Manager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:32.994662522 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec1_closure" {
     GHC.Event.Manager.$w$cshowsPrec1_closure:
         const GHC.Event.Manager.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(caDvg,
                       label: GHC.Event.Manager.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDvg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDvh; else goto caDvi;
       caDvh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDvi: // global
           I64[Sp - 16] = block_caDv6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDvB; else goto caDv7;
       uaDvB: // global
           call _caDv6(R1) args: 0, res: 0, upd: 0;
       caDv7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDv6() //  [R1]
         { info_tbl: [(caDv6,
                       label: block_caDv6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDv6: // global
           _saAv3::P64 = P64[Sp + 8];
           _caDvf::P64 = R1 & 7;
           if (_caDvf::P64 < 4) goto uaDvy; else goto uaDvA;
       uaDvy: // global
           if (_caDvf::P64 < 3) goto uaDvz; else goto caDvc;
       uaDvz: // global
           if (_caDvf::P64 < 2) goto caDva; else goto caDvb;
       caDva: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caDvb: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caDvc: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uaDvA: // global
           if (_caDvf::P64 < 5) goto caDvd; else goto caDve;
       caDvd: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caDve: // global
           R3 = _saAv3::P64;
           R2 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.001286685 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(caDvQ,
                       label: GHC.Event.Manager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDvQ: // global
           _saAv6::P64 = R3;
           R3 = R4;
           R2 = _saAv6::P64;
           call GHC.Event.Manager.$w$cshowsPrec1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.005336016 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c==_closure" {
     GHC.Event.Manager.$fEqState_$c==_closure:
         const GHC.Event.Manager.$fEqState_$c==_info;
 },
 GHC.Event.Manager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(caDwb,
                       label: GHC.Event.Manager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDwb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDwc; else goto caDwd;
       caDwc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDwd: // global
           I64[Sp - 16] = block_caDw1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDxO; else goto caDw2;
       uaDxO: // global
           call _caDw1(R1) args: 0, res: 0, upd: 0;
       caDw2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDw1() //  [R1]
         { info_tbl: [(caDw1,
                       label: block_caDw1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDw1: // global
           _saAv9::P64 = P64[Sp + 8];
           _caDwa::P64 = R1 & 7;
           if (_caDwa::P64 < 4) goto uaDxw; else goto uaDxy;
       uaDxw: // global
           if (_caDwa::P64 < 3) goto uaDxx; else goto caDw7;
       uaDxx: // global
           if (_caDwa::P64 < 2) goto caDw5; else goto caDw6;
       caDw5: // global
           I64[Sp + 8] = block_caDwg_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDxJ; else goto caDwi;
       uaDxJ: // global
           call _caDwg(R1) args: 0, res: 0, upd: 0;
       caDwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDw6: // global
           I64[Sp + 8] = block_caDwv_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDxK; else goto caDwx;
       uaDxK: // global
           call _caDwv(R1) args: 0, res: 0, upd: 0;
       caDwx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDw7: // global
           I64[Sp + 8] = block_caDwK_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDxL; else goto caDwM;
       uaDxL: // global
           call _caDwK(R1) args: 0, res: 0, upd: 0;
       caDwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaDxy: // global
           if (_caDwa::P64 < 5) goto caDw8; else goto caDw9;
       caDw8: // global
           I64[Sp + 8] = block_caDwZ_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDxM; else goto caDx1;
       uaDxM: // global
           call _caDwZ(R1) args: 0, res: 0, upd: 0;
       caDx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDw9: // global
           I64[Sp + 8] = block_caDxe_info;
           R1 = _saAv9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDxN; else goto caDxg;
       uaDxN: // global
           call _caDxe(R1) args: 0, res: 0, upd: 0;
       caDxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDwg() //  [R1]
         { info_tbl: [(caDwg,
                       label: block_caDwg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDwg: // global
           if (R1 & 7 == 1) goto uaDxz; else goto uaDxA;
       uaDxz: // global
           Sp = Sp + 8;
           call _caDxq() args: 0, res: 0, upd: 0;
       uaDxA: // global
           Sp = Sp + 8;
           call _caDxm() args: 0, res: 0, upd: 0;
     }
 },
 _caDwv() //  [R1]
         { info_tbl: [(caDwv,
                       label: block_caDwv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDwv: // global
           if (R1 & 7 == 2) goto uaDxB; else goto uaDxC;
       uaDxB: // global
           Sp = Sp + 8;
           call _caDxq() args: 0, res: 0, upd: 0;
       uaDxC: // global
           Sp = Sp + 8;
           call _caDxm() args: 0, res: 0, upd: 0;
     }
 },
 _caDwK() //  [R1]
         { info_tbl: [(caDwK,
                       label: block_caDwK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDwK: // global
           if (R1 & 7 == 3) goto uaDxD; else goto uaDxE;
       uaDxD: // global
           Sp = Sp + 8;
           call _caDxq() args: 0, res: 0, upd: 0;
       uaDxE: // global
           Sp = Sp + 8;
           call _caDxm() args: 0, res: 0, upd: 0;
     }
 },
 _caDwZ() //  [R1]
         { info_tbl: [(caDwZ,
                       label: block_caDwZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDwZ: // global
           if (R1 & 7 == 4) goto uaDxF; else goto uaDxG;
       uaDxF: // global
           Sp = Sp + 8;
           call _caDxq() args: 0, res: 0, upd: 0;
       uaDxG: // global
           Sp = Sp + 8;
           call _caDxm() args: 0, res: 0, upd: 0;
     }
 },
 _caDxe() //  [R1]
         { info_tbl: [(caDxe,
                       label: block_caDxe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDxe: // global
           if (R1 & 7 == 5) goto uaDxH; else goto uaDxI;
       uaDxH: // global
           Sp = Sp + 8;
           call _caDxq() args: 0, res: 0, upd: 0;
       uaDxI: // global
           Sp = Sp + 8;
           call _caDxm() args: 0, res: 0, upd: 0;
     }
 },
 _caDxq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDxq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDxm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDxm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.022236689 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey5_bytes" {
     GHC.Event.Manager.$fShowFdKey5_bytes:
         I8[] [70,100,75,101,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.023894401 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey4_bytes" {
     GHC.Event.Manager.$fShowFdKey4_bytes:
         I8[] [107,101,121,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.025562907 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey3_bytes" {
     GHC.Event.Manager.$fShowFdKey3_bytes:
         I8[] [107,101,121,85,110,105,113,117,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.027165772 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey2_bytes" {
     GHC.Event.Manager.$fShowFdKey2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.030741734 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec_closure" {
     GHC.Event.Manager.$w$cshowsPrec_closure:
         const GHC.Event.Manager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDyO: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvq_entry() //  [R1]
         { info_tbl: [(caDzn,
                       label: sat_saAvq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzn: // global
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Manager.$fShowFdKey2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvr_entry() //  [R1]
         { info_tbl: [(caDzr,
                       label: sat_saAvr_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caDzs; else goto caDzt;
       caDzs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDzt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caDzh_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caDzh() //  [R1, R2]
         { info_tbl: [(caDzh,
                       label: block_caDzh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caDzw; else goto caDzv;
       caDzw: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caDzv: // global
           I64[Hp - 40] = sat_saAvq_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvs_entry() //  [R1]
         { info_tbl: [(caDzx,
                       label: sat_saAvs_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDzB; else goto caDzA;
       caDzB: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDzA: // global
           _saAvl::P64 = P64[R1 + 16];
           _saAvi::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_saAvr_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Manager.$fShowFdKey3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvt_entry() //  [R1]
         { info_tbl: [(caDzC,
                       label: sat_saAvt_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzC: // global
           _saAvt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caDzD; else goto caDzE;
       caDzE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDzG; else goto caDzF;
       caDzG: // global
           HpAlloc = 32;
           goto caDzD;
       caDzD: // global
           R1 = _saAvt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvt::P64;
           _saAvl::P64 = P64[_saAvt::P64 + 16];
           _saAvi::I64 = I64[_saAvt::P64 + 24];
           I64[Hp - 24] = sat_saAvs_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvx_entry() //  [R1]
         { info_tbl: [(caDzK,
                       label: sat_saAvx_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzK: // global
           _saAvx::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caDzL; else goto caDzM;
       caDzM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDzO; else goto caDzN;
       caDzO: // global
           HpAlloc = 32;
           goto caDzL;
       caDzL: // global
           R1 = _saAvx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDzN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvx::P64;
           _saAvl::P64 = P64[_saAvx::P64 + 16];
           _saAvh::I64 = I64[_saAvx::P64 + 24];
           _saAvi::I64 = I64[_saAvx::P64 + 32];
           I64[Hp - 24] = sat_saAvt_info;
           P64[Hp - 8] = _saAvl::P64;
           I64[Hp] = _saAvi::I64;
           I64[Sp - 24] = block_caDzH_info;
           R4 = Hp - 24;
           R3 = _saAvh::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caDzH() //  [R1, R2]
         { info_tbl: [(caDzH,
                       label: block_caDzH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDzR; else goto caDzQ;
       caDzR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caDzQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAvy_entry() //  [R1]
         { info_tbl: [(caDzS,
                       label: sat_saAvy_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzS: // global
           _saAvy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caDzT; else goto caDzU;
       caDzU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caDzW; else goto caDzV;
       caDzW: // global
           HpAlloc = 40;
           goto caDzT;
       caDzT: // global
           R1 = _saAvy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDzV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvy::P64;
           _saAvl::P64 = P64[_saAvy::P64 + 16];
           _saAvh::I64 = I64[_saAvy::P64 + 24];
           _saAvi::I64 = I64[_saAvy::P64 + 32];
           I64[Hp - 32] = sat_saAvx_info;
           P64[Hp - 16] = _saAvl::P64;
           I64[Hp - 8] = _saAvh::I64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_saAvk_entry() //  [R1, R2]
         { info_tbl: [(caDzX,
                       label: p_saAvk_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDzX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caDA1; else goto caDA0;
       caDA1: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDA0: // global
           _saAvh::I64 = I64[R1 + 7];
           _saAvi::I64 = I64[R1 + 15];
           I64[Hp - 32] = sat_saAvy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = _saAvh::I64;
           I64[Hp] = _saAvi::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAvB_entry() //  [R1]
         { info_tbl: [(caDAb,
                       label: sat_saAvB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDAb: // global
           _saAvB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caDAc; else goto caDAd;
       caDAd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDAf; else goto caDAe;
       caDAf: // global
           HpAlloc = 24;
           goto caDAc;
       caDAc: // global
           R1 = _saAvB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDAe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAvB::P64;
           _saAvj::P64 = P64[_saAvB::P64 + 16];
           _saAvk::P64 = P64[_saAvB::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _saAvj::P64;
           R2 = Hp - 14;
           R1 = _saAvk::P64;
           Sp = Sp - 16;
           call p_saAvk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caDAj,
                       label: GHC.Event.Manager.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDAj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caDAn; else goto caDAm;
       caDAn: // global
           HpAlloc = 80;
           R1 = GHC.Event.Manager.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caDAm: // global
           I64[Hp - 72] = p_saAvk_info;
           I64[Hp - 64] = R3;
           I64[Hp - 56] = R4;
           _caDyS::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto caDAh; else goto caDAi;
       caDAh: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _caDyS::P64;
           call p_saAvk_entry(R2, R1) args: 8, res: 0, upd: 8;
       caDAi: // global
           I64[Hp - 48] = sat_saAvB_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _caDyS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.056516893 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caDBg,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDBg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDBk; else goto caDBl;
       caDBk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caDBl: // global
           I64[Sp - 24] = block_caDBd_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaDBt; else goto caDBe;
       uaDBt: // global
           call _caDBd(R1) args: 0, res: 0, upd: 0;
       caDBe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDBd() //  [R1]
         { info_tbl: [(caDBd,
                       label: block_caDBd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDBd: // global
           I64[Sp] = block_caDBj_info;
           _saAvG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saAvG::I64;
           if (R1 & 7 != 0) goto uaDBs; else goto caDBn;
       uaDBs: // global
           call _caDBj(R1) args: 0, res: 0, upd: 0;
       caDBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDBj() //  [R1]
         { info_tbl: [(caDBj,
                       label: block_caDBj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDBj: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.06446676 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey6_closure" {
     GHC.Event.Manager.$fShowFdKey6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.066459457 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshow_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshow_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshow_entry() //  [R2]
         { info_tbl: [(caDBP,
                       label: GHC.Event.Manager.$fShowFdKey_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDBP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDBQ; else goto caDBR;
       caDBQ: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDBR: // global
           I64[Sp - 8] = block_caDBM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDBV; else goto caDBN;
       uaDBV: // global
           call _caDBM(R1) args: 0, res: 0, upd: 0;
       caDBN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDBM() //  [R1]
         { info_tbl: [(caDBM,
                       label: block_caDBM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDBM: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.071851735 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey1_closure" {
     GHC.Event.Manager.$fShowFdKey1_closure:
         const GHC.Event.Manager.$fShowFdKey1_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey1_entry() //  [R2, R3]
         { info_tbl: [(caDCc,
                       label: GHC.Event.Manager.$fShowFdKey1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDCc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDCd; else goto caDCe;
       caDCd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDCe: // global
           I64[Sp - 16] = block_caDC9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDCi; else goto caDCa;
       uaDCi: // global
           call _caDC9(R1) args: 0, res: 0, upd: 0;
       caDCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDC9() //  [R1]
         { info_tbl: [(caDC9,
                       label: block_caDC9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDC9: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.077693562 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowList_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowList_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caDCw,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDCw: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$fShowFdKey1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.080924007 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_closure" {
     GHC.Event.Manager.$fShowFdKey_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure+1;
         const GHC.Event.Manager.$fShowFdKey_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.082971348 UTC

[section ""data" . GHC.Event.Manager.keyUnique_closure" {
     GHC.Event.Manager.keyUnique_closure:
         const GHC.Event.Manager.keyUnique_info;
 },
 GHC.Event.Manager.keyUnique_entry() //  [R2]
         { info_tbl: [(caDCL,
                       label: GHC.Event.Manager.keyUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDCL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDCP; else goto caDCQ;
       caDCP: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDCQ: // global
           I64[Sp - 8] = block_caDCI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDCU; else goto caDCJ;
       uaDCU: // global
           call _caDCI(R1) args: 0, res: 0, upd: 0;
       caDCJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDCI() //  [R1]
         { info_tbl: [(caDCI,
                       label: block_caDCI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDCI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDCT; else goto caDCS;
       caDCT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDCS: // global
           _saAvY::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAvY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.089066805 UTC

[section ""data" . GHC.Event.Manager.keyFd_closure" {
     GHC.Event.Manager.keyFd_closure:
         const GHC.Event.Manager.keyFd_info;
 },
 GHC.Event.Manager.keyFd_entry() //  [R2]
         { info_tbl: [(caDDc,
                       label: GHC.Event.Manager.keyFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDDc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDDg; else goto caDDh;
       caDDg: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDDh: // global
           I64[Sp - 8] = block_caDD9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDDl; else goto caDDa;
       uaDDl: // global
           call _caDD9(R1) args: 0, res: 0, upd: 0;
       caDDa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDD9() //  [R1]
         { info_tbl: [(caDD9,
                       label: block_caDD9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDD9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDDk; else goto caDDj;
       caDDk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDDj: // global
           _saAw1::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saAw1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.095402873 UTC

[section ""data" . GHC.Event.Manager._fdCallback_closure" {
     GHC.Event.Manager._fdCallback_closure:
         const GHC.Event.Manager._fdCallback_info;
 },
 GHC.Event.Manager._fdCallback_entry() //  [R2]
         { info_tbl: [(caDDD,
                       label: GHC.Event.Manager._fdCallback_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDDD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDDE; else goto caDDF;
       caDDE: // global
           R2 = R2;
           R1 = GHC.Event.Manager._fdCallback_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDDF: // global
           I64[Sp - 8] = block_caDDA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDDJ; else goto caDDB;
       uaDDJ: // global
           call _caDDA(R1) args: 0, res: 0, upd: 0;
       caDDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDDA() //  [R1]
         { info_tbl: [(caDDA,
                       label: block_caDDA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDDA: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.100581876 UTC

[section ""data" . GHC.Event.Manager.fdEvents_closure" {
     GHC.Event.Manager.fdEvents_closure:
         const GHC.Event.Manager.fdEvents_info;
 },
 GHC.Event.Manager.fdEvents_entry() //  [R2]
         { info_tbl: [(caDE0,
                       label: GHC.Event.Manager.fdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDE0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDE4; else goto caDE5;
       caDE4: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDE5: // global
           I64[Sp - 8] = block_caDDX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDE9; else goto caDDY;
       uaDE9: // global
           call _caDDX(R1) args: 0, res: 0, upd: 0;
       caDDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDDX() //  [R1]
         { info_tbl: [(caDDX,
                       label: block_caDDX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDDX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDE8; else goto caDE7;
       caDE8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDE7: // global
           _saAwd::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAwd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.106417987 UTC

[section ""data" . GHC.Event.Manager.fdKey_closure" {
     GHC.Event.Manager.fdKey_closure:
         const GHC.Event.Manager.fdKey_info;
 },
 GHC.Event.Manager.fdKey_entry() //  [R2]
         { info_tbl: [(caDEr,
                       label: GHC.Event.Manager.fdKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDEr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDEv; else goto caDEw;
       caDEv: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDEw: // global
           I64[Sp - 8] = block_caDEo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDEA; else goto caDEp;
       uaDEA: // global
           call _caDEo(R1) args: 0, res: 0, upd: 0;
       caDEp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDEo() //  [R1]
         { info_tbl: [(caDEo,
                       label: block_caDEo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDEo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDEz; else goto caDEy;
       caDEz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDEy: // global
           _saAwh::I64 = I64[R1 + 15];
           _saAwi::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAwh::I64;
           I64[Hp] = _saAwi::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.111974892 UTC

[section ""data" . GHC.Event.Manager.emLock_closure" {
     GHC.Event.Manager.emLock_closure:
         const GHC.Event.Manager.emLock_info;
 },
 GHC.Event.Manager.emLock_entry() //  [R2]
         { info_tbl: [(caDES,
                       label: GHC.Event.Manager.emLock_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDES: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDEW; else goto caDEX;
       caDEW: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emLock_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDEX: // global
           I64[Sp - 8] = block_caDEP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDF1; else goto caDEQ;
       uaDF1: // global
           call _caDEP(R1) args: 0, res: 0, upd: 0;
       caDEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDEP() //  [R1]
         { info_tbl: [(caDEP,
                       label: block_caDEP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDEP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDF0; else goto caDEZ;
       caDF0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDEZ: // global
           _saAwz::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _saAwz::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.117846045 UTC

[section ""data" . GHC.Event.Manager.emControl_closure" {
     GHC.Event.Manager.emControl_closure:
         const GHC.Event.Manager.emControl_info;
 },
 GHC.Event.Manager.emControl_entry() //  [R2]
         { info_tbl: [(caDFj,
                       label: GHC.Event.Manager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDFj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDFn; else goto caDFo;
       caDFn: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDFo: // global
           I64[Sp - 8] = block_caDFg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDFs; else goto caDFh;
       uaDFs: // global
           call _caDFg(R1) args: 0, res: 0, upd: 0;
       caDFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDFg() //  [R1]
         { info_tbl: [(caDFg,
                       label: block_caDFg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDFg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caDFr; else goto caDFq;
       caDFr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDFq: // global
           _saAwM::P64 = P64[R1 + 55];
           _saAwN::P64 = P64[R1 + 63];
           _saAwJ::I64 = I64[R1 + 87];
           _saAwK::I64 = I64[R1 + 95];
           _saAwL::I64 = I64[R1 + 103];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _saAwM::P64;
           P64[Hp - 24] = _saAwN::P64;
           I64[Hp - 16] = _saAwJ::I64;
           I64[Hp - 8] = _saAwK::I64;
           I64[Hp] = _saAwL::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.123732804 UTC

[section ""data" . GHC.Event.Manager.emUniqueSource_closure" {
     GHC.Event.Manager.emUniqueSource_closure:
         const GHC.Event.Manager.emUniqueSource_info;
 },
 GHC.Event.Manager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(caDFK,
                       label: GHC.Event.Manager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDFK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDFO; else goto caDFP;
       caDFO: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDFP: // global
           I64[Sp - 8] = block_caDFH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDFT; else goto caDFI;
       uaDFT: // global
           call _caDFH(R1) args: 0, res: 0, upd: 0;
       caDFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDFH() //  [R1]
         { info_tbl: [(caDFH,
                       label: block_caDFH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDFH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDFS; else goto caDFR;
       caDFS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDFR: // global
           _saAwX::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _saAwX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.130091173 UTC

[section ""data" . GHC.Event.Manager.emState_closure" {
     GHC.Event.Manager.emState_closure:
         const GHC.Event.Manager.emState_info;
 },
 GHC.Event.Manager.emState_entry() //  [R2]
         { info_tbl: [(caDGb,
                       label: GHC.Event.Manager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDGb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDGf; else goto caDGg;
       caDGf: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDGg: // global
           I64[Sp - 8] = block_caDG8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDGk; else goto caDG9;
       uaDGk: // global
           call _caDG8(R1) args: 0, res: 0, upd: 0;
       caDG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDG8() //  [R1]
         { info_tbl: [(caDG8,
                       label: block_caDG8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDG8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDGj; else goto caDGi;
       caDGj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDGi: // global
           _saAxb::P64 = P64[R1 + 39];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _saAxb::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.136103839 UTC

[section ""data" . GHC.Event.Manager.emFds_closure" {
     GHC.Event.Manager.emFds_closure:
         const GHC.Event.Manager.emFds_info;
 },
 GHC.Event.Manager.emFds_entry() //  [R2]
         { info_tbl: [(caDGC,
                       label: GHC.Event.Manager.emFds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDGC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDGG; else goto caDGH;
       caDGG: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emFds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDGH: // global
           I64[Sp - 8] = block_caDGz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDGL; else goto caDGA;
       uaDGL: // global
           call _caDGz(R1) args: 0, res: 0, upd: 0;
       caDGA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDGz() //  [R1]
         { info_tbl: [(caDGz,
                       label: block_caDGz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDGz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caDGK; else goto caDGJ;
       caDGK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDGJ: // global
           _saAxm::P64 = P64[R1 + 15];
           _saAxn::P64 = P64[R1 + 23];
           _saAxp::P64 = P64[R1 + 31];
           _saAxo::I64 = I64[R1 + 79];
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = _saAxm::P64;
           P64[Hp - 16] = _saAxn::P64;
           P64[Hp - 8] = _saAxp::P64;
           I64[Hp] = _saAxo::I64;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.141995813 UTC

[section ""data" . GHC.Event.Manager.emBackend_closure" {
     GHC.Event.Manager.emBackend_closure:
         const GHC.Event.Manager.emBackend_info;
 },
 GHC.Event.Manager.emBackend_entry() //  [R2]
         { info_tbl: [(caDH3,
                       label: GHC.Event.Manager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDH3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDH4; else goto caDH5;
       caDH4: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDH5: // global
           I64[Sp - 8] = block_caDH0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDH9; else goto caDH1;
       uaDH9: // global
           call _caDH0(R1) args: 0, res: 0, upd: 0;
       caDH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDH0() //  [R1]
         { info_tbl: [(caDH0,
                       label: block_caDH0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDH0: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.147257904 UTC

[section ""data" . GHC.Event.Manager.newDefaultBackend_closure" {
     GHC.Event.Manager.newDefaultBackend_closure:
         const GHC.Event.Manager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.Manager.newDefaultBackend_entry() //  []
         { info_tbl: [(caDHp,
                       label: GHC.Event.Manager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDHp: // global
           call GHC.Event.EPoll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.150463685 UTC

[section ""cstring" . GHC.Event.Manager.$trModule4_bytes" {
     GHC.Event.Manager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.152176924 UTC

[section ""data" . GHC.Event.Manager.$trModule3_closure" {
     GHC.Event.Manager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.153893331 UTC

[section ""cstring" . GHC.Event.Manager.$trModule2_bytes" {
     GHC.Event.Manager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.155533403 UTC

[section ""data" . GHC.Event.Manager.$trModule1_closure" {
     GHC.Event.Manager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.157186978 UTC

[section ""data" . GHC.Event.Manager.$trModule_closure" {
     GHC.Event.Manager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Manager.$trModule3_closure+1;
         const GHC.Event.Manager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.159475657 UTC

[section ""data" . $krep_raAtw_closure" {
     $krep_raAtw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.161192121 UTC

[section ""data" . $krep1_raAtx_closure" {
     $krep1_raAtx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.163301354 UTC

[section ""data" . $krep2_raAty_closure" {
     $krep2_raAty_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEvent_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.164980894 UTC

[section ""data" . $krep3_raAtz_closure" {
     $krep3_raAtz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEventLifetime_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.166648761 UTC

[section ""data" . $krep4_raAtA_closure" {
     $krep4_raAtA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.168337115 UTC

[section ""data" . $krep5_raAtB_closure" {
     $krep5_raAtB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.170076581 UTC

[section ""data" . $krep6_raAtC_closure" {
     $krep6_raAtC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.171689218 UTC

[section ""data" . $krep7_raAtD_closure" {
     $krep7_raAtD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.173461493 UTC

[section ""data" . $krep8_raAtE_closure" {
     $krep8_raAtE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.175199929 UTC

[section ""data" . $krep9_raAtF_closure" {
     $krep9_raAtF_closure:
         const :_con_info;
         const $krep4_raAtA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.176886029 UTC

[section ""data" . $krep10_raAtG_closure" {
     $krep10_raAtG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.179393714 UTC

[section ""data" . $krep11_raAtH_closure" {
     $krep11_raAtH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.181128685 UTC

[section ""data" . $krep12_raAtI_closure" {
     $krep12_raAtI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_raAty_closure+1;
         const $krep10_raAtG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.182880267 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdKey2_bytes" {
     GHC.Event.Manager.$tcFdKey2_bytes:
         I8[] [70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.185118347 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey1_closure" {
     GHC.Event.Manager.$tcFdKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.186841601 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey_closure" {
     GHC.Event.Manager.$tcFdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11469896173097407196;
         const 6069269054622812669;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.188654349 UTC

[section ""data" . $krep13_raAtJ_closure" {
     $krep13_raAtJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.190387259 UTC

[section ""data" . $krep14_raAtK_closure" {
     $krep14_raAtK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep12_raAtI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.192079894 UTC

[section ""data" . $krep15_raAtL_closure" {
     $krep15_raAtL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raAtw_closure+1;
         const $krep13_raAtJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.194225463 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey1_closure" {
     GHC.Event.Manager.$tc'FdKey1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raAtx_closure+1;
         const $krep15_raAtL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.195846516 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdKey3_bytes" {
     GHC.Event.Manager.$tc'FdKey3_bytes:
         I8[] [39,70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.197509829 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey2_closure" {
     GHC.Event.Manager.$tc'FdKey2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdKey3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.199151713 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey_closure" {
     GHC.Event.Manager.$tc'FdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdKey2_closure+1;
         const GHC.Event.Manager.$tc'FdKey1_closure+4;
         const 5122964525573573781;
         const 3523266410810375450;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.200878741 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdData2_bytes" {
     GHC.Event.Manager.$tcFdData2_bytes:
         I8[] [70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.202568855 UTC

[section ""data" . GHC.Event.Manager.$tcFdData1_closure" {
     GHC.Event.Manager.$tcFdData1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdData2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.204199774 UTC

[section ""data" . GHC.Event.Manager.$tcFdData_closure" {
     GHC.Event.Manager.$tcFdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdData1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9572952300930290737;
         const 248149994861342082;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.206519437 UTC

[section ""data" . $krep16_raAtM_closure" {
     $krep16_raAtM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdData_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.208240413 UTC

[section ""data" . $krep17_raAtN_closure" {
     $krep17_raAtN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_raAtK_closure+4;
         const $krep16_raAtM_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.210441152 UTC

[section ""data" . $krep18_raAtO_closure" {
     $krep18_raAtO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_raAtz_closure+1;
         const $krep17_raAtN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.212127772 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData1_closure" {
     GHC.Event.Manager.$tc'FdData1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep18_raAtO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.213847674 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdData3_bytes" {
     GHC.Event.Manager.$tc'FdData3_bytes:
         I8[] [39,70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.215434406 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData2_closure" {
     GHC.Event.Manager.$tc'FdData2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdData3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.217095127 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData_closure" {
     GHC.Event.Manager.$tc'FdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdData2_closure+1;
         const GHC.Event.Manager.$tc'FdData1_closure+4;
         const 13006093439393452327;
         const 3623098721817739111;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.218970569 UTC

[section ""data" . $krep19_raAtP_closure" {
     $krep19_raAtP_closure:
         const :_con_info;
         const $krep16_raAtM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.220701363 UTC

[section ""data" . $krep20_raAtQ_closure" {
     $krep20_raAtQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep19_raAtP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.222806073 UTC

[section ""data" . $krep21_raAtR_closure" {
     $krep21_raAtR_closure:
         const :_con_info;
         const $krep20_raAtQ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.224553197 UTC

[section ""data" . $krep22_raAtS_closure" {
     $krep22_raAtS_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.IntTable.$tcIntTable_closure;
         const $krep21_raAtR_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.226309435 UTC

[section ""data" . $krep23_raAtT_closure" {
     $krep23_raAtT_closure:
         const :_con_info;
         const $krep22_raAtS_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.228069597 UTC

[section ""data" . $krep24_raAtU_closure" {
     $krep24_raAtU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep23_raAtT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.229834584 UTC

[section ""data" . $krep25_raAtV_closure" {
     $krep25_raAtV_closure:
         const :_con_info;
         const $krep24_raAtU_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.231523098 UTC

[section ""data" . $krep26_raAtW_closure" {
     $krep26_raAtW_closure:
         const :_con_info;
         const $krep7_raAtD_closure+1;
         const $krep25_raAtV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.233210698 UTC

[section ""data" . $krep27_raAtX_closure" {
     $krep27_raAtX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Arr.$tcArray_closure;
         const $krep26_raAtW_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.235890481 UTC

[section ""cstring" . GHC.Event.Manager.$tcState2_bytes" {
     GHC.Event.Manager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.237639117 UTC

[section ""data" . GHC.Event.Manager.$tcState1_closure" {
     GHC.Event.Manager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.239353503 UTC

[section ""data" . GHC.Event.Manager.$tcState_closure" {
     GHC.Event.Manager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7442518771887689078;
         const 3049393439281173903;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.241139331 UTC

[section ""data" . GHC.Event.Manager.$tc'Created1_closure" {
     GHC.Event.Manager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.24287913 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Created3_bytes" {
     GHC.Event.Manager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.244500512 UTC

[section ""data" . GHC.Event.Manager.$tc'Created2_closure" {
     GHC.Event.Manager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.246360264 UTC

[section ""data" . GHC.Event.Manager.$tc'Created_closure" {
     GHC.Event.Manager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Created2_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 17846748838152018769;
         const 13865095201560943193;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.248128988 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Running2_bytes" {
     GHC.Event.Manager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.249739071 UTC

[section ""data" . GHC.Event.Manager.$tc'Running1_closure" {
     GHC.Event.Manager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.251355921 UTC

[section ""data" . GHC.Event.Manager.$tc'Running_closure" {
     GHC.Event.Manager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Running1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8784511774161450304;
         const 13551584807303205071;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.253130381 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Dying2_bytes" {
     GHC.Event.Manager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.254792994 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying1_closure" {
     GHC.Event.Manager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.256471427 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying_closure" {
     GHC.Event.Manager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Dying1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 10564881478355389136;
         const 3106847497763432300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.258722379 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Releasing2_bytes" {
     GHC.Event.Manager.$tc'Releasing2_bytes:
         I8[] [39,82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.260927743 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing1_closure" {
     GHC.Event.Manager.$tc'Releasing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Releasing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.262706468 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing_closure" {
     GHC.Event.Manager.$tc'Releasing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Releasing1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 3204716164798465120;
         const 4205553053946559474;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.264405191 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Finished2_bytes" {
     GHC.Event.Manager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.266157408 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished1_closure" {
     GHC.Event.Manager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.26777025 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished_closure" {
     GHC.Event.Manager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Finished1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8866864364616799312;
         const 2451390217632909923;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.269999536 UTC

[section ""data" . $krep28_raAtY_closure" {
     $krep28_raAtY_closure:
         const :_con_info;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.271661823 UTC

[section ""data" . $krep29_raAtZ_closure" {
     $krep29_raAtZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep28_raAtY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.27338805 UTC

[section ""cstring" . GHC.Event.Manager.$tcEventManager2_bytes" {
     GHC.Event.Manager.$tcEventManager2_bytes:
         I8[] [69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.275047043 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager1_closure" {
     GHC.Event.Manager.$tcEventManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcEventManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.276767198 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager_closure" {
     GHC.Event.Manager.$tcEventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcEventManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16777685112477180948;
         const 1210110422135437783;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.278621547 UTC

[section ""data" . $krep30_raAu0_closure" {
     $krep30_raAu0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcEventManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.280409839 UTC

[section ""data" . $krep31_raAu1_closure" {
     $krep31_raAu1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_raAtH_closure+1;
         const $krep30_raAu0_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.282514365 UTC

[section ""data" . $krep32_raAu2_closure" {
     $krep32_raAu2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_raAtB_closure+1;
         const $krep31_raAu1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.284182608 UTC

[section ""data" . $krep33_raAu3_closure" {
     $krep33_raAu3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_raAtC_closure+1;
         const $krep32_raAu2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.285807347 UTC

[section ""data" . $krep34_raAu4_closure" {
     $krep34_raAu4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep29_raAtZ_closure+1;
         const $krep33_raAu3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.287939595 UTC

[section ""data" . $krep35_raAu5_closure" {
     $krep35_raAu5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_raAtX_closure+1;
         const $krep34_raAu4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.289575476 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager1_closure" {
     GHC.Event.Manager.$tc'EventManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_raAtE_closure+1;
         const $krep35_raAu5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.291235929 UTC

[section ""cstring" . GHC.Event.Manager.$tc'EventManager3_bytes" {
     GHC.Event.Manager.$tc'EventManager3_bytes:
         I8[] [39,69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.292900262 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager2_closure" {
     GHC.Event.Manager.$tc'EventManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'EventManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.294552239 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager_closure" {
     GHC.Event.Manager.$tc'EventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'EventManager2_closure+1;
         const GHC.Event.Manager.$tc'EventManager1_closure+4;
         const 13274036699047731538;
         const 394780277405469411;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.296877145 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshow_closure" {
     GHC.Event.Manager.$fShowState_$cshow_closure:
         const GHC.Event.Manager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(caDJ3,
                       label: GHC.Event.Manager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDJ3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDJ4; else goto caDJ5;
       caDJ4: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDJ5: // global
           I64[Sp - 8] = block_caDIT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDJo; else goto caDIU;
       uaDJo: // global
           call _caDIT(R1) args: 0, res: 0, upd: 0;
       caDIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDIT() //  [R1]
         { info_tbl: [(caDIT,
                       label: block_caDIT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDIT: // global
           _caDJ2::P64 = R1 & 7;
           if (_caDJ2::P64 < 4) goto uaDJl; else goto uaDJn;
       uaDJl: // global
           if (_caDJ2::P64 < 3) goto uaDJm; else goto caDIZ;
       uaDJm: // global
           if (_caDJ2::P64 < 2) goto caDIX; else goto caDIY;
       caDIX: // global
           R1 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caDIY: // global
           R1 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caDIZ: // global
           R1 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uaDJn: // global
           if (_caDJ2::P64 < 5) goto caDJ0; else goto caDJ1;
       caDJ0: // global
           R1 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caDJ1: // global
           R1 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.303499266 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowList_closure" {
     GHC.Event.Manager.$fShowState_$cshowList_closure:
         const GHC.Event.Manager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caDJI,
                       label: GHC.Event.Manager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDJI: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.306796519 UTC

[section ""data" . GHC.Event.Manager.$fShowState_closure" {
     GHC.Event.Manager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowState_$cshow_closure+1;
         const GHC.Event.Manager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.308957003 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c==_closure" {
     GHC.Event.Manager.$fEqFdKey_$c==_closure:
         const GHC.Event.Manager.$fEqFdKey_$c==_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c==_entry() //  [R2, R3]
         { info_tbl: [(caDJX,
                       label: GHC.Event.Manager.$fEqFdKey_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDJX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDK1; else goto caDK2;
       caDK1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDK2: // global
           I64[Sp - 16] = block_caDJU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDKi; else goto caDJV;
       uaDKi: // global
           call _caDJU(R1) args: 0, res: 0, upd: 0;
       caDJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDJU() //  [R1]
         { info_tbl: [(caDJU,
                       label: block_caDJU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDJU: // global
           I64[Sp - 8] = block_caDK0_info;
           _saAxU::I64 = I64[R1 + 7];
           _saAxV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAxV::I64;
           I64[Sp + 8] = _saAxU::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDKh; else goto caDK4;
       uaDKh: // global
           call _caDK0(R1) args: 0, res: 0, upd: 0;
       caDK4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDK0() //  [R1]
         { info_tbl: [(caDK0,
                       label: block_caDK0_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDK0: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto caDKd; else goto caDKc;
       caDKd: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDKc: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.317028947 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c/=_closure" {
     GHC.Event.Manager.$fEqFdKey_$c/=_closure:
         const GHC.Event.Manager.$fEqFdKey_$c/=_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caDKJ,
                       label: GHC.Event.Manager.$fEqFdKey_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDKJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDKN; else goto caDKO;
       caDKN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDKO: // global
           I64[Sp - 16] = block_caDKG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDL8; else goto caDKH;
       uaDL8: // global
           call _caDKG(R1) args: 0, res: 0, upd: 0;
       caDKH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDKG() //  [R1]
         { info_tbl: [(caDKG,
                       label: block_caDKG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDKG: // global
           I64[Sp - 8] = block_caDKM_info;
           _saAy4::I64 = I64[R1 + 7];
           _saAy5::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAy5::I64;
           I64[Sp + 8] = _saAy4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDL7; else goto caDKQ;
       uaDL7: // global
           call _caDKM(R1) args: 0, res: 0, upd: 0;
       caDKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDKM() //  [R1]
         { info_tbl: [(caDKM,
                       label: block_caDKM_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDKM: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto caDL4; else goto caDL6;
       caDL6: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto caDL4; else goto caDL5;
       caDL4: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDL5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.324958095 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_closure" {
     GHC.Event.Manager.$fEqFdKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqFdKey_$c==_closure+2;
         const GHC.Event.Manager.$fEqFdKey_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.327565334 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c/=_closure" {
     GHC.Event.Manager.$fEqState_$c/=_closure:
         const GHC.Event.Manager.$fEqState_$c/=_info;
 },
 GHC.Event.Manager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caDLF,
                       label: GHC.Event.Manager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDLF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDLG; else goto caDLH;
       caDLG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDLH: // global
           I64[Sp - 16] = block_caDLv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDNi; else goto caDLw;
       uaDNi: // global
           call _caDLv(R1) args: 0, res: 0, upd: 0;
       caDLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDLv() //  [R1]
         { info_tbl: [(caDLv,
                       label: block_caDLv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDLv: // global
           _saAyc::P64 = P64[Sp + 8];
           _caDLE::P64 = R1 & 7;
           if (_caDLE::P64 < 4) goto uaDN0; else goto uaDN2;
       uaDN0: // global
           if (_caDLE::P64 < 3) goto uaDN1; else goto caDLB;
       uaDN1: // global
           if (_caDLE::P64 < 2) goto caDLz; else goto caDLA;
       caDLz: // global
           I64[Sp + 8] = block_caDLK_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDNd; else goto caDLM;
       uaDNd: // global
           call _caDLK(R1) args: 0, res: 0, upd: 0;
       caDLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDLA: // global
           I64[Sp + 8] = block_caDLZ_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDNe; else goto caDM1;
       uaDNe: // global
           call _caDLZ(R1) args: 0, res: 0, upd: 0;
       caDM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDLB: // global
           I64[Sp + 8] = block_caDMe_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDNf; else goto caDMg;
       uaDNf: // global
           call _caDMe(R1) args: 0, res: 0, upd: 0;
       caDMg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaDN2: // global
           if (_caDLE::P64 < 5) goto caDLC; else goto caDLD;
       caDLC: // global
           I64[Sp + 8] = block_caDMt_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDNg; else goto caDMv;
       uaDNg: // global
           call _caDMt(R1) args: 0, res: 0, upd: 0;
       caDMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caDLD: // global
           I64[Sp + 8] = block_caDMI_info;
           R1 = _saAyc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDNh; else goto caDMK;
       uaDNh: // global
           call _caDMI(R1) args: 0, res: 0, upd: 0;
       caDMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDLK() //  [R1]
         { info_tbl: [(caDLK,
                       label: block_caDLK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDLK: // global
           if (R1 & 7 == 1) goto uaDN3; else goto uaDN4;
       uaDN3: // global
           Sp = Sp + 8;
           call _caDMU() args: 0, res: 0, upd: 0;
       uaDN4: // global
           Sp = Sp + 8;
           call _caDMQ() args: 0, res: 0, upd: 0;
     }
 },
 _caDLZ() //  [R1]
         { info_tbl: [(caDLZ,
                       label: block_caDLZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDLZ: // global
           if (R1 & 7 == 2) goto uaDN5; else goto uaDN6;
       uaDN5: // global
           Sp = Sp + 8;
           call _caDMU() args: 0, res: 0, upd: 0;
       uaDN6: // global
           Sp = Sp + 8;
           call _caDMQ() args: 0, res: 0, upd: 0;
     }
 },
 _caDMe() //  [R1]
         { info_tbl: [(caDMe,
                       label: block_caDMe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDMe: // global
           if (R1 & 7 == 3) goto uaDN7; else goto uaDN8;
       uaDN7: // global
           Sp = Sp + 8;
           call _caDMU() args: 0, res: 0, upd: 0;
       uaDN8: // global
           Sp = Sp + 8;
           call _caDMQ() args: 0, res: 0, upd: 0;
     }
 },
 _caDMt() //  [R1]
         { info_tbl: [(caDMt,
                       label: block_caDMt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDMt: // global
           if (R1 & 7 == 4) goto uaDN9; else goto uaDNa;
       uaDN9: // global
           Sp = Sp + 8;
           call _caDMU() args: 0, res: 0, upd: 0;
       uaDNa: // global
           Sp = Sp + 8;
           call _caDMQ() args: 0, res: 0, upd: 0;
     }
 },
 _caDMI() //  [R1]
         { info_tbl: [(caDMI,
                       label: block_caDMI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDMI: // global
           if (R1 & 7 == 5) goto uaDNb; else goto uaDNc;
       uaDNb: // global
           Sp = Sp + 8;
           call _caDMU() args: 0, res: 0, upd: 0;
       uaDNc: // global
           Sp = Sp + 8;
           call _caDMQ() args: 0, res: 0, upd: 0;
     }
 },
 _caDMU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDMU: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDMQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDMQ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.343379808 UTC

[section ""data" . GHC.Event.Manager.$fEqState_closure" {
     GHC.Event.Manager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqState_$c==_closure+2;
         const GHC.Event.Manager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.345091551 UTC

[section ""cstring" . lvl1_raAu6_bytes" {
     lvl1_raAu6_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.347079263 UTC

[section ""data" . lvl2_raAu7_closure" {
     lvl2_raAu7_closure:
         const lvl2_raAu7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_raAu7_entry() //  [R1]
         { info_tbl: [(caDOl,
                       label: lvl2_raAu7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDOm; else goto caDOn;
       caDOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDOn: // global
           (_caDOi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDOi::I64 == 0) goto caDOk; else goto caDOj;
       caDOk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDOj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDOi::I64;
           R2 = lvl1_raAu6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.351391895 UTC

[section ""data" . lvl3_raAu8_closure" {
     lvl3_raAu8_closure:
         const lvl3_raAu8_info;
         const 0;
 },
 lvl3_raAu8_entry() //  [R2, R3, R4]
         { info_tbl: [(caDOA,
                       label: lvl3_raAu8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDOA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDOE; else goto caDOD;
       caDOE: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl3_raAu8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caDOD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl2_raAu7_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.356408469 UTC

[section ""data" . GHC.Event.Manager.callbackTableVar_closure" {
     GHC.Event.Manager.callbackTableVar_closure:
         const GHC.Event.Manager.callbackTableVar_info;
         const 0;
 },
 GHC.Event.Manager.callbackTableVar_entry() //  [R2, R3]
         { info_tbl: [(caDOQ,
                       label: GHC.Event.Manager.callbackTableVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDOQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caDP4; else goto caDP5;
       caDP4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.callbackTableVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDP5: // global
           I64[Sp - 16] = block_caDON_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDPx; else goto caDOO;
       uaDPx: // global
           call _caDON(R1) args: 0, res: 0, upd: 0;
       caDOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDON() //  [R1]
         { info_tbl: [(caDON,
                       label: block_caDON_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDON: // global
           I64[Sp - 16] = block_caDOT_info;
           _saAys::P64 = P64[R1 + 23];
           _saAyu::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saAyu::P64;
           P64[Sp] = _saAys::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDPw; else goto caDOU;
       uaDPw: // global
           call _caDOT(R1) args: 0, res: 0, upd: 0;
       caDOU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDOT() //  [R1]
         { info_tbl: [(caDOT,
                       label: block_caDOT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDOT: // global
           I64[Sp - 8] = block_caDOY_info;
           _saAyD::P64 = R1;
           _saAyE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saAyE::I64;
           P64[Sp + 16] = _saAyD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDPy; else goto caDOZ;
       uaDPy: // global
           call _caDOY(R1) args: 0, res: 0, upd: 0;
       caDOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDOY() //  [R1]
         { info_tbl: [(caDOY,
                       label: block_caDOY_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDOY: // global
           I64[Sp - 8] = block_caDP3_info;
           _saAyF::P64 = R1;
           _saAyG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saAyG::I64;
           P64[Sp + 32] = _saAyF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDPz; else goto caDP9;
       uaDPz: // global
           call _caDP3(R1) args: 0, res: 0, upd: 0;
       caDP9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDP3() //  [R1]
         { info_tbl: [(caDP3,
                       label: block_caDP3_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDP3: // global
           _saAyD::P64 = P64[Sp + 32];
           _saAyE::I64 = I64[Sp + 16];
           _saAyF::P64 = P64[Sp + 40];
           _saAyJ::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saAyE::I64,
                            _saAyJ::I64)) goto caDPq; else goto caDPs;
       caDPs: // global
           if (%MO_S_Gt_W64(_saAyJ::I64,
                            I64[Sp + 8])) goto caDPq; else goto caDPr;
       caDPq: // global
           R4 = _saAyJ::I64;
           R3 = _saAyD::P64;
           R2 = _saAyF::P64;
           Sp = Sp + 48;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caDPr: // global
           R1 = P64[P64[Sp + 24] + ((_saAyJ::I64 - _saAyE::I64 << 3) + 24)] & (-8);
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.367992152 UTC

[section ""data" . GHC.Event.Manager.wakeManager1_closure" {
     GHC.Event.Manager.wakeManager1_closure:
         const GHC.Event.Manager.wakeManager1_info;
 },
 GHC.Event.Manager.wakeManager1_entry() //  []
         { info_tbl: [(caDQ5,
                       label: GHC.Event.Manager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQ5: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.371352545 UTC

[section ""data" . GHC.Event.Manager.wakeManager_closure" {
     GHC.Event.Manager.wakeManager_closure:
         const GHC.Event.Manager.wakeManager_info;
 },
 GHC.Event.Manager.wakeManager_entry() //  [R2]
         { info_tbl: [(caDQh,
                       label: GHC.Event.Manager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQh: // global
           R2 = R2;
           call GHC.Event.Manager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.375556272 UTC

[section ""data" . GHC.Event.Manager.cleanup1_closure" {
     GHC.Event.Manager.cleanup1_closure:
         const GHC.Event.Manager.cleanup1_info;
 },
 GHC.Event.Manager.cleanup1_entry() //  [R2]
         { info_tbl: [(caDQv,
                       label: GHC.Event.Manager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQv: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caDQz; else goto caDQA;
       caDQz: // global
           R2 = R2;
           R1 = GHC.Event.Manager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDQA: // global
           I64[Sp - 8] = block_caDQs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDRt; else goto caDQt;
       uaDRt: // global
           call _caDQs(R1) args: 0, res: 0, upd: 0;
       caDQt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDQs() //  [R1]
         { info_tbl: [(caDQs,
                       label: block_caDQs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQs: // global
           I64[Sp - 56] = block_caDQy_info;
           _saAz1::P64 = P64[R1 + 39];
           _saAz6::P64 = P64[R1 + 55];
           _saAz7::P64 = P64[R1 + 63];
           _saAz8::P64 = P64[R1 + 71];
           _saAz3::I64 = I64[R1 + 87];
           _saAz4::I64 = I64[R1 + 95];
           _saAz5::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           I64[Sp - 48] = _saAz3::I64;
           I64[Sp - 40] = _saAz4::I64;
           I64[Sp - 32] = _saAz5::I64;
           P64[Sp - 24] = _saAz6::P64;
           P64[Sp - 16] = _saAz7::P64;
           P64[Sp - 8] = _saAz8::P64;
           P64[Sp] = _saAz1::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaDRs; else goto caDQC;
       uaDRs: // global
           call _caDQy(R1) args: 0, res: 0, upd: 0;
       caDQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDQy() //  [R1]
         { info_tbl: [(caDQy,
                       label: block_caDQy_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQy: // global
           _saAz1::P64 = P64[Sp + 56];
           _saAz8::P64 = P64[Sp + 48];
           _saAza::P64 = P64[R1 + 7];
           _saAze::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saAz1::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saAz1::P64);
           I64[Sp] = block_caDQJ_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saAz8::P64;
           P64[Sp + 48] = _saAze::P64;
           P64[Sp + 56] = _saAza::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDQJ() //  []
         { info_tbl: [(caDQJ,
                       label: block_caDQJ_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQJ: // global
           I64[Sp] = block_caDQL_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDQL() //  []
         { info_tbl: [(caDQL,
                       label: block_caDQL_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQL: // global
           I64[Sp] = block_caDQN_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDQN() //  []
         { info_tbl: [(caDQN,
                       label: block_caDQN_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDQN: // global
           _saAz4::I64 = I64[Sp + 16];
           _saAz6::P64 = P64[Sp + 32];
           (_saAzt::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saAzy::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz4::I64)));
           I64[Sp + 16] = block_caDR3_info;
           R1 = _saAz6::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaDRu; else goto caDR4;
       uaDRu: // global
           call _caDR3(R1) args: 0, res: 0, upd: 0;
       caDR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDR3() //  [R1]
         { info_tbl: [(caDR3,
                       label: block_caDR3_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDR3: // global
           _saAz5::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caDRa; else goto caDRe;
       caDRa: // global
           (_saAzE::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz5::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDRe: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saAzM::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saAz5::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.391701796 UTC

[section ""data" . GHC.Event.Manager.cleanup_closure" {
     GHC.Event.Manager.cleanup_closure:
         const GHC.Event.Manager.cleanup_info;
 },
 GHC.Event.Manager.cleanup_entry() //  [R2]
         { info_tbl: [(caDS5,
                       label: GHC.Event.Manager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDS5: // global
           R2 = R2;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.395545815 UTC

[section ""data" . GHC.Event.Manager.finished1_closure" {
     GHC.Event.Manager.finished1_closure:
         const GHC.Event.Manager.finished1_info;
 },
 sat_saAA7_entry() //  [R1]
         { info_tbl: [(caDSw,
                       label: sat_saAA7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDSw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDSx; else goto caDSy;
       caDSx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caDSp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaDSF; else goto caDSq;
       uaDSF: // global
           call _caDSp(R1) args: 0, res: 0, upd: 0;
       caDSq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caDSp() //  [R1]
         { info_tbl: [(caDSp,
                       label: block_caDSp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDSp: // global
           if (R1 & 7 == 5) goto caDSu; else goto caDSt;
       caDSu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caDSt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.finished1_entry() //  [R2]
         { info_tbl: [(caDSG,
                       label: GHC.Event.Manager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDSG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caDSH; else goto caDSI;
       caDSH: // global
           R2 = R2;
           R1 = GHC.Event.Manager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDSI: // global
           I64[Sp - 8] = block_caDSg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDSM; else goto caDSh;
       uaDSM: // global
           call _caDSg(R1) args: 0, res: 0, upd: 0;
       caDSh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDSg() //  [R1]
         { info_tbl: [(caDSg,
                       label: block_caDSg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDSg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDSL; else goto caDSK;
       caDSL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDSK: // global
           _saAA5::P64 = P64[P64[R1 + 39] + 8];
           I64[Hp - 16] = sat_saAA7_info;
           P64[Hp] = _saAA5::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.404948472 UTC

[section ""data" . GHC.Event.Manager.finished_closure" {
     GHC.Event.Manager.finished_closure:
         const GHC.Event.Manager.finished_info;
 },
 GHC.Event.Manager.finished_entry() //  [R2]
         { info_tbl: [(caDTe,
                       label: GHC.Event.Manager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDTe: // global
           R2 = R2;
           call GHC.Event.Manager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.408305776 UTC

[section ""data" . GHC.Event.Manager.release2_closure" {
     GHC.Event.Manager.release2_closure:
         const GHC.Event.Manager.release2_info;
 },
 GHC.Event.Manager.release2_entry() //  [R2]
         { info_tbl: [(caDTq,
                       label: GHC.Event.Manager.release2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDTq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDTu; else goto caDTt;
       caDTu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.release2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDTt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Releasing_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.412337129 UTC

[section ""data" . GHC.Event.Manager.release1_closure" {
     GHC.Event.Manager.release1_closure:
         const GHC.Event.Manager.release1_info;
         const 0;
 },
 GHC.Event.Manager.release1_entry() //  [R2]
         { info_tbl: [(caDTH,
                       label: GHC.Event.Manager.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDTH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDTI; else goto caDTJ;
       caDTI: // global
           R2 = R2;
           R1 = GHC.Event.Manager.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDTJ: // global
           I64[Sp - 8] = block_caDTE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDU3; else goto caDTF;
       uaDU3: // global
           call _caDTE(R1) args: 0, res: 0, upd: 0;
       caDTF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDTE() //  [R1]
         { info_tbl: [(caDTE,
                       label: block_caDTE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDTE: // global
           I64[Sp - 16] = block_caDTM_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saAAn::P64 = P64[R1 + 63];
           _saAAl::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saAAn::P64;
           I64[Sp] = _saAAl::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDTM() //  [R1]
         { info_tbl: [(caDTM,
                       label: block_caDTM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDTM: // global
           I64[Sp] = block_caDTO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDU4; else goto caDTR;
       uaDU4: // global
           call _caDTO(R1) args: 0, res: 0, upd: 0;
       caDTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDTO() //  [R1]
         { info_tbl: [(caDTO,
                       label: block_caDTO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDTO: // global
           if (R1 & 7 == 2) goto caDU1; else goto caDTX;
       caDU1: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       caDTX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.421526545 UTC

[section ""data" . GHC.Event.Manager.release_closure" {
     GHC.Event.Manager.release_closure:
         const GHC.Event.Manager.release_info;
         const 0;
 },
 GHC.Event.Manager.release_entry() //  [R2]
         { info_tbl: [(caDUs,
                       label: GHC.Event.Manager.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDUs: // global
           R2 = R2;
           call GHC.Event.Manager.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.42492163 UTC

[section ""data" . GHC.Event.Manager.shutdown2_closure" {
     GHC.Event.Manager.shutdown2_closure:
         const GHC.Event.Manager.shutdown2_info;
 },
 GHC.Event.Manager.shutdown2_entry() //  [R2]
         { info_tbl: [(caDUE,
                       label: GHC.Event.Manager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDUE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDUI; else goto caDUH;
       caDUI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDUH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.429854603 UTC

[section ""data" . GHC.Event.Manager.shutdown1_closure" {
     GHC.Event.Manager.shutdown1_closure:
         const GHC.Event.Manager.shutdown1_info;
         const 0;
 },
 GHC.Event.Manager.shutdown1_entry() //  [R2]
         { info_tbl: [(caDUV,
                       label: GHC.Event.Manager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDUV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDUW; else goto caDUX;
       caDUW: // global
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDUX: // global
           I64[Sp - 8] = block_caDUS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaDVh; else goto caDUT;
       uaDVh: // global
           call _caDUS(R1) args: 0, res: 0, upd: 0;
       caDUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDUS() //  [R1]
         { info_tbl: [(caDUS,
                       label: block_caDUS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDUS: // global
           I64[Sp - 16] = block_caDV0_info;
           R2 = GHC.Event.Manager.shutdown2_closure+1;
           _saAAI::P64 = P64[R1 + 63];
           _saAAF::I64 = I64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saAAI::P64;
           I64[Sp] = _saAAF::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDV0() //  [R1]
         { info_tbl: [(caDV0,
                       label: block_caDV0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDV0: // global
           I64[Sp] = block_caDV2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDVi; else goto caDV5;
       uaDVi: // global
           call _caDV2(R1) args: 0, res: 0, upd: 0;
       caDV5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDV2() //  [R1]
         { info_tbl: [(caDV2,
                       label: block_caDV2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDV2: // global
           if (R1 & 7 == 2) goto caDVf; else goto caDVb;
       caDVf: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       caDVb: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.438686901 UTC

[section ""data" . GHC.Event.Manager.shutdown_closure" {
     GHC.Event.Manager.shutdown_closure:
         const GHC.Event.Manager.shutdown_info;
         const 0;
 },
 GHC.Event.Manager.shutdown_entry() //  [R2]
         { info_tbl: [(caDVG,
                       label: GHC.Event.Manager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDVG: // global
           R2 = R2;
           call GHC.Event.Manager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.441931936 UTC

[section ""cstring" . lvl4_raAu9_bytes" {
     lvl4_raAu9_bytes:
         I8[] [70,97,105,108,101,100,32,119,104,105,108,101,32,97,116,116,101,109,112,116,105,110,103,32,116,111,32,109,111,100,105,102,121,32,114,101,103,105,115,116,114,97,116,105,111,110,32,111,102,32,102,105,108,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.443517458 UTC

[section ""cstring" . lvl5_raAua_bytes" {
     lvl5_raAua_bytes:
         I8[] [32,97,116,32,108,111,99,97,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.446163661 UTC

[section ""data" . $wlvl_raAub_closure" {
     $wlvl_raAub_closure:
         const $wlvl_raAub_info;
         const 0;
 },
 sat_saAAU_entry() //  [R1]
         { info_tbl: [(caDW3,
                       label: sat_saAAU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDW3: // global
           R3 = P64[R1 + 16];
           R2 = lvl5_raAua_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAAV_entry() //  [R1]
         { info_tbl: [(caDW7,
                       label: sat_saAAV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDW7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caDW8; else goto caDW9;
       caDW8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDW9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caDVX_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caDVX() //  [R1, R2]
         { info_tbl: [(caDVX,
                       label: block_caDVX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDVX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caDWc; else goto caDWb;
       caDWc: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caDWb: // global
           I64[Hp - 40] = sat_saAAU_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_raAub_entry() //  [R2, R3]
         { info_tbl: [(caDWf,
                       label: $wlvl_raAub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDWf: // global
           _saAAP::I64 = R3;
           _saAAO::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caDWg; else goto caDWh;
       caDWh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caDWj; else goto caDWi;
       caDWj: // global
           HpAlloc = 32;
           goto caDWg;
       caDWg: // global
           R3 = _saAAP::I64;
           R2 = _saAAO::P64;
           R1 = $wlvl_raAub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDWi: // global
           I64[Hp - 24] = sat_saAAV_info;
           P64[Hp - 8] = _saAAO::P64;
           I64[Hp] = _saAAP::I64;
           I64[Sp - 8] = block_caDWd_info;
           R3 = Hp - 24;
           R2 = lvl4_raAu9_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDWd() //  [R1]
         { info_tbl: [(caDWd,
                       label: block_caDWd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDWd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.456780538 UTC

[section ""cstring" . lvl6_raAuc_bytes" {
     lvl6_raAuc_bytes:
         I8[] [114,101,103,105,115,116,101,114,67,111,110,116,114,111,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.459594949 UTC

[section ""data" . lvl7_raAud_closure" {
     lvl7_raAud_closure:
         const lvl7_raAud_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_raAud_entry() //  [R1]
         { info_tbl: [(caDWO,
                       label: lvl7_raAud_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDWO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDWP; else goto caDWQ;
       caDWP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caDWQ: // global
           (_caDWL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caDWL::I64 == 0) goto caDWN; else goto caDWM;
       caDWN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caDWM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caDWL::I64;
           R2 = lvl6_raAuc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.463622706 UTC

[section ""data" . GHC.Event.Manager.new5_closure" {
     GHC.Event.Manager.new5_closure:
         const GHC.Event.Manager.new5_info;
 },
 GHC.Event.Manager.new5_entry() //  [R2]
         { info_tbl: [(caDX3,
                       label: GHC.Event.Manager.new5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDX3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDX7; else goto caDX6;
       caDX7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.new5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDX6: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Finished_closure+5;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.467295677 UTC

[section ""data" . GHC.Event.Manager.new4_closure" {
     GHC.Event.Manager.new4_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.46970887 UTC

[section ""data" . x_raAue_closure" {
     x_raAue_closure:
         const x_raAue_info;
 },
 x_raAue_entry() //  []
         { info_tbl: [(caDXt,
                       label: x_raAue_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDXt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDXG; else goto caDXH;
       caDXH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caDXJ; else goto caDXI;
       caDXJ: // global
           HpAlloc = 96;
           goto caDXG;
       caDXG: // global
           R1 = x_raAue_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caDXI: // global
           I64[Hp - 88] = stg_MUT_ARR_PTRS_DIRTY_info;
           I64[Hp - 80] = 8;
           I64[Hp - 72] = 9;
           _caDXi::I64 = Hp - 88;
           _caDXj::I64 = _caDXi::I64 + 24;
           goto caDXk;
       caDXk: // global
           if (_caDXj::I64 < (_caDXi::I64 + 88)) goto caDXm; else goto caDXl;
       caDXm: // global
           P64[_caDXj::I64] = GHC.Event.IntTable.Empty_closure+1;
           _caDXj::I64 = _caDXj::I64 + 8;
           goto caDXk;
       caDXl: // global
           I64[Sp - 16] = block_caDXn_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _caDXi::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDXn() //  [R1]
         { info_tbl: [(caDXn,
                       label: block_caDXn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDXn: // global
           I64[Sp - 8] = block_caDXp_info;
           R2 = 8;
           _saAB4::P64 = R1;
           R1 = 8;
           P64[Sp] = _saAB4::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDXp() //  [R1]
         { info_tbl: [(caDXp,
                       label: block_caDXp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDXp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caDXN; else goto caDXM;
       caDXN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDXM: // global
           _saAB1::P64 = P64[Sp + 16];
           _saAB4::P64 = P64[Sp + 8];
           _saAB8::I64 = R1 + 16;
           I64[_saAB8::I64] = 0;
           I64[Hp - 48] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 40] = R1;
           P64[Hp - 32] = _saAB4::P64;
           _caDXv::P64 = Hp - 46;
           call MO_Touch(_caDXv::P64);
           I64[Hp - 24] = GHC.Event.IntTable.IT_con_info;
           P64[Hp - 16] = _saAB1::P64;
           P64[Hp - 8] = _caDXv::P64;
           I64[Hp] = _saAB8::I64;
           I64[Sp + 16] = block_caDXy_info;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDXy() //  [R1]
         { info_tbl: [(caDXy,
                       label: block_caDXy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDXy: // global
           I64[Sp - 8] = block_caDXA_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caDXA() //  [R1]
         { info_tbl: [(caDXA,
                       label: block_caDXA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDXA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDXR; else goto caDXQ;
       caDXR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDXQ: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_caDXD_info;
           R2 = Hp - 7;
           _saABi::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _saABi::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDXD() //  []
         { info_tbl: [(caDXD,
                       label: block_caDXD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDXD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caDXU; else goto caDXT;
       caDXU: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caDXT: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.483303652 UTC

[section ""data" . GHC.Event.Manager.$wxs_closure" {
     GHC.Event.Manager.$wxs_closure:
         const GHC.Event.Manager.$wxs_info;
 },
 GHC.Event.Manager.$wxs_entry() //  [R2]
         { info_tbl: [(caDYr,
                       label: GHC.Event.Manager.$wxs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDYr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDYs; else goto caDYt;
       caDYs: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$wxs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caDYt: // global
           if (R2 == 1) goto caDYq; else goto caDYp;
       caDYq: // global
           I64[Sp - 8] = block_caDYI_info;
           Sp = Sp - 8;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
       caDYp: // global
           I64[Sp - 16] = block_caDYv_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caDYI() //  [R1]
         { info_tbl: [(caDYI,
                       label: block_caDYI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDYI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDYN; else goto caDYM;
       caDYN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDYM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDYv() //  [R1]
         { info_tbl: [(caDYv,
                       label: block_caDYv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDYv: // global
           I64[Sp] = block_caDYA_info;
           R2 = I64[Sp + 8] - 1;
           P64[Sp + 8] = R1;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDYA() //  [R1]
         { info_tbl: [(caDYA,
                       label: block_caDYA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDYA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caDYG; else goto caDYF;
       caDYG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caDYF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.492438713 UTC

[section ""data" . GHC.Event.Manager.new3_closure" {
     GHC.Event.Manager.new3_closure:
         const GHC.Event.Manager.new3_info;
         const 0;
 },
 GHC.Event.Manager.new3_entry() //  [R2]
         { info_tbl: [(caDZa,
                       label: GHC.Event.Manager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZa: // global
           R3 = R2;
           R2 = lvl7_raAud_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.498840569 UTC

[section ""data" . GHC.Event.Manager.new2_closure" {
     GHC.Event.Manager.new2_closure:
         const GHC.Event.Manager.new2_info;
         const 0;
 },
 sat_saAC5_entry() //  [R1]
         { info_tbl: [(caDZF,
                       label: sat_saAC5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caDZG; else goto caDZH;
       caDZG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caDZH: // global
           I64[Sp - 24] = block_caDZw_info;
           R2 = GHC.Event.Manager.new5_closure+1;
           _saABC::P64 = P64[R1 + 7];
           _saABJ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _saABC::P64;
           P64[Sp - 8] = _saABJ::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDZw() //  [R1]
         { info_tbl: [(caDZw,
                       label: block_caDZw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZw: // global
           I64[Sp] = block_caDZy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaDZY; else goto caDZz;
       uaDZY: // global
           call _caDZy(R1) args: 0, res: 0, upd: 0;
       caDZz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDZy() //  [R1]
         { info_tbl: [(caDZy,
                       label: block_caDZy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZy: // global
           if (R1 & 7 == 5) goto caDZD; else goto caDZC;
       caDZD: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caDZC: // global
           _saABC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caDZL_info;
           R1 = _saABC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaDZZ; else goto caDZM;
       uaDZZ: // global
           call _caDZL(R1) args: 0, res: 0, upd: 0;
       caDZM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDZL() //  [R1]
         { info_tbl: [(caDZL,
                       label: block_caDZL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZL: // global
           I64[Sp] = block_caDZQ_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDZQ() //  []
         { info_tbl: [(caDZQ,
                       label: block_caDZQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZQ: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.new2_entry() //  [R2]
         { info_tbl: [(caE0a,
                       label: GHC.Event.Manager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0a: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caE0s; else goto caE0t;
       caE0s: // global
           R2 = R2;
           R1 = GHC.Event.Manager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caE0t: // global
           I64[Sp - 16] = block_caDZl_info;
           _saABC::P64 = R2;
           R2 = 32;
           P64[Sp - 8] = _saABC::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDZl() //  [R1]
         { info_tbl: [(caDZl,
                       label: block_caDZl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZl: // global
           I64[Sp - 8] = block_caDZn_info;
           R2 = GHC.Types.False_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caDZn() //  [R1]
         { info_tbl: [(caDZn,
                       label: block_caDZn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZn: // global
           I64[Sp - 8] = block_caDZp_info;
           _saABJ::P64 = R1;
           R1 = GHC.Event.Manager.Created_closure+1;
           P64[Sp] = _saABJ::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDZp() //  [R1]
         { info_tbl: [(caDZp,
                       label: block_caDZp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDZp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caE0y; else goto caE0x;
       caE0y: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE0x: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_saAC5_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_caE01_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _saABM::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _saABM::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE01() //  []
         { info_tbl: [(caE01,
                       label: block_caE01_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE01: // global
           I64[Sp] = block_caE03_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caE03() //  [R1]
         { info_tbl: [(caE03,
                       label: block_caE03_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE03: // global
           I64[Sp - 8] = block_caE05_info;
           R2 = GHC.Tuple.()_closure+1;
           _saACb::P64 = R1;
           R1 = R1;
           P64[Sp] = _saACb::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE05() //  []
         { info_tbl: [(caE05,
                       label: block_caE05_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE05: // global
           I64[Sp] = block_caE07_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uaE1Y; else goto caE08;
       uaE1Y: // global
           call _caE07(R1) args: 0, res: 0, upd: 0;
       caE08: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE07() //  [R1]
         { info_tbl: [(caE07,
                       label: block_caE07_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE07: // global
           I64[Sp - 16] = block_caE0d_info;
           R2 = GHC.Arr.arrEleBottom_closure;
           _saACd::P64 = R1;
           _saACe::P64 = P64[R1 + 7];
           _saACg::P64 = P64[R1 + 23];
           R1 = 32;
           P64[Sp - 8] = _saACg::P64;
           P64[Sp] = _saACe::P64;
           P64[Sp + 48] = _saACd::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE0d() //  [R1]
         { info_tbl: [(caE0d,
                       label: block_caE0d_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0d: // global
           I64[Sp - 8] = 0;
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 56] = R1;
           Sp = Sp - 8;
           call _caE0K() args: 0, res: 0, upd: 0;
     }
 },
 _caE0K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0K: // global
           I64[Sp - 8] = block_caE0N_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaE22; else goto caE0P;
       uaE22: // global
           call _caE0N(R1) args: 0, res: 0, upd: 0;
       caE0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE0N() //  [R1]
         { info_tbl: [(caE0N,
                       label: block_caE0N_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0N: // global
           if (R1 & 7 == 1) goto uaE1V; else goto caE13;
       uaE1V: // global
           Sp = Sp + 16;
           goto uaE24;
       caE13: // global
           _saACl::P64 = P64[Sp + 72];
           _saACu::I64 = I64[Sp + 8];
           _saACx::P64 = P64[R1 + 6];
           _saACy::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[(_saACl::P64 + 24) + (_saACu::I64 << 3)] = _saACx::P64;
           I64[_saACl::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saACl::P64 + 24) + ((I64[_saACl::P64 + 8] << 3) + (_saACu::I64 >> 7))] = 1 :: W8;
           if (_saACu::I64 == 31) goto uaE1W; else goto caE11;
       uaE1W: // global
           Sp = Sp + 16;
           goto uaE24;
       uaE24: // global
           call _caE0F() args: 0, res: 0, upd: 0;
       caE11: // global
           P64[Sp + 16] = _saACy::P64;
           I64[Sp + 8] = _saACu::I64 + 1;
           Sp = Sp + 8;
           call _caE0K() args: 0, res: 0, upd: 0;
     }
 },
 _caE0F() //  []
         { info_tbl: [(caE0F,
                       label: block_caE0F_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0F: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caE0J; else goto caE0I;
       caE0J: // global
           HpAlloc = 40;
           I64[Sp] = block_caE0F_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caE0I: // global
           _saACl::P64 = P64[Sp + 56];
           I64[_saACl::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = GHC.Event.Manager.$fShowFdKey6_closure+1;
           P64[Hp - 16] = GHC.Event.Manager.new4_closure+1;
           P64[Hp - 8] = _saACl::P64;
           I64[Hp] = 32;
           I64[Sp] = block_caE0m_info;
           R1 = Hp - 31;
           if (R1 & 7 != 0) goto uaE21; else goto caE0n;
       uaE21: // global
           call _caE0m(R1) args: 0, res: 0, upd: 0;
       caE0n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE0m() //  [R1]
         { info_tbl: [(caE0m,
                       label: block_caE0m_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0m: // global
           I64[Sp - 16] = block_caE0r_info;
           _saACG::P64 = P64[R1 + 7];
           _saACH::P64 = P64[R1 + 15];
           _saACJ::P64 = P64[R1 + 23];
           _saACI::I64 = I64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saACJ::P64;
           I64[Sp] = _saACI::I64;
           P64[Sp + 48] = _saACH::P64;
           P64[Sp + 56] = _saACG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaE20; else goto caE16;
       uaE20: // global
           call _caE0r(R1) args: 0, res: 0, upd: 0;
       caE16: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE0r() //  [R1]
         { info_tbl: [(caE0r,
                       label: block_caE0r_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE0r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caE1g; else goto caE1f;
       caE1g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE1f: // global
           _saACO::P64 = P64[R1 + 7];
           _saACP::P64 = P64[R1 + 15];
           _saACL::I64 = I64[R1 + 23];
           _saACM::I64 = I64[R1 + 31];
           _saACN::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saACL::I64;
           I64[Sp - 40] = block_caE1b_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           I64[Sp - 48] = stg_ap_v_info;
           I64[Sp - 32] = _saACM::I64;
           I64[Sp - 24] = _saACN::I64;
           P64[Sp - 16] = _saACO::P64;
           P64[Sp - 8] = _saACP::P64;
           I64[Sp] = _saACL::I64;
           Sp = Sp - 48;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caE1b() //  [R1]
         { info_tbl: [(caE1b,
                       label: block_caE1b_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE1b: // global
           I64[Sp] = block_caE1d_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaE26; else goto caE1i;
       uaE26: // global
           call _caE1d(R1) args: 0, res: 0, upd: 0;
       caE1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE1d() //  [R1]
         { info_tbl: [(caE1d,
                       label: block_caE1d_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE1d: // global
           if (R1 & 7 == 1) goto caE1o; else goto caE1v;
       caE1o: // global
           R2 = I64[Sp + 40];
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caE1v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caE1y; else goto caE1x;
       caE1y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE1x: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caE1s_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 72];
           R1 = P64[Sp + 64];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caE1s() //  [R1]
         { info_tbl: [(caE1s,
                       label: block_caE1s_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE1s: // global
           I64[Sp] = block_caE1u_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaE27; else goto caE1A;
       uaE27: // global
           call _caE1u(R1) args: 0, res: 0, upd: 0;
       caE1A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE1u() //  [R1]
         { info_tbl: [(caE1u,
                       label: block_caE1u_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE1u: // global
           _saACN::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto caE1G; else goto caE1K;
       caE1G: // global
           R2 = _saACN::I64;
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caE1K: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caE1N; else goto caE1M;
       caE1N: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE1M: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 120];
           P64[Hp - 88] = P64[Sp + 112];
           P64[Hp - 80] = P64[Sp + 104];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 80];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saACN::I64;
           R1 = Hp - 103;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.543469081 UTC

[section ""data" . GHC.Event.Manager.newWith_closure" {
     GHC.Event.Manager.newWith_closure:
         const GHC.Event.Manager.newWith_info;
         const 0;
 },
 GHC.Event.Manager.newWith_entry() //  [R2]
         { info_tbl: [(caE3Z,
                       label: GHC.Event.Manager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE3Z: // global
           R2 = R2;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.547011593 UTC

[section ""data" . GHC.Event.Manager.new1_closure" {
     GHC.Event.Manager.new1_closure:
         const GHC.Event.Manager.new1_info;
         const 0;
 },
 GHC.Event.Manager.new1_entry() //  []
         { info_tbl: [(caE4c,
                       label: GHC.Event.Manager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE4c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caE4d; else goto caE4e;
       caE4d: // global
           R1 = GHC.Event.Manager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caE4e: // global
           I64[Sp - 8] = block_caE4a_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caE4a() //  [R1]
         { info_tbl: [(caE4a,
                       label: block_caE4a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE4a: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.552099042 UTC

[section ""data" . GHC.Event.Manager.new_closure" {
     GHC.Event.Manager.new_closure:
         const GHC.Event.Manager.new_info;
         const 0;
 },
 GHC.Event.Manager.new_entry() //  []
         { info_tbl: [(caE4s,
                       label: GHC.Event.Manager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE4s: // global
           call GHC.Event.Manager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.555727978 UTC

[section ""data" . GHC.Event.Manager.closeFd_3_closure" {
     GHC.Event.Manager.closeFd_3_closure:
         const GHC.Event.Manager.closeFd_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.closeFd_3_entry() //  [R1]
         { info_tbl: [(caE4H,
                       label: GHC.Event.Manager.closeFd_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE4H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caE4P; else goto caE4Q;
       caE4P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caE4Q: // global
           (_caE4C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caE4C::I64 == 0) goto caE4E; else goto caE4D;
       caE4E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caE4D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caE4C::I64;
           I64[Sp - 24] = block_caE4F_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp - 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _caE4F() //  [R1]
         { info_tbl: [(caE4F,
                       label: block_caE4F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE4F: // global
           I64[Sp] = block_caE4K_info;
           R2 = R1;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caE4K() //  [R1]
         { info_tbl: [(caE4K,
                       label: block_caE4K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caE4U; else goto caE4T;
       caE4U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caE4T: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.563846502 UTC

[section ""data" . GHC.Event.Manager.$weventsOf_closure" {
     GHC.Event.Manager.$weventsOf_closure:
         const GHC.Event.Manager.$weventsOf_info;
         const 0;
 },
 GHC.Event.Manager.$weventsOf_entry() //  [R2]
         { info_tbl: [(caE5k,
                       label: GHC.Event.Manager.$weventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE5k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caE5l; else goto caE5m;
       caE5l: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$weventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caE5m: // global
           I64[Sp - 8] = block_caE5d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaE5Z; else goto caE5e;
       uaE5Z: // global
           call _caE5d(R1) args: 0, res: 0, upd: 0;
       caE5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE5d() //  [R1]
         { info_tbl: [(caE5d,
                       label: block_caE5d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE5d: // global
           if (R1 & 7 == 1) goto caE5h; else goto caE5i;
       caE5h: // global
           I64[Sp] = block_caE5p_info;
           R1 = GHC.Event.Manager.closeFd_3_closure;
           if (R1 & 7 != 0) goto uaE5X; else goto caE5r;
       uaE5X: // global
           call _caE5p(R1) args: 0, res: 0, upd: 0;
       caE5r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caE5i: // global
           I64[Sp - 16] = block_caE5y_info;
           _saADa::P64 = R1;
           _saADd::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 8] = _saADd::P64;
           P64[Sp] = _saADa::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaE5Y; else goto caE5A;
       uaE5Y: // global
           call _caE5y(R1) args: 0, res: 0, upd: 0;
       caE5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE5p() //  [R1]
         { info_tbl: [(caE5p,
                       label: block_caE5p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE5p: // global
           R1 = I64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caE5y() //  [R1]
         { info_tbl: [(caE5y,
                       label: block_caE5y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE5y: // global
           if (R1 & 7 == 1) goto caE5H; else goto caE5R;
       caE5H: // global
           I64[Sp + 16] = block_caE5E_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaE60; else goto caE5I;
       uaE60: // global
           call _caE5E(R1) args: 0, res: 0, upd: 0;
       caE5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caE5R: // global
           _saADa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caE5P_info;
           R3 = _saADa::P64;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caE5E() //  [R1]
         { info_tbl: [(caE5E,
                       label: block_caE5E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE5E: // global
           R1 = I64[R1 + 31];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caE5P() //  [R1]
         { info_tbl: [(caE5P,
                       label: block_caE5P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE5P: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.577097072 UTC

[section ""data" . GHC.Event.Manager.eventsOf_closure" {
     GHC.Event.Manager.eventsOf_closure:
         const GHC.Event.Manager.eventsOf_info;
         const 0;
 },
 GHC.Event.Manager.eventsOf_entry() //  [R2]
         { info_tbl: [(caE6B,
                       label: GHC.Event.Manager.eventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE6B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caE6F; else goto caE6G;
       caE6F: // global
           R2 = R2;
           R1 = GHC.Event.Manager.eventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caE6G: // global
           I64[Sp - 8] = block_caE6z_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caE6z() //  [R1]
         { info_tbl: [(caE6z,
                       label: block_caE6z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE6z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caE6J; else goto caE6I;
       caE6J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caE6I: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.583108579 UTC

[section ""data" . GHC.Event.Manager.closeFd_2_closure" {
     GHC.Event.Manager.closeFd_2_closure:
         const GHC.Event.Manager.closeFd_2_info;
 },
 GHC.Event.Manager.closeFd_2_entry() //  [R2]
         { info_tbl: [(caE74,
                       label: GHC.Event.Manager.closeFd_2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE74: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caE75; else goto uaE7w;
       caE75: // global
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaE7w: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caE6U() args: 0, res: 0, upd: 0;
     }
 },
 _caE6U() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE6U: // global
           _saADq::P64 = P64[Sp];
           I64[Sp] = block_caE6X_info;
           R1 = _saADq::P64;
           if (R1 & 7 != 0) goto uaE7y; else goto caE6Y;
       uaE7y: // global
           call _caE6X(R1) args: 0, res: 0, upd: 0;
       caE6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE6X() //  [R1]
         { info_tbl: [(caE6X,
                       label: block_caE6X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE6X: // global
           if (R1 & 7 == 1) goto caE71; else goto caE72;
       caE71: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caE72: // global
           I64[Sp - 8] = block_caE7c_info;
           _saADu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saADu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaE7z; else goto caE7e;
       uaE7z: // global
           call _caE7c(R1) args: 0, res: 0, upd: 0;
       caE7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE7c() //  [R1]
         { info_tbl: [(caE7c,
                       label: block_caE7c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE7c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caE7k; else goto caE7j;
       caE7k: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE7j: // global
           _saADz::P64 = P64[R1 + 7];
           _saADw::I64 = I64[R1 + 15];
           _saADx::I64 = I64[R1 + 23];
           _saADC::I64 = I64[R1 + 31] & 7 | 4;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _saADC::I64;
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saADw::I64;
           I64[Hp] = _saADx::I64;
           I64[Sp] = block_caE7t_info;
           R3 = Hp - 31;
           R2 = Hp - 15;
           R1 = _saADz::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE7t() //  []
         { info_tbl: [(caE7t,
                       label: block_caE7t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE7t: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caE6U() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.599558981 UTC

[section ""data" . GHC.Event.Manager.closeFd1_closure" {
     GHC.Event.Manager.closeFd1_closure:
         const GHC.Event.Manager.closeFd1_info;
         const 0;
 },
 $wgo_saAEy_entry() //  [R1, R2]
         { info_tbl: [(caE9e,
                       label: $wgo_saAEy_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caE9f; else goto caE9g;
       caE9f: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caE9g: // global
           I64[Sp - 24] = block_caE97_info;
           _saAEy::P64 = R1;
           _saAE7::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAE7::I64;
           P64[Sp - 8] = _saAEy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaE9D; else goto caE98;
       uaE9D: // global
           call _caE97(R1) args: 0, res: 0, upd: 0;
       caE98: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE97() //  [R1]
         { info_tbl: [(caE97,
                       label: block_caE97_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE97: // global
           if (R1 & 7 == 1) goto caE9b; else goto caE9c;
       caE9b: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caE9c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caE9o; else goto caE9n;
       caE9o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE9n: // global
           _saAEC::P64 = P64[R1 + 6];
           _saAED::P64 = P64[R1 + 14];
           _saAEB::I64 = I64[R1 + 22];
           if (_saAEB::I64 == I64[Sp + 8]) goto caE9C; else goto caE9w;
       caE9C: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAEC::P64;
           R3 = _saAED::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caE9w: // global
           Hp = Hp - 16;
           I64[Sp] = block_caE9s_info;
           R2 = _saAED::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAEC::P64;
           I64[Sp + 16] = _saAEB::I64;
           call $wgo_saAEy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE9s() //  [R1, R2, R3]
         { info_tbl: [(caE9s,
                       label: block_caE9s_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caE9z; else goto caE9y;
       caE9z: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caE9y: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAEi_entry() //  [R1, R2]
         { info_tbl: [(caE9E,
                       label: $wio_saAEi_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9E: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caE9F; else goto caE9G;
       caE9F: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caE9G: // global
           I64[Sp - 40] = block_caE8O_info;
           _saADI::P64 = P64[R1 + 6];
           _saADP::P64 = P64[R1 + 14];
           _saAE6::P64 = P64[R1 + 22];
           _saAE7::I64 = I64[R1 + 30];
           R1 = P64[R2 + 8];
           P64[Sp - 32] = _saADI::P64;
           P64[Sp - 24] = _saADP::P64;
           P64[Sp - 16] = _saAE6::P64;
           I64[Sp - 8] = _saAE7::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaEbi; else goto caE8P;
       uaEbi: // global
           call _caE8O(R1) args: 0, res: 0, upd: 0;
       caE8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE8O() //  [R1]
         { info_tbl: [(caE8O,
                       label: block_caE8O_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE8O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caE9J; else goto caE9I;
       caE9J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE9I: // global
           _saAE7::I64 = I64[Sp + 32];
           _saAEp::P64 = P64[R1 + 7];
           _saAEr::P64 = P64[R1 + 15];
           _saAEq::I64 = I64[R1 + 23];
           _saAEs::I64 = _saAE7::I64 & (I64[_saAEp::P64 + 8] - 1);
           _saAEx::P64 = P64[(_saAEp::P64 + 24) + (_saAEs::I64 << 3)];
           I64[Hp - 8] = $wgo_saAEy_info;
           I64[Hp] = _saAE7::I64;
           I64[Sp - 24] = block_caE9K_info;
           R2 = _saAEx::P64;
           R1 = Hp - 7;
           P64[Sp - 16] = _saAEr::P64;
           I64[Sp - 8] = _saAEs::I64;
           I64[Sp] = _saAEq::I64;
           P64[Sp + 32] = _saAEp::P64;
           Sp = Sp - 24;
           call $wgo_saAEy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE9K() //  [R1, R2, R3]
         { info_tbl: [(caE9K,
                       label: block_caE9K_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9K: // global
           I64[Sp - 16] = block_caE9O_info;
           _saAEM::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAEM::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEbj; else goto caEaL;
       uaEbj: // global
           call _caE9O(R1) args: 0, res: 0, upd: 0;
       caEaL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE9O() //  [R1]
         { info_tbl: [(caE9O,
                       label: block_caE9O_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9O: // global
           if (R1 & 7 == 1) goto caEaR; else goto caEaW;
       caEaR: // global
           P64[Sp + 72] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAEP() args: 0, res: 0, upd: 0;
       caEaW: // global
           _saAEp::P64 = P64[Sp + 72];
           _saAEs::I64 = I64[Sp + 32];
           _saAEM::P64 = P64[Sp + 16];
           _saAEO::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAEp::P64 + 24) + (_saAEs::I64 << 3)] = _saAEO::P64;
           I64[_saAEp::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAEp::P64 + 24) + ((I64[_saAEp::P64 + 8] << 3) + (_saAEs::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caEaU_info;
           _saAFf::P64 = R1;
           R1 = _saAEM::P64;
           P64[Sp + 72] = _saAFf::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaEbk; else goto caEaX;
       uaEbk: // global
           call _caEaU(R1) args: 0, res: 0, upd: 0;
       caEaX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEaU() //  [R1]
         { info_tbl: [(caEaU,
                       label: block_caEaU_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEaU: // global
           _saAFf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto caEb3; else goto caEb7;
       caEb3: // global
           P64[Sp + 56] = _saAFf::P64;
           Sp = Sp + 32;
           goto uaEbo;
       caEb7: // global
           _saAEq::I64 = I64[Sp + 24];
           _saAEr::P64 = P64[Sp + 8];
           I64[_saAEq::I64] = I64[_saAEq::I64] - 1;
           call MO_Touch(_saAEr::P64);
           P64[Sp + 56] = _saAFf::P64;
           Sp = Sp + 32;
           goto uaEbo;
       uaEbo: // global
           call _saAEP() args: 0, res: 0, upd: 0;
     }
 },
 _saAEP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAEP: // global
           I64[Sp - 8] = block_caE9T_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEbp; else goto caE9V;
       uaEbp: // global
           call _caE9T(R1) args: 0, res: 0, upd: 0;
       caE9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE9T() //  [R1]
         { info_tbl: [(caE9T,
                       label: block_caE9T_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9T: // global
           if (R1 & 7 == 1) goto caEa2; else goto caEa9;
       caEa2: // global
           I64[Sp + 32] = block_caE9Z_info;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caEa9: // global
           I64[Sp] = block_caEa7_info;
           _saAEW::P64 = P64[R1 + 6];
           R2 = _saAEW::P64;
           P64[Sp + 32] = _saAEW::P64;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caE9Z() //  []
         { info_tbl: [(caE9Z,
                       label: block_caE9Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE9Z: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEa7() //  [R1]
         { info_tbl: [(caEa7,
                       label: block_caEa7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEa7: // global
           _saAEY::I64 = R1 & 7;
           if (_saAEY::I64 != 0) goto caEau; else goto caEaH;
       caEau: // global
           I64[Sp] = block_caEak_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAEY::I64;
           if (R1 & 7 != 0) goto uaEbm; else goto caEal;
       uaEbm: // global
           call _caEak(R1) args: 0, res: 0, upd: 0;
       caEal: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caEaH: // global
           _saAE6::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caEaG_info;
           R2 = _saAE6::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEak() //  [R1]
         { info_tbl: [(caEak,
                       label: block_caEak_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEak: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEay; else goto caEax;
       caEay: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEax: // global
           _saAF0::P64 = P64[R1 + 7];
           _saAF2::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caEaq_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 7;
           R3 = P64[Sp + 24];
           R2 = _saAF0::P64;
           R1 = _saAF2::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caEaq() //  []
         { info_tbl: [(caEaq,
                       label: block_caEaq_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEaq: // global
           _saAE6::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caEas_info;
           R2 = _saAE6::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEas() //  []
         { info_tbl: [(caEas,
                       label: block_caEas_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEas: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEaG() //  []
         { info_tbl: [(caEaG,
                       label: block_caEaG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEaG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAFp_entry() //  [R1, R2]
         { info_tbl: [(caEby,
                       label: io_saAFp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEby: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEbz; else goto caEbA;
       caEbz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEbA: // global
           I64[Sp - 16] = block_caEbv_info;
           _saAEi::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAEi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEbE; else goto caEbw;
       uaEbE: // global
           call _caEbv(R1) args: 0, res: 0, upd: 0;
       caEbw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEbv() //  [R1]
         { info_tbl: [(caEbv,
                       label: block_caEbv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEbv: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAEi_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFD_entry() //  [R1, R2]
         { info_tbl: [(caEbQ,
                       label: sat_saAFD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEbR; else goto caEbS;
       caEbR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEbS: // global
           I64[Sp - 16] = block_caEbO_info;
           _saAFA::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAFA::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEbO() //  []
         { info_tbl: [(caEbO,
                       label: block_caEbO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEbO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFy_entry() //  [R1]
         { info_tbl: [(caEbZ,
                       label: sat_saAFy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEbZ: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFz_entry() //  [R1]
         { info_tbl: [(caEc7,
                       label: sat_saAFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEc7: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFR_entry() //  [R1, R2]
         { info_tbl: [(caEcp,
                       label: sat_saAFR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEcq; else goto caEcr;
       caEcq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEcr: // global
           I64[Sp - 16] = block_caEcn_info;
           _saAFO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAFO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEcn() //  []
         { info_tbl: [(caEcn,
                       label: block_caEcn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFM_entry() //  [R1]
         { info_tbl: [(caEcy,
                       label: sat_saAFM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcy: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFN_entry() //  [R1]
         { info_tbl: [(caEcG,
                       label: sat_saAFN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcG: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAFW_entry() //  [R1]
         { info_tbl: [(caEcN,
                       label: sat_saAFW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEcO; else goto caEcP;
       caEcO: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caEcP: // global
           I64[Sp - 24] = block_caEcg_info;
           _saAEh::P64 = P64[R1 + 7];
           _saAFp::P64 = P64[R1 + 15];
           R1 = _saAEh::P64;
           P64[Sp - 16] = _saAEh::P64;
           P64[Sp - 8] = _saAFp::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEcg() //  [R1]
         { info_tbl: [(caEcg,
                       label: block_caEcg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEcS; else goto caEcR;
       caEcS: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEcR: // global
           I64[Hp - 56] = sat_saAFR_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAFM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAFN_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEcJ_info;
           R2 = Hp - 54;
           _saAFL::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAFL::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEcJ() //  [R1]
         { info_tbl: [(caEcJ,
                       label: block_caEcJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcJ: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEcL_info;
           R2 = P64[Sp + 16];
           _saAFU::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAFU::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEcL() //  []
         { info_tbl: [(caEcL,
                       label: block_caEcL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG8_entry() //  [R1, R2]
         { info_tbl: [(caEd5,
                       label: sat_saAG8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEd5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEd6; else goto caEd7;
       caEd6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEd7: // global
           I64[Sp - 16] = block_caEd3_info;
           _saAG5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAG5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEd3() //  []
         { info_tbl: [(caEd3,
                       label: block_caEd3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEd3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG3_entry() //  [R1]
         { info_tbl: [(caEde,
                       label: sat_saAG3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEde: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAFp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAG4_entry() //  [R1]
         { info_tbl: [(caEdm,
                       label: sat_saAG4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdm: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.closeFd1_entry() //  [R2, R3, R4]
         { info_tbl: [(caEdp,
                       label: GHC.Event.Manager.closeFd1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdp: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caEdq; else goto caEdr;
       caEdq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caEdr: // global
           I64[Sp - 32] = block_caE84_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caE84() //  [R1]
         { info_tbl: [(caE84,
                       label: block_caE84_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE84: // global
           I64[Sp] = block_caE86_info;
           _saADN::I64 = R1;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saADN::I64;
           if (R1 & 7 != 0) goto uaEe6; else goto caE87;
       uaEe6: // global
           call _caE86(R1) args: 0, res: 0, upd: 0;
       caE87: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE86() //  [R1]
         { info_tbl: [(caE86,
                       label: block_caE86_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE86: // global
           I64[Sp - 24] = block_caE8b_info;
           _saADP::P64 = P64[R1 + 7];
           _saADR::P64 = P64[R1 + 23];
           _saADT::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saADR::P64;
           P64[Sp - 8] = _saADT::P64;
           P64[Sp] = _saADP::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaEe7; else goto caE8c;
       uaEe7: // global
           call _caE8b(R1) args: 0, res: 0, upd: 0;
       caE8c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE8b() //  [R1]
         { info_tbl: [(caE8b,
                       label: block_caE8b_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE8b: // global
           I64[Sp - 8] = block_caE8g_info;
           _saAE2::P64 = R1;
           _saAE3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAE3::I64;
           P64[Sp + 8] = _saAE2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEe8; else goto caE8h;
       uaEe8: // global
           call _caE8g(R1) args: 0, res: 0, upd: 0;
       caE8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE8g() //  [R1]
         { info_tbl: [(caE8g,
                       label: block_caE8g_info
                       rep:StackRep [True, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE8g: // global
           I64[Sp - 8] = block_caE8l_info;
           _saAE4::P64 = R1;
           _saAE5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp] = _saAE5::I64;
           P64[Sp + 56] = _saAE4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEe9; else goto caE8m;
       uaEe9: // global
           call _caE8l(R1) args: 0, res: 0, upd: 0;
       caE8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE8l() //  [R1]
         { info_tbl: [(caE8l,
                       label: block_caE8l_info
                       rep:StackRep [True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE8l: // global
           _saAE2::P64 = P64[Sp + 24];
           _saAE3::I64 = I64[Sp + 16];
           _saAE4::P64 = P64[Sp + 64];
           _saAE7::I64 = I64[R1 + 7];
           _saAE8::I64 = _saAE7::I64 & 31;
           if (%MO_S_Gt_W64(_saAE3::I64,
                            _saAE8::I64)) goto caEdA; else goto caEe4;
       caEe4: // global
           if (%MO_S_Gt_W64(_saAE8::I64,
                            I64[Sp + 8])) goto caEdA; else goto caEdB;
       caEdA: // global
           R4 = _saAE8::I64;
           R3 = _saAE2::P64;
           R2 = _saAE4::P64;
           Sp = Sp + 72;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caEdB: // global
           _saAEf::P64 = P64[P64[Sp + 32] + ((_saAE8::I64 - _saAE3::I64 << 3) + 24)];
           I64[Sp + 24] = block_caE8E_info;
           _saAE6::P64 = R1;
           R1 = _saAEf::P64;
           I64[Sp + 32] = _saAE7::I64;
           P64[Sp + 64] = _saAE6::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaEea; else goto caE8F;
       uaEea: // global
           call _caE8E(R1) args: 0, res: 0, upd: 0;
       caE8F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caE8E() //  [R1]
         { info_tbl: [(caE8E,
                       label: block_caE8E_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caE8E: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caEdE; else goto caEdD;
       caEdE: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEdD: // global
           _saAEh::P64 = P64[R1 + 7];
           I64[Hp - 72] = $wio_saAEi_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saAFp_info;
           P64[Hp - 24] = Hp - 70;
           _caEbq::P64 = Hp - 30;
           _saAFu::I64 = I64[Sp + 24];
           if (_saAFu::I64 != 0) goto uaEe5; else goto caEdR;
       uaEe5: // global
           if (_saAFu::I64 != 1) goto caEdJ; else goto caEdX;
       caEdJ: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caEbH_info;
           R1 = _saAEh::P64;
           P64[Sp + 32] = _saAEh::P64;
           P64[Sp + 40] = _caEbq::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caEdX: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caEcW_info;
           R1 = _saAEh::P64;
           P64[Sp + 32] = _saAEh::P64;
           P64[Sp + 40] = _caEbq::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caEdR: // global
           I64[Hp - 16] = sat_saAFW_info;
           P64[Hp - 8] = _saAEh::P64;
           P64[Hp] = _caEbq::P64;
           I64[Sp + 40] = block_caEdQ_info;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEbH() //  [R1]
         { info_tbl: [(caEbH,
                       label: block_caEbH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEbH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEdM; else goto caEdL;
       caEdM: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEdL: // global
           I64[Hp - 56] = sat_saAFD_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAFy_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAFz_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEdF_info;
           R2 = Hp - 54;
           _saAFx::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAFx::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEdF() //  [R1]
         { info_tbl: [(caEdF,
                       label: block_caEdF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdF: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEdH_info;
           R2 = P64[Sp + 16];
           _saAFG::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAFG::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEdH() //  []
         { info_tbl: [(caEdH,
                       label: block_caEdH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdH: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caEcW() //  [R1]
         { info_tbl: [(caEcW,
                       label: block_caEcW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEcW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEe0; else goto caEdZ;
       caEe0: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEdZ: // global
           I64[Hp - 56] = sat_saAG8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAG3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAG4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEdU_info;
           R2 = Hp - 54;
           _saAG2::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAG2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEdU() //  [R1]
         { info_tbl: [(caEdU,
                       label: block_caEdU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdU: // global
           _saAEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEdW_info;
           R2 = P64[Sp + 16];
           _saAGb::P64 = R1;
           R1 = _saAEh::P64;
           P64[Sp + 16] = _saAGb::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEdW() //  []
         { info_tbl: [(caEdW,
                       label: block_caEdW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdW: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caEdQ() //  [R1]
         { info_tbl: [(caEdQ,
                       label: block_caEdQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEdQ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.690821788 UTC

[section ""data" . GHC.Event.Manager.closeFd_closure" {
     GHC.Event.Manager.closeFd_closure:
         const GHC.Event.Manager.closeFd_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_entry() //  [R2, R3, R4]
         { info_tbl: [(caEhB,
                       label: GHC.Event.Manager.closeFd_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEhB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.694830831 UTC

[section ""data" . lvl8_raAuf_closure" {
     lvl8_raAuf_closure:
         const lvl8_raAuf_info;
 },
 lvl8_raAuf_entry() //  [R2]
         { info_tbl: [(caEhP,
                       label: lvl8_raAuf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEhP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caEhQ; else goto caEhR;
       caEhQ: // global
           R2 = R2;
           R1 = lvl8_raAuf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEhR: // global
           I64[Sp - 8] = block_caEhM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEia; else goto caEhN;
       uaEia: // global
           call _caEhM(R1) args: 0, res: 0, upd: 0;
       caEhN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEhM() //  [R1]
         { info_tbl: [(caEhM,
                       label: block_caEhM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEhM: // global
           if (I64[R1 + 31] & 8 == 0) goto caEi6; else goto caEi0;
       caEi6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caEi0: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.710524734 UTC

[section ""data" . GHC.Event.Manager.loop5_closure" {
     GHC.Event.Manager.loop5_closure:
         const GHC.Event.Manager.loop5_info;
         const 0;
 },
 $wgo_saAHp_entry() //  [R1, R2]
         { info_tbl: [(caEjO,
                       label: $wgo_saAHp_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEjO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEjP; else goto caEjQ;
       caEjP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEjQ: // global
           I64[Sp - 24] = block_caEjH_info;
           _saAHp::P64 = R1;
           _saAGN::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAGN::I64;
           P64[Sp - 8] = _saAHp::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaEkd; else goto caEjI;
       uaEkd: // global
           call _caEjH(R1) args: 0, res: 0, upd: 0;
       caEjI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEjH() //  [R1]
         { info_tbl: [(caEjH,
                       label: block_caEjH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEjH: // global
           if (R1 & 7 == 1) goto caEjL; else goto caEjM;
       caEjL: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caEjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEjY; else goto caEjX;
       caEjY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEjX: // global
           _saAHt::P64 = P64[R1 + 6];
           _saAHu::P64 = P64[R1 + 14];
           _saAHs::I64 = I64[R1 + 22];
           if (_saAHs::I64 == I64[Sp + 8]) goto caEkc; else goto caEk6;
       caEkc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAHt::P64;
           R3 = _saAHu::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caEk6: // global
           Hp = Hp - 16;
           I64[Sp] = block_caEk2_info;
           R2 = _saAHu::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAHt::P64;
           I64[Sp + 16] = _saAHs::I64;
           call $wgo_saAHp_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEk2() //  [R1, R2, R3]
         { info_tbl: [(caEk2,
                       label: block_caEk2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEk2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caEk9; else goto caEk8;
       caEk9: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caEk8: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saAHY_entry() //  [R1]
         { info_tbl: [(caEkX,
                       label: w2_saAHY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEkX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEkY; else goto caEkZ;
       caEkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caEkZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caEkU_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo1_saAHM_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caEkU() //  [R1, R2]
         { info_tbl: [(caEkU,
                       label: block_caEkU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEkU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caEl2; else goto caEl1;
       caEl2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caEl1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo1_saAHM_entry() //  [R1, R2]
         { info_tbl: [(caEl7,
                       label: $wgo1_saAHM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEl7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caEl8; else goto caEl9;
       caEl8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEl9: // global
           I64[Sp - 24] = block_caEkA_info;
           _saAHM::P64 = R1;
           _saAGm::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _saAGm::P64;
           P64[Sp - 8] = _saAHM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaElz; else goto caEkB;
       uaElz: // global
           call _caEkA(R1) args: 0, res: 0, upd: 0;
       caEkB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEkA() //  [R1]
         { info_tbl: [(caEkA,
                       label: block_caEkA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEkA: // global
           if (R1 & 7 == 1) goto caEl4; else goto caEl5;
       caEl4: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caEl5: // global
           I64[Sp - 8] = block_caEkG_info;
           _saAHP::P64 = P64[R1 + 6];
           _saAHQ::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _saAHQ::P64;
           P64[Sp + 8] = _saAHP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaElx; else goto caEkH;
       uaElx: // global
           call _caEkG(R1) args: 0, res: 0, upd: 0;
       caEkH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEkG() //  [R1]
         { info_tbl: [(caEkG,
                       label: block_caEkG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEkG: // global
           I64[Sp] = block_caEkL_info;
           _saAHS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAHS::I64;
           if (R1 & 7 != 0) goto uaEly; else goto caEkM;
       uaEly: // global
           call _caEkL(R1) args: 0, res: 0, upd: 0;
       caEkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEkL() //  [R1]
         { info_tbl: [(caEkL,
                       label: block_caEkL_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEkL: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caElg; else goto caElf;
       caElg: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caElf: // global
           _saAHW::I64 = I64[R1 + 31];
           I64[Hp - 96] = w2_saAHY_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           _caEkQ::P64 = Hp - 96;
           if (I64[Sp + 16] & _saAHW::I64 & 7 == 0) goto caElw; else goto caElr;
       caElw: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caEkQ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _caEkQ::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caElr: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caEkQ::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _caEkQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds8_saAHL_entry() //  [R1]
         { info_tbl: [(caElD,
                       label: ds8_saAHL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caElD: // global
           _saAHL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caElE; else goto caElF;
       caElF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caElH; else goto caElG;
       caElH: // global
           HpAlloc = 16;
           goto caElE;
       caElE: // global
           R1 = _saAHL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caElG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saAHL::P64;
           _saAGm::P64 = P64[_saAHL::P64 + 16];
           _saAHK::P64 = P64[_saAHL::P64 + 24];
           I64[Hp - 8] = $wgo1_saAHM_info;
           P64[Hp] = _saAGm::P64;
           I64[Sp - 24] = block_caElA_info;
           R2 = _saAHK::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call $wgo1_saAHM_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caElA() //  [R1, R2]
         { info_tbl: [(caElA,
                       label: block_caElA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caElA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caElK; else goto caElJ;
       caElK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caElJ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAIx_entry() //  [R1]
         { info_tbl: [(caElZ,
                       label: sat_saAIx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caElZ: // global
           R3 = P64[R1 + 16];
           R2 = lvl8_raAuf_closure+1;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 saved_saAIt_entry() //  [R1]
         { info_tbl: [(caEm2,
                       label: saved_saAIt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEm2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caEm3; else goto caEm4;
       caEm3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caEm4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caElQ_info;
           _saAIp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saAIp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaEm8; else goto caElR;
       uaEm8: // global
           call _caElQ(R1) args: 0, res: 0, upd: 0;
       caElR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caElQ() //  [R1]
         { info_tbl: [(caElQ,
                       label: block_caElQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caElQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caEm7; else goto caEm6;
       caEm7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caEm6: // global
           _saAIw::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saAIx_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _saAIw::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saAIA_entry() //  [R1]
         { info_tbl: [(caEme,
                       label: sat_saAIA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEme: // global
           R1 = P64[R1 + 6] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAH9_entry() //  [R1, R2]
         { info_tbl: [(caEmh,
                       label: $wio_saAH9_info
                       rep:HeapRep 5 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmh: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caEmi; else goto caEmj;
       caEmi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEmj: // global
           I64[Sp - 64] = block_caEjo_info;
           _saAGm::P64 = P64[R1 + 6];
           _saAGD::P64 = P64[R1 + 14];
           _saAGF::P64 = P64[R1 + 22];
           _saAGG::P64 = P64[R1 + 30];
           _saAGM::P64 = P64[R1 + 38];
           _saAGN::I64 = I64[R1 + 46];
           R1 = P64[R2 + 8];
           P64[Sp - 56] = _saAGm::P64;
           P64[Sp - 48] = _saAGD::P64;
           P64[Sp - 40] = _saAGF::P64;
           P64[Sp - 32] = _saAGG::P64;
           P64[Sp - 24] = _saAGM::P64;
           I64[Sp - 16] = _saAGN::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto uaEoY; else goto caEjp;
       uaEoY: // global
           call _caEjo(R1) args: 0, res: 0, upd: 0;
       caEjp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEjo() //  [R1]
         { info_tbl: [(caEjo,
                       label: block_caEjo_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEjo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEmm; else goto caEml;
       caEmm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEml: // global
           _saAGN::I64 = I64[Sp + 48];
           _saAHg::P64 = P64[R1 + 7];
           _saAHi::P64 = P64[R1 + 15];
           _saAHh::I64 = I64[R1 + 23];
           _saAHj::I64 = _saAGN::I64 & (I64[_saAHg::P64 + 8] - 1);
           _saAHo::P64 = P64[(_saAHg::P64 + 24) + (_saAHj::I64 << 3)];
           I64[Hp - 8] = $wgo_saAHp_info;
           I64[Hp] = _saAGN::I64;
           I64[Sp - 32] = block_caEke_info;
           R2 = _saAHo::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saAHh::I64;
           P64[Sp - 16] = _saAHi::P64;
           I64[Sp - 8] = _saAHj::I64;
           P64[Sp] = _saAHg::P64;
           Sp = Sp - 32;
           call $wgo_saAHp_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEke() //  [R1, R2, R3]
         { info_tbl: [(caEke,
                       label: block_caEke_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEke: // global
           I64[Sp - 16] = block_caEmn_info;
           _saAHD::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAHD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEoX; else goto caEom;
       uaEoX: // global
           call _caEmn(R1) args: 0, res: 0, upd: 0;
       caEom: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEmn() //  [R1]
         { info_tbl: [(caEmn,
                       label: block_caEmn_info
                       rep:StackRep [False, False, True, False, True, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmn: // global
           if (R1 & 7 == 1) goto caEos; else goto caEox;
       caEos: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAHG() args: 0, res: 0, upd: 0;
       caEox: // global
           _saAHg::P64 = P64[Sp + 48];
           _saAHj::I64 = I64[Sp + 40];
           _saAHD::P64 = P64[Sp + 16];
           _saAHF::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAHg::P64 + 24) + (_saAHj::I64 << 3)] = _saAHF::P64;
           I64[_saAHg::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAHg::P64 + 24) + ((I64[_saAHg::P64 + 8] << 3) + (_saAHj::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caEov_info;
           _saAJ0::P64 = R1;
           R1 = _saAHD::P64;
           P64[Sp + 48] = _saAJ0::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaEoZ; else goto caEoy;
       uaEoZ: // global
           call _caEov(R1) args: 0, res: 0, upd: 0;
       caEoy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEov() //  [R1]
         { info_tbl: [(caEov,
                       label: block_caEov_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEov: // global
           _saAJ0::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caEoE; else goto caEoI;
       caEoE: // global
           P64[Sp + 32] = _saAJ0::P64;
           Sp = Sp + 32;
           goto uaEp6;
       caEoI: // global
           _saAHh::I64 = I64[Sp + 8];
           _saAHi::P64 = P64[Sp + 16];
           I64[_saAHh::I64] = I64[_saAHh::I64] - 1;
           call MO_Touch(_saAHi::P64);
           P64[Sp + 32] = _saAJ0::P64;
           Sp = Sp + 32;
           goto uaEp6;
       uaEp6: // global
           call _saAHG() args: 0, res: 0, upd: 0;
     }
 },
 _saAHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAHG: // global
           _saAHI::P64 = P64[Sp];
           I64[Sp] = block_caEkl_info;
           R1 = _saAHI::P64;
           if (R1 & 7 != 0) goto uaEp7; else goto caEkm;
       uaEp7: // global
           call _caEkl(R1) args: 0, res: 0, upd: 0;
       caEkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEkl() //  [R1]
         { info_tbl: [(caEkl,
                       label: block_caEkl_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEkl: // global
           if (R1 & 7 == 1) goto caEmt; else goto caEmB;
       caEmt: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caEmB: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caEmE; else goto caEmD;
       caEmE: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEmD: // global
           _saAHK::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds8_saAHL_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _saAHK::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           _caEkr::P64 = Hp - 96;
           P64[Hp - 48] = _caEkr::P64;
           I64[Hp - 40] = saved_saAIt_info;
           P64[Hp - 24] = _caEkr::P64;
           _caElL::P64 = Hp - 64;
           P64[Hp - 16] = _caElL::P64;
           I64[Hp - 8] = sat_saAIA_info;
           _caElM::P64 = Hp - 40;
           P64[Hp] = _caElM::P64;
           I64[Sp] = block_caEmu_info;
           R5 = P64[Sp + 56];
           R4 = _caElM::P64;
           R3 = I64[Sp + 48];
           R2 = Hp - 6;
           P64[Sp + 8] = _saAHK::P64;
           P64[Sp + 48] = _caElM::P64;
           P64[Sp + 56] = _caElL::P64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEmu() //  []
         { info_tbl: [(caEmu,
                       label: block_caEmu_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmu: // global
           _saAHK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEmw_info;
           R2 = _saAHK::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEmw() //  [R1]
         { info_tbl: [(caEmw,
                       label: block_caEmw_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmw: // global
           I64[Sp] = block_caEmA_info;
           R2 = P64[Sp + 40];
           I64[Sp + 40] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEmA() //  [R1]
         { info_tbl: [(caEmA,
                       label: block_caEmA_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmA: // global
           _caElL::P64 = P64[Sp + 48];
           _saAIE::I64 = I64[Sp + 40];
           _saAIF::I64 = R1;
           if (_saAIE::I64 & 8 == 0) goto saAIG; else goto caEo7;
       caEo7: // global
           if (_saAIE::I64 == _saAIF::I64) goto caEof; else goto saAIG;
       saAIG: // global
           _saAII::I64 = _saAIF::I64 & 8;
           if (_saAII::I64 != 0) goto uaEoT; else goto caEnf;
       uaEoT: // global
           I64[Sp] = _saAII::I64;
           I64[Sp + 24] = _saAIF::I64;
           call _caEmV() args: 0, res: 0, upd: 0;
       caEnf: // global
           if (_saAIE::I64 & 8 == 0) goto caEnJ; else goto uaEoV;
       caEnJ: // global
           if (_saAIF::I64 & 7 == 0) goto caEof; else goto uaEoW;
       caEof: // global
           R1 = _caElL::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaEoW: // global
           I64[Sp + 40] = _saAIF::I64;
           goto uaEp3;
       uaEoV: // global
           I64[Sp + 40] = _saAIF::I64;
           goto uaEp3;
       uaEp3: // global
           call _caEnm() args: 0, res: 0, upd: 0;
     }
 },
 _caEmV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caEna; else goto caEn9;
       caEna: // global
           HpAlloc = 32;
           _saAII::I64 = I64[Sp];
           I64[Sp] = block_caEmU_info;
           R1 = _saAII::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caEn9: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 24] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caEn5_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caEmU() //  [R1]
         { info_tbl: [(caEmU,
                       label: block_caEmU_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEmU: // global
           I64[Sp] = R1;
           call _caEmV() args: 0, res: 0, upd: 0;
     }
 },
 _caEn5() //  []
         { info_tbl: [(caEn5,
                       label: block_caEn5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEn5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEnm() //  []
         { info_tbl: [(caEnm,
                       label: block_caEnm_info
                       rep:StackRep [False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEnm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEnv; else goto caEnu;
       caEnv: // global
           HpAlloc = 16;
           I64[Sp] = block_caEnm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caEnu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caEns_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEns() //  []
         { info_tbl: [(caEns,
                       label: block_caEns_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEns: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAJa_entry() //  [R1, R2]
         { info_tbl: [(caEpg,
                       label: io_saAJa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEph; else goto caEpi;
       caEph: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEpi: // global
           I64[Sp - 16] = block_caEpd_info;
           _saAH9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAH9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEpm; else goto caEpe;
       uaEpm: // global
           call _caEpd(R1) args: 0, res: 0, upd: 0;
       caEpe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEpd() //  [R1]
         { info_tbl: [(caEpd,
                       label: block_caEpd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpd: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAH9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJo_entry() //  [R1, R2]
         { info_tbl: [(caEpy,
                       label: sat_saAJo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEpz; else goto caEpA;
       caEpz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEpA: // global
           I64[Sp - 16] = block_caEpw_info;
           _saAJl::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAJl::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEpw() //  []
         { info_tbl: [(caEpw,
                       label: block_caEpw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJj_entry() //  [R1]
         { info_tbl: [(caEpH,
                       label: sat_saAJj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpH: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJk_entry() //  [R1]
         { info_tbl: [(caEpP,
                       label: sat_saAJk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpP: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJR_entry() //  [R1, R2]
         { info_tbl: [(caEq7,
                       label: sat_saAJR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEq7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEq8; else goto caEq9;
       caEq8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEq9: // global
           I64[Sp - 16] = block_caEq5_info;
           _saAJO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAJO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEq5() //  []
         { info_tbl: [(caEq5,
                       label: block_caEq5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEq5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJM_entry() //  [R1]
         { info_tbl: [(caEqg,
                       label: sat_saAJM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqg: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJN_entry() //  [R1]
         { info_tbl: [(caEqo,
                       label: sat_saAJN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqo: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAJW_entry() //  [R1]
         { info_tbl: [(caEqv,
                       label: sat_saAJW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEqw; else goto caEqx;
       caEqw: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caEqx: // global
           I64[Sp - 24] = block_caEpY_info;
           _saAH8::P64 = P64[R1 + 7];
           _saAJa::P64 = P64[R1 + 15];
           R1 = _saAH8::P64;
           P64[Sp - 16] = _saAH8::P64;
           P64[Sp - 8] = _saAJa::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEpY() //  [R1]
         { info_tbl: [(caEpY,
                       label: block_caEpY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEqA; else goto caEqz;
       caEqA: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEqz: // global
           I64[Hp - 56] = sat_saAJR_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAJM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAJN_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEqr_info;
           R2 = Hp - 54;
           _saAJL::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAJL::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEqr() //  [R1]
         { info_tbl: [(caEqr,
                       label: block_caEqr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqr: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEqt_info;
           R2 = P64[Sp + 16];
           _saAJU::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAJU::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEqt() //  []
         { info_tbl: [(caEqt,
                       label: block_caEqt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKn_entry() //  [R1, R2]
         { info_tbl: [(caEqN,
                       label: sat_saAKn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEqO; else goto caEqP;
       caEqO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEqP: // global
           I64[Sp - 16] = block_caEqL_info;
           _saAKk::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAKk::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEqL() //  []
         { info_tbl: [(caEqL,
                       label: block_caEqL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKi_entry() //  [R1]
         { info_tbl: [(caEqW,
                       label: sat_saAKi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqW: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAJa_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAKj_entry() //  [R1]
         { info_tbl: [(caEr4,
                       label: sat_saAKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEr4: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop5_entry() //  [R2, R3, R4]
         { info_tbl: [(caEr7,
                       label: GHC.Event.Manager.loop5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEr7: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caEr8; else goto caEr9;
       caEr8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.loop5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caEr9: // global
           I64[Sp - 24] = block_caEir_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaEu2; else goto caEis;
       uaEu2: // global
           call _caEir(R1) args: 0, res: 0, upd: 0;
       caEis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEir() //  [R1]
         { info_tbl: [(caEir,
                       label: block_caEir_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEir: // global
           I64[Sp - 56] = block_caEiw_info;
           _saAGq::P64 = P64[R1 + 15];
           _saAGr::P64 = P64[R1 + 23];
           _saAGt::P64 = P64[R1 + 31];
           _saAGu::P64 = P64[R1 + 39];
           _saAGA::P64 = P64[R1 + 63];
           _saAGw::I64 = I64[R1 + 87];
           _saAGy::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           P64[Sp - 48] = _saAGr::P64;
           P64[Sp - 40] = _saAGt::P64;
           P64[Sp - 32] = _saAGu::P64;
           I64[Sp - 24] = _saAGw::I64;
           I64[Sp - 16] = _saAGy::I64;
           P64[Sp - 8] = _saAGA::P64;
           P64[Sp] = _saAGq::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaEtX; else goto caEix;
       uaEtX: // global
           call _caEiw(R1) args: 0, res: 0, upd: 0;
       caEix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEiw() //  [R1]
         { info_tbl: [(caEiw,
                       label: block_caEiw_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEiw: // global
           I64[Sp - 16] = block_caEiB_info;
           _saAGD::P64 = P64[R1 + 7];
           _saAGF::P64 = P64[R1 + 23];
           _saAGG::P64 = P64[R1 + 31];
           R1 = P64[Sp + 56];
           P64[Sp - 8] = _saAGG::P64;
           P64[Sp] = _saAGF::P64;
           P64[Sp + 56] = _saAGD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEtY; else goto caEiC;
       uaEtY: // global
           call _caEiB(R1) args: 0, res: 0, upd: 0;
       caEiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEiB() //  [R1]
         { info_tbl: [(caEiB,
                       label: block_caEiB_info
                       rep:StackRep [False, False, False, False, False, True, True, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEiB: // global
           I64[Sp - 8] = block_caEiG_info;
           _saAGI::P64 = R1;
           _saAGJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saAGJ::I64;
           P64[Sp + 24] = _saAGI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEtZ; else goto caEiH;
       uaEtZ: // global
           call _caEiG(R1) args: 0, res: 0, upd: 0;
       caEiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEiG() //  [R1]
         { info_tbl: [(caEiG,
                       label: block_caEiG_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEiG: // global
           I64[Sp - 8] = block_caEiL_info;
           _saAGK::P64 = R1;
           _saAGL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saAGL::I64;
           P64[Sp + 88] = _saAGK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEu0; else goto caEiM;
       uaEu0: // global
           call _caEiL(R1) args: 0, res: 0, upd: 0;
       caEiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEiL() //  [R1]
         { info_tbl: [(caEiL,
                       label: block_caEiL_info
                       rep:StackRep [True, True, False, False, False, False, False, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEiL: // global
           _saAGy::I64 = I64[Sp + 72];
           _saAGA::P64 = P64[Sp + 80];
           _saAGN::I64 = I64[R1 + 7];
           if (_saAGN::I64 == I64[Sp + 64]) goto saAGO; else goto caEtD;
       caEtD: // global
           if (_saAGN::I64 == _saAGy::I64) goto saAGO; else goto caErz;
       saAGO: // global
           I64[Sp + 48] = block_caEri_info;
           R4 = _saAGN::I64;
           R3 = _saAGA::P64;
           R2 = _saAGy::I64;
           Sp = Sp + 48;
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
       caErz: // global
           I64[Sp] = block_caEiY_info;
           I64[Sp + 72] = _saAGN::I64;
           P64[Sp + 80] = R1;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caEri() //  [R1]
         { info_tbl: [(caEri,
                       label: block_caEri_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEri: // global
           I64[Sp] = block_caErk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEu3; else goto caErn;
       uaEu3: // global
           call _caErk(R1) args: 0, res: 0, upd: 0;
       caErn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caErk() //  [R1]
         { info_tbl: [(caErk,
                       label: block_caErk_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caErk: // global
           if (R1 & 7 == 2) goto caErx; else goto uaEtW;
       caErx: // global
           _saAGu::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saAGu::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saAGu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaEtW: // global
           Sp = Sp + 64;
           call _caErt() args: 0, res: 0, upd: 0;
     }
 },
 _caEiY() //  [R1]
         { info_tbl: [(caEiY,
                       label: block_caEiY_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEiY: // global
           _saAGI::P64 = P64[Sp + 40];
           _saAGJ::I64 = I64[Sp + 16];
           _saAGK::P64 = P64[Sp + 96];
           _saAGZ::I64 = I64[Sp + 72] & 31;
           if (%MO_S_Gt_W64(_saAGJ::I64,
                            _saAGZ::I64)) goto caErE; else goto caEtA;
       caEtA: // global
           if (%MO_S_Gt_W64(_saAGZ::I64,
                            I64[Sp + 8])) goto caErE; else goto caErF;
       caErE: // global
           R4 = _saAGZ::I64;
           R3 = _saAGI::P64;
           R2 = _saAGK::P64;
           Sp = Sp + 112;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caErF: // global
           _saAH6::P64 = P64[P64[Sp + 48] + ((_saAGZ::I64 - _saAGJ::I64 << 3) + 24)];
           I64[Sp + 16] = block_caEje_info;
           _saAGY::I64 = R1;
           R1 = _saAH6::P64;
           I64[Sp + 96] = _saAGY::I64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaEu1; else goto caEjf;
       uaEu1: // global
           call _caEje(R1) args: 0, res: 0, upd: 0;
       caEjf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEje() //  [R1]
         { info_tbl: [(caEje,
                       label: block_caEje_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEje: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caErI; else goto caErH;
       caErI: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caErH: // global
           _saAH8::P64 = P64[R1 + 7];
           I64[Hp - 88] = $wio_saAH9_info;
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 72];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 64];
           I64[Hp - 40] = I64[Sp + 56];
           I64[Hp - 32] = io_saAJa_info;
           P64[Hp - 24] = Hp - 86;
           _caEp8::P64 = Hp - 30;
           _saAJf::I64 = I64[Sp + 80];
           if (_saAJf::I64 != 0) goto uaEtM; else goto caEsp;
       uaEtM: // global
           if (_saAJf::I64 != 1) goto caErN; else goto caEsZ;
       caErN: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caEpp_info;
           R1 = _saAH8::P64;
           P64[Sp + 72] = _saAH8::P64;
           P64[Sp + 80] = _caEp8::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caEsZ: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caEqE_info;
           R1 = _saAH8::P64;
           P64[Sp + 72] = _saAH8::P64;
           P64[Sp + 80] = _caEp8::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caEsp: // global
           I64[Hp - 16] = sat_saAJW_info;
           P64[Hp - 8] = _saAH8::P64;
           P64[Hp] = _caEp8::P64;
           I64[Sp + 80] = block_caEso_info;
           R1 = Hp - 15;
           Sp = Sp + 80;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEpp() //  [R1]
         { info_tbl: [(caEpp,
                       label: block_caEpp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEpp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caErQ; else goto caErP;
       caErQ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caErP: // global
           I64[Hp - 56] = sat_saAJo_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAJj_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAJk_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caErJ_info;
           R2 = Hp - 54;
           _saAJi::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAJi::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caErJ() //  [R1]
         { info_tbl: [(caErJ,
                       label: block_caErJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caErJ: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caErL_info;
           R2 = P64[Sp + 16];
           _saAJr::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAJr::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caErL() //  []
         { info_tbl: [(caErL,
                       label: block_caErL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caErL: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caErX() args: 0, res: 0, upd: 0;
     }
 },
 _caErX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caErX: // global
           _saAJu::P64 = P64[Sp];
           I64[Sp] = block_caErZ_info;
           R1 = _saAJu::P64;
           if (R1 & 7 != 0) goto uaEu6; else goto caEs1;
       uaEu6: // global
           call _caErZ(R1) args: 0, res: 0, upd: 0;
       caEs1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caErZ() //  [R1]
         { info_tbl: [(caErZ,
                       label: block_caErZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caErZ: // global
           if (R1 & 7 == 1) goto uaEtO; else goto caEsc;
       uaEtO: // global
           Sp = Sp + 16;
           call _caErt() args: 0, res: 0, upd: 0;
       caEsc: // global
           I64[Sp - 8] = block_caEsa_info;
           _saAJy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAJy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEu7; else goto caEsd;
       uaEu7: // global
           call _caEsa(R1) args: 0, res: 0, upd: 0;
       caEsd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEsa() //  [R1]
         { info_tbl: [(caEsa,
                       label: block_caEsa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caEsl; else goto caEsk;
       caEsl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEsk: // global
           _saAJD::P64 = P64[R1 + 7];
           _saAJA::I64 = I64[R1 + 15];
           _saAJB::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAJA::I64;
           I64[Hp] = _saAJB::I64;
           I64[Sp] = block_caEsi_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAJD::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEsi() //  []
         { info_tbl: [(caEsi,
                       label: block_caEsi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsi: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caErX() args: 0, res: 0, upd: 0;
     }
 },
 _caEqE() //  [R1]
         { info_tbl: [(caEqE,
                       label: block_caEqE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEqE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEt2; else goto caEt1;
       caEt2: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEt1: // global
           I64[Hp - 56] = sat_saAKn_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAKi_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAKj_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEsW_info;
           R2 = Hp - 54;
           _saAKh::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAKh::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEsW() //  [R1]
         { info_tbl: [(caEsW,
                       label: block_caEsW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsW: // global
           _saAH8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEsY_info;
           R2 = P64[Sp + 16];
           _saAKq::P64 = R1;
           R1 = _saAH8::P64;
           P64[Sp + 16] = _saAKq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEsY() //  []
         { info_tbl: [(caEsY,
                       label: block_caEsY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsY: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caEt9() args: 0, res: 0, upd: 0;
     }
 },
 _caEt9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEt9: // global
           _saAKt::P64 = P64[Sp];
           I64[Sp] = block_caEtb_info;
           R1 = _saAKt::P64;
           if (R1 & 7 != 0) goto uaEug; else goto caEtd;
       uaEug: // global
           call _caEtb(R1) args: 0, res: 0, upd: 0;
       caEtd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEtb() //  [R1]
         { info_tbl: [(caEtb,
                       label: block_caEtb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEtb: // global
           if (R1 & 7 == 1) goto uaEtR; else goto caEto;
       uaEtR: // global
           Sp = Sp + 16;
           call _caErt() args: 0, res: 0, upd: 0;
       caEto: // global
           I64[Sp - 8] = block_caEtm_info;
           _saAKx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAKx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEuh; else goto caEtp;
       uaEuh: // global
           call _caEtm(R1) args: 0, res: 0, upd: 0;
       caEtp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEtm() //  [R1]
         { info_tbl: [(caEtm,
                       label: block_caEtm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEtm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caEtx; else goto caEtw;
       caEtx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEtw: // global
           _saAKC::P64 = P64[R1 + 7];
           _saAKz::I64 = I64[R1 + 15];
           _saAKA::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAKz::I64;
           I64[Hp] = _saAKA::I64;
           I64[Sp] = block_caEtu_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAKC::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEtu() //  []
         { info_tbl: [(caEtu,
                       label: block_caEtu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEtu: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caEt9() args: 0, res: 0, upd: 0;
     }
 },
 _caEso() //  [R1]
         { info_tbl: [(caEso,
                       label: block_caEso_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEso: // global
           P64[Sp] = R1;
           call _caEsv() args: 0, res: 0, upd: 0;
     }
 },
 _caEsv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsv: // global
           _saAK1::P64 = P64[Sp];
           I64[Sp] = block_caEsx_info;
           R1 = _saAK1::P64;
           if (R1 & 7 != 0) goto uaEub; else goto caEsz;
       uaEub: // global
           call _caEsx(R1) args: 0, res: 0, upd: 0;
       caEsz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEsx() //  [R1]
         { info_tbl: [(caEsx,
                       label: block_caEsx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsx: // global
           if (R1 & 7 == 1) goto uaEtU; else goto caEsK;
       uaEtU: // global
           Sp = Sp + 16;
           call _caErt() args: 0, res: 0, upd: 0;
       caEsK: // global
           I64[Sp - 8] = block_caEsI_info;
           _saAK5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saAK5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEuc; else goto caEsL;
       uaEuc: // global
           call _caEsI(R1) args: 0, res: 0, upd: 0;
       caEsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caErt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caErt: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEsI() //  [R1]
         { info_tbl: [(caEsI,
                       label: block_caEsI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caEsT; else goto caEsS;
       caEsT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEsS: // global
           _saAKa::P64 = P64[R1 + 7];
           _saAK7::I64 = I64[R1 + 15];
           _saAK8::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saAK7::I64;
           I64[Hp] = _saAK8::I64;
           I64[Sp] = block_caEsQ_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saAKa::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEsQ() //  []
         { info_tbl: [(caEsQ,
                       label: block_caEsQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEsQ: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caEsv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.855369746 UTC

[section ""data" . GHC.Event.Manager.loop4_closure" {
     GHC.Event.Manager.loop4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Event.Internal.Forever_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.858790319 UTC

[section ""data" . GHC.Event.Manager.loop3_closure" {
     GHC.Event.Manager.loop3_closure:
         const GHC.Event.Manager.loop3_info;
         const 0;
 },
 sat_saAL3_entry() //  [R1, R2, R3]
         { info_tbl: [(caEAj,
                       label: sat_saAL3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saALf_entry() //  [R1, R2, R3]
         { info_tbl: [(caEAE,
                       label: sat_saALf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saALq_entry() //  [R1, R2, R3]
         { info_tbl: [(caEAX,
                       label: sat_saALq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop3_entry() //  [R2]
         { info_tbl: [(caEB0,
                       label: GHC.Event.Manager.loop3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEB0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caEB1; else goto caEB2;
       caEB1: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEB2: // global
           I64[Sp - 8] = block_caEA4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEBM; else goto caEA5;
       uaEBM: // global
           call _caEA4(R1) args: 0, res: 0, upd: 0;
       caEA5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEA4() //  [R1]
         { info_tbl: [(caEA4,
                       label: block_caEA4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEA4: // global
           I64[Sp - 16] = block_caEA9_info;
           _saAKJ::P64 = R1;
           _saAKP::P64 = P64[R1 + 39];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saAKP::P64;
           P64[Sp] = _saAKJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEBH; else goto caEAa;
       uaEBH: // global
           call _caEA9(R1) args: 0, res: 0, upd: 0;
       caEAa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEA9() //  [R1]
         { info_tbl: [(caEA9,
                       label: block_caEA9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEA9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEB6; else goto caEB5;
       caEB6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEB5: // global
           _saAKY::P64 = P64[R1 + 7];
           _saAKZ::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_saAL3_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_caEAm_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = _saAKY::P64;
           R1 = _saAKZ::P64;
           P64[Sp - 8] = _saAKZ::P64;
           P64[Sp] = _saAKY::P64;
           Sp = Sp - 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEAm() //  [R1]
         { info_tbl: [(caEAm,
                       label: block_caEAm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAm: // global
           I64[Sp] = block_caEAo_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEBI; else goto caEAp;
       uaEBI: // global
           call _caEAo(R1) args: 0, res: 0, upd: 0;
       caEAp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEAo() //  [R1]
         { info_tbl: [(caEAo,
                       label: block_caEAo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAo: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caEBb; else goto caEBh;
       caEBb: // global
           _saALc::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caEB9_info;
           R1 = _saALc::P64;
           P64[Sp + 32] = _saALc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaEBJ; else goto caEBc;
       uaEBJ: // global
           call _caEB9() args: 0, res: 0, upd: 0;
       caEBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caEBh: // global
           I64[Sp] = block_caEAx_info;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caEB9() //  []
         { info_tbl: [(caEB9,
                       label: block_caEB9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEB9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEAx() //  []
         { info_tbl: [(caEAx,
                       label: block_caEAx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEBk; else goto caEBj;
       caEBk: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caEBj: // global
           I64[Hp - 8] = sat_saALf_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caEAH_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEAH() //  [R1]
         { info_tbl: [(caEAH,
                       label: block_caEAH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAH: // global
           I64[Sp] = block_caEAJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEBK; else goto caEAK;
       uaEBK: // global
           call _caEAJ(R1) args: 0, res: 0, upd: 0;
       caEAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEAJ() //  [R1]
         { info_tbl: [(caEAJ,
                       label: block_caEAJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEAJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEBo; else goto caEBn;
       caEBo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEBn: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caEBr; else goto caEBA;
       caEBr: // global
           Hp = Hp - 16;
           _saALo::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caEBp_info;
           R1 = _saALo::P64;
           P64[Sp + 32] = _saALo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaEBL; else goto caEBs;
       uaEBL: // global
           call _caEBp() args: 0, res: 0, upd: 0;
       caEBs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caEBA: // global
           I64[Hp - 8] = sat_saALq_info;
           P64[Hp] = P64[Sp + 32];
           _saAKY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caEBx_info;
           R4 = Hp - 5;
           R3 = GHC.Event.Manager.loop4_closure+2;
           R2 = _saAKY::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEBp() //  []
         { info_tbl: [(caEBp,
                       label: block_caEBp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEBp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEBx() //  []
         { info_tbl: [(caEBx,
                       label: block_caEBx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEBx: // global
           _saALw::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_caEBz_info;
           R1 = _saALw::P64;
           P64[Sp + 16] = _saALw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaEBN; else goto caEBC;
       uaEBN: // global
           call _caEBz() args: 0, res: 0, upd: 0;
       caEBC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEBz() //  []
         { info_tbl: [(caEBz,
                       label: block_caEBz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEBz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.88787195 UTC

[section ""data" . GHC.Event.Manager.step_closure" {
     GHC.Event.Manager.step_closure:
         const GHC.Event.Manager.step_info;
         const 0;
 },
 GHC.Event.Manager.step_entry() //  [R2]
         { info_tbl: [(caECT,
                       label: GHC.Event.Manager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caECT: // global
           R2 = R2;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.891071503 UTC

[section ""cstring" . lvl9_raAug_bytes" {
     lvl9_raAug_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.893058815 UTC

[section ""data" . GHC.Event.Manager.loop2_closure" {
     GHC.Event.Manager.loop2_closure:
         const GHC.Event.Manager.loop2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.loop2_entry() //  [R1]
         { info_tbl: [(caED9,
                       label: GHC.Event.Manager.loop2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caED9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEDa; else goto caEDb;
       caEDa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caEDb: // global
           (_caED4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caED4::I64 == 0) goto caED6; else goto caED5;
       caED6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caED5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caED4::I64;
           I64[Sp - 24] = block_caED7_info;
           R2 = lvl9_raAug_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caED7() //  [R1]
         { info_tbl: [(caED7,
                       label: block_caED7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caED7: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.89885575 UTC

[section ""data" . GHC.Event.Manager.loop8_closure" {
     GHC.Event.Manager.loop8_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.900513261 UTC

[section ""data" . GHC.Event.Manager.loop7_closure" {
     GHC.Event.Manager.loop7_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Releasing_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.903321446 UTC

[section ""data" . GHC.Event.Manager.loop6_closure" {
     GHC.Event.Manager.loop6_closure:
         const GHC.Event.Manager.loop6_info;
 },
 GHC.Event.Manager.loop6_entry() //  [R2]
         { info_tbl: [(caEDD,
                       label: GHC.Event.Manager.loop6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEDD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caEDE; else goto caEDF;
       caEDE: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEDF: // global
           I64[Sp - 8] = block_caEDv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEDT; else goto caEDw;
       uaEDT: // global
           call _caEDv(R1) args: 0, res: 0, upd: 0;
       caEDw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEDv() //  [R1]
         { info_tbl: [(caEDv,
                       label: block_caEDv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEDv: // global
           _caEDC::P64 = R1 & 7;
           if (_caEDC::P64 == 1) goto caEDA; else goto uaEDS;
       caEDA: // global
           R1 = GHC.Event.Manager.loop8_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaEDS: // global
           if (_caEDC::P64 == 4) goto caEDB; else goto caEDz;
       caEDB: // global
           R1 = GHC.Event.Manager.loop7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caEDz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caEDL; else goto caEDK;
       caEDL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEDK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.911942187 UTC

[section ""data" . GHC.Event.Manager.loop1_closure" {
     GHC.Event.Manager.loop1_closure:
         const GHC.Event.Manager.loop1_info;
         const 0;
 },
 go_saALY_entry() //  [R1]
         { info_tbl: [(caEEE,
                       label: go_saALY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caEEF; else goto uaEEY;
       caEEF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       uaEEY: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 16;
           call _caEEr() args: 0, res: 0, upd: 0;
     }
 },
 _caEEr() //  []
         { info_tbl: [(caEEr,
                       label: block_caEEr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEr: // global
           I64[Sp - 16] = block_caEEu_info;
           _saALY::P64 = P64[Sp + 8];
           _saALD::P64 = P64[_saALY::P64 + 7];
           R2 = _saALD::P64;
           P64[Sp - 8] = P64[_saALY::P64 + 15];
           P64[Sp] = _saALD::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEEu() //  [R1]
         { info_tbl: [(caEEu,
                       label: block_caEEu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEu: // global
           I64[Sp] = block_caEEw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEEZ; else goto caEEx;
       uaEEZ: // global
           call _caEEw(R1) args: 0, res: 0, upd: 0;
       caEEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEEw() //  [R1]
         { info_tbl: [(caEEw,
                       label: block_caEEw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEw: // global
           _caEED::P64 = R1 & 7;
           if (_caEED::P64 != 2) goto uaEEX; else goto caEEB;
       uaEEX: // global
           if (_caEED::P64 != 4) goto caEEA; else goto caEEC;
       caEEA: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       caEEC: // global
           I64[Sp + 24] = block_caEET_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caEEB: // global
           I64[Sp + 16] = block_caEEr_info;
           Sp = Sp + 16;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caEET() //  []
         { info_tbl: [(caEET,
                       label: block_caEET_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEET: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAMM_entry() //  [R1, R2]
         { info_tbl: [(caEF9,
                       label: sat_saAMM_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEF9: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caEFa; else goto caEFb;
       caEFa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEFb: // global
           I64[Sp - 72] = block_caEF6_info;
           _saALJ::P64 = P64[R1 + 14];
           _saALO::P64 = P64[R1 + 22];
           _saALP::P64 = P64[R1 + 30];
           _saALQ::P64 = P64[R1 + 38];
           _saALL::I64 = I64[R1 + 46];
           _saALM::I64 = I64[R1 + 54];
           _saALN::I64 = I64[R1 + 62];
           R1 = P64[R1 + 6];
           P64[Sp - 64] = _saALJ::P64;
           I64[Sp - 56] = _saALL::I64;
           I64[Sp - 48] = _saALM::I64;
           I64[Sp - 40] = _saALN::I64;
           P64[Sp - 32] = _saALO::P64;
           P64[Sp - 24] = _saALP::P64;
           P64[Sp - 16] = _saALQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaEG0; else goto caEF7;
       uaEG0: // global
           call _caEF6(R1) args: 0, res: 0, upd: 0;
       caEF7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEF6() //  [R1]
         { info_tbl: [(caEF6,
                       label: block_caEF6_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEF6: // global
           _saALJ::P64 = P64[Sp + 8];
           _saALQ::P64 = P64[Sp + 56];
           _saAM9::P64 = P64[R1 + 7];
           _saAMd::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saALJ::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saALJ::P64);
           I64[Sp] = block_caEFh_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saALQ::P64;
           P64[Sp + 8] = _saAMd::P64;
           P64[Sp + 56] = _saAM9::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEFh() //  []
         { info_tbl: [(caEFh,
                       label: block_caEFh_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEFh: // global
           _saAMd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEFj_info;
           R2 = P64[Sp + 56];
           R1 = _saAMd::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEFj() //  []
         { info_tbl: [(caEFj,
                       label: block_caEFj_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEFj: // global
           I64[Sp] = block_caEFl_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEFl() //  []
         { info_tbl: [(caEFl,
                       label: block_caEFl_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEFl: // global
           _saALM::I64 = I64[Sp + 16];
           _saALO::P64 = P64[Sp + 32];
           (_saAMs::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saAMx::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALM::I64)));
           I64[Sp + 16] = block_caEFB_info;
           R1 = _saALO::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaEG1; else goto caEFC;
       uaEG1: // global
           call _caEFB(R1) args: 0, res: 0, upd: 0;
       caEFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEFB() //  [R1]
         { info_tbl: [(caEFB,
                       label: block_caEFB_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEFB: // global
           _saALN::I64 = I64[Sp + 8];
           _saAM6::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caEFI; else goto caEFM;
       caEFI: // global
           (_saAMD::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = _saAM6::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caEFM: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saAML::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = _saAM6::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop1_entry() //  [R2]
         { info_tbl: [(caEG2,
                       label: GHC.Event.Manager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEG2: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caEG3; else goto caEG4;
       caEG3: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEG4: // global
           I64[Sp - 8] = block_caEEb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEHm; else goto caEEc;
       uaEHm: // global
           call _caEEb(R1) args: 0, res: 0, upd: 0;
       caEEc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEEb() //  [R1]
         { info_tbl: [(caEEb,
                       label: block_caEEb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEb: // global
           I64[Sp - 72] = block_caEEg_info;
           _saALD::P64 = R1;
           _saALE::P64 = P64[R1 + 7];
           _saALJ::P64 = P64[R1 + 39];
           _saALO::P64 = P64[R1 + 55];
           _saALP::P64 = P64[R1 + 63];
           _saALQ::P64 = P64[R1 + 71];
           _saALL::I64 = I64[R1 + 87];
           _saALM::I64 = I64[R1 + 95];
           _saALN::I64 = I64[R1 + 103];
           R1 = _saALQ::P64;
           P64[Sp - 64] = _saALE::P64;
           P64[Sp - 56] = _saALJ::P64;
           I64[Sp - 48] = _saALL::I64;
           I64[Sp - 40] = _saALM::I64;
           I64[Sp - 32] = _saALN::I64;
           P64[Sp - 24] = _saALO::P64;
           P64[Sp - 16] = _saALP::P64;
           P64[Sp - 8] = _saALQ::P64;
           P64[Sp] = _saALD::P64;
           Sp = Sp - 72;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEEg() //  []
         { info_tbl: [(caEEg,
                       label: block_caEEg_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEg: // global
           I64[Sp] = block_caEEi_info;
           R2 = GHC.Event.Manager.loop6_closure+1;
           R1 = P64[Sp + 16];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEEi() //  [R1]
         { info_tbl: [(caEEi,
                       label: block_caEEi_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEi: // global
           I64[Sp] = block_caEEk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEHk; else goto caEEl;
       uaEHk: // global
           call _caEEk(R1) args: 0, res: 0, upd: 0;
       caEEl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEEk() //  [R1]
         { info_tbl: [(caEEk,
                       label: block_caEEk_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEEk: // global
           _saALD::P64 = P64[Sp + 72];
           _saALE::P64 = P64[Sp + 8];
           _saALJ::P64 = P64[Sp + 16];
           _saALL::I64 = I64[Sp + 24];
           _saALM::I64 = I64[Sp + 32];
           _saALN::I64 = I64[Sp + 40];
           _saALO::P64 = P64[Sp + 48];
           _saALP::P64 = P64[Sp + 56];
           _saALQ::P64 = P64[Sp + 64];
           _caEH3::P64 = R1 & 7;
           if (_caEH3::P64 < 4) goto uaEHh; else goto uaEHj;
       uaEHh: // global
           if (_caEH3::P64 < 3) goto uaEHi; else goto caEGY;
       uaEHi: // global
           _saALX::P64 = R1;
           if (_caEH3::P64 < 2) goto caEG9; else goto caEGh;
       caEGh: // global
           I64[Sp + 8] = block_caEGf_info;
           R1 = _saALE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaEHl; else goto caEGi;
       uaEHl: // global
           call _caEGf(R1) args: 0, res: 0, upd: 0;
       caEGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caEGY: // global
           R2 = _saALD::P64;
           Sp = Sp + 80;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       uaEHj: // global
           _saALX::P64 = R1;
           if (_caEH3::P64 < 5) goto caEG9; else goto caEH2;
       caEG9: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caEGc; else goto caEGb;
       caEGc: // global
           HpAlloc = 96;
           R1 = _saALX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEGb: // global
           I64[Hp - 88] = go_saALY_info;
           P64[Hp - 80] = _saALD::P64;
           P64[Hp - 72] = _saALQ::P64;
           I64[Hp - 64] = sat_saAMM_info;
           P64[Hp - 56] = _saALE::P64;
           P64[Hp - 48] = _saALJ::P64;
           P64[Hp - 40] = _saALO::P64;
           P64[Hp - 32] = _saALP::P64;
           P64[Hp - 24] = _saALQ::P64;
           I64[Hp - 16] = _saALL::I64;
           I64[Hp - 8] = _saALM::I64;
           I64[Hp] = _saALN::I64;
           R2 = Hp - 62;
           R1 = Hp - 87;
           Sp = Sp + 80;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       caEH2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEGf() //  [R1]
         { info_tbl: [(caEGf,
                       label: block_caEGf_info
                       rep:StackRep [False, True, True, True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEGf: // global
           _saALJ::P64 = P64[Sp + 8];
           _saALQ::P64 = P64[Sp + 56];
           _saAMO::P64 = P64[R1 + 7];
           _saAMS::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saALJ::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saALJ::P64);
           I64[Sp + 8] = block_caEGp_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saALQ::P64;
           P64[Sp + 56] = _saAMS::P64;
           P64[Sp + 64] = _saAMO::P64;
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEGp() //  []
         { info_tbl: [(caEGp,
                       label: block_caEGp_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEGp: // global
           I64[Sp] = block_caEGr_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEGr() //  []
         { info_tbl: [(caEGr,
                       label: block_caEGr_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEGr: // global
           I64[Sp] = block_caEGt_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEGt() //  []
         { info_tbl: [(caEGt,
                       label: block_caEGt_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEGt: // global
           _saALM::I64 = I64[Sp + 16];
           _saALO::P64 = P64[Sp + 32];
           (_saAN7::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saANc::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALM::I64)));
           I64[Sp + 16] = block_caEGJ_info;
           R1 = _saALO::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaEHn; else goto caEGK;
       uaEHn: // global
           call _caEGJ(R1) args: 0, res: 0, upd: 0;
       caEGK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEGJ() //  [R1]
         { info_tbl: [(caEGJ,
                       label: block_caEGJ_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEGJ: // global
           _saALN::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caEGQ; else goto caEGU;
       caEGQ: // global
           (_saANi::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caEGU: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saANr::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saALN::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.954985505 UTC

[section ""data" . GHC.Event.Manager.loop_closure" {
     GHC.Event.Manager.loop_closure:
         const GHC.Event.Manager.loop_info;
         const 0;
 },
 GHC.Event.Manager.loop_entry() //  [R2]
         { info_tbl: [(caEIR,
                       label: GHC.Event.Manager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEIR: // global
           R2 = R2;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.958268753 UTC

[section ""data" . GHC.Event.Manager.closeFd_4_closure" {
     GHC.Event.Manager.closeFd_4_closure:
         const GHC.Event.Manager.closeFd_4_info;
 },
 GHC.Event.Manager.closeFd_4_entry() //  []
         { info_tbl: [(caEJ2,
                       label: GHC.Event.Manager.closeFd_4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEJ2: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.964225476 UTC

[section ""data" . GHC.Event.Manager.$wcloseFd__closure" {
     GHC.Event.Manager.$wcloseFd__closure:
         const GHC.Event.Manager.$wcloseFd__info;
         const 0;
 },
 $wgo_saANL_entry() //  [R1, R2]
         { info_tbl: [(caEJE,
                       label: $wgo_saANL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEJE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEJF; else goto caEJG;
       caEJF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEJG: // global
           I64[Sp - 24] = block_caEJx_info;
           _saANL::P64 = R1;
           _saANw::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saANw::I64;
           P64[Sp - 8] = _saANL::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaEK3; else goto caEJy;
       uaEK3: // global
           call _caEJx(R1) args: 0, res: 0, upd: 0;
       caEJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEJx() //  [R1]
         { info_tbl: [(caEJx,
                       label: block_caEJx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEJx: // global
           if (R1 & 7 == 1) goto caEJB; else goto caEJC;
       caEJB: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caEJC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEJO; else goto caEJN;
       caEJO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEJN: // global
           _saANP::P64 = P64[R1 + 6];
           _saANQ::P64 = P64[R1 + 14];
           _saANO::I64 = I64[R1 + 22];
           if (_saANO::I64 == I64[Sp + 8]) goto caEK2; else goto caEJW;
       caEK2: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saANP::P64;
           R3 = _saANQ::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caEJW: // global
           Hp = Hp - 16;
           I64[Sp] = block_caEJS_info;
           R2 = _saANQ::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saANP::P64;
           I64[Sp + 16] = _saANO::I64;
           call $wgo_saANL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEJS() //  [R1, R2, R3]
         { info_tbl: [(caEJS,
                       label: block_caEJS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEJS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caEJZ; else goto caEJY;
       caEJZ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caEJY: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAOy_entry() //  [R1]
         { info_tbl: [(caEKH,
                       label: sat_saAOy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKH: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAOz_entry() //  [R1]
         { info_tbl: [(caEKR,
                       label: sat_saAOz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKR: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.$wcloseFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caEKU,
                       label: GHC.Event.Manager.$wcloseFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKU: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caEKV; else goto caEKW;
       caEKV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$wcloseFd__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caEKW: // global
           I64[Sp - 24] = block_caEJe_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaELX; else goto caEJf;
       uaELX: // global
           call _caEJe(R1) args: 0, res: 0, upd: 0;
       caEJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEJe() //  [R1]
         { info_tbl: [(caEJe,
                       label: block_caEJe_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEJe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEKZ; else goto caEKY;
       caEKZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEKY: // global
           _saANw::I64 = I64[Sp + 16];
           _saANC::P64 = P64[R1 + 7];
           _saANE::P64 = P64[R1 + 15];
           _saAND::I64 = I64[R1 + 23];
           _saANF::I64 = _saANw::I64 & (I64[_saANC::P64 + 8] - 1);
           _saANK::P64 = P64[(_saANC::P64 + 24) + (_saANF::I64 << 3)];
           I64[Hp - 8] = $wgo_saANL_info;
           I64[Hp] = _saANw::I64;
           I64[Sp - 32] = block_caEK4_info;
           R2 = _saANK::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saAND::I64;
           P64[Sp - 16] = _saANE::P64;
           I64[Sp - 8] = _saANF::I64;
           P64[Sp] = _saANC::P64;
           Sp = Sp - 32;
           call $wgo_saANL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEK4() //  [R1, R2, R3]
         { info_tbl: [(caEK4,
                       label: block_caEK4_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEK4: // global
           I64[Sp - 16] = block_caEL0_info;
           _saANZ::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saANZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaELU; else goto caELn;
       uaELU: // global
           call _caEL0(R1) args: 0, res: 0, upd: 0;
       caELn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEL0() //  [R1]
         { info_tbl: [(caEL0,
                       label: block_caEL0_info
                       rep:StackRep [False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEL0: // global
           if (R1 & 7 == 1) goto caELt; else goto caELy;
       caELt: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAO2() args: 0, res: 0, upd: 0;
       caELy: // global
           _saANC::P64 = P64[Sp + 48];
           _saANF::I64 = I64[Sp + 40];
           _saANZ::P64 = P64[Sp + 16];
           _saAO1::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saANC::P64 + 24) + (_saANF::I64 << 3)] = _saAO1::P64;
           I64[_saANC::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saANC::P64 + 24) + ((I64[_saANC::P64 + 8] << 3) + (_saANF::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caELw_info;
           _saAOA::P64 = R1;
           R1 = _saANZ::P64;
           P64[Sp + 48] = _saAOA::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaELY; else goto caELz;
       uaELY: // global
           call _caELw(R1) args: 0, res: 0, upd: 0;
       caELz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caELw() //  [R1]
         { info_tbl: [(caELw,
                       label: block_caELw_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caELw: // global
           _saAOA::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caELF; else goto caELJ;
       caELF: // global
           P64[Sp + 32] = _saAOA::P64;
           Sp = Sp + 32;
           goto uaEM1;
       caELJ: // global
           _saAND::I64 = I64[Sp + 8];
           _saANE::P64 = P64[Sp + 16];
           I64[_saAND::I64] = I64[_saAND::I64] - 1;
           call MO_Touch(_saANE::P64);
           P64[Sp + 32] = _saAOA::P64;
           Sp = Sp + 32;
           goto uaEM1;
       uaEM1: // global
           call _saAO2() args: 0, res: 0, upd: 0;
     }
 },
 _saAO2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAO2: // global
           _saAO4::P64 = P64[Sp];
           I64[Sp] = block_caEKb_info;
           R1 = _saAO4::P64;
           if (R1 & 7 != 0) goto uaEM2; else goto caEKc;
       uaEM2: // global
           call _caEKb(R1) args: 0, res: 0, upd: 0;
       caEKc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEKb() //  [R1]
         { info_tbl: [(caEKb,
                       label: block_caEKb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKb: // global
           if (R1 & 7 == 1) goto caEL6; else goto caEL8;
       caEL6: // global
           R1 = GHC.Event.Manager.closeFd_4_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caEL8: // global
           I64[Sp - 8] = block_caEKh_info;
           _saAO6::P64 = P64[R1 + 6];
           R2 = _saAO6::P64;
           P64[Sp] = _saAO6::P64;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEKh() //  [R1]
         { info_tbl: [(caEKh,
                       label: block_caEKh_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKh: // global
           if (R1 == 0) goto caELj; else goto caELb;
       caELj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caELm; else goto caELl;
       caELm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caELl: // global
           I64[Hp - 8] = sat_saAOz_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caELb: // global
           I64[Sp] = block_caEKl_info;
           _saAO7::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saAO7::I64;
           if (R1 & 7 != 0) goto uaELV; else goto caEKm;
       uaELV: // global
           call _caEKl(R1) args: 0, res: 0, upd: 0;
       caEKm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEKl() //  [R1]
         { info_tbl: [(caEKl,
                       label: block_caEKl_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKl: // global
           I64[Sp] = block_caEKq_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uaELW; else goto caEKr;
       uaELW: // global
           call _caEKq(R1) args: 0, res: 0, upd: 0;
       caEKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEKq() //  [R1]
         { info_tbl: [(caEKq,
                       label: block_caEKq_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caELf; else goto caELe;
       caELf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caELe: // global
           _saAOn::P64 = P64[R1 + 7];
           _saAOp::P64 = P64[R1 + 23];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 16] & 7;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_caEKA_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAOn::P64;
           R1 = _saAOp::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caEKA() //  [R1]
         { info_tbl: [(caEKA,
                       label: block_caEKA_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEKA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caELi; else goto caELh;
       caELi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caELh: // global
           I64[Hp - 8] = sat_saAOy_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:33.997655017 UTC

[section ""data" . GHC.Event.Manager.closeFd_1_closure" {
     GHC.Event.Manager.closeFd_1_closure:
         const GHC.Event.Manager.closeFd_1_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_1_entry() //  [R2, R3, R4]
         { info_tbl: [(caENx,
                       label: GHC.Event.Manager.closeFd_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caENx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caENB; else goto caENC;
       caENB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caENC: // global
           I64[Sp - 24] = block_caENu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaENK; else goto caENv;
       uaENK: // global
           call _caENu(R1) args: 0, res: 0, upd: 0;
       caENv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caENu() //  [R1]
         { info_tbl: [(caENu,
                       label: block_caENu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caENu: // global
           I64[Sp] = block_caENA_info;
           _saAOP::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _saAOP::P64;
           if (R1 & 7 != 0) goto uaENJ; else goto caENE;
       uaENJ: // global
           call _caENA(R1) args: 0, res: 0, upd: 0;
       caENE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caENA() //  [R1]
         { info_tbl: [(caENA,
                       label: block_caENA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caENA: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.004627964 UTC

[section ""data" . GHC.Event.Manager.closeFd__closure" {
     GHC.Event.Manager.closeFd__closure:
         const GHC.Event.Manager.closeFd__info;
         const 0;
 },
 GHC.Event.Manager.closeFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caEO2,
                       label: GHC.Event.Manager.closeFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEO2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd_1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.007820497 UTC

[section ""data" . lvl10_raAuh_closure" {
     lvl10_raAuh_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.009854661 UTC

[section ""data" . lvl11_raAui_closure" {
     lvl11_raAui_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.011538664 UTC

[section ""data" . lvl12_raAuj_closure" {
     lvl12_raAuj_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.022494834 UTC

[section ""data" . registerFd1_raAuk_closure" {
     registerFd1_raAuk_closure:
         const registerFd1_raAuk_info;
         const 0;
 },
 $wgo_saAQj_entry() //  [R1, R2]
         { info_tbl: [(caEQq,
                       label: $wgo_saAQj_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEQr; else goto caEQs;
       caEQr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEQs: // global
           I64[Sp - 24] = block_caEQj_info;
           _saAQj::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAPq::I64;
           P64[Sp - 8] = _saAQj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaEQP; else goto caEQk;
       uaEQP: // global
           call _caEQj(R1) args: 0, res: 0, upd: 0;
       caEQk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEQj() //  [R1]
         { info_tbl: [(caEQj,
                       label: block_caEQj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQj: // global
           if (R1 & 7 == 1) goto caEQn; else goto caEQo;
       caEQn: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caEQo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caEQA; else goto caEQz;
       caEQA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEQz: // global
           _saAQn::P64 = P64[R1 + 6];
           _saAQo::P64 = P64[R1 + 14];
           _saAQm::I64 = I64[R1 + 22];
           if (_saAQm::I64 == I64[Sp + 8]) goto caEQO; else goto caEQI;
       caEQO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAQn::P64;
           R3 = _saAQo::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caEQI: // global
           Hp = Hp - 16;
           I64[Sp] = block_caEQE_info;
           R2 = _saAQo::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saAQn::P64;
           I64[Sp + 16] = _saAQm::I64;
           call $wgo_saAQj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEQE() //  [R1, R2, R3]
         { info_tbl: [(caEQE,
                       label: block_caEQE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caEQL; else goto caEQK;
       caEQL: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caEQK: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saAR8_entry() //  [R1, R2]
         { info_tbl: [(caERA,
                       label: $wgo_saAR8_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caERA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caERB; else goto caERC;
       caERB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caERC: // global
           I64[Sp - 24] = block_caERt_info;
           _saAR8::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saAPq::I64;
           P64[Sp - 8] = _saAR8::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaERZ; else goto caERu;
       uaERZ: // global
           call _caERt(R1) args: 0, res: 0, upd: 0;
       caERu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caERt() //  [R1]
         { info_tbl: [(caERt,
                       label: block_caERt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caERt: // global
           if (R1 & 7 == 1) goto caERx; else goto caERy;
       caERx: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caERy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caERK; else goto caERJ;
       caERK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caERJ: // global
           _saARc::P64 = P64[R1 + 6];
           _saARd::P64 = P64[R1 + 14];
           _saARb::I64 = I64[R1 + 22];
           if (_saARb::I64 == I64[Sp + 8]) goto caERY; else goto caERS;
       caERY: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saARc::P64;
           R3 = _saARd::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caERS: // global
           Hp = Hp - 16;
           I64[Sp] = block_caERO_info;
           R2 = _saARd::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saARc::P64;
           I64[Sp + 16] = _saARb::I64;
           call $wgo_saAR8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caERO() //  [R1, R2, R3]
         { info_tbl: [(caERO,
                       label: block_caERO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caERO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caERV; else goto caERU;
       caERV: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caERU: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saAPK_entry() //  [R1, R2]
         { info_tbl: [(caES7,
                       label: $wio_saAPK_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caES7: // global
           _saAPL::P64 = R2;
           _saAPK::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caES8; else goto caES9;
       caES9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caESb; else goto caESa;
       caESb: // global
           HpAlloc = 64;
           goto caES8;
       caES8: // global
           R2 = _saAPL::P64;
           R1 = _saAPK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caESa: // global
           _saAPh::P64 = P64[_saAPK::P64 + 6];
           _saAPj::P64 = P64[_saAPK::P64 + 14];
           _saAPk::P64 = P64[_saAPK::P64 + 22];
           _saAPp::P64 = P64[_saAPK::P64 + 30];
           _saAPv::P64 = P64[_saAPK::P64 + 38];
           _saAPo::I64 = I64[_saAPK::P64 + 46];
           _saAPq::I64 = I64[_saAPK::P64 + 54];
           _saAPu::I64 = I64[_saAPK::P64 + 62];
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = _saAPv::P64;
           I64[Hp - 40] = _saAPq::I64;
           I64[Hp - 32] = _saAPo::I64;
           I64[Hp - 24] = _saAPu::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caEPm_info;
           R5 = _saAPL::P64;
           R4 = Hp - 14;
           R3 = _saAPq::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saAPh::P64;
           P64[Sp - 48] = _saAPj::P64;
           P64[Sp - 40] = _saAPk::P64;
           P64[Sp - 32] = _saAPp::P64;
           I64[Sp - 24] = _saAPq::I64;
           I64[Sp - 16] = _saAPu::I64;
           P64[Sp - 8] = _saAPL::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEPm() //  [R1]
         { info_tbl: [(caEPm,
                       label: block_caEPm_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEPm: // global
           I64[Sp - 8] = block_caES0_info;
           _saAPR::P64 = R1;
           R1 = R1;
           P64[Sp] = _saAPR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEUz; else goto caES1;
       uaEUz: // global
           call _caES0(R1) args: 0, res: 0, upd: 0;
       caES1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caES0() //  [R1]
         { info_tbl: [(caES0,
                       label: block_caES0_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caES0: // global
           if (R1 & 7 == 1) goto caES4; else goto caES5;
       caES4: // global
           I64[Sp] = 0;
           call _saAPS() args: 0, res: 0, upd: 0;
       caES5: // global
           I64[Sp] = block_caEU3_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEU3() //  [R1]
         { info_tbl: [(caEU3,
                       label: block_caEU3_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEU3: // global
           I64[Sp] = R1;
           call _saAPS() args: 0, res: 0, upd: 0;
     }
 },
 _saAPS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAPS: // global
           _saAPU::I64 = I64[Sp] | I64[Sp + 56];
           _saAPV::I64 = _saAPU::I64 & 8;
           if (_saAPV::I64 != 0) goto uaEUs; else goto uaEUr;
       uaEUs: // global
           I64[Sp + 32] = _saAPV::I64;
           I64[Sp + 56] = _saAPU::I64;
           call _caEPA() args: 0, res: 0, upd: 0;
       uaEUr: // global
           I64[Sp + 24] = _saAPV::I64;
           I64[Sp + 56] = _saAPU::I64;
           Sp = Sp + 8;
           call _caEQS() args: 0, res: 0, upd: 0;
     }
 },
 _caEPA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEPA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caESi; else goto caESh;
       caESi: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caEPz_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caESh: // global
           _saAPT::I64 = I64[Sp];
           _saAPU::I64 = I64[Sp + 56];
           if (_saAPT::I64 == _saAPU::I64) goto caESk; else goto caESl;
       caESk: // global
           Hp = Hp - 32;
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caESl: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAPU::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAPT::I64 & 7;
           I64[Sp] = block_caEPO_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caEPz() //  [R1]
         { info_tbl: [(caEPz,
                       label: block_caEPz_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEPz: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caEPA() args: 0, res: 0, upd: 0;
     }
 },
 _caEPO() //  [R1]
         { info_tbl: [(caEPO,
                       label: block_caEPO_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEPO: // global
           I64[Sp] = block_caEPQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEUB; else goto caEPR;
       uaEUB: // global
           call _caEPQ(R1) args: 0, res: 0, upd: 0;
       caEPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEPQ() //  [R1]
         { info_tbl: [(caEPQ,
                       label: block_caEPQ_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEPQ: // global
           if (R1 & 7 == 1) goto caESp; else goto caET7;
       caESp: // global
           I64[Sp + 40] = block_caEPV_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaEUC; else goto caEPW;
       uaEUC: // global
           call _caEPV(R1) args: 0, res: 0, upd: 0;
       caEPW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caET7: // global
           R1 = lvl12_raAuj_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEPV() //  [R1]
         { info_tbl: [(caEPV,
                       label: block_caEPV_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEPV: // global
           _saAPL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caESs; else goto caET1;
       caESs: // global
           I64[Sp] = block_caEQ0_info;
           R1 = P64[_saAPL::P64 + 8];
           if (R1 & 7 != 0) goto uaEUD; else goto caEQ1;
       uaEUD: // global
           call _caEQ0(R1) args: 0, res: 0, upd: 0;
       caEQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caET1: // global
           I64[Sp + 24] = block_caESZ_info;
           R5 = _saAPL::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caEQ0() //  [R1]
         { info_tbl: [(caEQ0,
                       label: block_caEQ0_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQ0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caESv; else goto caESu;
       caESv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caESu: // global
           _saAPq::I64 = I64[Sp + 8];
           _saAQa::P64 = P64[R1 + 7];
           _saAQc::P64 = P64[R1 + 15];
           _saAQb::I64 = I64[R1 + 23];
           _saAQd::I64 = _saAPq::I64 & (I64[_saAQa::P64 + 8] - 1);
           _saAQi::P64 = P64[(_saAQa::P64 + 24) + (_saAQd::I64 << 3)];
           I64[Hp - 8] = $wgo_saAQj_info;
           I64[Hp] = _saAPq::I64;
           I64[Sp - 8] = block_caESw_info;
           R2 = _saAQi::P64;
           R1 = Hp - 7;
           I64[Sp] = _saAQd::I64;
           P64[Sp + 8] = _saAQc::P64;
           I64[Sp + 16] = _saAQb::I64;
           P64[Sp + 24] = _saAQa::P64;
           Sp = Sp - 8;
           call $wgo_saAQj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caESw() //  [R1, R2, R3]
         { info_tbl: [(caESw,
                       label: block_caESw_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caESw: // global
           I64[Sp - 16] = block_caESy_info;
           _saAQx::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAQx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEUJ; else goto caESA;
       uaEUJ: // global
           call _caESy(R1) args: 0, res: 0, upd: 0;
       caESA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caESy() //  [R1]
         { info_tbl: [(caESy,
                       label: block_caESy_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caESy: // global
           if (R1 & 7 == 1) goto uaEUu; else goto caESL;
       uaEUu: // global
           Sp = Sp + 56;
           call _caETI() args: 0, res: 0, upd: 0;
       caESL: // global
           _saAQa::P64 = P64[Sp + 48];
           _saAQd::I64 = I64[Sp + 24];
           _saAQx::P64 = P64[Sp + 16];
           _saAQz::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAQa::P64 + 24) + (_saAQd::I64 << 3)] = _saAQz::P64;
           I64[_saAQa::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAQa::P64 + 24) + ((I64[_saAQa::P64 + 8] << 3) + (_saAQd::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caESJ_info;
           R1 = _saAQx::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaEUK; else goto caESM;
       uaEUK: // global
           call _caESJ(R1) args: 0, res: 0, upd: 0;
       caESM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caESJ() //  [R1]
         { info_tbl: [(caESJ,
                       label: block_caESJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caESJ: // global
           if (R1 & 7 == 1) goto uaEUv; else goto caESW;
       uaEUv: // global
           Sp = Sp + 32;
           call _caETI() args: 0, res: 0, upd: 0;
       caESW: // global
           _saAQb::I64 = I64[Sp + 16];
           _saAQc::P64 = P64[Sp + 8];
           I64[_saAQb::I64] = I64[_saAQb::I64] - 1;
           call MO_Touch(_saAQc::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caESZ() //  []
         { info_tbl: [(caESZ,
                       label: block_caESZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caESZ: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEQS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caETb; else goto caETa;
       caETb: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caEQR_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caETa: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caEQY_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEQR() //  [R1]
         { info_tbl: [(caEQR,
                       label: block_caEQR_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQR: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caEQS() args: 0, res: 0, upd: 0;
     }
 },
 _caEQY() //  [R1]
         { info_tbl: [(caEQY,
                       label: block_caEQY_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEQY: // global
           I64[Sp] = block_caER0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEUF; else goto caER1;
       uaEUF: // global
           call _caER0(R1) args: 0, res: 0, upd: 0;
       caER1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caER0() //  [R1]
         { info_tbl: [(caER0,
                       label: block_caER0_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caER0: // global
           if (R1 & 7 == 1) goto caETf; else goto caETX;
       caETf: // global
           I64[Sp + 40] = block_caER5_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaEUG; else goto caER6;
       uaEUG: // global
           call _caER5(R1) args: 0, res: 0, upd: 0;
       caER6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caETX: // global
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caER5() //  [R1]
         { info_tbl: [(caER5,
                       label: block_caER5_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caER5: // global
           _saAPL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caETi; else goto caETR;
       caETi: // global
           I64[Sp] = block_caERa_info;
           R1 = P64[_saAPL::P64 + 8];
           if (R1 & 7 != 0) goto uaEUH; else goto caERb;
       uaEUH: // global
           call _caERa(R1) args: 0, res: 0, upd: 0;
       caERb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caETR: // global
           I64[Sp + 24] = block_caETP_info;
           R5 = _saAPL::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caERa() //  [R1]
         { info_tbl: [(caERa,
                       label: block_caERa_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caERa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caETl; else goto caETk;
       caETl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caETk: // global
           _saAPq::I64 = I64[Sp + 8];
           _saAQZ::P64 = P64[R1 + 7];
           _saAR1::P64 = P64[R1 + 15];
           _saAR0::I64 = I64[R1 + 23];
           _saAR2::I64 = _saAPq::I64 & (I64[_saAQZ::P64 + 8] - 1);
           _saAR7::P64 = P64[(_saAQZ::P64 + 24) + (_saAR2::I64 << 3)];
           I64[Hp - 8] = $wgo_saAR8_info;
           I64[Hp] = _saAPq::I64;
           I64[Sp - 8] = block_caETm_info;
           R2 = _saAR7::P64;
           R1 = Hp - 7;
           I64[Sp] = _saAR2::I64;
           P64[Sp + 8] = _saAR1::P64;
           I64[Sp + 16] = _saAR0::I64;
           P64[Sp + 24] = _saAQZ::P64;
           Sp = Sp - 8;
           call $wgo_saAR8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caETm() //  [R1, R2, R3]
         { info_tbl: [(caETm,
                       label: block_caETm_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caETm: // global
           I64[Sp - 16] = block_caETo_info;
           _saARm::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saARm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEUN; else goto caETq;
       uaEUN: // global
           call _caETo(R1) args: 0, res: 0, upd: 0;
       caETq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caETo() //  [R1]
         { info_tbl: [(caETo,
                       label: block_caETo_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caETo: // global
           if (R1 & 7 == 1) goto uaEUx; else goto caETB;
       uaEUx: // global
           Sp = Sp + 56;
           call _caETI() args: 0, res: 0, upd: 0;
       caETB: // global
           _saAQZ::P64 = P64[Sp + 48];
           _saAR2::I64 = I64[Sp + 24];
           _saARm::P64 = P64[Sp + 16];
           _saARo::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saAQZ::P64 + 24) + (_saAR2::I64 << 3)] = _saARo::P64;
           I64[_saAQZ::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saAQZ::P64 + 24) + ((I64[_saAQZ::P64 + 8] << 3) + (_saAR2::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caETz_info;
           R1 = _saARm::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaEUO; else goto caETC;
       uaEUO: // global
           call _caETz(R1) args: 0, res: 0, upd: 0;
       caETC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caETz() //  [R1]
         { info_tbl: [(caETz,
                       label: block_caETz_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caETz: // global
           if (R1 & 7 == 1) goto uaEUy; else goto caETM;
       uaEUy: // global
           Sp = Sp + 32;
           call _caETI() args: 0, res: 0, upd: 0;
       caETM: // global
           _saAR0::I64 = I64[Sp + 16];
           _saAR1::P64 = P64[Sp + 8];
           I64[_saAR0::I64] = I64[_saAR0::I64] - 1;
           call MO_Touch(_saAR1::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caETI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caETI: // global
           R1 = lvl10_raAuh_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caETP() //  []
         { info_tbl: [(caETP,
                       label: block_caETP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caETP: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saARG_entry() //  [R1, R2]
         { info_tbl: [(caEV2,
                       label: io_saARG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEV2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEV3; else goto caEV4;
       caEV3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEV4: // global
           I64[Sp - 16] = block_caEUZ_info;
           _saAPK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saAPK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEV8; else goto caEV0;
       uaEV8: // global
           call _caEUZ(R1) args: 0, res: 0, upd: 0;
       caEV0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEUZ() //  [R1]
         { info_tbl: [(caEUZ,
                       label: block_caEUZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEUZ: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saAPK_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARU_entry() //  [R1, R2]
         { info_tbl: [(caEVk,
                       label: sat_saARU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEVl; else goto caEVm;
       caEVl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEVm: // global
           I64[Sp - 16] = block_caEVi_info;
           _saARR::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saARR::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEVi() //  []
         { info_tbl: [(caEVi,
                       label: block_caEVi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARP_entry() //  [R1]
         { info_tbl: [(caEVt,
                       label: sat_saARP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVt: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saARQ_entry() //  [R1]
         { info_tbl: [(caEVB,
                       label: sat_saARQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVB: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASh_entry() //  [R1, R2]
         { info_tbl: [(caEVT,
                       label: sat_saASh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEVU; else goto caEVV;
       caEVU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEVV: // global
           I64[Sp - 16] = block_caEVR_info;
           _saASe::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saASe::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEVR() //  []
         { info_tbl: [(caEVR,
                       label: block_caEVR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASc_entry() //  [R1]
         { info_tbl: [(caEW2,
                       label: sat_saASc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEW2: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASd_entry() //  [R1]
         { info_tbl: [(caEWa,
                       label: sat_saASd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWa: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASm_entry() //  [R1]
         { info_tbl: [(caEWh,
                       label: sat_saASm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caEWi; else goto caEWj;
       caEWi: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caEWj: // global
           I64[Sp - 24] = block_caEVK_info;
           _saAPI::P64 = P64[R1 + 7];
           _saARG::P64 = P64[R1 + 15];
           R1 = _saAPI::P64;
           P64[Sp - 16] = _saAPI::P64;
           P64[Sp - 8] = _saARG::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEVK() //  [R1]
         { info_tbl: [(caEVK,
                       label: block_caEVK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEWm; else goto caEWl;
       caEWm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEWl: // global
           I64[Hp - 56] = sat_saASh_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saASc_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saASd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEWd_info;
           R2 = Hp - 54;
           _saASb::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saASb::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEWd() //  [R1]
         { info_tbl: [(caEWd,
                       label: block_caEWd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWd: // global
           _saAPI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEWf_info;
           R2 = P64[Sp + 16];
           _saASk::P64 = R1;
           R1 = _saAPI::P64;
           P64[Sp + 16] = _saASk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEWf() //  []
         { info_tbl: [(caEWf,
                       label: block_caEWf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASH_entry() //  [R1, R2]
         { info_tbl: [(caEWz,
                       label: sat_saASH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caEWA; else goto caEWB;
       caEWA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caEWB: // global
           I64[Sp - 16] = block_caEWx_info;
           _saASE::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saASE::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEWx() //  []
         { info_tbl: [(caEWx,
                       label: block_caEWx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASC_entry() //  [R1]
         { info_tbl: [(caEWI,
                       label: sat_saASC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWI: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saARG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saASD_entry() //  [R1]
         { info_tbl: [(caEWQ,
                       label: sat_saASD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWQ: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 registerFd1_raAuk_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caEWT,
                       label: registerFd1_raAuk_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWT: // global
           if ((Sp + -120) < SpLim) (likely: False) goto caEWU; else goto caEWV;
       caEWU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = registerFd1_raAuk_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caEWV: // global
           I64[Sp - 40] = block_caEOg_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaEZD; else goto caEOh;
       uaEZD: // global
           call _caEOg(R1) args: 0, res: 0, upd: 0;
       caEOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOg() //  [R1]
         { info_tbl: [(caEOg,
                       label: block_caEOg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOg: // global
           I64[Sp - 32] = block_caEOl_info;
           _saAOZ::P64 = P64[R1 + 7];
           _saAP1::P64 = P64[R1 + 23];
           _saAP3::P64 = P64[R1 + 31];
           _saAP5::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _saAP1::P64;
           P64[Sp - 16] = _saAP3::P64;
           P64[Sp - 8] = _saAP5::P64;
           P64[Sp] = _saAOZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaEZw; else goto caEOm;
       uaEZw: // global
           call _caEOl(R1) args: 0, res: 0, upd: 0;
       caEOm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOl() //  [R1]
         { info_tbl: [(caEOl,
                       label: block_caEOl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOl: // global
           I64[Sp - 8] = block_caEOq_info;
           _saAPc::P64 = R1;
           _saAPd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saAPd::I64;
           P64[Sp + 8] = _saAPc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEZx; else goto caEOr;
       uaEZx: // global
           call _caEOq(R1) args: 0, res: 0, upd: 0;
       caEOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOq() //  [R1]
         { info_tbl: [(caEOq,
                       label: block_caEOq_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOq: // global
           I64[Sp - 8] = block_caEOv_info;
           _saAPe::P64 = R1;
           _saAPf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saAPf::I64;
           P64[Sp + 40] = _saAPe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEZy; else goto caEOw;
       uaEZy: // global
           call _caEOv(R1) args: 0, res: 0, upd: 0;
       caEOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOv() //  [R1]
         { info_tbl: [(caEOv,
                       label: block_caEOv_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOv: // global
           _saAOU::P64 = P64[Sp + 64];
           _saAPh::P64 = P64[R1 + 7];
           _saAPj::P64 = P64[R1 + 23];
           _saAPk::P64 = P64[R1 + 31];
           (_saAPo::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 40] + 16, 1);
           I64[Sp - 16] = block_caEOC_info;
           R1 = _saAOU::P64;
           I64[Sp - 8] = _saAPo::I64;
           P64[Sp] = _saAPk::P64;
           P64[Sp + 40] = _saAPj::P64;
           P64[Sp + 64] = _saAPh::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaEZz; else goto caEOD;
       uaEZz: // global
           call _caEOC(R1) args: 0, res: 0, upd: 0;
       caEOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOC() //  [R1]
         { info_tbl: [(caEOC,
                       label: block_caEOC_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOC: // global
           I64[Sp - 8] = block_caEOH_info;
           _saAPp::P64 = R1;
           _saAPq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saAPq::I64;
           P64[Sp + 88] = _saAPp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEZA; else goto caEOI;
       uaEZA: // global
           call _caEOH(R1) args: 0, res: 0, upd: 0;
       caEOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOH() //  [R1]
         { info_tbl: [(caEOH,
                       label: block_caEOH_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOH: // global
           I64[Sp - 8] = block_caEX1_info;
           _saAPr::P64 = R1;
           _saAPs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 104];
           I64[Sp] = _saAPs::I64;
           P64[Sp + 104] = _saAPr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaEZB; else goto caEZf;
       uaEZB: // global
           call _caEX1(R1) args: 0, res: 0, upd: 0;
       caEZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEX1() //  [R1]
         { info_tbl: [(caEX1,
                       label: block_caEX1_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEX1: // global
           _saAOT::P64 = P64[Sp + 88];
           _saAPs::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caEZl; else goto caEZp;
       caEZl: // global
           _saAPu::I64 = _saAPs::I64;
           goto saAPt;
       caEZp: // global
           _saAPu::I64 = _saAPs::I64 | 8;
           goto saAPt;
       saAPt: // global
           I64[Sp + 8] = block_caEOR_info;
           R1 = _saAOT::P64;
           I64[Sp + 88] = _saAPu::I64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEOR() //  [R1]
         { info_tbl: [(caEOR,
                       label: block_caEOR_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOR: // global
           I64[Sp - 8] = block_caEOT_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caEOT() //  [R1]
         { info_tbl: [(caEOT,
                       label: block_caEOT_info
                       rep:StackRep [False, True, True, False, True, True, False, False,
                                     False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEOT: // global
           _saAPc::P64 = P64[Sp + 56];
           _saAPd::I64 = I64[Sp + 48];
           _saAPe::P64 = P64[Sp + 80];
           _saAPz::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saAPd::I64,
                            _saAPz::I64)) goto caEX9; else goto caEZe;
       caEZe: // global
           if (%MO_S_Gt_W64(_saAPz::I64,
                            I64[Sp + 40])) goto caEX9; else goto caEXa;
       caEX9: // global
           R4 = _saAPz::I64;
           R3 = _saAPc::P64;
           R2 = _saAPe::P64;
           Sp = Sp + 120;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caEXa: // global
           _saAPG::P64 = P64[P64[Sp + 64] + ((_saAPz::I64 - _saAPd::I64 << 3) + 24)];
           I64[Sp] = block_caEP9_info;
           _saAPy::I64 = R1;
           R1 = _saAPG::P64;
           I64[Sp + 80] = _saAPy::I64;
           if (R1 & 7 != 0) goto uaEZC; else goto caEPa;
       uaEZC: // global
           call _caEP9(R1) args: 0, res: 0, upd: 0;
       caEPa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEP9() //  [R1]
         { info_tbl: [(caEP9,
                       label: block_caEP9_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEP9: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto caEXd; else goto caEXc;
       caEXd: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEXc: // global
           _saAPI::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.Event.Manager.FdKey_con_info;
           _saAPq::I64 = I64[Sp + 16];
           I64[Hp - 120] = _saAPq::I64;
           _saAPo::I64 = I64[Sp + 24];
           I64[Hp - 112] = _saAPo::I64;
           I64[Hp - 104] = $wio_saAPK_info;
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = _saAPo::I64;
           I64[Hp - 48] = _saAPq::I64;
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = io_saARG_info;
           P64[Hp - 24] = Hp - 102;
           _caEPe::P64 = Hp - 127;
           _caEUU::P64 = Hp - 30;
           _saARL::I64 = I64[Sp + 80];
           if (_saARL::I64 != 0) goto uaEZv; else goto caEXZ;
       uaEZv: // global
           if (_saARL::I64 != 1) goto caEXk; else goto caEYC;
       caEXk: // global
           Hp = Hp - 24;
           I64[Sp] = block_caEVb_info;
           R1 = _saAPI::P64;
           P64[Sp + 88] = _saAPI::P64;
           P64[Sp + 96] = _caEUU::P64;
           P64[Sp + 104] = _caEPe::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caEYC: // global
           Hp = Hp - 24;
           I64[Sp] = block_caEWq_info;
           R1 = _saAPI::P64;
           P64[Sp + 88] = _saAPI::P64;
           P64[Sp + 96] = _caEUU::P64;
           P64[Sp + 104] = _caEPe::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caEXZ: // global
           I64[Hp - 16] = sat_saASm_info;
           P64[Hp - 8] = _saAPI::P64;
           P64[Hp] = _caEUU::P64;
           I64[Sp] = block_caEXW_info;
           R1 = Hp - 15;
           P64[Sp + 104] = _caEPe::P64;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEVb() //  [R1]
         { info_tbl: [(caEVb,
                       label: block_caEVb_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEVb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEXn; else goto caEXm;
       caEXn: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEXm: // global
           I64[Hp - 56] = sat_saARU_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saARP_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saARQ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEXe_info;
           R2 = Hp - 54;
           _saARO::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saARO::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXe() //  [R1]
         { info_tbl: [(caEXe,
                       label: block_caEXe_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXe: // global
           I64[Sp] = block_caEXg_info;
           R2 = P64[Sp + 96];
           _saARX::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saARX::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXg() //  []
         { info_tbl: [(caEXg,
                       label: block_caEXg_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXg: // global
           I64[Sp] = block_caEXi_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaEZE; else goto caEXq;
       uaEZE: // global
           call _caEXi(R1) args: 0, res: 0, upd: 0;
       caEXq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXi() //  [R1]
         { info_tbl: [(caEXi,
                       label: block_caEXi_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXi: // global
           I64[Sp] = block_caEXu_info;
           _saAS0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saAS0::P64;
           if (R1 & 7 != 0) goto uaEZF; else goto caEXw;
       uaEZF: // global
           call _caEXu(R1) args: 0, res: 0, upd: 0;
       caEXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXu() //  [R1]
         { info_tbl: [(caEXu,
                       label: block_caEXu_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXu: // global
           if (R1 & 7 == 1) goto caEXF; else goto caEXQ;
       caEXF: // global
           I64[Sp + 88] = block_caEXA_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caEXQ: // global
           _saAS0::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caEXO_info;
           R1 = _saAS0::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaEZG; else goto caEXR;
       uaEZG: // global
           call _caEXO() args: 0, res: 0, upd: 0;
       caEXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXA() //  []
         { info_tbl: [(caEXA,
                       label: block_caEXA_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXA: // global
           _saAS0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEXC_info;
           R1 = _saAS0::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaEZH; else goto caEXH;
       uaEZH: // global
           call _caEXC() args: 0, res: 0, upd: 0;
       caEXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXC() //  []
         { info_tbl: [(caEXC,
                       label: block_caEXC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEXO() //  []
         { info_tbl: [(caEXO,
                       label: block_caEXO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEWq() //  [R1]
         { info_tbl: [(caEWq,
                       label: block_caEWq_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEWq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caEYF; else goto caEYE;
       caEYF: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caEYE: // global
           I64[Hp - 56] = sat_saASH_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saASC_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saASD_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caEYx_info;
           R2 = Hp - 54;
           _saASB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saASB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYx() //  [R1]
         { info_tbl: [(caEYx,
                       label: block_caEYx_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYx: // global
           I64[Sp] = block_caEYz_info;
           R2 = P64[Sp + 96];
           _saASK::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saASK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYz() //  []
         { info_tbl: [(caEYz,
                       label: block_caEYz_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYz: // global
           I64[Sp] = block_caEYB_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaEZM; else goto caEYI;
       uaEZM: // global
           call _caEYB(R1) args: 0, res: 0, upd: 0;
       caEYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYB() //  [R1]
         { info_tbl: [(caEYB,
                       label: block_caEYB_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYB: // global
           I64[Sp] = block_caEYM_info;
           _saASN::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saASN::P64;
           if (R1 & 7 != 0) goto uaEZN; else goto caEYO;
       uaEZN: // global
           call _caEYM(R1) args: 0, res: 0, upd: 0;
       caEYO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYM() //  [R1]
         { info_tbl: [(caEYM,
                       label: block_caEYM_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYM: // global
           if (R1 & 7 == 1) goto caEYX; else goto caEZ8;
       caEYX: // global
           I64[Sp + 88] = block_caEYS_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caEZ8: // global
           _saASN::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caEZ6_info;
           R1 = _saASN::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaEZO; else goto caEZ9;
       uaEZO: // global
           call _caEZ6() args: 0, res: 0, upd: 0;
       caEZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYS() //  []
         { info_tbl: [(caEYS,
                       label: block_caEYS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYS: // global
           _saASN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEYU_info;
           R1 = _saASN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaEZP; else goto caEYZ;
       uaEZP: // global
           call _caEYU() args: 0, res: 0, upd: 0;
       caEYZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYU() //  []
         { info_tbl: [(caEYU,
                       label: block_caEYU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEZ6() //  []
         { info_tbl: [(caEZ6,
                       label: block_caEZ6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEZ6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEXW() //  [R1]
         { info_tbl: [(caEXW,
                       label: block_caEXW_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXW: // global
           I64[Sp] = block_caEXY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaEZI; else goto caEY1;
       uaEZI: // global
           call _caEXY(R1) args: 0, res: 0, upd: 0;
       caEY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEXY() //  [R1]
         { info_tbl: [(caEXY,
                       label: block_caEXY_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEXY: // global
           I64[Sp] = block_caEY5_info;
           _saASr::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saASr::P64;
           if (R1 & 7 != 0) goto uaEZJ; else goto caEY7;
       uaEZJ: // global
           call _caEY5(R1) args: 0, res: 0, upd: 0;
       caEY7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEY5() //  [R1]
         { info_tbl: [(caEY5,
                       label: block_caEY5_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEY5: // global
           if (R1 & 7 == 1) goto caEYg; else goto caEYr;
       caEYg: // global
           I64[Sp + 88] = block_caEYb_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caEYr: // global
           _saASr::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caEYp_info;
           R1 = _saASr::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaEZK; else goto caEYs;
       uaEZK: // global
           call _caEYp() args: 0, res: 0, upd: 0;
       caEYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYb() //  []
         { info_tbl: [(caEYb,
                       label: block_caEYb_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYb: // global
           _saASr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caEYd_info;
           R1 = _saASr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaEZL; else goto caEYi;
       uaEZL: // global
           call _caEYd() args: 0, res: 0, upd: 0;
       caEYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEYd() //  []
         { info_tbl: [(caEYd,
                       label: block_caEYd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYd: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caEYp() //  []
         { info_tbl: [(caEYp,
                       label: block_caEYp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEYp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.176370224 UTC

[section ""data" . GHC.Event.Manager.registerFd_closure" {
     GHC.Event.Manager.registerFd_closure:
         const GHC.Event.Manager.registerFd_info;
         const 0;
 },
 GHC.Event.Manager.registerFd_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caF6c,
                       label: GHC.Event.Manager.registerFd_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF6c: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call registerFd1_raAuk_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.179768527 UTC

[section ""cstring" . lvl13_raAul_bytes" {
     lvl13_raAul_bytes:
         I8[] [117,110,114,101,103,105,115,116,101,114,70,100,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.18182638 UTC

[section ""data" . lvl14_raAum_closure" {
     lvl14_raAum_closure:
         const lvl14_raAum_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_raAum_entry() //  [R1]
         { info_tbl: [(caF6q,
                       label: lvl14_raAum_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF6q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caF6r; else goto caF6s;
       caF6r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caF6s: // global
           (_caF6n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caF6n::I64 == 0) goto caF6p; else goto caF6o;
       caF6p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caF6o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caF6n::I64;
           R2 = lvl13_raAul_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.186360517 UTC

[section ""data" . lvl15_raAun_closure" {
     lvl15_raAun_closure:
         const lvl15_raAun_info;
         const 0;
 },
 lvl15_raAun_entry() //  [R2]
         { info_tbl: [(caF6E,
                       label: lvl15_raAun_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF6E: // global
           R3 = R2;
           R2 = lvl14_raAum_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.2008081 UTC

[section ""data" . GHC.Event.Manager.unregisterFd2_closure" {
     GHC.Event.Manager.unregisterFd2_closure:
         const GHC.Event.Manager.unregisterFd2_info;
         const 0;
 },
 g_saATV_entry() //  [R1, R2]
         { info_tbl: [(caF80,
                       label: g_saATV_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF80: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caF81; else goto caF82;
       caF81: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caF82: // global
           I64[Sp - 16] = block_caF7X_info;
           _saATr::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _saATr::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaF87; else goto caF7Y;
       uaF87: // global
           call _caF7X(R1) args: 0, res: 0, upd: 0;
       caF7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF7X() //  [R1]
         { info_tbl: [(caF7X,
                       label: block_caF7X_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF7X: // global
           R1 = I64[((I64[R1 + 23] != I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saAU3_entry() //  [R1, R2]
         { info_tbl: [(caF8k,
                       label: $wgo_saAU3_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF8k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caF8l; else goto caF8m;
       caF8l: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caF8m: // global
           I64[Sp - 32] = block_caF8d_info;
           _saAU3::P64 = R1;
           _saATV::P64 = P64[R1 + 7];
           _saATq::I64 = I64[R1 + 15];
           R1 = R2;
           I64[Sp - 24] = _saATq::I64;
           P64[Sp - 16] = _saATV::P64;
           P64[Sp - 8] = _saAU3::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaF8Z; else goto caF8e;
       uaF8Z: // global
           call _caF8d(R1) args: 0, res: 0, upd: 0;
       caF8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF8d() //  [R1]
         { info_tbl: [(caF8d,
                       label: block_caF8d_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF8d: // global
           if (R1 & 7 == 1) goto caF8h; else goto caF8i;
       caF8h: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caF8i: // global
           _saAU7::P64 = P64[R1 + 6];
           _saAU8::P64 = P64[R1 + 14];
           _saAU6::I64 = I64[R1 + 22];
           if (_saAU6::I64 == I64[Sp + 8]) goto caF8G; else goto caF8A;
       caF8G: // global
           I64[Sp] = block_caF8F_info;
           R3 = _saAU7::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 8] = _saAU8::P64;
           P64[Sp + 16] = _saAU7::P64;
           I64[Sp + 24] = _saAU6::I64;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 8;
       caF8A: // global
           I64[Sp + 8] = block_caF8w_info;
           R2 = _saAU8::P64;
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _saAU7::P64;
           I64[Sp + 24] = _saAU6::I64;
           Sp = Sp + 8;
           call $wgo_saAU3_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF8F() //  [R1]
         { info_tbl: [(caF8F,
                       label: block_caF8F_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF8F: // global
           _saAU7::P64 = P64[Sp + 16];
           _saAU8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto caF8M; else goto caF8U;
       caF8M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caF8P; else goto caF8O;
       caF8P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caF8O: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU7::P64;
           R3 = _saAU8::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caF8U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caF8X; else goto caF8W;
       caF8X: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caF8W: // global
           I64[Hp - 40] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = _saAU8::P64;
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU7::P64;
           R3 = Hp - 38;
           R2 = Hp - 6;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caF8w() //  [R1, R2, R3]
         { info_tbl: [(caF8w,
                       label: block_caF8w_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF8w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caF8D; else goto caF8C;
       caF8D: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caF8C: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_saAV6_entry() //  [R1, R2]
         { info_tbl: [(caF9F,
                       label: go_saAV6_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF9F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caF9G; else goto uaF9Y;
       caF9G: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaF9Y: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _caF9v() args: 0, res: 0, upd: 0;
     }
 },
 _caF9v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF9v: // global
           _saATq::I64 = I64[P64[Sp] + 7];
           I64[Sp - 8] = block_caF9y_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saATq::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaFa0; else goto caF9z;
       uaFa0: // global
           call _caF9y(R1) args: 0, res: 0, upd: 0;
       caF9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF9y() //  [R1]
         { info_tbl: [(caF9y,
                       label: block_caF9y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF9y: // global
           if (R1 & 7 == 1) goto caF9C; else goto caF9D;
       caF9C: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caF9D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caF9P; else goto caF9O;
       caF9P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caF9O: // global
           if (I64[R1 + 22] == I64[Sp + 16]) goto caF9X; else goto caF9T;
       caF9X: // global
           _saAVa::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAVa::P64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caF9T: // global
           _saAVb::P64 = P64[R1 + 14];
           Hp = Hp - 16;
           P64[Sp + 16] = _saAVb::P64;
           Sp = Sp + 8;
           call _caF9v() args: 0, res: 0, upd: 0;
     }
 },
 $wio_saATF_entry() //  [R1, R2]
         { info_tbl: [(caFa3,
                       label: $wio_saATF_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFa3: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caFa4; else goto caFa5;
       caFa4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caFa5: // global
           I64[Sp - 56] = block_caF7E_info;
           _saATk::P64 = P64[R1 + 6];
           _saATm::P64 = P64[R1 + 14];
           _saATn::P64 = P64[R1 + 22];
           _saATq::I64 = I64[R1 + 30];
           _saATr::I64 = I64[R1 + 38];
           R1 = P64[R2 + 8];
           P64[Sp - 48] = _saATk::P64;
           P64[Sp - 40] = _saATm::P64;
           P64[Sp - 32] = _saATn::P64;
           I64[Sp - 24] = _saATq::I64;
           I64[Sp - 16] = _saATr::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaFcJ; else goto caF7F;
       uaFcJ: // global
           call _caF7E(R1) args: 0, res: 0, upd: 0;
       caF7F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF7E() //  [R1]
         { info_tbl: [(caF7E,
                       label: block_caF7E_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF7E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caFa8; else goto caFa7;
       caFa8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFa7: // global
           _saATq::I64 = I64[Sp + 32];
           _saATM::P64 = P64[R1 + 7];
           _saATO::P64 = P64[R1 + 15];
           _saATN::I64 = I64[R1 + 23];
           _saATP::I64 = _saATq::I64 & (I64[_saATM::P64 + 8] - 1);
           _saATU::P64 = P64[(_saATM::P64 + 24) + (_saATP::I64 << 3)];
           I64[Hp - 32] = g_saATV_info;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = $wgo_saAU3_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _saATq::I64;
           I64[Sp - 24] = block_caF90_info;
           R2 = _saATU::P64;
           R1 = Hp - 15;
           P64[Sp - 16] = _saATO::P64;
           I64[Sp - 8] = _saATP::I64;
           I64[Sp] = _saATN::I64;
           P64[Sp + 40] = _saATM::P64;
           Sp = Sp - 24;
           call $wgo_saAU3_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF90() //  [R1, R2, R3]
         { info_tbl: [(caF90,
                       label: block_caF90_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF90: // global
           I64[Sp - 16] = block_caFa9_info;
           _saAUm::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saAUm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFcG; else goto caFbY;
       uaFcG: // global
           call _caFa9(R1) args: 0, res: 0, upd: 0;
       caFbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFa9() //  [R1]
         { info_tbl: [(caFa9,
                       label: block_caFa9_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFa9: // global
           if (R1 & 7 == 1) goto caFc4; else goto caFc9;
       caFc4: // global
           P64[Sp + 80] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saAUp() args: 0, res: 0, upd: 0;
       caFc9: // global
           _saATM::P64 = P64[Sp + 80];
           _saATP::I64 = I64[Sp + 32];
           _saAUm::P64 = P64[Sp + 16];
           _saAUo::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saATM::P64 + 24) + (_saATP::I64 << 3)] = _saAUo::P64;
           I64[_saATM::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saATM::P64 + 24) + ((I64[_saATM::P64 + 8] << 3) + (_saATP::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caFc7_info;
           _saAVi::P64 = R1;
           R1 = _saAUm::P64;
           P64[Sp + 80] = _saAVi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaFcK; else goto caFca;
       uaFcK: // global
           call _caFc7(R1) args: 0, res: 0, upd: 0;
       caFca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFc7() //  [R1]
         { info_tbl: [(caFc7,
                       label: block_caFc7_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFc7: // global
           _saAVi::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto caFcg; else goto caFck;
       caFcg: // global
           P64[Sp + 64] = _saAVi::P64;
           Sp = Sp + 32;
           goto uaFcX;
       caFck: // global
           _saATN::I64 = I64[Sp + 24];
           _saATO::P64 = P64[Sp + 8];
           I64[_saATN::I64] = I64[_saATN::I64] - 1;
           call MO_Touch(_saATO::P64);
           P64[Sp + 64] = _saAVi::P64;
           Sp = Sp + 32;
           goto uaFcX;
       uaFcX: // global
           call _saAUp() args: 0, res: 0, upd: 0;
     }
 },
 _saAUp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saAUp: // global
           I64[Sp - 8] = block_caF99_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaFcY; else goto caF9a;
       uaFcY: // global
           call _caF99(R1) args: 0, res: 0, upd: 0;
       caF9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF99() //  [R1]
         { info_tbl: [(caF99,
                       label: block_caF99_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF99: // global
           if (R1 & 7 == 1) goto caFbr; else goto caFby;
       caFbr: // global
           I64[Sp + 48] = 0;
           I64[Sp + 40] = 0;
           call _caFac() args: 0, res: 0, upd: 0;
       caFby: // global
           _saAUV::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp] = block_caF9f_info;
           _saAUS::P64 = P64[R1 + 6];
           R1 = _saAUV::P64;
           P64[Sp + 48] = _saAUS::P64;
           if (R1 & 7 != 0) goto uaFcH; else goto caF9g;
       uaFcH: // global
           call _caF9f(R1) args: 0, res: 0, upd: 0;
       caF9g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF9f() //  [R1]
         { info_tbl: [(caF9f,
                       label: block_caF9f_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF9f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caFbB; else goto caFbA;
       caFbB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFbA: // global
           _saATq::I64 = I64[Sp + 32];
           _saAUX::P64 = P64[R1 + 7];
           _saAV5::P64 = P64[(_saAUX::P64 + 24) + (_saATq::I64 & (I64[_saAUX::P64 + 8] - 1) << 3)];
           I64[Hp - 8] = go_saAV6_info;
           I64[Hp] = _saATq::I64;
           I64[Sp] = block_caFbs_info;
           R2 = _saAV5::P64;
           R1 = Hp - 7;
           call go_saAV6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFbs() //  [R1]
         { info_tbl: [(caFbs,
                       label: block_caFbs_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFbs: // global
           I64[Sp] = block_caFbw_info;
           R2 = P64[Sp + 48];
           P64[Sp + 48] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFbw() //  [R1]
         { info_tbl: [(caFbw,
                       label: block_caFbw_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFbw: // global
           I64[Sp] = block_caFbG_info;
           _saAVe::I64 = R1;
           R1 = P64[Sp + 48];
           I64[Sp + 48] = _saAVe::I64;
           if (R1 & 7 != 0) goto uaFcT; else goto caFbI;
       uaFcT: // global
           call _caFbG(R1) args: 0, res: 0, upd: 0;
       caFbI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFbG() //  [R1]
         { info_tbl: [(caFbG,
                       label: block_caFbG_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFbG: // global
           if (R1 & 7 == 1) goto caFbO; else goto caFbT;
       caFbO: // global
           I64[Sp + 48] = I64[Sp + 48];
           I64[Sp + 40] = 0;
           call _caFac() args: 0, res: 0, upd: 0;
       caFbT: // global
           I64[Sp] = block_caFbR_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFbR() //  [R1]
         { info_tbl: [(caFbR,
                       label: block_caFbR_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFbR: // global
           I64[Sp + 40] = R1;
           I64[Sp + 48] = I64[Sp + 48];
           call _caFac() args: 0, res: 0, upd: 0;
     }
 },
 _caFac() //  []
         { info_tbl: [(caFac,
                       label: block_caFac_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFac: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caFah; else goto caFag;
       caFah: // global
           HpAlloc = 32;
           I64[Sp] = block_caFac_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caFag: // global
           _saAUv::I64 = I64[Sp + 40];
           if (I64[Sp + 48] == _saAUv::I64) goto caFal; else goto caFbn;
       caFal: // global
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caFbn: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = I64[Sp + 32];
           _caFao::P64 = Hp - 23;
           if (_saAUv::I64 & 8 != 0) goto caFbl; else goto caFbm;
       caFbm: // global
           _saAUK::I64 = _saAUv::I64 & 7;
           if (_saAUK::I64 == 0) goto caFbl; else goto caFb8;
       caFbl: // global
           Hp = Hp - 16;
           P64[Sp + 24] = _caFao::P64;
           call _caFas() args: 0, res: 0, upd: 0;
       caFb8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAUK::I64;
           _saATn::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caFb4_info;
           R4 = Hp - 7;
           R3 = _caFao::P64;
           R2 = P64[Sp + 8];
           R1 = _saATn::P64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFb4() //  [R1]
         { info_tbl: [(caFb4,
                       label: block_caFb4_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFb4: // global
           I64[Sp] = block_caFb6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaFcQ; else goto caFba;
       uaFcQ: // global
           call _caFb6(R1) args: 0, res: 0, upd: 0;
       caFba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFb6() //  [R1]
         { info_tbl: [(caFb6,
                       label: block_caFb6_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFb6: // global
           if (R1 & 7 == 1) goto uaFcB; else goto uaFcC;
       uaFcB: // global
           Sp = Sp + 8;
           call _caFbg() args: 0, res: 0, upd: 0;
       uaFcC: // global
           Sp = Sp + 32;
           call _caFbk() args: 0, res: 0, upd: 0;
     }
 },
 _caFas() //  []
         { info_tbl: [(caFas,
                       label: block_caFas_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFas: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caFaw; else goto caFav;
       caFaw: // global
           HpAlloc = 32;
           I64[Sp] = block_caFas_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caFav: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 40] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           _caFao::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caFaF_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _caFao::P64;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_v_info;
           Sp = Sp + 16;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caFaF() //  [R1]
         { info_tbl: [(caFaF,
                       label: block_caFaF_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFaF: // global
           I64[Sp] = block_caFaH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaFcN; else goto caFaJ;
       uaFcN: // global
           call _caFaH(R1) args: 0, res: 0, upd: 0;
       caFaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFaH() //  [R1]
         { info_tbl: [(caFaH,
                       label: block_caFaH_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFaH: // global
           if (R1 & 7 == 1) goto uaFcE; else goto uaFcF;
       uaFcE: // global
           Sp = Sp + 8;
           call _caFbg() args: 0, res: 0, upd: 0;
       uaFcF: // global
           Sp = Sp + 32;
           call _caFbk() args: 0, res: 0, upd: 0;
     }
 },
 _caFbg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFbg: // global
           R2 = I64[Sp];
           Sp = Sp + 24;
           call lvl15_raAun_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caFbk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFbk: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saAVs_entry() //  [R1, R2]
         { info_tbl: [(caFd7,
                       label: io_saAVs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFd7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFd8; else goto caFd9;
       caFd8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caFd9: // global
           I64[Sp - 16] = block_caFd4_info;
           _saATF::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saATF::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFdd; else goto caFd5;
       uaFdd: // global
           call _caFd4(R1) args: 0, res: 0, upd: 0;
       caFd5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFd4() //  [R1]
         { info_tbl: [(caFd4,
                       label: block_caFd4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFd4: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saATF_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVG_entry() //  [R1, R2]
         { info_tbl: [(caFdp,
                       label: sat_saAVG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFdq; else goto caFdr;
       caFdq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caFdr: // global
           I64[Sp - 16] = block_caFdn_info;
           _saAVD::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAVD::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFdn() //  []
         { info_tbl: [(caFdn,
                       label: block_caFdn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVB_entry() //  [R1]
         { info_tbl: [(caFdy,
                       label: sat_saAVB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdy: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVC_entry() //  [R1]
         { info_tbl: [(caFdG,
                       label: sat_saAVC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdG: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVU_entry() //  [R1, R2]
         { info_tbl: [(caFdY,
                       label: sat_saAVU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFdZ; else goto caFe0;
       caFdZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caFe0: // global
           I64[Sp - 16] = block_caFdW_info;
           _saAVR::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAVR::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFdW() //  []
         { info_tbl: [(caFdW,
                       label: block_caFdW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVP_entry() //  [R1]
         { info_tbl: [(caFe7,
                       label: sat_saAVP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFe7: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVQ_entry() //  [R1]
         { info_tbl: [(caFef,
                       label: sat_saAVQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFef: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAVZ_entry() //  [R1]
         { info_tbl: [(caFem,
                       label: sat_saAVZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFem: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caFen; else goto caFeo;
       caFen: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caFeo: // global
           I64[Sp - 24] = block_caFdP_info;
           _saATE::P64 = P64[R1 + 7];
           _saAVs::P64 = P64[R1 + 15];
           R1 = _saATE::P64;
           P64[Sp - 16] = _saATE::P64;
           P64[Sp - 8] = _saAVs::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFdP() //  [R1]
         { info_tbl: [(caFdP,
                       label: block_caFdP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caFer; else goto caFeq;
       caFer: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFeq: // global
           I64[Hp - 56] = sat_saAVU_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAVP_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAVQ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caFei_info;
           R2 = Hp - 54;
           _saAVO::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAVO::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFei() //  [R1]
         { info_tbl: [(caFei,
                       label: block_caFei_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFei: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caFek_info;
           R2 = P64[Sp + 16];
           _saAVX::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAVX::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFek() //  []
         { info_tbl: [(caFek,
                       label: block_caFek_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFek: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW8_entry() //  [R1, R2]
         { info_tbl: [(caFeE,
                       label: sat_saAW8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFeE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFeF; else goto caFeG;
       caFeF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caFeG: // global
           I64[Sp - 16] = block_caFeC_info;
           _saAW5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saAW5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFeC() //  []
         { info_tbl: [(caFeC,
                       label: block_caFeC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFeC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW3_entry() //  [R1]
         { info_tbl: [(caFeN,
                       label: sat_saAW3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFeN: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saAVs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saAW4_entry() //  [R1]
         { info_tbl: [(caFeV,
                       label: sat_saAW4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFeV: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.unregisterFd2_entry() //  [R2, R3]
         { info_tbl: [(caFeY,
                       label: GHC.Event.Manager.unregisterFd2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFeY: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caFeZ; else goto caFf0;
       caFeZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFf0: // global
           I64[Sp - 16] = block_caF6P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFfI; else goto caF6Q;
       uaFfI: // global
           call _caF6P(R1) args: 0, res: 0, upd: 0;
       caF6Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF6P() //  [R1]
         { info_tbl: [(caF6P,
                       label: block_caF6P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF6P: // global
           I64[Sp - 24] = block_caF6U_info;
           _saAT2::P64 = P64[R1 + 7];
           _saAT4::P64 = P64[R1 + 23];
           _saAT6::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saAT4::P64;
           P64[Sp - 8] = _saAT6::P64;
           P64[Sp] = _saAT2::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaFfD; else goto caF6V;
       uaFfD: // global
           call _caF6U(R1) args: 0, res: 0, upd: 0;
       caF6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF6U() //  [R1]
         { info_tbl: [(caF6U,
                       label: block_caF6U_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF6U: // global
           I64[Sp - 8] = block_caF6Z_info;
           _saATf::P64 = R1;
           _saATg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saATg::I64;
           P64[Sp + 8] = _saATf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaFfE; else goto caF70;
       uaFfE: // global
           call _caF6Z(R1) args: 0, res: 0, upd: 0;
       caF70: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF6Z() //  [R1]
         { info_tbl: [(caF6Z,
                       label: block_caF6Z_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF6Z: // global
           I64[Sp - 8] = block_caF74_info;
           _saATh::P64 = R1;
           _saATi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saATi::I64;
           P64[Sp + 32] = _saATh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaFfF; else goto caF75;
       uaFfF: // global
           call _caF74(R1) args: 0, res: 0, upd: 0;
       caF75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF74() //  [R1]
         { info_tbl: [(caF74,
                       label: block_caF74_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF74: // global
           I64[Sp - 16] = block_caF79_info;
           _saATk::P64 = P64[R1 + 7];
           _saATm::P64 = P64[R1 + 23];
           _saATn::P64 = P64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saATn::P64;
           P64[Sp] = _saATm::P64;
           P64[Sp + 48] = _saATk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFfG; else goto caF7a;
       uaFfG: // global
           call _caF79(R1) args: 0, res: 0, upd: 0;
       caF7a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF79() //  [R1]
         { info_tbl: [(caF79,
                       label: block_caF79_info
                       rep:StackRep [False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF79: // global
           I64[Sp - 16] = block_caF7e_info;
           I64[Sp - 8] = I64[R1 + 15];
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caF7e() //  [R1]
         { info_tbl: [(caF7e,
                       label: block_caF7e_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF7e: // global
           _saATf::P64 = P64[Sp + 56];
           _saATg::I64 = I64[Sp + 48];
           _saATh::P64 = P64[Sp + 72];
           _saATv::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saATg::I64,
                            _saATv::I64)) goto caFfa; else goto caFfB;
       caFfB: // global
           if (%MO_S_Gt_W64(_saATv::I64,
                            I64[Sp + 40])) goto caFfa; else goto caFfb;
       caFfa: // global
           R4 = _saATv::I64;
           R3 = _saATf::P64;
           R2 = _saATh::P64;
           Sp = Sp + 88;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caFfb: // global
           _saATC::P64 = P64[P64[Sp + 64] + ((_saATv::I64 - _saATg::I64 << 3) + 24)];
           I64[Sp] = block_caF7u_info;
           _saATu::I64 = R1;
           R1 = _saATC::P64;
           I64[Sp + 72] = _saATu::I64;
           if (R1 & 7 != 0) goto uaFfH; else goto caF7v;
       uaFfH: // global
           call _caF7u(R1) args: 0, res: 0, upd: 0;
       caF7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caF7u() //  [R1]
         { info_tbl: [(caF7u,
                       label: block_caF7u_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF7u: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caFfe; else goto caFfd;
       caFfe: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFfd: // global
           _saATE::P64 = P64[R1 + 7];
           I64[Hp - 80] = $wio_saATF_info;
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saAVs_info;
           P64[Hp - 24] = Hp - 78;
           _caFcZ::P64 = Hp - 30;
           _saAVx::I64 = I64[Sp + 72];
           if (_saAVx::I64 != 0) goto uaFfC; else goto caFfq;
       uaFfC: // global
           if (_saAVx::I64 != 1) goto caFfj; else goto caFfu;
       caFfj: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caFdg_info;
           R1 = _saATE::P64;
           P64[Sp + 72] = _saATE::P64;
           P64[Sp + 80] = _caFcZ::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caFfu: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caFev_info;
           R1 = _saATE::P64;
           P64[Sp + 72] = _saATE::P64;
           P64[Sp + 80] = _caFcZ::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caFfq: // global
           I64[Hp - 16] = sat_saAVZ_info;
           P64[Hp - 8] = _saATE::P64;
           P64[Hp] = _caFcZ::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caFdg() //  [R1]
         { info_tbl: [(caFdg,
                       label: block_caFdg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFdg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caFfm; else goto caFfl;
       caFfm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFfl: // global
           I64[Hp - 56] = sat_saAVG_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAVB_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAVC_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caFff_info;
           R2 = Hp - 54;
           _saAVA::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAVA::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFff() //  [R1]
         { info_tbl: [(caFff,
                       label: block_caFff_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFff: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caFfh_info;
           R2 = P64[Sp + 16];
           _saAVJ::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAVJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFfh() //  []
         { info_tbl: [(caFfh,
                       label: block_caFfh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFfh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caFev() //  [R1]
         { info_tbl: [(caFev,
                       label: block_caFev_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFev: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caFfx; else goto caFfw;
       caFfx: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFfw: // global
           I64[Hp - 56] = sat_saAW8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saAW3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saAW4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caFfr_info;
           R2 = Hp - 54;
           _saAW2::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saAW2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFfr() //  [R1]
         { info_tbl: [(caFfr,
                       label: block_caFfr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFfr: // global
           _saATE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caFft_info;
           R2 = P64[Sp + 16];
           _saAWb::P64 = R1;
           R1 = _saATE::P64;
           P64[Sp + 16] = _saAWb::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFft() //  []
         { info_tbl: [(caFft,
                       label: block_caFft_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFft: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.325120158 UTC

[section ""data" . GHC.Event.Manager.unregisterFd__closure" {
     GHC.Event.Manager.unregisterFd__closure:
         const GHC.Event.Manager.unregisterFd__info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd__entry() //  [R2, R3]
         { info_tbl: [(caFks,
                       label: GHC.Event.Manager.unregisterFd__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFks: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.32927815 UTC

[section ""data" . GHC.Event.Manager.unregisterFd1_closure" {
     GHC.Event.Manager.unregisterFd1_closure:
         const GHC.Event.Manager.unregisterFd1_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd1_entry() //  [R2, R3]
         { info_tbl: [(caFkI,
                       label: GHC.Event.Manager.unregisterFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFkI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caFkJ; else goto caFkK;
       caFkJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFkK: // global
           I64[Sp - 8] = block_caFkD_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caFkD() //  [R1]
         { info_tbl: [(caFkD,
                       label: block_caFkD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFkD: // global
           I64[Sp] = block_caFkF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaFkP; else goto caFkG;
       uaFkP: // global
           call _caFkF() args: 0, res: 0, upd: 0;
       caFkG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFkF() //  []
         { info_tbl: [(caFkF,
                       label: block_caFkF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFkF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.33578433 UTC

[section ""data" . GHC.Event.Manager.unregisterFd_closure" {
     GHC.Event.Manager.unregisterFd_closure:
         const GHC.Event.Manager.unregisterFd_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd_entry() //  [R2, R3]
         { info_tbl: [(caFl7,
                       label: GHC.Event.Manager.unregisterFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFl7: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.339409886 UTC

[section ""data" . GHC.Event.Manager.EventManager_closure" {
     GHC.Event.Manager.EventManager_closure:
         const GHC.Event.Manager.EventManager_info;
 },
 GHC.Event.Manager.EventManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFlf: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Manager.EventManager_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 72, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.EventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caFlk,
                       label: GHC.Event.Manager.EventManager_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, False, True, False, False, False,
                                                    True, True, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFlk: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caFlo; else goto caFln;
       caFlo: // global
           HpAlloc = 112;
           R1 = GHC.Event.Manager.EventManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 112, res: 0, upd: 8;
       caFln: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 56];
           I64[Hp - 24] = R5;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           R1 = Hp - 103;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.345110712 UTC

[section ""data" . GHC.Event.Manager.Created_closure" {
     GHC.Event.Manager.Created_closure:
         const GHC.Event.Manager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.346841176 UTC

[section ""data" . GHC.Event.Manager.Running_closure" {
     GHC.Event.Manager.Running_closure:
         const GHC.Event.Manager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.348458271 UTC

[section ""data" . GHC.Event.Manager.Dying_closure" {
     GHC.Event.Manager.Dying_closure:
         const GHC.Event.Manager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.350148919 UTC

[section ""data" . GHC.Event.Manager.Releasing_closure" {
     GHC.Event.Manager.Releasing_closure:
         const GHC.Event.Manager.Releasing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.35177741 UTC

[section ""data" . GHC.Event.Manager.Finished_closure" {
     GHC.Event.Manager.Finished_closure:
         const GHC.Event.Manager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.355003184 UTC

[section ""data" . GHC.Event.Manager.FdKey_closure" {
     GHC.Event.Manager.FdKey_closure:
         const GHC.Event.Manager.FdKey_info;
 },
 GHC.Event.Manager.FdKey_entry() //  [R2, R3]
         { info_tbl: [(caFlO,
                       label: GHC.Event.Manager.FdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFlO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caFlS; else goto caFlR;
       caFlS: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.FdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFlR: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.359589496 UTC

[section ""data" . GHC.Event.Manager.FdData_closure" {
     GHC.Event.Manager.FdData_closure:
         const GHC.Event.Manager.FdData_info;
 },
 GHC.Event.Manager.FdData_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFlZ: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.FdData_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.FdData_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caFm4,
                       label: GHC.Event.Manager.FdData_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFm4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caFm8; else goto caFm7;
       caFm8: // global
           HpAlloc = 40;
           R1 = GHC.Event.Manager.FdData_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caFm7: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.364790771 UTC

[GHC.Event.Manager.EventManager_con_entry() //  [R1]
         { info_tbl: [(caFmg,
                       label: GHC.Event.Manager.EventManager_con_info
                       rep:HeapRep 9 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,69,118,101,110,116,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.368066983 UTC

[section ""relreadonly" . GHC.Event.Manager.State_closure_tbl" {
     GHC.Event.Manager.State_closure_tbl:
         const GHC.Event.Manager.Created_closure+1;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Dying_closure+3;
         const GHC.Event.Manager.Releasing_closure+4;
         const GHC.Event.Manager.Finished_closure+5;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.369893258 UTC

[GHC.Event.Manager.Created_con_entry() //  [R1]
         { info_tbl: [(caFmn,
                       label: GHC.Event.Manager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.37311021 UTC

[GHC.Event.Manager.Running_con_entry() //  [R1]
         { info_tbl: [(caFmt,
                       label: GHC.Event.Manager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmt: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.376452601 UTC

[GHC.Event.Manager.Dying_con_entry() //  [R1]
         { info_tbl: [(caFmz,
                       label: GHC.Event.Manager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmz: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.379659891 UTC

[GHC.Event.Manager.Releasing_con_entry() //  [R1]
         { info_tbl: [(caFmF,
                       label: GHC.Event.Manager.Releasing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,101,108,101,97,115,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmF: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.38296386 UTC

[GHC.Event.Manager.Finished_con_entry() //  [R1]
         { info_tbl: [(caFmL,
                       label: GHC.Event.Manager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmL: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.386569258 UTC

[GHC.Event.Manager.FdKey_con_entry() //  [R1]
         { info_tbl: [(caFmR,
                       label: GHC.Event.Manager.FdKey_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,75,101,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.390410868 UTC

[GHC.Event.Manager.FdData_con_entry() //  [R1]
         { info_tbl: [(caFmX,
                       label: GHC.Event.Manager.FdData_con_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,68,97,116,97]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFmX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:34.3935959 UTC

[section ""relreadonly" . SaAZi_srt" {
     SaAZi_srt:
         const GHC.Event.Manager.$w$cshowsPrec1_closure;
         const GHC.Event.Manager.$fShowState1_closure;
         const GHC.Event.Manager.$fShowState3_closure;
         const GHC.Event.Manager.$fShowState5_closure;
         const GHC.Event.Manager.$fShowState7_closure;
         const GHC.Event.Manager.$fShowState9_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Manager.$w$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure;
         const GHC.Event.Manager.$fShowFdKey1_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.$fShowState_$cshow_closure;
         const GHC.Arr.$windexError_closure;
         const lvl2_raAu7_closure;
         const lvl3_raAu8_closure;
         const GHC.Event.Manager.callbackTableVar_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.Manager.release1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.Manager.shutdown1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const $wlvl_raAub_closure;
         const lvl7_raAud_closure;
         const GHC.Arr.arrEleBottom_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Manager.new3_closure;
         const GHC.Event.Manager.new1_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.closeFd_3_closure;
         const GHC.Event.Manager.eventsOf_closure;
         const GHC.Event.Manager.closeFd1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.Manager.loop5_closure;
         const GHC.Event.Manager.loop3_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Event.Manager.loop2_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Manager.closeFd_1_closure;
         const registerFd1_raAuk_closure;
         const lvl14_raAum_closure;
         const lvl15_raAun_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const GHC.Event.Manager.unregisterFd1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.697008688 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:40.699024521 UTC

[section ""data" . GHC.Event.Manager.$WEventManager_closure" {
     GHC.Event.Manager.$WEventManager_closure:
         const GHC.Event.Manager.$WEventManager_info;
 },
 GHC.Event.Manager.$WEventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caFP6,
                       label: GHC.Event.Manager.$WEventManager_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFP6: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caFPz; else goto caFPA;
       caFPz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WEventManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caFPA: // global
           I64[Sp - 40] = block_caFP3_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaFPK; else goto caFP4;
       uaFPK: // global
           call _caFP3(R1) args: 0, res: 0, upd: 0;
       caFP4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFP3() //  [R1]
         { info_tbl: [(caFP3,
                       label: block_caFP3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFP3: // global
           I64[Sp] = block_caFP9_info;
           _saFna::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saFna::P64;
           if (R1 & 7 != 0) goto uaFPJ; else goto caFPa;
       uaFPJ: // global
           call _caFP9(R1) args: 0, res: 0, upd: 0;
       caFPa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFP9() //  [R1]
         { info_tbl: [(caFP9,
                       label: block_caFP9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFP9: // global
           I64[Sp - 24] = block_caFPe_info;
           _saFnc::P64 = P64[R1 + 7];
           _saFnd::P64 = P64[R1 + 15];
           _saFnf::P64 = P64[R1 + 23];
           _saFne::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           I64[Sp - 16] = _saFne::I64;
           P64[Sp - 8] = _saFnf::P64;
           P64[Sp] = _saFnd::P64;
           P64[Sp + 16] = _saFnc::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaFPL; else goto caFPf;
       uaFPL: // global
           call _caFPe(R1) args: 0, res: 0, upd: 0;
       caFPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFPe() //  [R1]
         { info_tbl: [(caFPe,
                       label: block_caFPe_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFPe: // global
           I64[Sp] = block_caFPj_info;
           _saFnh::P64 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _saFnh::P64;
           if (R1 & 7 != 0) goto uaFPM; else goto caFPk;
       uaFPM: // global
           call _caFPj(R1) args: 0, res: 0, upd: 0;
       caFPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFPj() //  [R1]
         { info_tbl: [(caFPj,
                       label: block_caFPj_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFPj: // global
           I64[Sp] = block_caFPo_info;
           _saFnj::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _saFnj::P64;
           if (R1 & 7 != 0) goto uaFPN; else goto caFPp;
       uaFPN: // global
           call _caFPo(R1) args: 0, res: 0, upd: 0;
       caFPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFPo() //  [R1]
         { info_tbl: [(caFPo,
                       label: block_caFPo_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFPo: // global
           I64[Sp - 32] = block_caFPt_info;
           _saFno::P64 = P64[R1 + 7];
           _saFnp::P64 = P64[R1 + 15];
           _saFnl::I64 = I64[R1 + 23];
           _saFnm::I64 = I64[R1 + 31];
           _saFnn::I64 = I64[R1 + 39];
           R1 = P64[Sp + 64];
           I64[Sp - 24] = _saFnn::I64;
           P64[Sp - 16] = _saFno::P64;
           P64[Sp - 8] = _saFnp::P64;
           I64[Sp] = _saFnm::I64;
           I64[Sp + 64] = _saFnl::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaFPO; else goto caFPu;
       uaFPO: // global
           call _caFPt(R1) args: 0, res: 0, upd: 0;
       caFPu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFPt() //  [R1]
         { info_tbl: [(caFPt,
                       label: block_caFPt_info
                       rep:StackRep [True, False, False, True, True, False, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFPt: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caFPI; else goto caFPH;
       caFPI: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFPH: // global
           _saFnr::P64 = P64[R1 + 7];
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 80];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _saFnr::P64;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 96];
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 103;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.783504423 UTC

[section ""data" . GHC.Event.Manager.$WFdKey_closure" {
     GHC.Event.Manager.$WFdKey_closure:
         const GHC.Event.Manager.$WFdKey_info;
 },
 GHC.Event.Manager.$WFdKey_entry() //  [R2, R3]
         { info_tbl: [(caFQJ,
                       label: GHC.Event.Manager.$WFdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFQJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFQS; else goto caFQT;
       caFQS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFQT: // global
           I64[Sp - 16] = block_caFQG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFQZ; else goto caFQH;
       uaFQZ: // global
           call _caFQG(R1) args: 0, res: 0, upd: 0;
       caFQH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFQG() //  [R1]
         { info_tbl: [(caFQG,
                       label: block_caFQG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFQG: // global
           I64[Sp] = block_caFQM_info;
           _saFnv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saFnv::I64;
           if (R1 & 7 != 0) goto uaFQY; else goto caFQN;
       uaFQY: // global
           call _caFQM(R1) args: 0, res: 0, upd: 0;
       caFQN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFQM() //  [R1]
         { info_tbl: [(caFQM,
                       label: block_caFQM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFQM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caFQX; else goto caFQW;
       caFQX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFQW: // global
           _saFnx::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saFnx::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.791538959 UTC

[section ""data" . GHC.Event.Manager.$WFdData_closure" {
     GHC.Event.Manager.$WFdData_closure:
         const GHC.Event.Manager.$WFdData_info;
 },
 GHC.Event.Manager.$WFdData_entry() //  [R2, R3, R4]
         { info_tbl: [(caFRp,
                       label: GHC.Event.Manager.$WFdData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFRp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caFRA; else goto caFRB;
       caFRA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$WFdData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caFRB: // global
           I64[Sp - 24] = block_caFRm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaFRI; else goto caFRn;
       uaFRI: // global
           call _caFRm(R1) args: 0, res: 0, upd: 0;
       caFRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFRm() //  [R1]
         { info_tbl: [(caFRm,
                       label: block_caFRm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFRm: // global
           I64[Sp - 8] = block_caFRs_info;
           _saFnC::I64 = I64[R1 + 7];
           _saFnD::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saFnD::I64;
           I64[Sp + 8] = _saFnC::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaFRH; else goto caFRt;
       uaFRH: // global
           call _caFRs(R1) args: 0, res: 0, upd: 0;
       caFRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFRs() //  [R1]
         { info_tbl: [(caFRs,
                       label: block_caFRs_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFRs: // global
           I64[Sp] = block_caFRx_info;
           _saFnF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _saFnF::I64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFRx() //  [R1]
         { info_tbl: [(caFRx,
                       label: block_caFRx_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFRx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caFRG; else goto caFRF;
       caFRG: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caFRF: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.800322807 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState10_bytes" {
     GHC.Event.Manager.$fShowState10_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.802121645 UTC

[section ""data" . GHC.Event.Manager.$fShowState9_closure" {
     GHC.Event.Manager.$fShowState9_closure:
         const GHC.Event.Manager.$fShowState9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState9_entry() //  [R1]
         { info_tbl: [(caFSe,
                       label: GHC.Event.Manager.$fShowState9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFSe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFSf; else goto caFSg;
       caFSf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFSg: // global
           (_caFSb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caFSb::I64 == 0) goto caFSd; else goto caFSc;
       caFSd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caFSc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caFSb::I64;
           R2 = GHC.Event.Manager.$fShowState10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.806296548 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState8_bytes" {
     GHC.Event.Manager.$fShowState8_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.808692166 UTC

[section ""data" . GHC.Event.Manager.$fShowState7_closure" {
     GHC.Event.Manager.$fShowState7_closure:
         const GHC.Event.Manager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState7_entry() //  [R1]
         { info_tbl: [(caFSw,
                       label: GHC.Event.Manager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFSw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFSx; else goto caFSy;
       caFSx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFSy: // global
           (_caFSt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caFSt::I64 == 0) goto caFSv; else goto caFSu;
       caFSv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caFSu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caFSt::I64;
           R2 = GHC.Event.Manager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.812494989 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState6_bytes" {
     GHC.Event.Manager.$fShowState6_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.814372492 UTC

[section ""data" . GHC.Event.Manager.$fShowState5_closure" {
     GHC.Event.Manager.$fShowState5_closure:
         const GHC.Event.Manager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState5_entry() //  [R1]
         { info_tbl: [(caFSO,
                       label: GHC.Event.Manager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFSO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFSP; else goto caFSQ;
       caFSP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFSQ: // global
           (_caFSL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caFSL::I64 == 0) goto caFSN; else goto caFSM;
       caFSN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caFSM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caFSL::I64;
           R2 = GHC.Event.Manager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.818729175 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState4_bytes" {
     GHC.Event.Manager.$fShowState4_bytes:
         I8[] [82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.820564812 UTC

[section ""data" . GHC.Event.Manager.$fShowState3_closure" {
     GHC.Event.Manager.$fShowState3_closure:
         const GHC.Event.Manager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState3_entry() //  [R1]
         { info_tbl: [(caFT6,
                       label: GHC.Event.Manager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFT6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFT7; else goto caFT8;
       caFT7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFT8: // global
           (_caFT3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caFT3::I64 == 0) goto caFT5; else goto caFT4;
       caFT5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caFT4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caFT3::I64;
           R2 = GHC.Event.Manager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.824423976 UTC

[section ""cstring" . GHC.Event.Manager.$fShowState2_bytes" {
     GHC.Event.Manager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.826296255 UTC

[section ""data" . GHC.Event.Manager.$fShowState1_closure" {
     GHC.Event.Manager.$fShowState1_closure:
         const GHC.Event.Manager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.$fShowState1_entry() //  [R1]
         { info_tbl: [(caFTo,
                       label: GHC.Event.Manager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFTo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFTp; else goto caFTq;
       caFTp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFTq: // global
           (_caFTl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caFTl::I64 == 0) goto caFTn; else goto caFTm;
       caFTn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caFTm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caFTl::I64;
           R2 = GHC.Event.Manager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.830583429 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec1_closure" {
     GHC.Event.Manager.$w$cshowsPrec1_closure:
         const GHC.Event.Manager.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec1_entry() //  [R2, R3]
         { info_tbl: [(caFTN,
                       label: GHC.Event.Manager.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFTN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFTO; else goto caFTP;
       caFTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFTP: // global
           I64[Sp - 16] = block_caFTD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFU8; else goto caFTE;
       uaFU8: // global
           call _caFTD(R1) args: 0, res: 0, upd: 0;
       caFTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFTD() //  [R1]
         { info_tbl: [(caFTD,
                       label: block_caFTD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFTD: // global
           _saFnI::P64 = P64[Sp + 8];
           _caFTM::P64 = R1 & 7;
           if (_caFTM::P64 < 4) goto uaFU5; else goto uaFU7;
       uaFU5: // global
           if (_caFTM::P64 < 3) goto uaFU6; else goto caFTJ;
       uaFU6: // global
           if (_caFTM::P64 < 2) goto caFTH; else goto caFTI;
       caFTH: // global
           R3 = _saFnI::P64;
           R2 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caFTI: // global
           R3 = _saFnI::P64;
           R2 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caFTJ: // global
           R3 = _saFnI::P64;
           R2 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uaFU7: // global
           if (_caFTM::P64 < 5) goto caFTK; else goto caFTL;
       caFTK: // global
           R3 = _saFnI::P64;
           R2 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       caFTL: // global
           R3 = _saFnI::P64;
           R2 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.83694752 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(caFUp,
                       label: GHC.Event.Manager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFUp: // global
           _saFnL::P64 = R3;
           R3 = R4;
           R2 = _saFnL::P64;
           call GHC.Event.Manager.$w$cshowsPrec1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.842481711 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c==_closure" {
     GHC.Event.Manager.$fEqState_$c==_closure:
         const GHC.Event.Manager.$fEqState_$c==_info;
 },
 GHC.Event.Manager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(caFUK,
                       label: GHC.Event.Manager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFUK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFUL; else goto caFUM;
       caFUL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caFUM: // global
           I64[Sp - 16] = block_caFUA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFWn; else goto caFUB;
       uaFWn: // global
           call _caFUA(R1) args: 0, res: 0, upd: 0;
       caFUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFUA() //  [R1]
         { info_tbl: [(caFUA,
                       label: block_caFUA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFUA: // global
           _saFnO::P64 = P64[Sp + 8];
           _caFUJ::P64 = R1 & 7;
           if (_caFUJ::P64 < 4) goto uaFW5; else goto uaFW7;
       uaFW5: // global
           if (_caFUJ::P64 < 3) goto uaFW6; else goto caFUG;
       uaFW6: // global
           if (_caFUJ::P64 < 2) goto caFUE; else goto caFUF;
       caFUE: // global
           I64[Sp + 8] = block_caFUP_info;
           R1 = _saFnO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaFWi; else goto caFUR;
       uaFWi: // global
           call _caFUP(R1) args: 0, res: 0, upd: 0;
       caFUR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caFUF: // global
           I64[Sp + 8] = block_caFV4_info;
           R1 = _saFnO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaFWj; else goto caFV6;
       uaFWj: // global
           call _caFV4(R1) args: 0, res: 0, upd: 0;
       caFV6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caFUG: // global
           I64[Sp + 8] = block_caFVj_info;
           R1 = _saFnO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaFWk; else goto caFVl;
       uaFWk: // global
           call _caFVj(R1) args: 0, res: 0, upd: 0;
       caFVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaFW7: // global
           if (_caFUJ::P64 < 5) goto caFUH; else goto caFUI;
       caFUH: // global
           I64[Sp + 8] = block_caFVy_info;
           R1 = _saFnO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaFWl; else goto caFVA;
       uaFWl: // global
           call _caFVy(R1) args: 0, res: 0, upd: 0;
       caFVA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caFUI: // global
           I64[Sp + 8] = block_caFVN_info;
           R1 = _saFnO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaFWm; else goto caFVP;
       uaFWm: // global
           call _caFVN(R1) args: 0, res: 0, upd: 0;
       caFVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caFUP() //  [R1]
         { info_tbl: [(caFUP,
                       label: block_caFUP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFUP: // global
           if (R1 & 7 == 1) goto uaFW8; else goto uaFW9;
       uaFW8: // global
           Sp = Sp + 8;
           call _caFVZ() args: 0, res: 0, upd: 0;
       uaFW9: // global
           Sp = Sp + 8;
           call _caFVV() args: 0, res: 0, upd: 0;
     }
 },
 _caFV4() //  [R1]
         { info_tbl: [(caFV4,
                       label: block_caFV4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFV4: // global
           if (R1 & 7 == 2) goto uaFWa; else goto uaFWb;
       uaFWa: // global
           Sp = Sp + 8;
           call _caFVZ() args: 0, res: 0, upd: 0;
       uaFWb: // global
           Sp = Sp + 8;
           call _caFVV() args: 0, res: 0, upd: 0;
     }
 },
 _caFVj() //  [R1]
         { info_tbl: [(caFVj,
                       label: block_caFVj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFVj: // global
           if (R1 & 7 == 3) goto uaFWc; else goto uaFWd;
       uaFWc: // global
           Sp = Sp + 8;
           call _caFVZ() args: 0, res: 0, upd: 0;
       uaFWd: // global
           Sp = Sp + 8;
           call _caFVV() args: 0, res: 0, upd: 0;
     }
 },
 _caFVy() //  [R1]
         { info_tbl: [(caFVy,
                       label: block_caFVy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFVy: // global
           if (R1 & 7 == 4) goto uaFWe; else goto uaFWf;
       uaFWe: // global
           Sp = Sp + 8;
           call _caFVZ() args: 0, res: 0, upd: 0;
       uaFWf: // global
           Sp = Sp + 8;
           call _caFVV() args: 0, res: 0, upd: 0;
     }
 },
 _caFVN() //  [R1]
         { info_tbl: [(caFVN,
                       label: block_caFVN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFVN: // global
           if (R1 & 7 == 5) goto uaFWg; else goto uaFWh;
       uaFWg: // global
           Sp = Sp + 8;
           call _caFVZ() args: 0, res: 0, upd: 0;
       uaFWh: // global
           Sp = Sp + 8;
           call _caFVV() args: 0, res: 0, upd: 0;
     }
 },
 _caFVZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFVZ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caFVV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFVV: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.858891049 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey5_bytes" {
     GHC.Event.Manager.$fShowFdKey5_bytes:
         I8[] [70,100,75,101,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.860508025 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey4_bytes" {
     GHC.Event.Manager.$fShowFdKey4_bytes:
         I8[] [107,101,121,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.862147267 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey3_bytes" {
     GHC.Event.Manager.$fShowFdKey3_bytes:
         I8[] [107,101,121,85,110,105,113,117,101,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.863773796 UTC

[section ""cstring" . GHC.Event.Manager.$fShowFdKey2_bytes" {
     GHC.Event.Manager.$fShowFdKey2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.867651718 UTC

[section ""data" . GHC.Event.Manager.$w$cshowsPrec_closure" {
     GHC.Event.Manager.$w$cshowsPrec_closure:
         const GHC.Event.Manager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFXv: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFo5_entry() //  [R1]
         { info_tbl: [(caFY4,
                       label: sat_saFo5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFY4: // global
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Manager.$fShowFdKey2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFo6_entry() //  [R1]
         { info_tbl: [(caFY8,
                       label: sat_saFo6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFY8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caFY9; else goto caFYa;
       caFY9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFYa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caFXY_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caFXY() //  [R1, R2]
         { info_tbl: [(caFXY,
                       label: block_caFXY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFXY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caFYd; else goto caFYc;
       caFYd: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caFYc: // global
           I64[Hp - 40] = sat_saFo5_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saFo7_entry() //  [R1]
         { info_tbl: [(caFYe,
                       label: sat_saFo7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caFYi; else goto caFYh;
       caFYi: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFYh: // global
           _saFo0::P64 = P64[R1 + 16];
           _saFnX::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_saFo6_info;
           P64[Hp - 8] = _saFo0::P64;
           I64[Hp] = _saFnX::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Manager.$fShowFdKey3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFo8_entry() //  [R1]
         { info_tbl: [(caFYj,
                       label: sat_saFo8_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYj: // global
           _saFo8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caFYk; else goto caFYl;
       caFYl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caFYn; else goto caFYm;
       caFYn: // global
           HpAlloc = 32;
           goto caFYk;
       caFYk: // global
           R1 = _saFo8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFYm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saFo8::P64;
           _saFo0::P64 = P64[_saFo8::P64 + 16];
           _saFnX::I64 = I64[_saFo8::P64 + 24];
           I64[Hp - 24] = sat_saFo7_info;
           P64[Hp - 8] = _saFo0::P64;
           I64[Hp] = _saFnX::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saFoc_entry() //  [R1]
         { info_tbl: [(caFYr,
                       label: sat_saFoc_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYr: // global
           _saFoc::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caFYs; else goto caFYt;
       caFYt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caFYv; else goto caFYu;
       caFYv: // global
           HpAlloc = 32;
           goto caFYs;
       caFYs: // global
           R1 = _saFoc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFYu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saFoc::P64;
           _saFo0::P64 = P64[_saFoc::P64 + 16];
           _saFnW::I64 = I64[_saFoc::P64 + 24];
           _saFnX::I64 = I64[_saFoc::P64 + 32];
           I64[Hp - 24] = sat_saFo8_info;
           P64[Hp - 8] = _saFo0::P64;
           I64[Hp] = _saFnX::I64;
           I64[Sp - 24] = block_caFYo_info;
           R4 = Hp - 24;
           R3 = _saFnW::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caFYo() //  [R1, R2]
         { info_tbl: [(caFYo,
                       label: block_caFYo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caFYy; else goto caFYx;
       caFYy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caFYx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saFod_entry() //  [R1]
         { info_tbl: [(caFYz,
                       label: sat_saFod_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYz: // global
           _saFod::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caFYA; else goto caFYB;
       caFYB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caFYD; else goto caFYC;
       caFYD: // global
           HpAlloc = 40;
           goto caFYA;
       caFYA: // global
           R1 = _saFod::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFYC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saFod::P64;
           _saFo0::P64 = P64[_saFod::P64 + 16];
           _saFnW::I64 = I64[_saFod::P64 + 24];
           _saFnX::I64 = I64[_saFod::P64 + 32];
           I64[Hp - 32] = sat_saFoc_info;
           P64[Hp - 16] = _saFo0::P64;
           I64[Hp - 8] = _saFnW::I64;
           I64[Hp] = _saFnX::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_saFnZ_entry() //  [R1, R2]
         { info_tbl: [(caFYE,
                       label: p_saFnZ_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caFYI; else goto caFYH;
       caFYI: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caFYH: // global
           _saFnW::I64 = I64[R1 + 7];
           _saFnX::I64 = I64[R1 + 15];
           I64[Hp - 32] = sat_saFod_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = _saFnW::I64;
           I64[Hp] = _saFnX::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Manager.$fShowFdKey5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFog_entry() //  [R1]
         { info_tbl: [(caFYS,
                       label: sat_saFog_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFYS: // global
           _saFog::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caFYT; else goto caFYU;
       caFYU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caFYW; else goto caFYV;
       caFYW: // global
           HpAlloc = 24;
           goto caFYT;
       caFYT: // global
           R1 = _saFog::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFYV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saFog::P64;
           _saFnY::P64 = P64[_saFog::P64 + 16];
           _saFnZ::P64 = P64[_saFog::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _saFnY::P64;
           R2 = Hp - 14;
           R1 = _saFnZ::P64;
           Sp = Sp - 16;
           call p_saFnZ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caFZ0,
                       label: GHC.Event.Manager.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFZ0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caFZ4; else goto caFZ3;
       caFZ4: // global
           HpAlloc = 80;
           R1 = GHC.Event.Manager.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caFZ3: // global
           I64[Hp - 72] = p_saFnZ_info;
           I64[Hp - 64] = R3;
           I64[Hp - 56] = R4;
           _caFXz::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto caFYY; else goto caFYZ;
       caFYY: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _caFXz::P64;
           call p_saFnZ_entry(R2, R1) args: 8, res: 0, upd: 8;
       caFYZ: // global
           I64[Hp - 48] = sat_saFog_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _caFXz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.894818487 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(caG0j,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG0j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caG0n; else goto caG0o;
       caG0n: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caG0o: // global
           I64[Sp - 24] = block_caG0g_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaG0w; else goto caG0h;
       uaG0w: // global
           call _caG0g(R1) args: 0, res: 0, upd: 0;
       caG0h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG0g() //  [R1]
         { info_tbl: [(caG0g,
                       label: block_caG0g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG0g: // global
           I64[Sp] = block_caG0m_info;
           _saFol::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saFol::I64;
           if (R1 & 7 != 0) goto uaG0v; else goto caG0q;
       uaG0v: // global
           call _caG0m(R1) args: 0, res: 0, upd: 0;
       caG0q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG0m() //  [R1]
         { info_tbl: [(caG0m,
                       label: block_caG0m_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG0m: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.901888725 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey6_closure" {
     GHC.Event.Manager.$fShowFdKey6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.903800925 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshow_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshow_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshow_entry() //  [R2]
         { info_tbl: [(caG0U,
                       label: GHC.Event.Manager.$fShowFdKey_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG0U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG0V; else goto caG0W;
       caG0V: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG0W: // global
           I64[Sp - 8] = block_caG0R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG10; else goto caG0S;
       uaG10: // global
           call _caG0R(R1) args: 0, res: 0, upd: 0;
       caG0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG0R() //  [R1]
         { info_tbl: [(caG0R,
                       label: block_caG0R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG0R: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.909510779 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey1_closure" {
     GHC.Event.Manager.$fShowFdKey1_closure:
         const GHC.Event.Manager.$fShowFdKey1_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey1_entry() //  [R2, R3]
         { info_tbl: [(caG1j,
                       label: GHC.Event.Manager.$fShowFdKey1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG1j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caG1k; else goto caG1l;
       caG1k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowFdKey1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caG1l: // global
           I64[Sp - 16] = block_caG1g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaG1p; else goto caG1h;
       uaG1p: // global
           call _caG1g(R1) args: 0, res: 0, upd: 0;
       caG1h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG1g() //  [R1]
         { info_tbl: [(caG1g,
                       label: block_caG1g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG1g: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Manager.$w$cshowsPrec_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.914922995 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_$cshowList_closure" {
     GHC.Event.Manager.$fShowFdKey_$cshowList_closure:
         const GHC.Event.Manager.$fShowFdKey_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowFdKey_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caG1E,
                       label: GHC.Event.Manager.$fShowFdKey_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG1E: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$fShowFdKey1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.919063146 UTC

[section ""data" . GHC.Event.Manager.$fShowFdKey_closure" {
     GHC.Event.Manager.$fShowFdKey_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure+1;
         const GHC.Event.Manager.$fShowFdKey_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.921101698 UTC

[section ""data" . GHC.Event.Manager.keyUnique_closure" {
     GHC.Event.Manager.keyUnique_closure:
         const GHC.Event.Manager.keyUnique_info;
 },
 GHC.Event.Manager.keyUnique_entry() //  [R2]
         { info_tbl: [(caG1T,
                       label: GHC.Event.Manager.keyUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG1T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG1X; else goto caG1Y;
       caG1X: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG1Y: // global
           I64[Sp - 8] = block_caG1Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG22; else goto caG1R;
       uaG22: // global
           call _caG1Q(R1) args: 0, res: 0, upd: 0;
       caG1R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG1Q() //  [R1]
         { info_tbl: [(caG1Q,
                       label: block_caG1Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG1Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caG21; else goto caG20;
       caG21: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG20: // global
           _saFoD::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFoD::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.92692302 UTC

[section ""data" . GHC.Event.Manager.keyFd_closure" {
     GHC.Event.Manager.keyFd_closure:
         const GHC.Event.Manager.keyFd_info;
 },
 GHC.Event.Manager.keyFd_entry() //  [R2]
         { info_tbl: [(caG2m,
                       label: GHC.Event.Manager.keyFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG2m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG2q; else goto caG2r;
       caG2q: // global
           R2 = R2;
           R1 = GHC.Event.Manager.keyFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG2r: // global
           I64[Sp - 8] = block_caG2j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG2v; else goto caG2k;
       uaG2v: // global
           call _caG2j(R1) args: 0, res: 0, upd: 0;
       caG2k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG2j() //  [R1]
         { info_tbl: [(caG2j,
                       label: block_caG2j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG2j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caG2u; else goto caG2t;
       caG2u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG2t: // global
           _saFoG::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saFoG::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.932979043 UTC

[section ""data" . GHC.Event.Manager._fdCallback_closure" {
     GHC.Event.Manager._fdCallback_closure:
         const GHC.Event.Manager._fdCallback_info;
 },
 GHC.Event.Manager._fdCallback_entry() //  [R2]
         { info_tbl: [(caG2P,
                       label: GHC.Event.Manager._fdCallback_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG2P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG2Q; else goto caG2R;
       caG2Q: // global
           R2 = R2;
           R1 = GHC.Event.Manager._fdCallback_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG2R: // global
           I64[Sp - 8] = block_caG2M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG2V; else goto caG2N;
       uaG2V: // global
           call _caG2M(R1) args: 0, res: 0, upd: 0;
       caG2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG2M() //  [R1]
         { info_tbl: [(caG2M,
                       label: block_caG2M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG2M: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.938261824 UTC

[section ""data" . GHC.Event.Manager.fdEvents_closure" {
     GHC.Event.Manager.fdEvents_closure:
         const GHC.Event.Manager.fdEvents_info;
 },
 GHC.Event.Manager.fdEvents_entry() //  [R2]
         { info_tbl: [(caG3d,
                       label: GHC.Event.Manager.fdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG3d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG3h; else goto caG3i;
       caG3h: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG3i: // global
           I64[Sp - 8] = block_caG3a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG3m; else goto caG3b;
       uaG3m: // global
           call _caG3a(R1) args: 0, res: 0, upd: 0;
       caG3b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG3a() //  [R1]
         { info_tbl: [(caG3a,
                       label: block_caG3a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG3a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caG3l; else goto caG3k;
       caG3l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG3k: // global
           _saFoS::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFoS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.943945429 UTC

[section ""data" . GHC.Event.Manager.fdKey_closure" {
     GHC.Event.Manager.fdKey_closure:
         const GHC.Event.Manager.fdKey_info;
 },
 GHC.Event.Manager.fdKey_entry() //  [R2]
         { info_tbl: [(caG3G,
                       label: GHC.Event.Manager.fdKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG3G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG3K; else goto caG3L;
       caG3K: // global
           R2 = R2;
           R1 = GHC.Event.Manager.fdKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG3L: // global
           I64[Sp - 8] = block_caG3D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG3P; else goto caG3E;
       uaG3P: // global
           call _caG3D(R1) args: 0, res: 0, upd: 0;
       caG3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG3D() //  [R1]
         { info_tbl: [(caG3D,
                       label: block_caG3D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG3D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caG3O; else goto caG3N;
       caG3O: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG3N: // global
           _saFoW::I64 = I64[R1 + 15];
           _saFoX::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saFoW::I64;
           I64[Hp] = _saFoX::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.950031092 UTC

[section ""data" . GHC.Event.Manager.emLock_closure" {
     GHC.Event.Manager.emLock_closure:
         const GHC.Event.Manager.emLock_info;
 },
 GHC.Event.Manager.emLock_entry() //  [R2]
         { info_tbl: [(caG49,
                       label: GHC.Event.Manager.emLock_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG49: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG4d; else goto caG4e;
       caG4d: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emLock_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG4e: // global
           I64[Sp - 8] = block_caG46_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG4i; else goto caG47;
       uaG4i: // global
           call _caG46(R1) args: 0, res: 0, upd: 0;
       caG47: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG46() //  [R1]
         { info_tbl: [(caG46,
                       label: block_caG46_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG46: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caG4h; else goto caG4g;
       caG4h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG4g: // global
           _saFpe::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _saFpe::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.956276006 UTC

[section ""data" . GHC.Event.Manager.emControl_closure" {
     GHC.Event.Manager.emControl_closure:
         const GHC.Event.Manager.emControl_info;
 },
 GHC.Event.Manager.emControl_entry() //  [R2]
         { info_tbl: [(caG4C,
                       label: GHC.Event.Manager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG4C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG4G; else goto caG4H;
       caG4G: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG4H: // global
           I64[Sp - 8] = block_caG4z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG4L; else goto caG4A;
       uaG4L: // global
           call _caG4z(R1) args: 0, res: 0, upd: 0;
       caG4A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG4z() //  [R1]
         { info_tbl: [(caG4z,
                       label: block_caG4z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG4z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caG4K; else goto caG4J;
       caG4K: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG4J: // global
           _saFpr::P64 = P64[R1 + 55];
           _saFps::P64 = P64[R1 + 63];
           _saFpo::I64 = I64[R1 + 87];
           _saFpp::I64 = I64[R1 + 95];
           _saFpq::I64 = I64[R1 + 103];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _saFpr::P64;
           P64[Hp - 24] = _saFps::P64;
           I64[Hp - 16] = _saFpo::I64;
           I64[Hp - 8] = _saFpp::I64;
           I64[Hp] = _saFpq::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.962753695 UTC

[section ""data" . GHC.Event.Manager.emUniqueSource_closure" {
     GHC.Event.Manager.emUniqueSource_closure:
         const GHC.Event.Manager.emUniqueSource_info;
 },
 GHC.Event.Manager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(caG55,
                       label: GHC.Event.Manager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG55: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG59; else goto caG5a;
       caG59: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG5a: // global
           I64[Sp - 8] = block_caG52_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG5e; else goto caG53;
       uaG5e: // global
           call _caG52(R1) args: 0, res: 0, upd: 0;
       caG53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG52() //  [R1]
         { info_tbl: [(caG52,
                       label: block_caG52_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG52: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caG5d; else goto caG5c;
       caG5d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG5c: // global
           _saFpC::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _saFpC::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.968515305 UTC

[section ""data" . GHC.Event.Manager.emState_closure" {
     GHC.Event.Manager.emState_closure:
         const GHC.Event.Manager.emState_info;
 },
 GHC.Event.Manager.emState_entry() //  [R2]
         { info_tbl: [(caG5y,
                       label: GHC.Event.Manager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG5y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG5C; else goto caG5D;
       caG5C: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG5D: // global
           I64[Sp - 8] = block_caG5v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG5H; else goto caG5w;
       uaG5H: // global
           call _caG5v(R1) args: 0, res: 0, upd: 0;
       caG5w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG5v() //  [R1]
         { info_tbl: [(caG5v,
                       label: block_caG5v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG5v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caG5G; else goto caG5F;
       caG5G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG5F: // global
           _saFpQ::P64 = P64[R1 + 39];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _saFpQ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.974238264 UTC

[section ""data" . GHC.Event.Manager.emFds_closure" {
     GHC.Event.Manager.emFds_closure:
         const GHC.Event.Manager.emFds_info;
 },
 GHC.Event.Manager.emFds_entry() //  [R2]
         { info_tbl: [(caG61,
                       label: GHC.Event.Manager.emFds_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG61: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG65; else goto caG66;
       caG65: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emFds_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG66: // global
           I64[Sp - 8] = block_caG5Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG6a; else goto caG5Z;
       uaG6a: // global
           call _caG5Y(R1) args: 0, res: 0, upd: 0;
       caG5Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG5Y() //  [R1]
         { info_tbl: [(caG5Y,
                       label: block_caG5Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG5Y: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caG69; else goto caG68;
       caG69: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caG68: // global
           _saFq1::P64 = P64[R1 + 15];
           _saFq2::P64 = P64[R1 + 23];
           _saFq4::P64 = P64[R1 + 31];
           _saFq3::I64 = I64[R1 + 79];
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = _saFq1::P64;
           P64[Hp - 16] = _saFq2::P64;
           P64[Hp - 8] = _saFq4::P64;
           I64[Hp] = _saFq3::I64;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.979885932 UTC

[section ""data" . GHC.Event.Manager.emBackend_closure" {
     GHC.Event.Manager.emBackend_closure:
         const GHC.Event.Manager.emBackend_info;
 },
 GHC.Event.Manager.emBackend_entry() //  [R2]
         { info_tbl: [(caG6u,
                       label: GHC.Event.Manager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG6u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG6v; else goto caG6w;
       caG6v: // global
           R2 = R2;
           R1 = GHC.Event.Manager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG6w: // global
           I64[Sp - 8] = block_caG6r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG6A; else goto caG6s;
       uaG6A: // global
           call _caG6r(R1) args: 0, res: 0, upd: 0;
       caG6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG6r() //  [R1]
         { info_tbl: [(caG6r,
                       label: block_caG6r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG6r: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.985816247 UTC

[section ""data" . GHC.Event.Manager.newDefaultBackend_closure" {
     GHC.Event.Manager.newDefaultBackend_closure:
         const GHC.Event.Manager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.Manager.newDefaultBackend_entry() //  []
         { info_tbl: [(caG6R,
                       label: GHC.Event.Manager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG6R: // global
           call GHC.Event.EPoll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.989412412 UTC

[section ""cstring" . GHC.Event.Manager.$trModule4_bytes" {
     GHC.Event.Manager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.991037823 UTC

[section ""data" . GHC.Event.Manager.$trModule3_closure" {
     GHC.Event.Manager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.992690528 UTC

[section ""cstring" . GHC.Event.Manager.$trModule2_bytes" {
     GHC.Event.Manager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.994640488 UTC

[section ""data" . GHC.Event.Manager.$trModule1_closure" {
     GHC.Event.Manager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.996282716 UTC

[section ""data" . GHC.Event.Manager.$trModule_closure" {
     GHC.Event.Manager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Manager.$trModule3_closure+1;
         const GHC.Event.Manager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.997902368 UTC

[section ""data" . $krep_raAtw_closure" {
     $krep_raAtw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:40.999518273 UTC

[section ""data" . $krep1_raAtx_closure" {
     $krep1_raAtx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.001157292 UTC

[section ""data" . $krep2_raAty_closure" {
     $krep2_raAty_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEvent_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.002777684 UTC

[section ""data" . $krep3_raAtz_closure" {
     $krep3_raAtz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcEventLifetime_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.004415944 UTC

[section ""data" . $krep4_raAtA_closure" {
     $krep4_raAtA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.006507171 UTC

[section ""data" . $krep5_raAtB_closure" {
     $krep5_raAtB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.00816384 UTC

[section ""data" . $krep6_raAtC_closure" {
     $krep6_raAtC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.009780084 UTC

[section ""data" . $krep7_raAtD_closure" {
     $krep7_raAtD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.011459353 UTC

[section ""data" . $krep8_raAtE_closure" {
     $krep8_raAtE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.013622372 UTC

[section ""data" . $krep9_raAtF_closure" {
     $krep9_raAtF_closure:
         const :_con_info;
         const $krep4_raAtA_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.01530464 UTC

[section ""data" . $krep10_raAtG_closure" {
     $krep10_raAtG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.016959659 UTC

[section ""data" . $krep11_raAtH_closure" {
     $krep11_raAtH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep9_raAtF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.018655235 UTC

[section ""data" . $krep12_raAtI_closure" {
     $krep12_raAtI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_raAty_closure+1;
         const $krep10_raAtG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.020314593 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdKey2_bytes" {
     GHC.Event.Manager.$tcFdKey2_bytes:
         I8[] [70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.022430483 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey1_closure" {
     GHC.Event.Manager.$tcFdKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.024124736 UTC

[section ""data" . GHC.Event.Manager.$tcFdKey_closure" {
     GHC.Event.Manager.$tcFdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11469896173097407196;
         const 6069269054622812669;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.025914154 UTC

[section ""data" . $krep13_raAtJ_closure" {
     $krep13_raAtJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.027553073 UTC

[section ""data" . $krep14_raAtK_closure" {
     $krep14_raAtK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep12_raAtI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.029215349 UTC

[section ""data" . $krep15_raAtL_closure" {
     $krep15_raAtL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_raAtw_closure+1;
         const $krep13_raAtJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.030924365 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey1_closure" {
     GHC.Event.Manager.$tc'FdKey1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_raAtx_closure+1;
         const $krep15_raAtL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.032627825 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdKey3_bytes" {
     GHC.Event.Manager.$tc'FdKey3_bytes:
         I8[] [39,70,100,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.034239586 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey2_closure" {
     GHC.Event.Manager.$tc'FdKey2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdKey3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.035852679 UTC

[section ""data" . GHC.Event.Manager.$tc'FdKey_closure" {
     GHC.Event.Manager.$tc'FdKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdKey2_closure+1;
         const GHC.Event.Manager.$tc'FdKey1_closure+4;
         const 5122964525573573781;
         const 3523266410810375450;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.038180837 UTC

[section ""cstring" . GHC.Event.Manager.$tcFdData2_bytes" {
     GHC.Event.Manager.$tcFdData2_bytes:
         I8[] [70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.039757652 UTC

[section ""data" . GHC.Event.Manager.$tcFdData1_closure" {
     GHC.Event.Manager.$tcFdData1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcFdData2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.041456807 UTC

[section ""data" . GHC.Event.Manager.$tcFdData_closure" {
     GHC.Event.Manager.$tcFdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcFdData1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9572952300930290737;
         const 248149994861342082;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.043148468 UTC

[section ""data" . $krep16_raAtM_closure" {
     $krep16_raAtM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcFdData_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.044810491 UTC

[section ""data" . $krep17_raAtN_closure" {
     $krep17_raAtN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_raAtK_closure+4;
         const $krep16_raAtM_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.046576817 UTC

[section ""data" . $krep18_raAtO_closure" {
     $krep18_raAtO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_raAtz_closure+1;
         const $krep17_raAtN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.048271369 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData1_closure" {
     GHC.Event.Manager.$tc'FdData1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_raAtJ_closure+1;
         const $krep18_raAtO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.050440018 UTC

[section ""cstring" . GHC.Event.Manager.$tc'FdData3_bytes" {
     GHC.Event.Manager.$tc'FdData3_bytes:
         I8[] [39,70,100,68,97,116,97]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.052112572 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData2_closure" {
     GHC.Event.Manager.$tc'FdData2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'FdData3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.053667365 UTC

[section ""data" . GHC.Event.Manager.$tc'FdData_closure" {
     GHC.Event.Manager.$tc'FdData_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'FdData2_closure+1;
         const GHC.Event.Manager.$tc'FdData1_closure+4;
         const 13006093439393452327;
         const 3623098721817739111;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.055480495 UTC

[section ""data" . $krep19_raAtP_closure" {
     $krep19_raAtP_closure:
         const :_con_info;
         const $krep16_raAtM_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.057142193 UTC

[section ""data" . $krep20_raAtQ_closure" {
     $krep20_raAtQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep19_raAtP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.058843969 UTC

[section ""data" . $krep21_raAtR_closure" {
     $krep21_raAtR_closure:
         const :_con_info;
         const $krep20_raAtQ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.060524627 UTC

[section ""data" . $krep22_raAtS_closure" {
     $krep22_raAtS_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.IntTable.$tcIntTable_closure;
         const $krep21_raAtR_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.062791931 UTC

[section ""data" . $krep23_raAtT_closure" {
     $krep23_raAtT_closure:
         const :_con_info;
         const $krep22_raAtS_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.064454765 UTC

[section ""data" . $krep24_raAtU_closure" {
     $krep24_raAtU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep23_raAtT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.066187365 UTC

[section ""data" . $krep25_raAtV_closure" {
     $krep25_raAtV_closure:
         const :_con_info;
         const $krep24_raAtU_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.067831166 UTC

[section ""data" . $krep26_raAtW_closure" {
     $krep26_raAtW_closure:
         const :_con_info;
         const $krep7_raAtD_closure+1;
         const $krep25_raAtV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.070497048 UTC

[section ""data" . $krep27_raAtX_closure" {
     $krep27_raAtX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Arr.$tcArray_closure;
         const $krep26_raAtW_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.07226151 UTC

[section ""cstring" . GHC.Event.Manager.$tcState2_bytes" {
     GHC.Event.Manager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.07393859 UTC

[section ""data" . GHC.Event.Manager.$tcState1_closure" {
     GHC.Event.Manager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.075641566 UTC

[section ""data" . GHC.Event.Manager.$tcState_closure" {
     GHC.Event.Manager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7442518771887689078;
         const 3049393439281173903;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.077497033 UTC

[section ""data" . GHC.Event.Manager.$tc'Created1_closure" {
     GHC.Event.Manager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.079232778 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Created3_bytes" {
     GHC.Event.Manager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.080876434 UTC

[section ""data" . GHC.Event.Manager.$tc'Created2_closure" {
     GHC.Event.Manager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.082573396 UTC

[section ""data" . GHC.Event.Manager.$tc'Created_closure" {
     GHC.Event.Manager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Created2_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 17846748838152018769;
         const 13865095201560943193;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.084358191 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Running2_bytes" {
     GHC.Event.Manager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.086641188 UTC

[section ""data" . GHC.Event.Manager.$tc'Running1_closure" {
     GHC.Event.Manager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.088698471 UTC

[section ""data" . GHC.Event.Manager.$tc'Running_closure" {
     GHC.Event.Manager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Running1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8784511774161450304;
         const 13551584807303205071;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.09053481 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Dying2_bytes" {
     GHC.Event.Manager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.092052908 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying1_closure" {
     GHC.Event.Manager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.093733857 UTC

[section ""data" . GHC.Event.Manager.$tc'Dying_closure" {
     GHC.Event.Manager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Dying1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 10564881478355389136;
         const 3106847497763432300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.095507605 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Releasing2_bytes" {
     GHC.Event.Manager.$tc'Releasing2_bytes:
         I8[] [39,82,101,108,101,97,115,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.097108069 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing1_closure" {
     GHC.Event.Manager.$tc'Releasing1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Releasing2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.099250685 UTC

[section ""data" . GHC.Event.Manager.$tc'Releasing_closure" {
     GHC.Event.Manager.$tc'Releasing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Releasing1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 3204716164798465120;
         const 4205553053946559474;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.101055047 UTC

[section ""cstring" . GHC.Event.Manager.$tc'Finished2_bytes" {
     GHC.Event.Manager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.102830657 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished1_closure" {
     GHC.Event.Manager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.104601464 UTC

[section ""data" . GHC.Event.Manager.$tc'Finished_closure" {
     GHC.Event.Manager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'Finished1_closure+1;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const 8866864364616799312;
         const 2451390217632909923;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.106414354 UTC

[section ""data" . $krep28_raAtY_closure" {
     $krep28_raAtY_closure:
         const :_con_info;
         const GHC.Event.Manager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.1081248 UTC

[section ""data" . $krep29_raAtZ_closure" {
     $krep29_raAtZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep28_raAtY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.110118344 UTC

[section ""cstring" . GHC.Event.Manager.$tcEventManager2_bytes" {
     GHC.Event.Manager.$tcEventManager2_bytes:
         I8[] [69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.111710854 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager1_closure" {
     GHC.Event.Manager.$tcEventManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tcEventManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.113425275 UTC

[section ""data" . GHC.Event.Manager.$tcEventManager_closure" {
     GHC.Event.Manager.$tcEventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tcEventManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16777685112477180948;
         const 1210110422135437783;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.115683457 UTC

[section ""data" . $krep30_raAu0_closure" {
     $krep30_raAu0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Manager.$tcEventManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.117434078 UTC

[section ""data" . $krep31_raAu1_closure" {
     $krep31_raAu1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_raAtH_closure+1;
         const $krep30_raAu0_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.119131391 UTC

[section ""data" . $krep32_raAu2_closure" {
     $krep32_raAu2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_raAtB_closure+1;
         const $krep31_raAu1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.120901209 UTC

[section ""data" . $krep33_raAu3_closure" {
     $krep33_raAu3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_raAtC_closure+1;
         const $krep32_raAu2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.122954687 UTC

[section ""data" . $krep34_raAu4_closure" {
     $krep34_raAu4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep29_raAtZ_closure+1;
         const $krep33_raAu3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.124549772 UTC

[section ""data" . $krep35_raAu5_closure" {
     $krep35_raAu5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_raAtX_closure+1;
         const $krep34_raAu4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.126246427 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager1_closure" {
     GHC.Event.Manager.$tc'EventManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_raAtE_closure+1;
         const $krep35_raAu5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.127939451 UTC

[section ""cstring" . GHC.Event.Manager.$tc'EventManager3_bytes" {
     GHC.Event.Manager.$tc'EventManager3_bytes:
         I8[] [39,69,118,101,110,116,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.12960601 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager2_closure" {
     GHC.Event.Manager.$tc'EventManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Manager.$tc'EventManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.131294105 UTC

[section ""data" . GHC.Event.Manager.$tc'EventManager_closure" {
     GHC.Event.Manager.$tc'EventManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Manager.$trModule_closure+1;
         const GHC.Event.Manager.$tc'EventManager2_closure+1;
         const GHC.Event.Manager.$tc'EventManager1_closure+4;
         const 13274036699047731538;
         const 394780277405469411;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.133992437 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshow_closure" {
     GHC.Event.Manager.$fShowState_$cshow_closure:
         const GHC.Event.Manager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(caG8v,
                       label: GHC.Event.Manager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG8v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caG8w; else goto caG8x;
       caG8w: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG8x: // global
           I64[Sp - 8] = block_caG8l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG8Q; else goto caG8m;
       uaG8Q: // global
           call _caG8l(R1) args: 0, res: 0, upd: 0;
       caG8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG8l() //  [R1]
         { info_tbl: [(caG8l,
                       label: block_caG8l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG8l: // global
           _caG8u::P64 = R1 & 7;
           if (_caG8u::P64 < 4) goto uaG8N; else goto uaG8P;
       uaG8N: // global
           if (_caG8u::P64 < 3) goto uaG8O; else goto caG8r;
       uaG8O: // global
           if (_caG8u::P64 < 2) goto caG8p; else goto caG8q;
       caG8p: // global
           R1 = GHC.Event.Manager.$fShowState9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caG8q: // global
           R1 = GHC.Event.Manager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caG8r: // global
           R1 = GHC.Event.Manager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uaG8P: // global
           if (_caG8u::P64 < 5) goto caG8s; else goto caG8t;
       caG8s: // global
           R1 = GHC.Event.Manager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caG8t: // global
           R1 = GHC.Event.Manager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.140213554 UTC

[section ""data" . GHC.Event.Manager.$fShowState_$cshowList_closure" {
     GHC.Event.Manager.$fShowState_$cshowList_closure:
         const GHC.Event.Manager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.Manager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caG9b,
                       label: GHC.Event.Manager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG9b: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Manager.$w$cshowsPrec1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.143997033 UTC

[section ""data" . GHC.Event.Manager.$fShowState_closure" {
     GHC.Event.Manager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Manager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.Manager.$fShowState_$cshow_closure+1;
         const GHC.Event.Manager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.146498219 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c==_closure" {
     GHC.Event.Manager.$fEqFdKey_$c==_closure:
         const GHC.Event.Manager.$fEqFdKey_$c==_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c==_entry() //  [R2, R3]
         { info_tbl: [(caG9q,
                       label: GHC.Event.Manager.$fEqFdKey_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG9q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caG9u; else goto caG9v;
       caG9u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caG9v: // global
           I64[Sp - 16] = block_caG9n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaG9L; else goto caG9o;
       uaG9L: // global
           call _caG9n(R1) args: 0, res: 0, upd: 0;
       caG9o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG9n() //  [R1]
         { info_tbl: [(caG9n,
                       label: block_caG9n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG9n: // global
           I64[Sp - 8] = block_caG9t_info;
           _saFqz::I64 = I64[R1 + 7];
           _saFqA::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saFqA::I64;
           I64[Sp + 8] = _saFqz::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaG9K; else goto caG9x;
       uaG9K: // global
           call _caG9t(R1) args: 0, res: 0, upd: 0;
       caG9x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caG9t() //  [R1]
         { info_tbl: [(caG9t,
                       label: block_caG9t_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG9t: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto caG9G; else goto caG9F;
       caG9G: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caG9F: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.154285384 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_$c/=_closure" {
     GHC.Event.Manager.$fEqFdKey_$c/=_closure:
         const GHC.Event.Manager.$fEqFdKey_$c/=_info;
 },
 GHC.Event.Manager.$fEqFdKey_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caGag,
                       label: GHC.Event.Manager.$fEqFdKey_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGag: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGak; else goto caGal;
       caGak: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqFdKey_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGal: // global
           I64[Sp - 16] = block_caGad_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGaF; else goto caGae;
       uaGaF: // global
           call _caGad(R1) args: 0, res: 0, upd: 0;
       caGae: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGad() //  [R1]
         { info_tbl: [(caGad,
                       label: block_caGad_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGad: // global
           I64[Sp - 8] = block_caGaj_info;
           _saFqJ::I64 = I64[R1 + 7];
           _saFqK::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _saFqK::I64;
           I64[Sp + 8] = _saFqJ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGaE; else goto caGan;
       uaGaE: // global
           call _caGaj(R1) args: 0, res: 0, upd: 0;
       caGan: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGaj() //  [R1]
         { info_tbl: [(caGaj,
                       label: block_caGaj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGaj: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto caGaB; else goto caGaD;
       caGaD: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto caGaB; else goto caGaC;
       caGaB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caGaC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.161799047 UTC

[section ""data" . GHC.Event.Manager.$fEqFdKey_closure" {
     GHC.Event.Manager.$fEqFdKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqFdKey_$c==_closure+2;
         const GHC.Event.Manager.$fEqFdKey_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.164523901 UTC

[section ""data" . GHC.Event.Manager.$fEqState_$c/=_closure" {
     GHC.Event.Manager.$fEqState_$c/=_closure:
         const GHC.Event.Manager.$fEqState_$c/=_info;
 },
 GHC.Event.Manager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(caGbg,
                       label: GHC.Event.Manager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGbg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGbh; else goto caGbi;
       caGbh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGbi: // global
           I64[Sp - 16] = block_caGb6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGcT; else goto caGb7;
       uaGcT: // global
           call _caGb6(R1) args: 0, res: 0, upd: 0;
       caGb7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGb6() //  [R1]
         { info_tbl: [(caGb6,
                       label: block_caGb6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGb6: // global
           _saFqR::P64 = P64[Sp + 8];
           _caGbf::P64 = R1 & 7;
           if (_caGbf::P64 < 4) goto uaGcB; else goto uaGcD;
       uaGcB: // global
           if (_caGbf::P64 < 3) goto uaGcC; else goto caGbc;
       uaGcC: // global
           if (_caGbf::P64 < 2) goto caGba; else goto caGbb;
       caGba: // global
           I64[Sp + 8] = block_caGbl_info;
           R1 = _saFqR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaGcO; else goto caGbn;
       uaGcO: // global
           call _caGbl(R1) args: 0, res: 0, upd: 0;
       caGbn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caGbb: // global
           I64[Sp + 8] = block_caGbA_info;
           R1 = _saFqR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaGcP; else goto caGbC;
       uaGcP: // global
           call _caGbA(R1) args: 0, res: 0, upd: 0;
       caGbC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caGbc: // global
           I64[Sp + 8] = block_caGbP_info;
           R1 = _saFqR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaGcQ; else goto caGbR;
       uaGcQ: // global
           call _caGbP(R1) args: 0, res: 0, upd: 0;
       caGbR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaGcD: // global
           if (_caGbf::P64 < 5) goto caGbd; else goto caGbe;
       caGbd: // global
           I64[Sp + 8] = block_caGc4_info;
           R1 = _saFqR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaGcR; else goto caGc6;
       uaGcR: // global
           call _caGc4(R1) args: 0, res: 0, upd: 0;
       caGc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caGbe: // global
           I64[Sp + 8] = block_caGcj_info;
           R1 = _saFqR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaGcS; else goto caGcl;
       uaGcS: // global
           call _caGcj(R1) args: 0, res: 0, upd: 0;
       caGcl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGbl() //  [R1]
         { info_tbl: [(caGbl,
                       label: block_caGbl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGbl: // global
           if (R1 & 7 == 1) goto uaGcE; else goto uaGcF;
       uaGcE: // global
           Sp = Sp + 8;
           call _caGcv() args: 0, res: 0, upd: 0;
       uaGcF: // global
           Sp = Sp + 8;
           call _caGcr() args: 0, res: 0, upd: 0;
     }
 },
 _caGbA() //  [R1]
         { info_tbl: [(caGbA,
                       label: block_caGbA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGbA: // global
           if (R1 & 7 == 2) goto uaGcG; else goto uaGcH;
       uaGcG: // global
           Sp = Sp + 8;
           call _caGcv() args: 0, res: 0, upd: 0;
       uaGcH: // global
           Sp = Sp + 8;
           call _caGcr() args: 0, res: 0, upd: 0;
     }
 },
 _caGbP() //  [R1]
         { info_tbl: [(caGbP,
                       label: block_caGbP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGbP: // global
           if (R1 & 7 == 3) goto uaGcI; else goto uaGcJ;
       uaGcI: // global
           Sp = Sp + 8;
           call _caGcv() args: 0, res: 0, upd: 0;
       uaGcJ: // global
           Sp = Sp + 8;
           call _caGcr() args: 0, res: 0, upd: 0;
     }
 },
 _caGc4() //  [R1]
         { info_tbl: [(caGc4,
                       label: block_caGc4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGc4: // global
           if (R1 & 7 == 4) goto uaGcK; else goto uaGcL;
       uaGcK: // global
           Sp = Sp + 8;
           call _caGcv() args: 0, res: 0, upd: 0;
       uaGcL: // global
           Sp = Sp + 8;
           call _caGcr() args: 0, res: 0, upd: 0;
     }
 },
 _caGcj() //  [R1]
         { info_tbl: [(caGcj,
                       label: block_caGcj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGcj: // global
           if (R1 & 7 == 5) goto uaGcM; else goto uaGcN;
       uaGcM: // global
           Sp = Sp + 8;
           call _caGcv() args: 0, res: 0, upd: 0;
       uaGcN: // global
           Sp = Sp + 8;
           call _caGcr() args: 0, res: 0, upd: 0;
     }
 },
 _caGcv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGcv: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGcr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGcr: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.181597473 UTC

[section ""data" . GHC.Event.Manager.$fEqState_closure" {
     GHC.Event.Manager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.Manager.$fEqState_$c==_closure+2;
         const GHC.Event.Manager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.183299856 UTC

[section ""cstring" . lvl1_raAu6_bytes" {
     lvl1_raAu6_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.18519587 UTC

[section ""data" . lvl2_raAu7_closure" {
     lvl2_raAu7_closure:
         const lvl2_raAu7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_raAu7_entry() //  [R1]
         { info_tbl: [(caGe4,
                       label: lvl2_raAu7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGe4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGe5; else goto caGe6;
       caGe5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGe6: // global
           (_caGe1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caGe1::I64 == 0) goto caGe3; else goto caGe2;
       caGe3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caGe2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caGe1::I64;
           R2 = lvl1_raAu6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.189493884 UTC

[section ""data" . lvl3_raAu8_closure" {
     lvl3_raAu8_closure:
         const lvl3_raAu8_info;
         const 0;
 },
 lvl3_raAu8_entry() //  [R2, R3, R4]
         { info_tbl: [(caGek,
                       label: lvl3_raAu8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGek: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGeo; else goto caGen;
       caGeo: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl3_raAu8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caGen: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl2_raAu7_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.193914843 UTC

[section ""data" . GHC.Event.Manager.callbackTableVar_closure" {
     GHC.Event.Manager.callbackTableVar_closure:
         const GHC.Event.Manager.callbackTableVar_info;
         const 0;
 },
 GHC.Event.Manager.callbackTableVar_entry() //  [R2, R3]
         { info_tbl: [(caGeB,
                       label: GHC.Event.Manager.callbackTableVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGeB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caGeP; else goto caGeQ;
       caGeP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.callbackTableVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGeQ: // global
           I64[Sp - 16] = block_caGey_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGfi; else goto caGez;
       uaGfi: // global
           call _caGey(R1) args: 0, res: 0, upd: 0;
       caGez: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGey() //  [R1]
         { info_tbl: [(caGey,
                       label: block_caGey_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGey: // global
           I64[Sp - 16] = block_caGeE_info;
           _saFr7::P64 = P64[R1 + 23];
           _saFr9::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saFr9::P64;
           P64[Sp] = _saFr7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGfh; else goto caGeF;
       uaGfh: // global
           call _caGeE(R1) args: 0, res: 0, upd: 0;
       caGeF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGeE() //  [R1]
         { info_tbl: [(caGeE,
                       label: block_caGeE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGeE: // global
           I64[Sp - 8] = block_caGeJ_info;
           _saFri::P64 = R1;
           _saFrj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saFrj::I64;
           P64[Sp + 16] = _saFri::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGfj; else goto caGeK;
       uaGfj: // global
           call _caGeJ(R1) args: 0, res: 0, upd: 0;
       caGeK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGeJ() //  [R1]
         { info_tbl: [(caGeJ,
                       label: block_caGeJ_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGeJ: // global
           I64[Sp - 8] = block_caGeO_info;
           _saFrk::P64 = R1;
           _saFrl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saFrl::I64;
           P64[Sp + 32] = _saFrk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGfk; else goto caGeU;
       uaGfk: // global
           call _caGeO(R1) args: 0, res: 0, upd: 0;
       caGeU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGeO() //  [R1]
         { info_tbl: [(caGeO,
                       label: block_caGeO_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGeO: // global
           _saFri::P64 = P64[Sp + 32];
           _saFrj::I64 = I64[Sp + 16];
           _saFrk::P64 = P64[Sp + 40];
           _saFro::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saFrj::I64,
                            _saFro::I64)) goto caGfb; else goto caGfd;
       caGfd: // global
           if (%MO_S_Gt_W64(_saFro::I64,
                            I64[Sp + 8])) goto caGfb; else goto caGfc;
       caGfb: // global
           R4 = _saFro::I64;
           R3 = _saFri::P64;
           R2 = _saFrk::P64;
           Sp = Sp + 48;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caGfc: // global
           R1 = P64[P64[Sp + 24] + ((_saFro::I64 - _saFrj::I64 << 3) + 24)] & (-8);
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.205591077 UTC

[section ""data" . GHC.Event.Manager.wakeManager1_closure" {
     GHC.Event.Manager.wakeManager1_closure:
         const GHC.Event.Manager.wakeManager1_info;
 },
 GHC.Event.Manager.wakeManager1_entry() //  []
         { info_tbl: [(caGfU,
                       label: GHC.Event.Manager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGfU: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.209021754 UTC

[section ""data" . GHC.Event.Manager.wakeManager_closure" {
     GHC.Event.Manager.wakeManager_closure:
         const GHC.Event.Manager.wakeManager_info;
 },
 GHC.Event.Manager.wakeManager_entry() //  [R2]
         { info_tbl: [(caGg7,
                       label: GHC.Event.Manager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGg7: // global
           R2 = R2;
           call GHC.Event.Manager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.213256786 UTC

[section ""data" . GHC.Event.Manager.cleanup1_closure" {
     GHC.Event.Manager.cleanup1_closure:
         const GHC.Event.Manager.cleanup1_info;
 },
 GHC.Event.Manager.cleanup1_entry() //  [R2]
         { info_tbl: [(caGgl,
                       label: GHC.Event.Manager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgl: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caGgp; else goto caGgq;
       caGgp: // global
           R2 = R2;
           R1 = GHC.Event.Manager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGgq: // global
           I64[Sp - 8] = block_caGgi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGhj; else goto caGgj;
       uaGhj: // global
           call _caGgi(R1) args: 0, res: 0, upd: 0;
       caGgj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGgi() //  [R1]
         { info_tbl: [(caGgi,
                       label: block_caGgi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgi: // global
           I64[Sp - 56] = block_caGgo_info;
           _saFrG::P64 = P64[R1 + 39];
           _saFrL::P64 = P64[R1 + 55];
           _saFrM::P64 = P64[R1 + 63];
           _saFrN::P64 = P64[R1 + 71];
           _saFrI::I64 = I64[R1 + 87];
           _saFrJ::I64 = I64[R1 + 95];
           _saFrK::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           I64[Sp - 48] = _saFrI::I64;
           I64[Sp - 40] = _saFrJ::I64;
           I64[Sp - 32] = _saFrK::I64;
           P64[Sp - 24] = _saFrL::P64;
           P64[Sp - 16] = _saFrM::P64;
           P64[Sp - 8] = _saFrN::P64;
           P64[Sp] = _saFrG::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaGhi; else goto caGgs;
       uaGhi: // global
           call _caGgo(R1) args: 0, res: 0, upd: 0;
       caGgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGgo() //  [R1]
         { info_tbl: [(caGgo,
                       label: block_caGgo_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgo: // global
           _saFrG::P64 = P64[Sp + 56];
           _saFrN::P64 = P64[Sp + 48];
           _saFrP::P64 = P64[R1 + 7];
           _saFrT::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saFrG::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saFrG::P64);
           I64[Sp] = block_caGgz_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saFrN::P64;
           P64[Sp + 48] = _saFrT::P64;
           P64[Sp + 56] = _saFrP::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGgz() //  []
         { info_tbl: [(caGgz,
                       label: block_caGgz_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgz: // global
           I64[Sp] = block_caGgB_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGgB() //  []
         { info_tbl: [(caGgB,
                       label: block_caGgB_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgB: // global
           I64[Sp] = block_caGgD_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGgD() //  []
         { info_tbl: [(caGgD,
                       label: block_caGgD_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgD: // global
           _saFrJ::I64 = I64[Sp + 16];
           _saFrL::P64 = P64[Sp + 32];
           (_saFs8::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saFsd::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFrJ::I64)));
           I64[Sp + 16] = block_caGgT_info;
           R1 = _saFrL::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaGhk; else goto caGgU;
       uaGhk: // global
           call _caGgT(R1) args: 0, res: 0, upd: 0;
       caGgU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGgT() //  [R1]
         { info_tbl: [(caGgT,
                       label: block_caGgT_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGgT: // global
           _saFrK::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caGh0; else goto caGh4;
       caGh0: // global
           (_saFsj::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFrK::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caGh4: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saFsr::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFrK::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.229317412 UTC

[section ""data" . GHC.Event.Manager.cleanup_closure" {
     GHC.Event.Manager.cleanup_closure:
         const GHC.Event.Manager.cleanup_info;
 },
 GHC.Event.Manager.cleanup_entry() //  [R2]
         { info_tbl: [(caGi6,
                       label: GHC.Event.Manager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGi6: // global
           R2 = R2;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.232967476 UTC

[section ""data" . GHC.Event.Manager.finished1_closure" {
     GHC.Event.Manager.finished1_closure:
         const GHC.Event.Manager.finished1_info;
 },
 sat_saFsM_entry() //  [R1]
         { info_tbl: [(caGix,
                       label: sat_saFsM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGix: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGiy; else goto caGiz;
       caGiy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGiz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caGiq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaGiG; else goto caGir;
       uaGiG: // global
           call _caGiq(R1) args: 0, res: 0, upd: 0;
       caGir: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caGiq() //  [R1]
         { info_tbl: [(caGiq,
                       label: block_caGiq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGiq: // global
           if (R1 & 7 == 5) goto caGiv; else goto caGiu;
       caGiv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caGiu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Manager.finished1_entry() //  [R2]
         { info_tbl: [(caGiH,
                       label: GHC.Event.Manager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGiH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caGiI; else goto caGiJ;
       caGiI: // global
           R2 = R2;
           R1 = GHC.Event.Manager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGiJ: // global
           I64[Sp - 8] = block_caGih_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGiN; else goto caGii;
       uaGiN: // global
           call _caGih(R1) args: 0, res: 0, upd: 0;
       caGii: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGih() //  [R1]
         { info_tbl: [(caGih,
                       label: block_caGih_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGih: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGiM; else goto caGiL;
       caGiM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGiL: // global
           _saFsK::P64 = P64[P64[R1 + 39] + 8];
           I64[Hp - 16] = sat_saFsM_info;
           P64[Hp] = _saFsK::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.242344239 UTC

[section ""data" . GHC.Event.Manager.finished_closure" {
     GHC.Event.Manager.finished_closure:
         const GHC.Event.Manager.finished_info;
 },
 GHC.Event.Manager.finished_entry() //  [R2]
         { info_tbl: [(caGjl,
                       label: GHC.Event.Manager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGjl: // global
           R2 = R2;
           call GHC.Event.Manager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.245580498 UTC

[section ""data" . GHC.Event.Manager.release2_closure" {
     GHC.Event.Manager.release2_closure:
         const GHC.Event.Manager.release2_info;
 },
 GHC.Event.Manager.release2_entry() //  [R2]
         { info_tbl: [(caGjx,
                       label: GHC.Event.Manager.release2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGjx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGjB; else goto caGjA;
       caGjB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.release2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGjA: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Releasing_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.249978422 UTC

[section ""data" . GHC.Event.Manager.release1_closure" {
     GHC.Event.Manager.release1_closure:
         const GHC.Event.Manager.release1_info;
         const 0;
 },
 GHC.Event.Manager.release1_entry() //  [R2]
         { info_tbl: [(caGjQ,
                       label: GHC.Event.Manager.release1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGjQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGjR; else goto caGjS;
       caGjR: // global
           R2 = R2;
           R1 = GHC.Event.Manager.release1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGjS: // global
           I64[Sp - 8] = block_caGjN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGkc; else goto caGjO;
       uaGkc: // global
           call _caGjN(R1) args: 0, res: 0, upd: 0;
       caGjO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGjN() //  [R1]
         { info_tbl: [(caGjN,
                       label: block_caGjN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGjN: // global
           I64[Sp - 16] = block_caGjV_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saFt2::P64 = P64[R1 + 63];
           _saFt0::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saFt2::P64;
           I64[Sp] = _saFt0::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGjV() //  [R1]
         { info_tbl: [(caGjV,
                       label: block_caGjV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGjV: // global
           I64[Sp] = block_caGjX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaGkd; else goto caGk0;
       uaGkd: // global
           call _caGjX(R1) args: 0, res: 0, upd: 0;
       caGk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGjX() //  [R1]
         { info_tbl: [(caGjX,
                       label: block_caGjX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGjX: // global
           if (R1 & 7 == 2) goto caGka; else goto caGk6;
       caGka: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       caGk6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.259293632 UTC

[section ""data" . GHC.Event.Manager.release_closure" {
     GHC.Event.Manager.release_closure:
         const GHC.Event.Manager.release_info;
         const 0;
 },
 GHC.Event.Manager.release_entry() //  [R2]
         { info_tbl: [(caGkF,
                       label: GHC.Event.Manager.release_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGkF: // global
           R2 = R2;
           call GHC.Event.Manager.release1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.262930504 UTC

[section ""data" . GHC.Event.Manager.shutdown2_closure" {
     GHC.Event.Manager.shutdown2_closure:
         const GHC.Event.Manager.shutdown2_info;
 },
 GHC.Event.Manager.shutdown2_entry() //  [R2]
         { info_tbl: [(caGkR,
                       label: GHC.Event.Manager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGkR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGkV; else goto caGkU;
       caGkV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGkU: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.266925733 UTC

[section ""data" . GHC.Event.Manager.shutdown1_closure" {
     GHC.Event.Manager.shutdown1_closure:
         const GHC.Event.Manager.shutdown1_info;
         const 0;
 },
 GHC.Event.Manager.shutdown1_entry() //  [R2]
         { info_tbl: [(caGla,
                       label: GHC.Event.Manager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGla: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGlb; else goto caGlc;
       caGlb: // global
           R2 = R2;
           R1 = GHC.Event.Manager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGlc: // global
           I64[Sp - 8] = block_caGl7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGlw; else goto caGl8;
       uaGlw: // global
           call _caGl7(R1) args: 0, res: 0, upd: 0;
       caGl8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGl7() //  [R1]
         { info_tbl: [(caGl7,
                       label: block_caGl7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGl7: // global
           I64[Sp - 16] = block_caGlf_info;
           R2 = GHC.Event.Manager.shutdown2_closure+1;
           _saFtn::P64 = P64[R1 + 63];
           _saFtk::I64 = I64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _saFtn::P64;
           I64[Sp] = _saFtk::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGlf() //  [R1]
         { info_tbl: [(caGlf,
                       label: block_caGlf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGlf: // global
           I64[Sp] = block_caGlh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaGlx; else goto caGlk;
       uaGlx: // global
           call _caGlh(R1) args: 0, res: 0, upd: 0;
       caGlk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGlh() //  [R1]
         { info_tbl: [(caGlh,
                       label: block_caGlh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGlh: // global
           if (R1 & 7 == 2) goto caGlu; else goto caGlq;
       caGlu: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       caGlq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.276270714 UTC

[section ""data" . GHC.Event.Manager.shutdown_closure" {
     GHC.Event.Manager.shutdown_closure:
         const GHC.Event.Manager.shutdown_info;
         const 0;
 },
 GHC.Event.Manager.shutdown_entry() //  [R2]
         { info_tbl: [(caGlZ,
                       label: GHC.Event.Manager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGlZ: // global
           R2 = R2;
           call GHC.Event.Manager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.279571366 UTC

[section ""cstring" . lvl4_raAu9_bytes" {
     lvl4_raAu9_bytes:
         I8[] [70,97,105,108,101,100,32,119,104,105,108,101,32,97,116,116,101,109,112,116,105,110,103,32,116,111,32,109,111,100,105,102,121,32,114,101,103,105,115,116,114,97,116,105,111,110,32,111,102,32,102,105,108,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.281260487 UTC

[section ""cstring" . lvl5_raAua_bytes" {
     lvl5_raAua_bytes:
         I8[] [32,97,116,32,108,111,99,97,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.283613518 UTC

[section ""data" . $wlvl_raAub_closure" {
     $wlvl_raAub_closure:
         const $wlvl_raAub_info;
         const 0;
 },
 sat_saFtz_entry() //  [R1]
         { info_tbl: [(caGmm,
                       label: sat_saFtz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGmm: // global
           R3 = P64[R1 + 16];
           R2 = lvl5_raAua_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFtA_entry() //  [R1]
         { info_tbl: [(caGmq,
                       label: sat_saFtA_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGmq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caGmr; else goto caGms;
       caGmr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGms: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caGmg_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caGmg() //  [R1, R2]
         { info_tbl: [(caGmg,
                       label: block_caGmg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGmg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caGmv; else goto caGmu;
       caGmv: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caGmu: // global
           I64[Hp - 40] = sat_saFtz_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_raAub_entry() //  [R2, R3]
         { info_tbl: [(caGmy,
                       label: $wlvl_raAub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGmy: // global
           _saFtu::I64 = R3;
           _saFtt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caGmz; else goto caGmA;
       caGmA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caGmC; else goto caGmB;
       caGmC: // global
           HpAlloc = 32;
           goto caGmz;
       caGmz: // global
           R3 = _saFtu::I64;
           R2 = _saFtt::P64;
           R1 = $wlvl_raAub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGmB: // global
           I64[Hp - 24] = sat_saFtA_info;
           P64[Hp - 8] = _saFtt::P64;
           I64[Hp] = _saFtu::I64;
           I64[Sp - 8] = block_caGmw_info;
           R3 = Hp - 24;
           R2 = lvl4_raAu9_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGmw() //  [R1]
         { info_tbl: [(caGmw,
                       label: block_caGmw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGmw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.295082378 UTC

[section ""cstring" . lvl6_raAuc_bytes" {
     lvl6_raAuc_bytes:
         I8[] [114,101,103,105,115,116,101,114,67,111,110,116,114,111,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.296955883 UTC

[section ""data" . lvl7_raAud_closure" {
     lvl7_raAud_closure:
         const lvl7_raAud_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_raAud_entry() //  [R1]
         { info_tbl: [(caGne,
                       label: lvl7_raAud_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGne: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGnf; else goto caGng;
       caGnf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGng: // global
           (_caGnb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caGnb::I64 == 0) goto caGnd; else goto caGnc;
       caGnd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caGnc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caGnb::I64;
           R2 = lvl6_raAuc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.300979556 UTC

[section ""data" . GHC.Event.Manager.new5_closure" {
     GHC.Event.Manager.new5_closure:
         const GHC.Event.Manager.new5_info;
 },
 GHC.Event.Manager.new5_entry() //  [R2]
         { info_tbl: [(caGnu,
                       label: GHC.Event.Manager.new5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGnu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGny; else goto caGnx;
       caGny: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Manager.new5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGnx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.Manager.Finished_closure+5;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.304842256 UTC

[section ""data" . GHC.Event.Manager.new4_closure" {
     GHC.Event.Manager.new4_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.307213497 UTC

[section ""data" . x_raAue_closure" {
     x_raAue_closure:
         const x_raAue_info;
 },
 x_raAue_entry() //  []
         { info_tbl: [(caGnW,
                       label: x_raAue_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGnW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGo9; else goto caGoa;
       caGoa: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caGoc; else goto caGob;
       caGoc: // global
           HpAlloc = 96;
           goto caGo9;
       caGo9: // global
           R1 = x_raAue_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caGob: // global
           I64[Hp - 88] = stg_MUT_ARR_PTRS_DIRTY_info;
           I64[Hp - 80] = 8;
           I64[Hp - 72] = 9;
           _caGnL::I64 = Hp - 88;
           _caGnM::I64 = _caGnL::I64 + 24;
           goto caGnN;
       caGnN: // global
           if (_caGnM::I64 < (_caGnL::I64 + 88)) goto caGnP; else goto caGnO;
       caGnP: // global
           P64[_caGnM::I64] = GHC.Event.IntTable.Empty_closure+1;
           _caGnM::I64 = _caGnM::I64 + 8;
           goto caGnN;
       caGnO: // global
           I64[Sp - 16] = block_caGnQ_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _caGnL::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGnQ() //  [R1]
         { info_tbl: [(caGnQ,
                       label: block_caGnQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGnQ: // global
           I64[Sp - 8] = block_caGnS_info;
           R2 = 8;
           _saFtJ::P64 = R1;
           R1 = 8;
           P64[Sp] = _saFtJ::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGnS() //  [R1]
         { info_tbl: [(caGnS,
                       label: block_caGnS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGnS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caGog; else goto caGof;
       caGog: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGof: // global
           _saFtG::P64 = P64[Sp + 16];
           _saFtJ::P64 = P64[Sp + 8];
           _saFtN::I64 = R1 + 16;
           I64[_saFtN::I64] = 0;
           I64[Hp - 48] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 40] = R1;
           P64[Hp - 32] = _saFtJ::P64;
           _caGnY::P64 = Hp - 46;
           call MO_Touch(_caGnY::P64);
           I64[Hp - 24] = GHC.Event.IntTable.IT_con_info;
           P64[Hp - 16] = _saFtG::P64;
           P64[Hp - 8] = _caGnY::P64;
           I64[Hp] = _saFtN::I64;
           I64[Sp + 16] = block_caGo1_info;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGo1() //  [R1]
         { info_tbl: [(caGo1,
                       label: block_caGo1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGo1: // global
           I64[Sp - 8] = block_caGo3_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caGo3() //  [R1]
         { info_tbl: [(caGo3,
                       label: block_caGo3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGo3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGok; else goto caGoj;
       caGok: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGoj: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_caGo6_info;
           R2 = Hp - 7;
           _saFtX::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _saFtX::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGo6() //  []
         { info_tbl: [(caGo6,
                       label: block_caGo6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGo6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGon; else goto caGom;
       caGon: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caGom: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.321590033 UTC

[section ""data" . GHC.Event.Manager.$wxs_closure" {
     GHC.Event.Manager.$wxs_closure:
         const GHC.Event.Manager.$wxs_info;
 },
 GHC.Event.Manager.$wxs_entry() //  [R2]
         { info_tbl: [(caGp7,
                       label: GHC.Event.Manager.$wxs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGp7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGp8; else goto caGp9;
       caGp8: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$wxs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGp9: // global
           if (R2 == 1) goto caGp6; else goto caGp5;
       caGp6: // global
           I64[Sp - 8] = block_caGpo_info;
           Sp = Sp - 8;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
       caGp5: // global
           I64[Sp - 16] = block_caGpb_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call x_raAue_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caGpo() //  [R1]
         { info_tbl: [(caGpo,
                       label: block_caGpo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGpo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGpt; else goto caGps;
       caGpt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGps: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGpb() //  [R1]
         { info_tbl: [(caGpb,
                       label: block_caGpb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGpb: // global
           I64[Sp] = block_caGpg_info;
           R2 = I64[Sp + 8] - 1;
           P64[Sp + 8] = R1;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGpg() //  [R1]
         { info_tbl: [(caGpg,
                       label: block_caGpg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGpg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGpm; else goto caGpl;
       caGpm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGpl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.330753908 UTC

[section ""data" . GHC.Event.Manager.new3_closure" {
     GHC.Event.Manager.new3_closure:
         const GHC.Event.Manager.new3_info;
         const 0;
 },
 GHC.Event.Manager.new3_entry() //  [R2]
         { info_tbl: [(caGpX,
                       label: GHC.Event.Manager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGpX: // global
           R3 = R2;
           R2 = lvl7_raAud_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.33638308 UTC

[section ""data" . GHC.Event.Manager.new2_closure" {
     GHC.Event.Manager.new2_closure:
         const GHC.Event.Manager.new2_info;
         const 0;
 },
 sat_saFuK_entry() //  [R1]
         { info_tbl: [(caGqs,
                       label: sat_saFuK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGqt; else goto caGqu;
       caGqt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caGqu: // global
           I64[Sp - 24] = block_caGqj_info;
           R2 = GHC.Event.Manager.new5_closure+1;
           _saFuh::P64 = P64[R1 + 7];
           _saFuo::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _saFuh::P64;
           P64[Sp - 8] = _saFuo::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqj() //  [R1]
         { info_tbl: [(caGqj,
                       label: block_caGqj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqj: // global
           I64[Sp] = block_caGql_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaGqL; else goto caGqm;
       uaGqL: // global
           call _caGql(R1) args: 0, res: 0, upd: 0;
       caGqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGql() //  [R1]
         { info_tbl: [(caGql,
                       label: block_caGql_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGql: // global
           if (R1 & 7 == 5) goto caGqq; else goto caGqp;
       caGqq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caGqp: // global
           _saFuh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGqy_info;
           R1 = _saFuh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaGqM; else goto caGqz;
       uaGqM: // global
           call _caGqy(R1) args: 0, res: 0, upd: 0;
       caGqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqy() //  [R1]
         { info_tbl: [(caGqy,
                       label: block_caGqy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqy: // global
           I64[Sp] = block_caGqD_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqD() //  []
         { info_tbl: [(caGqD,
                       label: block_caGqD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqD: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.new2_entry() //  [R2]
         { info_tbl: [(caGqX,
                       label: GHC.Event.Manager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqX: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caGrf; else goto caGrg;
       caGrf: // global
           R2 = R2;
           R1 = GHC.Event.Manager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGrg: // global
           I64[Sp - 16] = block_caGq8_info;
           _saFuh::P64 = R2;
           R2 = 32;
           P64[Sp - 8] = _saFuh::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.$wxs_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGq8() //  [R1]
         { info_tbl: [(caGq8,
                       label: block_caGq8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGq8: // global
           I64[Sp - 8] = block_caGqa_info;
           R2 = GHC.Types.False_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGqa() //  [R1]
         { info_tbl: [(caGqa,
                       label: block_caGqa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqa: // global
           I64[Sp - 8] = block_caGqc_info;
           _saFuo::P64 = R1;
           R1 = GHC.Event.Manager.Created_closure+1;
           P64[Sp] = _saFuo::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqc() //  [R1]
         { info_tbl: [(caGqc,
                       label: block_caGqc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caGrl; else goto caGrk;
       caGrl: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGrk: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_saFuK_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_caGqO_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _saFur::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _saFur::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqO() //  []
         { info_tbl: [(caGqO,
                       label: block_caGqO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqO: // global
           I64[Sp] = block_caGqQ_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caGqQ() //  [R1]
         { info_tbl: [(caGqQ,
                       label: block_caGqQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqQ: // global
           I64[Sp - 8] = block_caGqS_info;
           R2 = GHC.Tuple.()_closure+1;
           _saFuQ::P64 = R1;
           R1 = R1;
           P64[Sp] = _saFuQ::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqS() //  []
         { info_tbl: [(caGqS,
                       label: block_caGqS_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqS: // global
           I64[Sp] = block_caGqU_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uaGsL; else goto caGqV;
       uaGsL: // global
           call _caGqU(R1) args: 0, res: 0, upd: 0;
       caGqV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGqU() //  [R1]
         { info_tbl: [(caGqU,
                       label: block_caGqU_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGqU: // global
           I64[Sp - 16] = block_caGr0_info;
           R2 = GHC.Arr.arrEleBottom_closure;
           _saFuS::P64 = R1;
           _saFuT::P64 = P64[R1 + 7];
           _saFuV::P64 = P64[R1 + 23];
           R1 = 32;
           P64[Sp - 8] = _saFuV::P64;
           P64[Sp] = _saFuT::P64;
           P64[Sp + 48] = _saFuS::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGr0() //  [R1]
         { info_tbl: [(caGr0,
                       label: block_caGr0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGr0: // global
           I64[Sp - 8] = 0;
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 56] = R1;
           Sp = Sp - 8;
           call _caGrx() args: 0, res: 0, upd: 0;
     }
 },
 _caGrx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGrx: // global
           I64[Sp - 8] = block_caGrA_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGsP; else goto caGrC;
       uaGsP: // global
           call _caGrA(R1) args: 0, res: 0, upd: 0;
       caGrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGrA() //  [R1]
         { info_tbl: [(caGrA,
                       label: block_caGrA_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGrA: // global
           if (R1 & 7 == 1) goto uaGsI; else goto caGrQ;
       uaGsI: // global
           Sp = Sp + 16;
           goto uaGsR;
       caGrQ: // global
           _saFv0::P64 = P64[Sp + 72];
           _saFv9::I64 = I64[Sp + 8];
           _saFvc::P64 = P64[R1 + 6];
           _saFvd::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[(_saFv0::P64 + 24) + (_saFv9::I64 << 3)] = _saFvc::P64;
           I64[_saFv0::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFv0::P64 + 24) + ((I64[_saFv0::P64 + 8] << 3) + (_saFv9::I64 >> 7))] = 1 :: W8;
           if (_saFv9::I64 == 31) goto uaGsJ; else goto caGrO;
       uaGsJ: // global
           Sp = Sp + 16;
           goto uaGsR;
       uaGsR: // global
           call _caGrs() args: 0, res: 0, upd: 0;
       caGrO: // global
           P64[Sp + 16] = _saFvd::P64;
           I64[Sp + 8] = _saFv9::I64 + 1;
           Sp = Sp + 8;
           call _caGrx() args: 0, res: 0, upd: 0;
     }
 },
 _caGrs() //  []
         { info_tbl: [(caGrs,
                       label: block_caGrs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGrs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caGrw; else goto caGrv;
       caGrw: // global
           HpAlloc = 40;
           I64[Sp] = block_caGrs_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caGrv: // global
           _saFv0::P64 = P64[Sp + 56];
           I64[_saFv0::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = GHC.Event.Manager.$fShowFdKey6_closure+1;
           P64[Hp - 16] = GHC.Event.Manager.new4_closure+1;
           P64[Hp - 8] = _saFv0::P64;
           I64[Hp] = 32;
           I64[Sp] = block_caGr9_info;
           R1 = Hp - 31;
           if (R1 & 7 != 0) goto uaGsO; else goto caGra;
       uaGsO: // global
           call _caGr9(R1) args: 0, res: 0, upd: 0;
       caGra: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGr9() //  [R1]
         { info_tbl: [(caGr9,
                       label: block_caGr9_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGr9: // global
           I64[Sp - 16] = block_caGre_info;
           _saFvl::P64 = P64[R1 + 7];
           _saFvm::P64 = P64[R1 + 15];
           _saFvo::P64 = P64[R1 + 23];
           _saFvn::I64 = I64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saFvo::P64;
           I64[Sp] = _saFvn::I64;
           P64[Sp + 48] = _saFvm::P64;
           P64[Sp + 56] = _saFvl::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGsN; else goto caGrT;
       uaGsN: // global
           call _caGre(R1) args: 0, res: 0, upd: 0;
       caGrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGre() //  [R1]
         { info_tbl: [(caGre,
                       label: block_caGre_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGre: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGs3; else goto caGs2;
       caGs3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGs2: // global
           _saFvt::P64 = P64[R1 + 7];
           _saFvu::P64 = P64[R1 + 15];
           _saFvq::I64 = I64[R1 + 23];
           _saFvr::I64 = I64[R1 + 31];
           _saFvs::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _saFvq::I64;
           I64[Sp - 40] = block_caGrY_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           I64[Sp - 48] = stg_ap_v_info;
           I64[Sp - 32] = _saFvr::I64;
           I64[Sp - 24] = _saFvs::I64;
           P64[Sp - 16] = _saFvt::P64;
           P64[Sp - 8] = _saFvu::P64;
           I64[Sp] = _saFvq::I64;
           Sp = Sp - 48;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caGrY() //  [R1]
         { info_tbl: [(caGrY,
                       label: block_caGrY_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGrY: // global
           I64[Sp] = block_caGs0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaGsT; else goto caGs5;
       uaGsT: // global
           call _caGs0(R1) args: 0, res: 0, upd: 0;
       caGs5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGs0() //  [R1]
         { info_tbl: [(caGs0,
                       label: block_caGs0_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGs0: // global
           if (R1 & 7 == 1) goto caGsb; else goto caGsi;
       caGsb: // global
           R2 = I64[Sp + 40];
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caGsi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGsl; else goto caGsk;
       caGsl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGsk: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caGsf_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 7;
           R2 = P64[Sp + 72];
           R1 = P64[Sp + 64];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caGsf() //  [R1]
         { info_tbl: [(caGsf,
                       label: block_caGsf_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGsf: // global
           I64[Sp] = block_caGsh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaGsU; else goto caGsn;
       uaGsU: // global
           call _caGsh(R1) args: 0, res: 0, upd: 0;
       caGsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGsh() //  [R1]
         { info_tbl: [(caGsh,
                       label: block_caGsh_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGsh: // global
           _saFvs::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto caGst; else goto caGsx;
       caGst: // global
           R2 = _saFvs::I64;
           Sp = Sp + 128;
           call GHC.Event.Manager.new3_entry(R2) args: 8, res: 0, upd: 8;
       caGsx: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caGsA; else goto caGsz;
       caGsA: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGsz: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = P64[Sp + 120];
           P64[Hp - 88] = P64[Sp + 112];
           P64[Hp - 80] = P64[Sp + 104];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 88];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 80];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _saFvs::I64;
           R1 = Hp - 103;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.381495552 UTC

[section ""data" . GHC.Event.Manager.newWith_closure" {
     GHC.Event.Manager.newWith_closure:
         const GHC.Event.Manager.newWith_info;
         const 0;
 },
 GHC.Event.Manager.newWith_entry() //  [R2]
         { info_tbl: [(caGvm,
                       label: GHC.Event.Manager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGvm: // global
           R2 = R2;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.384850397 UTC

[section ""data" . GHC.Event.Manager.new1_closure" {
     GHC.Event.Manager.new1_closure:
         const GHC.Event.Manager.new1_info;
         const 0;
 },
 GHC.Event.Manager.new1_entry() //  []
         { info_tbl: [(caGvz,
                       label: GHC.Event.Manager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGvz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caGvA; else goto caGvB;
       caGvA: // global
           R1 = GHC.Event.Manager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caGvB: // global
           I64[Sp - 8] = block_caGvx_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caGvx() //  [R1]
         { info_tbl: [(caGvx,
                       label: block_caGvx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGvx: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.390055266 UTC

[section ""data" . GHC.Event.Manager.new_closure" {
     GHC.Event.Manager.new_closure:
         const GHC.Event.Manager.new_info;
         const 0;
 },
 GHC.Event.Manager.new_entry() //  []
         { info_tbl: [(caGvQ,
                       label: GHC.Event.Manager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGvQ: // global
           call GHC.Event.Manager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.394142461 UTC

[section ""data" . GHC.Event.Manager.closeFd_3_closure" {
     GHC.Event.Manager.closeFd_3_closure:
         const GHC.Event.Manager.closeFd_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.closeFd_3_entry() //  [R1]
         { info_tbl: [(caGw5,
                       label: GHC.Event.Manager.closeFd_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGw5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGwd; else goto caGwe;
       caGwd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGwe: // global
           (_caGw0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caGw0::I64 == 0) goto caGw2; else goto caGw1;
       caGw2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caGw1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caGw0::I64;
           I64[Sp - 24] = block_caGw3_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp - 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _caGw3() //  [R1]
         { info_tbl: [(caGw3,
                       label: block_caGw3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGw3: // global
           I64[Sp] = block_caGw8_info;
           R2 = R1;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caGw8() //  [R1]
         { info_tbl: [(caGw8,
                       label: block_caGw8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGw8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGwi; else goto caGwh;
       caGwi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caGwh: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.402401352 UTC

[section ""data" . GHC.Event.Manager.$weventsOf_closure" {
     GHC.Event.Manager.$weventsOf_closure:
         const GHC.Event.Manager.$weventsOf_info;
         const 0;
 },
 GHC.Event.Manager.$weventsOf_entry() //  [R2]
         { info_tbl: [(caGwN,
                       label: GHC.Event.Manager.$weventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGwN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGwO; else goto caGwP;
       caGwO: // global
           R2 = R2;
           R1 = GHC.Event.Manager.$weventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGwP: // global
           I64[Sp - 8] = block_caGwG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGxs; else goto caGwH;
       uaGxs: // global
           call _caGwG(R1) args: 0, res: 0, upd: 0;
       caGwH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGwG() //  [R1]
         { info_tbl: [(caGwG,
                       label: block_caGwG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGwG: // global
           if (R1 & 7 == 1) goto caGwK; else goto caGwL;
       caGwK: // global
           I64[Sp] = block_caGwS_info;
           R1 = GHC.Event.Manager.closeFd_3_closure;
           if (R1 & 7 != 0) goto uaGxq; else goto caGwU;
       uaGxq: // global
           call _caGwS(R1) args: 0, res: 0, upd: 0;
       caGwU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caGwL: // global
           I64[Sp - 16] = block_caGx1_info;
           _saFvP::P64 = R1;
           _saFvS::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 8] = _saFvS::P64;
           P64[Sp] = _saFvP::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGxr; else goto caGx3;
       uaGxr: // global
           call _caGx1(R1) args: 0, res: 0, upd: 0;
       caGx3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGwS() //  [R1]
         { info_tbl: [(caGwS,
                       label: block_caGwS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGwS: // global
           R1 = I64[R1 + 7];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGx1() //  [R1]
         { info_tbl: [(caGx1,
                       label: block_caGx1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGx1: // global
           if (R1 & 7 == 1) goto caGxa; else goto caGxk;
       caGxa: // global
           I64[Sp + 16] = block_caGx7_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaGxt; else goto caGxb;
       uaGxt: // global
           call _caGx7(R1) args: 0, res: 0, upd: 0;
       caGxb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caGxk: // global
           _saFvP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caGxi_info;
           R3 = _saFvP::P64;
           R2 = GHC.Event.Manager.fdEvents_closure+1;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGx7() //  [R1]
         { info_tbl: [(caGx7,
                       label: block_caGx7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGx7: // global
           R1 = I64[R1 + 31];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGxi() //  [R1]
         { info_tbl: [(caGxi,
                       label: block_caGxi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGxi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Internal.$wgo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.41531415 UTC

[section ""data" . GHC.Event.Manager.eventsOf_closure" {
     GHC.Event.Manager.eventsOf_closure:
         const GHC.Event.Manager.eventsOf_info;
         const 0;
 },
 GHC.Event.Manager.eventsOf_entry() //  [R2]
         { info_tbl: [(caGy9,
                       label: GHC.Event.Manager.eventsOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGy9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caGyd; else goto caGye;
       caGyd: // global
           R2 = R2;
           R1 = GHC.Event.Manager.eventsOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGye: // global
           I64[Sp - 8] = block_caGy7_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGy7() //  [R1]
         { info_tbl: [(caGy7,
                       label: block_caGy7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGy7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGyh; else goto caGyg;
       caGyh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caGyg: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.421502835 UTC

[section ""data" . GHC.Event.Manager.closeFd_2_closure" {
     GHC.Event.Manager.closeFd_2_closure:
         const GHC.Event.Manager.closeFd_2_info;
 },
 GHC.Event.Manager.closeFd_2_entry() //  [R2]
         { info_tbl: [(caGyE,
                       label: GHC.Event.Manager.closeFd_2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGyE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGyF; else goto uaGz6;
       caGyF: // global
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaGz6: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caGyu() args: 0, res: 0, upd: 0;
     }
 },
 _caGyu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGyu: // global
           _saFw5::P64 = P64[Sp];
           I64[Sp] = block_caGyx_info;
           R1 = _saFw5::P64;
           if (R1 & 7 != 0) goto uaGz8; else goto caGyy;
       uaGz8: // global
           call _caGyx(R1) args: 0, res: 0, upd: 0;
       caGyy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGyx() //  [R1]
         { info_tbl: [(caGyx,
                       label: block_caGyx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGyx: // global
           if (R1 & 7 == 1) goto caGyB; else goto caGyC;
       caGyB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caGyC: // global
           I64[Sp - 8] = block_caGyM_info;
           _saFw9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saFw9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGz9; else goto caGyO;
       uaGz9: // global
           call _caGyM(R1) args: 0, res: 0, upd: 0;
       caGyO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGyM() //  [R1]
         { info_tbl: [(caGyM,
                       label: block_caGyM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGyM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caGyU; else goto caGyT;
       caGyU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGyT: // global
           _saFwe::P64 = P64[R1 + 7];
           _saFwb::I64 = I64[R1 + 15];
           _saFwc::I64 = I64[R1 + 23];
           _saFwh::I64 = I64[R1 + 31] & 7 | 4;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _saFwh::I64;
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saFwb::I64;
           I64[Hp] = _saFwc::I64;
           I64[Sp] = block_caGz3_info;
           R3 = Hp - 31;
           R2 = Hp - 15;
           R1 = _saFwe::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGz3() //  []
         { info_tbl: [(caGz3,
                       label: block_caGz3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGz3: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caGyu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.43702537 UTC

[section ""data" . GHC.Event.Manager.closeFd1_closure" {
     GHC.Event.Manager.closeFd1_closure:
         const GHC.Event.Manager.closeFd1_info;
         const 0;
 },
 $wgo_saFxd_entry() //  [R1, R2]
         { info_tbl: [(caGAU,
                       label: $wgo_saFxd_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGAU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGAV; else goto caGAW;
       caGAV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGAW: // global
           I64[Sp - 24] = block_caGAN_info;
           _saFxd::P64 = R1;
           _saFwM::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saFwM::I64;
           P64[Sp - 8] = _saFxd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaGBj; else goto caGAO;
       uaGBj: // global
           call _caGAN(R1) args: 0, res: 0, upd: 0;
       caGAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGAN() //  [R1]
         { info_tbl: [(caGAN,
                       label: block_caGAN_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGAN: // global
           if (R1 & 7 == 1) goto caGAR; else goto caGAS;
       caGAR: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGAS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGB4; else goto caGB3;
       caGB4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGB3: // global
           _saFxh::P64 = P64[R1 + 6];
           _saFxi::P64 = P64[R1 + 14];
           _saFxg::I64 = I64[R1 + 22];
           if (_saFxg::I64 == I64[Sp + 8]) goto caGBi; else goto caGBc;
       caGBi: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFxh::P64;
           R3 = _saFxi::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGBc: // global
           Hp = Hp - 16;
           I64[Sp] = block_caGB8_info;
           R2 = _saFxi::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saFxh::P64;
           I64[Sp + 16] = _saFxg::I64;
           call $wgo_saFxd_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGB8() //  [R1, R2, R3]
         { info_tbl: [(caGB8,
                       label: block_caGB8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGB8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caGBf; else goto caGBe;
       caGBf: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caGBe: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saFwX_entry() //  [R1, R2]
         { info_tbl: [(caGBk,
                       label: $wio_saFwX_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGBk: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caGBl; else goto caGBm;
       caGBl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGBm: // global
           I64[Sp - 40] = block_caGAu_info;
           _saFwn::P64 = P64[R1 + 6];
           _saFwu::P64 = P64[R1 + 14];
           _saFwL::P64 = P64[R1 + 22];
           _saFwM::I64 = I64[R1 + 30];
           R1 = P64[R2 + 8];
           P64[Sp - 32] = _saFwn::P64;
           P64[Sp - 24] = _saFwu::P64;
           P64[Sp - 16] = _saFwL::P64;
           I64[Sp - 8] = _saFwM::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaGCY; else goto caGAv;
       uaGCY: // global
           call _caGAu(R1) args: 0, res: 0, upd: 0;
       caGAv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGAu() //  [R1]
         { info_tbl: [(caGAu,
                       label: block_caGAu_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGAu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGBp; else goto caGBo;
       caGBp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGBo: // global
           _saFwM::I64 = I64[Sp + 32];
           _saFx4::P64 = P64[R1 + 7];
           _saFx6::P64 = P64[R1 + 15];
           _saFx5::I64 = I64[R1 + 23];
           _saFx7::I64 = _saFwM::I64 & (I64[_saFx4::P64 + 8] - 1);
           _saFxc::P64 = P64[(_saFx4::P64 + 24) + (_saFx7::I64 << 3)];
           I64[Hp - 8] = $wgo_saFxd_info;
           I64[Hp] = _saFwM::I64;
           I64[Sp - 24] = block_caGBq_info;
           R2 = _saFxc::P64;
           R1 = Hp - 7;
           P64[Sp - 16] = _saFx6::P64;
           I64[Sp - 8] = _saFx7::I64;
           I64[Sp] = _saFx5::I64;
           P64[Sp + 32] = _saFx4::P64;
           Sp = Sp - 24;
           call $wgo_saFxd_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGBq() //  [R1, R2, R3]
         { info_tbl: [(caGBq,
                       label: block_caGBq_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGBq: // global
           I64[Sp - 16] = block_caGBu_info;
           _saFxr::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saFxr::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGCZ; else goto caGCr;
       uaGCZ: // global
           call _caGBu(R1) args: 0, res: 0, upd: 0;
       caGCr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGBu() //  [R1]
         { info_tbl: [(caGBu,
                       label: block_caGBu_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGBu: // global
           if (R1 & 7 == 1) goto caGCx; else goto caGCC;
       caGCx: // global
           P64[Sp + 72] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saFxu() args: 0, res: 0, upd: 0;
       caGCC: // global
           _saFx4::P64 = P64[Sp + 72];
           _saFx7::I64 = I64[Sp + 32];
           _saFxr::P64 = P64[Sp + 16];
           _saFxt::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saFx4::P64 + 24) + (_saFx7::I64 << 3)] = _saFxt::P64;
           I64[_saFx4::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFx4::P64 + 24) + ((I64[_saFx4::P64 + 8] << 3) + (_saFx7::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caGCA_info;
           _saFxU::P64 = R1;
           R1 = _saFxr::P64;
           P64[Sp + 72] = _saFxU::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaGD0; else goto caGCD;
       uaGD0: // global
           call _caGCA(R1) args: 0, res: 0, upd: 0;
       caGCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGCA() //  [R1]
         { info_tbl: [(caGCA,
                       label: block_caGCA_info
                       rep:StackRep [False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGCA: // global
           _saFxU::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto caGCJ; else goto caGCN;
       caGCJ: // global
           P64[Sp + 56] = _saFxU::P64;
           Sp = Sp + 32;
           goto uaGD4;
       caGCN: // global
           _saFx5::I64 = I64[Sp + 24];
           _saFx6::P64 = P64[Sp + 8];
           I64[_saFx5::I64] = I64[_saFx5::I64] - 1;
           call MO_Touch(_saFx6::P64);
           P64[Sp + 56] = _saFxU::P64;
           Sp = Sp + 32;
           goto uaGD4;
       uaGD4: // global
           call _saFxu() args: 0, res: 0, upd: 0;
     }
 },
 _saFxu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saFxu: // global
           I64[Sp - 8] = block_caGBz_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGD5; else goto caGBB;
       uaGD5: // global
           call _caGBz(R1) args: 0, res: 0, upd: 0;
       caGBB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGBz() //  [R1]
         { info_tbl: [(caGBz,
                       label: block_caGBz_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGBz: // global
           if (R1 & 7 == 1) goto caGBI; else goto caGBP;
       caGBI: // global
           I64[Sp + 32] = block_caGBF_info;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caGBP: // global
           I64[Sp] = block_caGBN_info;
           _saFxB::P64 = P64[R1 + 6];
           R2 = _saFxB::P64;
           P64[Sp + 32] = _saFxB::P64;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGBF() //  []
         { info_tbl: [(caGBF,
                       label: block_caGBF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGBF: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGBN() //  [R1]
         { info_tbl: [(caGBN,
                       label: block_caGBN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGBN: // global
           _saFxD::I64 = R1 & 7;
           if (_saFxD::I64 != 0) goto caGCa; else goto caGCn;
       caGCa: // global
           I64[Sp] = block_caGC0_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saFxD::I64;
           if (R1 & 7 != 0) goto uaGD2; else goto caGC1;
       uaGD2: // global
           call _caGC0(R1) args: 0, res: 0, upd: 0;
       caGC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caGCn: // global
           _saFwL::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caGCm_info;
           R2 = _saFwL::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGC0() //  [R1]
         { info_tbl: [(caGC0,
                       label: block_caGC0_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGC0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGCe; else goto caGCd;
       caGCe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGCd: // global
           _saFxF::P64 = P64[R1 + 7];
           _saFxH::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           I64[Sp] = block_caGC6_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 7;
           R3 = P64[Sp + 24];
           R2 = _saFxF::P64;
           R1 = _saFxH::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caGC6() //  []
         { info_tbl: [(caGC6,
                       label: block_caGC6_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGC6: // global
           _saFwL::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caGC8_info;
           R2 = _saFwL::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGC8() //  []
         { info_tbl: [(caGC8,
                       label: block_caGC8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGC8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGCm() //  []
         { info_tbl: [(caGCm,
                       label: block_caGCm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGCm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saFy4_entry() //  [R1, R2]
         { info_tbl: [(caGDe,
                       label: io_saFy4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGDf; else goto caGDg;
       caGDf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGDg: // global
           I64[Sp - 16] = block_caGDb_info;
           _saFwX::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saFwX::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGDk; else goto caGDc;
       uaGDk: // global
           call _caGDb(R1) args: 0, res: 0, upd: 0;
       caGDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGDb() //  [R1]
         { info_tbl: [(caGDb,
                       label: block_caGDb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDb: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saFwX_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyi_entry() //  [R1, R2]
         { info_tbl: [(caGDw,
                       label: sat_saFyi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGDx; else goto caGDy;
       caGDx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGDy: // global
           I64[Sp - 16] = block_caGDu_info;
           _saFyf::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFyf::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGDu() //  []
         { info_tbl: [(caGDu,
                       label: block_caGDu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyd_entry() //  [R1]
         { info_tbl: [(caGDF,
                       label: sat_saFyd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDF: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFy4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFye_entry() //  [R1]
         { info_tbl: [(caGDN,
                       label: sat_saFye_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDN: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyw_entry() //  [R1, R2]
         { info_tbl: [(caGE5,
                       label: sat_saFyw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGE5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGE6; else goto caGE7;
       caGE6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGE7: // global
           I64[Sp - 16] = block_caGE3_info;
           _saFyt::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFyt::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGE3() //  []
         { info_tbl: [(caGE3,
                       label: block_caGE3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGE3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyr_entry() //  [R1]
         { info_tbl: [(caGEe,
                       label: sat_saFyr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEe: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFy4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFys_entry() //  [R1]
         { info_tbl: [(caGEm,
                       label: sat_saFys_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEm: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyB_entry() //  [R1]
         { info_tbl: [(caGEt,
                       label: sat_saFyB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGEu; else goto caGEv;
       caGEu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caGEv: // global
           I64[Sp - 24] = block_caGDW_info;
           _saFwW::P64 = P64[R1 + 7];
           _saFy4::P64 = P64[R1 + 15];
           R1 = _saFwW::P64;
           P64[Sp - 16] = _saFwW::P64;
           P64[Sp - 8] = _saFy4::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGDW() //  [R1]
         { info_tbl: [(caGDW,
                       label: block_caGDW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caGEy; else goto caGEx;
       caGEy: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGEx: // global
           I64[Hp - 56] = sat_saFyw_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFyr_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFys_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caGEp_info;
           R2 = Hp - 54;
           _saFyq::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFyq::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGEp() //  [R1]
         { info_tbl: [(caGEp,
                       label: block_caGEp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEp: // global
           _saFwW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGEr_info;
           R2 = P64[Sp + 16];
           _saFyz::P64 = R1;
           R1 = _saFwW::P64;
           P64[Sp + 16] = _saFyz::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGEr() //  []
         { info_tbl: [(caGEr,
                       label: block_caGEr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyN_entry() //  [R1, R2]
         { info_tbl: [(caGEL,
                       label: sat_saFyN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGEM; else goto caGEN;
       caGEM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGEN: // global
           I64[Sp - 16] = block_caGEJ_info;
           _saFyK::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFyK::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGEJ() //  []
         { info_tbl: [(caGEJ,
                       label: block_caGEJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyI_entry() //  [R1]
         { info_tbl: [(caGEU,
                       label: sat_saFyI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEU: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFy4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFyJ_entry() //  [R1]
         { info_tbl: [(caGF2,
                       label: sat_saFyJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGF2: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.closeFd1_entry() //  [R2, R3, R4]
         { info_tbl: [(caGF5,
                       label: GHC.Event.Manager.closeFd1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGF5: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caGF6; else goto caGF7;
       caGF6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caGF7: // global
           I64[Sp - 32] = block_caGzK_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caGzK() //  [R1]
         { info_tbl: [(caGzK,
                       label: block_caGzK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGzK: // global
           I64[Sp] = block_caGzM_info;
           _saFws::I64 = R1;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saFws::I64;
           if (R1 & 7 != 0) goto uaGFM; else goto caGzN;
       uaGFM: // global
           call _caGzM(R1) args: 0, res: 0, upd: 0;
       caGzN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGzM() //  [R1]
         { info_tbl: [(caGzM,
                       label: block_caGzM_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGzM: // global
           I64[Sp - 24] = block_caGzR_info;
           _saFwu::P64 = P64[R1 + 7];
           _saFww::P64 = P64[R1 + 23];
           _saFwy::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saFww::P64;
           P64[Sp - 8] = _saFwy::P64;
           P64[Sp] = _saFwu::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaGFN; else goto caGzS;
       uaGFN: // global
           call _caGzR(R1) args: 0, res: 0, upd: 0;
       caGzS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGzR() //  [R1]
         { info_tbl: [(caGzR,
                       label: block_caGzR_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGzR: // global
           I64[Sp - 8] = block_caGzW_info;
           _saFwH::P64 = R1;
           _saFwI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saFwI::I64;
           P64[Sp + 8] = _saFwH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGFO; else goto caGzX;
       uaGFO: // global
           call _caGzW(R1) args: 0, res: 0, upd: 0;
       caGzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGzW() //  [R1]
         { info_tbl: [(caGzW,
                       label: block_caGzW_info
                       rep:StackRep [True, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGzW: // global
           I64[Sp - 8] = block_caGA1_info;
           _saFwJ::P64 = R1;
           _saFwK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp] = _saFwK::I64;
           P64[Sp + 56] = _saFwJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGFP; else goto caGA2;
       uaGFP: // global
           call _caGA1(R1) args: 0, res: 0, upd: 0;
       caGA2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGA1() //  [R1]
         { info_tbl: [(caGA1,
                       label: block_caGA1_info
                       rep:StackRep [True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGA1: // global
           _saFwH::P64 = P64[Sp + 24];
           _saFwI::I64 = I64[Sp + 16];
           _saFwJ::P64 = P64[Sp + 64];
           _saFwM::I64 = I64[R1 + 7];
           _saFwN::I64 = _saFwM::I64 & 31;
           if (%MO_S_Gt_W64(_saFwI::I64,
                            _saFwN::I64)) goto caGFg; else goto caGFK;
       caGFK: // global
           if (%MO_S_Gt_W64(_saFwN::I64,
                            I64[Sp + 8])) goto caGFg; else goto caGFh;
       caGFg: // global
           R4 = _saFwN::I64;
           R3 = _saFwH::P64;
           R2 = _saFwJ::P64;
           Sp = Sp + 72;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caGFh: // global
           _saFwU::P64 = P64[P64[Sp + 32] + ((_saFwN::I64 - _saFwI::I64 << 3) + 24)];
           I64[Sp + 24] = block_caGAk_info;
           _saFwL::P64 = R1;
           R1 = _saFwU::P64;
           I64[Sp + 32] = _saFwM::I64;
           P64[Sp + 64] = _saFwL::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaGFQ; else goto caGAl;
       uaGFQ: // global
           call _caGAk(R1) args: 0, res: 0, upd: 0;
       caGAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGAk() //  [R1]
         { info_tbl: [(caGAk,
                       label: block_caGAk_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGAk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caGFk; else goto caGFj;
       caGFk: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGFj: // global
           _saFwW::P64 = P64[R1 + 7];
           I64[Hp - 72] = $wio_saFwX_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saFy4_info;
           P64[Hp - 24] = Hp - 70;
           _caGD6::P64 = Hp - 30;
           _saFy9::I64 = I64[Sp + 24];
           if (_saFy9::I64 != 0) goto uaGFL; else goto caGFx;
       uaGFL: // global
           if (_saFy9::I64 != 1) goto caGFp; else goto caGFD;
       caGFp: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caGDn_info;
           R1 = _saFwW::P64;
           P64[Sp + 32] = _saFwW::P64;
           P64[Sp + 40] = _caGD6::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caGFD: // global
           Hp = Hp - 24;
           I64[Sp + 24] = block_caGEC_info;
           R1 = _saFwW::P64;
           P64[Sp + 32] = _saFwW::P64;
           P64[Sp + 40] = _caGD6::P64;
           Sp = Sp + 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caGFx: // global
           I64[Hp - 16] = sat_saFyB_info;
           P64[Hp - 8] = _saFwW::P64;
           P64[Hp] = _caGD6::P64;
           I64[Sp + 40] = block_caGFw_info;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGDn() //  [R1]
         { info_tbl: [(caGDn,
                       label: block_caGDn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGDn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caGFs; else goto caGFr;
       caGFs: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGFr: // global
           I64[Hp - 56] = sat_saFyi_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFyd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFye_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caGFl_info;
           R2 = Hp - 54;
           _saFyc::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFyc::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGFl() //  [R1]
         { info_tbl: [(caGFl,
                       label: block_caGFl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGFl: // global
           _saFwW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGFn_info;
           R2 = P64[Sp + 16];
           _saFyl::P64 = R1;
           R1 = _saFwW::P64;
           P64[Sp + 16] = _saFyl::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGFn() //  []
         { info_tbl: [(caGFn,
                       label: block_caGFn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGFn: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caGEC() //  [R1]
         { info_tbl: [(caGEC,
                       label: block_caGEC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGEC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caGFG; else goto caGFF;
       caGFG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGFF: // global
           I64[Hp - 56] = sat_saFyN_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFyI_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFyJ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caGFA_info;
           R2 = Hp - 54;
           _saFyH::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFyH::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGFA() //  [R1]
         { info_tbl: [(caGFA,
                       label: block_caGFA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGFA: // global
           _saFwW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGFC_info;
           R2 = P64[Sp + 16];
           _saFyQ::P64 = R1;
           R1 = _saFwW::P64;
           P64[Sp + 16] = _saFyQ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGFC() //  []
         { info_tbl: [(caGFC,
                       label: block_caGFC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGFC: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caGFw() //  [R1]
         { info_tbl: [(caGFw,
                       label: block_caGFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGFw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.527286721 UTC

[section ""data" . GHC.Event.Manager.closeFd_closure" {
     GHC.Event.Manager.closeFd_closure:
         const GHC.Event.Manager.closeFd_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_entry() //  [R2, R3, R4]
         { info_tbl: [(caGKd,
                       label: GHC.Event.Manager.closeFd_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGKd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.530879582 UTC

[section ""data" . lvl8_raAuf_closure" {
     lvl8_raAuf_closure:
         const lvl8_raAuf_info;
 },
 lvl8_raAuf_entry() //  [R2]
         { info_tbl: [(caGKr,
                       label: lvl8_raAuf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGKr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caGKs; else goto caGKt;
       caGKs: // global
           R2 = R2;
           R1 = lvl8_raAuf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGKt: // global
           I64[Sp - 8] = block_caGKo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGKM; else goto caGKp;
       uaGKM: // global
           call _caGKo(R1) args: 0, res: 0, upd: 0;
       caGKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGKo() //  [R1]
         { info_tbl: [(caGKo,
                       label: block_caGKo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGKo: // global
           if (I64[R1 + 31] & 8 == 0) goto caGKI; else goto caGKC;
       caGKI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caGKC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.546439624 UTC

[section ""data" . GHC.Event.Manager.loop5_closure" {
     GHC.Event.Manager.loop5_closure:
         const GHC.Event.Manager.loop5_info;
         const 0;
 },
 $wgo_saFA4_entry() //  [R1, R2]
         { info_tbl: [(caGMt,
                       label: $wgo_saFA4_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGMt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGMu; else goto caGMv;
       caGMu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGMv: // global
           I64[Sp - 24] = block_caGMm_info;
           _saFA4::P64 = R1;
           _saFzs::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saFzs::I64;
           P64[Sp - 8] = _saFA4::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaGMS; else goto caGMn;
       uaGMS: // global
           call _caGMm(R1) args: 0, res: 0, upd: 0;
       caGMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGMm() //  [R1]
         { info_tbl: [(caGMm,
                       label: block_caGMm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGMm: // global
           if (R1 & 7 == 1) goto caGMq; else goto caGMr;
       caGMq: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGMr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGMD; else goto caGMC;
       caGMD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGMC: // global
           _saFA8::P64 = P64[R1 + 6];
           _saFA9::P64 = P64[R1 + 14];
           _saFA7::I64 = I64[R1 + 22];
           if (_saFA7::I64 == I64[Sp + 8]) goto caGMR; else goto caGML;
       caGMR: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFA8::P64;
           R3 = _saFA9::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caGML: // global
           Hp = Hp - 16;
           I64[Sp] = block_caGMH_info;
           R2 = _saFA9::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saFA8::P64;
           I64[Sp + 16] = _saFA7::I64;
           call $wgo_saFA4_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGMH() //  [R1, R2, R3]
         { info_tbl: [(caGMH,
                       label: block_caGMH_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGMH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caGMO; else goto caGMN;
       caGMO: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caGMN: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saFAD_entry() //  [R1]
         { info_tbl: [(caGNC,
                       label: w2_saFAD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGNC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGND; else goto caGNE;
       caGND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGNE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caGNz_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo1_saFAr_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caGNz() //  [R1, R2]
         { info_tbl: [(caGNz,
                       label: block_caGNz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGNz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGNH; else goto caGNG;
       caGNH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caGNG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo1_saFAr_entry() //  [R1, R2]
         { info_tbl: [(caGNM,
                       label: $wgo1_saFAr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGNM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caGNN; else goto caGNO;
       caGNN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGNO: // global
           I64[Sp - 24] = block_caGNf_info;
           _saFAr::P64 = R1;
           _saFz1::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _saFz1::P64;
           P64[Sp - 8] = _saFAr::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaGOe; else goto caGNg;
       uaGOe: // global
           call _caGNf(R1) args: 0, res: 0, upd: 0;
       caGNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGNf() //  [R1]
         { info_tbl: [(caGNf,
                       label: block_caGNf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGNf: // global
           if (R1 & 7 == 1) goto caGNJ; else goto caGNK;
       caGNJ: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caGNK: // global
           I64[Sp - 8] = block_caGNl_info;
           _saFAu::P64 = P64[R1 + 6];
           _saFAv::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _saFAv::P64;
           P64[Sp + 8] = _saFAu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGOc; else goto caGNm;
       uaGOc: // global
           call _caGNl(R1) args: 0, res: 0, upd: 0;
       caGNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGNl() //  [R1]
         { info_tbl: [(caGNl,
                       label: block_caGNl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGNl: // global
           I64[Sp] = block_caGNq_info;
           _saFAx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saFAx::I64;
           if (R1 & 7 != 0) goto uaGOd; else goto caGNr;
       uaGOd: // global
           call _caGNq(R1) args: 0, res: 0, upd: 0;
       caGNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGNq() //  [R1]
         { info_tbl: [(caGNq,
                       label: block_caGNq_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGNq: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caGNV; else goto caGNU;
       caGNV: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGNU: // global
           _saFAB::I64 = I64[R1 + 31];
           I64[Hp - 96] = w2_saFAD_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           _caGNv::P64 = Hp - 96;
           if (I64[Sp + 16] & _saFAB::I64 & 7 == 0) goto caGOb; else goto caGO6;
       caGOb: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caGNv::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _caGNv::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       caGO6: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _caGNv::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _caGNv::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds8_saFAq_entry() //  [R1]
         { info_tbl: [(caGOi,
                       label: ds8_saFAq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOi: // global
           _saFAq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caGOj; else goto caGOk;
       caGOk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGOm; else goto caGOl;
       caGOm: // global
           HpAlloc = 16;
           goto caGOj;
       caGOj: // global
           R1 = _saFAq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGOl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saFAq::P64;
           _saFz1::P64 = P64[_saFAq::P64 + 16];
           _saFAp::P64 = P64[_saFAq::P64 + 24];
           I64[Hp - 8] = $wgo1_saFAr_info;
           P64[Hp] = _saFz1::P64;
           I64[Sp - 24] = block_caGOf_info;
           R2 = _saFAp::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call $wgo1_saFAr_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _caGOf() //  [R1, R2]
         { info_tbl: [(caGOf,
                       label: block_caGOf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGOp; else goto caGOo;
       caGOp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caGOo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saFBc_entry() //  [R1]
         { info_tbl: [(caGOE,
                       label: sat_saFBc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOE: // global
           R3 = P64[R1 + 16];
           R2 = lvl8_raAuf_closure+1;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 saved_saFB8_entry() //  [R1]
         { info_tbl: [(caGOH,
                       label: saved_saFB8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caGOI; else goto caGOJ;
       caGOI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGOJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caGOv_info;
           _saFB4::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saFB4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaGON; else goto caGOw;
       uaGON: // global
           call _caGOv(R1) args: 0, res: 0, upd: 0;
       caGOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caGOv() //  [R1]
         { info_tbl: [(caGOv,
                       label: block_caGOv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGOM; else goto caGOL;
       caGOM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caGOL: // global
           _saFBb::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saFBc_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _saFBb::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saFBf_entry() //  [R1]
         { info_tbl: [(caGOT,
                       label: sat_saFBf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOT: // global
           R1 = P64[R1 + 6] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saFzO_entry() //  [R1, R2]
         { info_tbl: [(caGOW,
                       label: $wio_saFzO_info
                       rep:HeapRep 5 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGOW: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caGOX; else goto caGOY;
       caGOX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGOY: // global
           I64[Sp - 64] = block_caGM3_info;
           _saFz1::P64 = P64[R1 + 6];
           _saFzi::P64 = P64[R1 + 14];
           _saFzk::P64 = P64[R1 + 22];
           _saFzl::P64 = P64[R1 + 30];
           _saFzr::P64 = P64[R1 + 38];
           _saFzs::I64 = I64[R1 + 46];
           R1 = P64[R2 + 8];
           P64[Sp - 56] = _saFz1::P64;
           P64[Sp - 48] = _saFzi::P64;
           P64[Sp - 40] = _saFzk::P64;
           P64[Sp - 32] = _saFzl::P64;
           P64[Sp - 24] = _saFzr::P64;
           I64[Sp - 16] = _saFzs::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto uaGRD; else goto caGM4;
       uaGRD: // global
           call _caGM3(R1) args: 0, res: 0, upd: 0;
       caGM4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGM3() //  [R1]
         { info_tbl: [(caGM3,
                       label: block_caGM3_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGM3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGP1; else goto caGP0;
       caGP1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGP0: // global
           _saFzs::I64 = I64[Sp + 48];
           _saFzV::P64 = P64[R1 + 7];
           _saFzX::P64 = P64[R1 + 15];
           _saFzW::I64 = I64[R1 + 23];
           _saFzY::I64 = _saFzs::I64 & (I64[_saFzV::P64 + 8] - 1);
           _saFA3::P64 = P64[(_saFzV::P64 + 24) + (_saFzY::I64 << 3)];
           I64[Hp - 8] = $wgo_saFA4_info;
           I64[Hp] = _saFzs::I64;
           I64[Sp - 32] = block_caGMT_info;
           R2 = _saFA3::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saFzW::I64;
           P64[Sp - 16] = _saFzX::P64;
           I64[Sp - 8] = _saFzY::I64;
           P64[Sp] = _saFzV::P64;
           Sp = Sp - 32;
           call $wgo_saFA4_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGMT() //  [R1, R2, R3]
         { info_tbl: [(caGMT,
                       label: block_caGMT_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGMT: // global
           I64[Sp - 16] = block_caGP2_info;
           _saFAi::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saFAi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGRC; else goto caGR1;
       uaGRC: // global
           call _caGP2(R1) args: 0, res: 0, upd: 0;
       caGR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGP2() //  [R1]
         { info_tbl: [(caGP2,
                       label: block_caGP2_info
                       rep:StackRep [False, False, True, False, True, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGP2: // global
           if (R1 & 7 == 1) goto caGR7; else goto caGRc;
       caGR7: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saFAl() args: 0, res: 0, upd: 0;
       caGRc: // global
           _saFzV::P64 = P64[Sp + 48];
           _saFzY::I64 = I64[Sp + 40];
           _saFAi::P64 = P64[Sp + 16];
           _saFAk::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saFzV::P64 + 24) + (_saFzY::I64 << 3)] = _saFAk::P64;
           I64[_saFzV::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFzV::P64 + 24) + ((I64[_saFzV::P64 + 8] << 3) + (_saFzY::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caGRa_info;
           _saFBF::P64 = R1;
           R1 = _saFAi::P64;
           P64[Sp + 48] = _saFBF::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaGRE; else goto caGRd;
       uaGRE: // global
           call _caGRa(R1) args: 0, res: 0, upd: 0;
       caGRd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGRa() //  [R1]
         { info_tbl: [(caGRa,
                       label: block_caGRa_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGRa: // global
           _saFBF::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caGRj; else goto caGRn;
       caGRj: // global
           P64[Sp + 32] = _saFBF::P64;
           Sp = Sp + 32;
           goto uaGRL;
       caGRn: // global
           _saFzW::I64 = I64[Sp + 8];
           _saFzX::P64 = P64[Sp + 16];
           I64[_saFzW::I64] = I64[_saFzW::I64] - 1;
           call MO_Touch(_saFzX::P64);
           P64[Sp + 32] = _saFBF::P64;
           Sp = Sp + 32;
           goto uaGRL;
       uaGRL: // global
           call _saFAl() args: 0, res: 0, upd: 0;
     }
 },
 _saFAl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saFAl: // global
           _saFAn::P64 = P64[Sp];
           I64[Sp] = block_caGN0_info;
           R1 = _saFAn::P64;
           if (R1 & 7 != 0) goto uaGRM; else goto caGN1;
       uaGRM: // global
           call _caGN0(R1) args: 0, res: 0, upd: 0;
       caGN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGN0() //  [R1]
         { info_tbl: [(caGN0,
                       label: block_caGN0_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGN0: // global
           if (R1 & 7 == 1) goto caGP8; else goto caGPg;
       caGP8: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caGPg: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caGPj; else goto caGPi;
       caGPj: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGPi: // global
           _saFAp::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds8_saFAq_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _saFAp::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           _caGN6::P64 = Hp - 96;
           P64[Hp - 48] = _caGN6::P64;
           I64[Hp - 40] = saved_saFB8_info;
           P64[Hp - 24] = _caGN6::P64;
           _caGOq::P64 = Hp - 64;
           P64[Hp - 16] = _caGOq::P64;
           I64[Hp - 8] = sat_saFBf_info;
           _caGOr::P64 = Hp - 40;
           P64[Hp] = _caGOr::P64;
           I64[Sp] = block_caGP9_info;
           R5 = P64[Sp + 56];
           R4 = _caGOr::P64;
           R3 = I64[Sp + 48];
           R2 = Hp - 6;
           P64[Sp + 8] = _saFAp::P64;
           P64[Sp + 48] = _caGOr::P64;
           P64[Sp + 56] = _caGOq::P64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGP9() //  []
         { info_tbl: [(caGP9,
                       label: block_caGP9_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGP9: // global
           _saFAp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGPb_info;
           R2 = _saFAp::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGPb() //  [R1]
         { info_tbl: [(caGPb,
                       label: block_caGPb_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGPb: // global
           I64[Sp] = block_caGPf_info;
           R2 = P64[Sp + 40];
           I64[Sp + 40] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caGPf() //  [R1]
         { info_tbl: [(caGPf,
                       label: block_caGPf_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGPf: // global
           _caGOq::P64 = P64[Sp + 48];
           _saFBj::I64 = I64[Sp + 40];
           _saFBk::I64 = R1;
           if (_saFBj::I64 & 8 == 0) goto saFBl; else goto caGQM;
       caGQM: // global
           if (_saFBj::I64 == _saFBk::I64) goto caGQU; else goto saFBl;
       saFBl: // global
           _saFBn::I64 = _saFBk::I64 & 8;
           if (_saFBn::I64 != 0) goto uaGRy; else goto caGPU;
       uaGRy: // global
           I64[Sp] = _saFBn::I64;
           I64[Sp + 24] = _saFBk::I64;
           call _caGPA() args: 0, res: 0, upd: 0;
       caGPU: // global
           if (_saFBj::I64 & 8 == 0) goto caGQo; else goto uaGRA;
       caGQo: // global
           if (_saFBk::I64 & 7 == 0) goto caGQU; else goto uaGRB;
       caGQU: // global
           R1 = _caGOq::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaGRB: // global
           I64[Sp + 40] = _saFBk::I64;
           goto uaGRI;
       uaGRA: // global
           I64[Sp + 40] = _saFBk::I64;
           goto uaGRI;
       uaGRI: // global
           call _caGQ1() args: 0, res: 0, upd: 0;
     }
 },
 _caGPA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGPA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caGPP; else goto caGPO;
       caGPP: // global
           HpAlloc = 32;
           _saFBn::I64 = I64[Sp];
           I64[Sp] = block_caGPz_info;
           R1 = _saFBn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caGPO: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 24] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caGPK_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caGPz() //  [R1]
         { info_tbl: [(caGPz,
                       label: block_caGPz_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGPz: // global
           I64[Sp] = R1;
           call _caGPA() args: 0, res: 0, upd: 0;
     }
 },
 _caGPK() //  []
         { info_tbl: [(caGPK,
                       label: block_caGPK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGPK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGQ1() //  []
         { info_tbl: [(caGQ1,
                       label: block_caGQ1_info
                       rep:StackRep [False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGQ1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caGQa; else goto caGQ9;
       caGQa: // global
           HpAlloc = 16;
           I64[Sp] = block_caGQ1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caGQ9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40] & 7;
           I64[Sp + 40] = block_caGQ7_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGQ7() //  []
         { info_tbl: [(caGQ7,
                       label: block_caGQ7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGQ7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saFBP_entry() //  [R1, R2]
         { info_tbl: [(caGRV,
                       label: io_saFBP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGRV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGRW; else goto caGRX;
       caGRW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGRX: // global
           I64[Sp - 16] = block_caGRS_info;
           _saFzO::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saFzO::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGS1; else goto caGRT;
       uaGS1: // global
           call _caGRS(R1) args: 0, res: 0, upd: 0;
       caGRT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGRS() //  [R1]
         { info_tbl: [(caGRS,
                       label: block_caGRS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGRS: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saFzO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFC3_entry() //  [R1, R2]
         { info_tbl: [(caGSd,
                       label: sat_saFC3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGSe; else goto caGSf;
       caGSe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGSf: // global
           I64[Sp - 16] = block_caGSb_info;
           _saFC0::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFC0::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGSb() //  []
         { info_tbl: [(caGSb,
                       label: block_caGSb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFBY_entry() //  [R1]
         { info_tbl: [(caGSm,
                       label: sat_saFBY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSm: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFBP_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFBZ_entry() //  [R1]
         { info_tbl: [(caGSu,
                       label: sat_saFBZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSu: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFCw_entry() //  [R1, R2]
         { info_tbl: [(caGSM,
                       label: sat_saFCw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGSN; else goto caGSO;
       caGSN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGSO: // global
           I64[Sp - 16] = block_caGSK_info;
           _saFCt::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFCt::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGSK() //  []
         { info_tbl: [(caGSK,
                       label: block_caGSK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFCr_entry() //  [R1]
         { info_tbl: [(caGSV,
                       label: sat_saFCr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSV: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFBP_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFCs_entry() //  [R1]
         { info_tbl: [(caGT3,
                       label: sat_saFCs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGT3: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFCB_entry() //  [R1]
         { info_tbl: [(caGTa,
                       label: sat_saFCB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caGTb; else goto caGTc;
       caGTb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caGTc: // global
           I64[Sp - 24] = block_caGSD_info;
           _saFzN::P64 = P64[R1 + 7];
           _saFBP::P64 = P64[R1 + 15];
           R1 = _saFzN::P64;
           P64[Sp - 16] = _saFzN::P64;
           P64[Sp - 8] = _saFBP::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGSD() //  [R1]
         { info_tbl: [(caGSD,
                       label: block_caGSD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGSD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caGTf; else goto caGTe;
       caGTf: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGTe: // global
           I64[Hp - 56] = sat_saFCw_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFCr_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFCs_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caGT6_info;
           R2 = Hp - 54;
           _saFCq::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFCq::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGT6() //  [R1]
         { info_tbl: [(caGT6,
                       label: block_caGT6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGT6: // global
           _saFzN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGT8_info;
           R2 = P64[Sp + 16];
           _saFCz::P64 = R1;
           R1 = _saFzN::P64;
           P64[Sp + 16] = _saFCz::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGT8() //  []
         { info_tbl: [(caGT8,
                       label: block_caGT8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGT8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFD2_entry() //  [R1, R2]
         { info_tbl: [(caGTs,
                       label: sat_saFD2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGTt; else goto caGTu;
       caGTt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGTu: // global
           I64[Sp - 16] = block_caGTq_info;
           _saFCZ::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFCZ::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGTq() //  []
         { info_tbl: [(caGTq,
                       label: block_caGTq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFCX_entry() //  [R1]
         { info_tbl: [(caGTB,
                       label: sat_saFCX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTB: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFBP_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFCY_entry() //  [R1]
         { info_tbl: [(caGTJ,
                       label: sat_saFCY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTJ: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop5_entry() //  [R2, R3, R4]
         { info_tbl: [(caGTM,
                       label: GHC.Event.Manager.loop5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTM: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caGTN; else goto caGTO;
       caGTN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.loop5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caGTO: // global
           I64[Sp - 24] = block_caGL6_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaGWH; else goto caGL7;
       uaGWH: // global
           call _caGL6(R1) args: 0, res: 0, upd: 0;
       caGL7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGL6() //  [R1]
         { info_tbl: [(caGL6,
                       label: block_caGL6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGL6: // global
           I64[Sp - 56] = block_caGLb_info;
           _saFz5::P64 = P64[R1 + 15];
           _saFz6::P64 = P64[R1 + 23];
           _saFz8::P64 = P64[R1 + 31];
           _saFz9::P64 = P64[R1 + 39];
           _saFzf::P64 = P64[R1 + 63];
           _saFzb::I64 = I64[R1 + 87];
           _saFzd::I64 = I64[R1 + 103];
           R1 = P64[R1 + 7];
           P64[Sp - 48] = _saFz6::P64;
           P64[Sp - 40] = _saFz8::P64;
           P64[Sp - 32] = _saFz9::P64;
           I64[Sp - 24] = _saFzb::I64;
           I64[Sp - 16] = _saFzd::I64;
           P64[Sp - 8] = _saFzf::P64;
           P64[Sp] = _saFz5::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaGWC; else goto caGLc;
       uaGWC: // global
           call _caGLb(R1) args: 0, res: 0, upd: 0;
       caGLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGLb() //  [R1]
         { info_tbl: [(caGLb,
                       label: block_caGLb_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGLb: // global
           I64[Sp - 16] = block_caGLg_info;
           _saFzi::P64 = P64[R1 + 7];
           _saFzk::P64 = P64[R1 + 23];
           _saFzl::P64 = P64[R1 + 31];
           R1 = P64[Sp + 56];
           P64[Sp - 8] = _saFzl::P64;
           P64[Sp] = _saFzk::P64;
           P64[Sp + 56] = _saFzi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaGWD; else goto caGLh;
       uaGWD: // global
           call _caGLg(R1) args: 0, res: 0, upd: 0;
       caGLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGLg() //  [R1]
         { info_tbl: [(caGLg,
                       label: block_caGLg_info
                       rep:StackRep [False, False, False, False, False, True, True, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGLg: // global
           I64[Sp - 8] = block_caGLl_info;
           _saFzn::P64 = R1;
           _saFzo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saFzo::I64;
           P64[Sp + 24] = _saFzn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGWE; else goto caGLm;
       uaGWE: // global
           call _caGLl(R1) args: 0, res: 0, upd: 0;
       caGLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGLl() //  [R1]
         { info_tbl: [(caGLl,
                       label: block_caGLl_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGLl: // global
           I64[Sp - 8] = block_caGLq_info;
           _saFzp::P64 = R1;
           _saFzq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saFzq::I64;
           P64[Sp + 88] = _saFzp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGWF; else goto caGLr;
       uaGWF: // global
           call _caGLq(R1) args: 0, res: 0, upd: 0;
       caGLr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGLq() //  [R1]
         { info_tbl: [(caGLq,
                       label: block_caGLq_info
                       rep:StackRep [True, True, False, False, False, False, False, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGLq: // global
           _saFzd::I64 = I64[Sp + 72];
           _saFzf::P64 = P64[Sp + 80];
           _saFzs::I64 = I64[R1 + 7];
           if (_saFzs::I64 == I64[Sp + 64]) goto saFzt; else goto caGWi;
       caGWi: // global
           if (_saFzs::I64 == _saFzd::I64) goto saFzt; else goto caGUe;
       saFzt: // global
           I64[Sp + 48] = block_caGTX_info;
           R4 = _saFzs::I64;
           R3 = _saFzf::P64;
           R2 = _saFzd::I64;
           Sp = Sp + 48;
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
       caGUe: // global
           I64[Sp] = block_caGLD_info;
           I64[Sp + 72] = _saFzs::I64;
           P64[Sp + 80] = R1;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caGTX() //  [R1]
         { info_tbl: [(caGTX,
                       label: block_caGTX_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTX: // global
           I64[Sp] = block_caGTZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaGWI; else goto caGU2;
       uaGWI: // global
           call _caGTZ(R1) args: 0, res: 0, upd: 0;
       caGU2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGTZ() //  [R1]
         { info_tbl: [(caGTZ,
                       label: block_caGTZ_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTZ: // global
           if (R1 & 7 == 2) goto caGUc; else goto uaGWB;
       caGUc: // global
           _saFz9::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saFz9::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saFz9::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaGWB: // global
           Sp = Sp + 64;
           call _caGU8() args: 0, res: 0, upd: 0;
     }
 },
 _caGLD() //  [R1]
         { info_tbl: [(caGLD,
                       label: block_caGLD_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGLD: // global
           _saFzn::P64 = P64[Sp + 40];
           _saFzo::I64 = I64[Sp + 16];
           _saFzp::P64 = P64[Sp + 96];
           _saFzE::I64 = I64[Sp + 72] & 31;
           if (%MO_S_Gt_W64(_saFzo::I64,
                            _saFzE::I64)) goto caGUj; else goto caGWf;
       caGWf: // global
           if (%MO_S_Gt_W64(_saFzE::I64,
                            I64[Sp + 8])) goto caGUj; else goto caGUk;
       caGUj: // global
           R4 = _saFzE::I64;
           R3 = _saFzn::P64;
           R2 = _saFzp::P64;
           Sp = Sp + 112;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caGUk: // global
           _saFzL::P64 = P64[P64[Sp + 48] + ((_saFzE::I64 - _saFzo::I64 << 3) + 24)];
           I64[Sp + 16] = block_caGLT_info;
           _saFzD::I64 = R1;
           R1 = _saFzL::P64;
           I64[Sp + 96] = _saFzD::I64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaGWG; else goto caGLU;
       uaGWG: // global
           call _caGLT(R1) args: 0, res: 0, upd: 0;
       caGLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGLT() //  [R1]
         { info_tbl: [(caGLT,
                       label: block_caGLT_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGLT: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caGUn; else goto caGUm;
       caGUn: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGUm: // global
           _saFzN::P64 = P64[R1 + 7];
           I64[Hp - 88] = $wio_saFzO_info;
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 72];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 64];
           I64[Hp - 40] = I64[Sp + 56];
           I64[Hp - 32] = io_saFBP_info;
           P64[Hp - 24] = Hp - 86;
           _caGRN::P64 = Hp - 30;
           _saFBU::I64 = I64[Sp + 80];
           if (_saFBU::I64 != 0) goto uaGWr; else goto caGV4;
       uaGWr: // global
           if (_saFBU::I64 != 1) goto caGUs; else goto caGVE;
       caGUs: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caGS4_info;
           R1 = _saFzN::P64;
           P64[Sp + 72] = _saFzN::P64;
           P64[Sp + 80] = _caGRN::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caGVE: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caGTj_info;
           R1 = _saFzN::P64;
           P64[Sp + 72] = _saFzN::P64;
           P64[Sp + 80] = _caGRN::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caGV4: // global
           I64[Hp - 16] = sat_saFCB_info;
           P64[Hp - 8] = _saFzN::P64;
           P64[Hp] = _caGRN::P64;
           I64[Sp + 80] = block_caGV3_info;
           R1 = Hp - 15;
           Sp = Sp + 80;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGS4() //  [R1]
         { info_tbl: [(caGS4,
                       label: block_caGS4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGS4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caGUv; else goto caGUu;
       caGUv: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGUu: // global
           I64[Hp - 56] = sat_saFC3_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFBY_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFBZ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caGUo_info;
           R2 = Hp - 54;
           _saFBX::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFBX::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGUo() //  [R1]
         { info_tbl: [(caGUo,
                       label: block_caGUo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGUo: // global
           _saFzN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGUq_info;
           R2 = P64[Sp + 16];
           _saFC6::P64 = R1;
           R1 = _saFzN::P64;
           P64[Sp + 16] = _saFC6::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGUq() //  []
         { info_tbl: [(caGUq,
                       label: block_caGUq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGUq: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caGUC() args: 0, res: 0, upd: 0;
     }
 },
 _caGUC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGUC: // global
           _saFC9::P64 = P64[Sp];
           I64[Sp] = block_caGUE_info;
           R1 = _saFC9::P64;
           if (R1 & 7 != 0) goto uaGWL; else goto caGUG;
       uaGWL: // global
           call _caGUE(R1) args: 0, res: 0, upd: 0;
       caGUG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGUE() //  [R1]
         { info_tbl: [(caGUE,
                       label: block_caGUE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGUE: // global
           if (R1 & 7 == 1) goto uaGWt; else goto caGUR;
       uaGWt: // global
           Sp = Sp + 16;
           call _caGU8() args: 0, res: 0, upd: 0;
       caGUR: // global
           I64[Sp - 8] = block_caGUP_info;
           _saFCd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saFCd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGWM; else goto caGUS;
       uaGWM: // global
           call _caGUP(R1) args: 0, res: 0, upd: 0;
       caGUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGUP() //  [R1]
         { info_tbl: [(caGUP,
                       label: block_caGUP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGUP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGV0; else goto caGUZ;
       caGV0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGUZ: // global
           _saFCi::P64 = P64[R1 + 7];
           _saFCf::I64 = I64[R1 + 15];
           _saFCg::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saFCf::I64;
           I64[Hp] = _saFCg::I64;
           I64[Sp] = block_caGUX_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saFCi::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGUX() //  []
         { info_tbl: [(caGUX,
                       label: block_caGUX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGUX: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caGUC() args: 0, res: 0, upd: 0;
     }
 },
 _caGTj() //  [R1]
         { info_tbl: [(caGTj,
                       label: block_caGTj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGTj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caGVH; else goto caGVG;
       caGVH: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGVG: // global
           I64[Hp - 56] = sat_saFD2_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFCX_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFCY_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caGVB_info;
           R2 = Hp - 54;
           _saFCW::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFCW::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGVB() //  [R1]
         { info_tbl: [(caGVB,
                       label: block_caGVB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVB: // global
           _saFzN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caGVD_info;
           R2 = P64[Sp + 16];
           _saFD5::P64 = R1;
           R1 = _saFzN::P64;
           P64[Sp + 16] = _saFD5::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGVD() //  []
         { info_tbl: [(caGVD,
                       label: block_caGVD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVD: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caGVO() args: 0, res: 0, upd: 0;
     }
 },
 _caGVO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVO: // global
           _saFD8::P64 = P64[Sp];
           I64[Sp] = block_caGVQ_info;
           R1 = _saFD8::P64;
           if (R1 & 7 != 0) goto uaGWV; else goto caGVS;
       uaGWV: // global
           call _caGVQ(R1) args: 0, res: 0, upd: 0;
       caGVS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGVQ() //  [R1]
         { info_tbl: [(caGVQ,
                       label: block_caGVQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVQ: // global
           if (R1 & 7 == 1) goto uaGWw; else goto caGW3;
       uaGWw: // global
           Sp = Sp + 16;
           call _caGU8() args: 0, res: 0, upd: 0;
       caGW3: // global
           I64[Sp - 8] = block_caGW1_info;
           _saFDc::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saFDc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGWW; else goto caGW4;
       uaGWW: // global
           call _caGW1(R1) args: 0, res: 0, upd: 0;
       caGW4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGW1() //  [R1]
         { info_tbl: [(caGW1,
                       label: block_caGW1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGW1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGWc; else goto caGWb;
       caGWc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGWb: // global
           _saFDh::P64 = P64[R1 + 7];
           _saFDe::I64 = I64[R1 + 15];
           _saFDf::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saFDe::I64;
           I64[Hp] = _saFDf::I64;
           I64[Sp] = block_caGW9_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saFDh::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGW9() //  []
         { info_tbl: [(caGW9,
                       label: block_caGW9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGW9: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caGVO() args: 0, res: 0, upd: 0;
     }
 },
 _caGV3() //  [R1]
         { info_tbl: [(caGV3,
                       label: block_caGV3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGV3: // global
           P64[Sp] = R1;
           call _caGVa() args: 0, res: 0, upd: 0;
     }
 },
 _caGVa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVa: // global
           _saFCG::P64 = P64[Sp];
           I64[Sp] = block_caGVc_info;
           R1 = _saFCG::P64;
           if (R1 & 7 != 0) goto uaGWQ; else goto caGVe;
       uaGWQ: // global
           call _caGVc(R1) args: 0, res: 0, upd: 0;
       caGVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGVc() //  [R1]
         { info_tbl: [(caGVc,
                       label: block_caGVc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVc: // global
           if (R1 & 7 == 1) goto uaGWz; else goto caGVp;
       uaGWz: // global
           Sp = Sp + 16;
           call _caGU8() args: 0, res: 0, upd: 0;
       caGVp: // global
           I64[Sp - 8] = block_caGVn_info;
           _saFCK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saFCK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaGWR; else goto caGVq;
       uaGWR: // global
           call _caGVn(R1) args: 0, res: 0, upd: 0;
       caGVq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGU8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGU8: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caGVn() //  [R1]
         { info_tbl: [(caGVn,
                       label: block_caGVn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGVy; else goto caGVx;
       caGVy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caGVx: // global
           _saFCP::P64 = P64[R1 + 7];
           _saFCM::I64 = I64[R1 + 15];
           _saFCN::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = _saFCM::I64;
           I64[Hp] = _saFCN::I64;
           I64[Sp] = block_caGVv_info;
           R3 = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = _saFCP::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caGVv() //  []
         { info_tbl: [(caGVv,
                       label: block_caGVv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGVv: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caGVa() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.694487293 UTC

[section ""data" . GHC.Event.Manager.loop4_closure" {
     GHC.Event.Manager.loop4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Event.Internal.Forever_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.698173082 UTC

[section ""data" . GHC.Event.Manager.loop3_closure" {
     GHC.Event.Manager.loop3_closure:
         const GHC.Event.Manager.loop3_info;
         const 0;
 },
 sat_saFDI_entry() //  [R1, R2, R3]
         { info_tbl: [(caH4F,
                       label: sat_saFDI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH4F: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFDU_entry() //  [R1, R2, R3]
         { info_tbl: [(caH50,
                       label: sat_saFDU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH50: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFE5_entry() //  [R1, R2, R3]
         { info_tbl: [(caH5j,
                       label: sat_saFE5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH5j: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Event.Manager.loop5_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop3_entry() //  [R2]
         { info_tbl: [(caH5m,
                       label: GHC.Event.Manager.loop3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH5m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caH5n; else goto caH5o;
       caH5n: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caH5o: // global
           I64[Sp - 8] = block_caH4q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaH68; else goto caH4r;
       uaH68: // global
           call _caH4q(R1) args: 0, res: 0, upd: 0;
       caH4r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH4q() //  [R1]
         { info_tbl: [(caH4q,
                       label: block_caH4q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH4q: // global
           I64[Sp - 16] = block_caH4v_info;
           _saFDo::P64 = R1;
           _saFDu::P64 = P64[R1 + 39];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saFDu::P64;
           P64[Sp] = _saFDo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaH63; else goto caH4w;
       uaH63: // global
           call _caH4v(R1) args: 0, res: 0, upd: 0;
       caH4w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH4v() //  [R1]
         { info_tbl: [(caH4v,
                       label: block_caH4v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH4v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caH5s; else goto caH5r;
       caH5s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caH5r: // global
           _saFDD::P64 = P64[R1 + 7];
           _saFDE::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_saFDI_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_caH4I_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = _saFDD::P64;
           R1 = _saFDE::P64;
           P64[Sp - 8] = _saFDE::P64;
           P64[Sp] = _saFDD::P64;
           Sp = Sp - 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH4I() //  [R1]
         { info_tbl: [(caH4I,
                       label: block_caH4I_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH4I: // global
           I64[Sp] = block_caH4K_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaH64; else goto caH4L;
       uaH64: // global
           call _caH4K(R1) args: 0, res: 0, upd: 0;
       caH4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH4K() //  [R1]
         { info_tbl: [(caH4K,
                       label: block_caH4K_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH4K: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caH5x; else goto caH5D;
       caH5x: // global
           _saFDR::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caH5v_info;
           R1 = _saFDR::P64;
           P64[Sp + 32] = _saFDR::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaH65; else goto caH5y;
       uaH65: // global
           call _caH5v() args: 0, res: 0, upd: 0;
       caH5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caH5D: // global
           I64[Sp] = block_caH4T_info;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caH5v() //  []
         { info_tbl: [(caH5v,
                       label: block_caH5v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH5v: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caH4T() //  []
         { info_tbl: [(caH4T,
                       label: block_caH4T_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH4T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caH5G; else goto caH5F;
       caH5G: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caH5F: // global
           I64[Hp - 8] = sat_saFDU_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caH53_info;
           R4 = Hp - 5;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH53() //  [R1]
         { info_tbl: [(caH53,
                       label: block_caH53_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH53: // global
           I64[Sp] = block_caH55_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaH66; else goto caH56;
       uaH66: // global
           call _caH55(R1) args: 0, res: 0, upd: 0;
       caH56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH55() //  [R1]
         { info_tbl: [(caH55,
                       label: block_caH55_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH55: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caH5K; else goto caH5J;
       caH5K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caH5J: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto caH5N; else goto caH5W;
       caH5N: // global
           Hp = Hp - 16;
           _saFE3::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caH5L_info;
           R1 = _saFE3::P64;
           P64[Sp + 32] = _saFE3::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaH67; else goto caH5O;
       uaH67: // global
           call _caH5L() args: 0, res: 0, upd: 0;
       caH5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caH5W: // global
           I64[Hp - 8] = sat_saFE5_info;
           P64[Hp] = P64[Sp + 32];
           _saFDD::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caH5T_info;
           R4 = Hp - 5;
           R3 = GHC.Event.Manager.loop4_closure+2;
           R2 = _saFDD::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH5L() //  []
         { info_tbl: [(caH5L,
                       label: block_caH5L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH5L: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caH5T() //  []
         { info_tbl: [(caH5T,
                       label: block_caH5T_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH5T: // global
           _saFEb::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_caH5V_info;
           R1 = _saFEb::P64;
           P64[Sp + 16] = _saFEb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaH69; else goto caH5Y;
       uaH69: // global
           call _caH5V() args: 0, res: 0, upd: 0;
       caH5Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH5V() //  []
         { info_tbl: [(caH5V,
                       label: block_caH5V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH5V: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.72695073 UTC

[section ""data" . GHC.Event.Manager.step_closure" {
     GHC.Event.Manager.step_closure:
         const GHC.Event.Manager.step_info;
         const 0;
 },
 GHC.Event.Manager.step_entry() //  [R2]
         { info_tbl: [(caH7v,
                       label: GHC.Event.Manager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH7v: // global
           R2 = R2;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.730782723 UTC

[section ""cstring" . lvl9_raAug_bytes" {
     lvl9_raAug_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.73266658 UTC

[section ""data" . GHC.Event.Manager.loop2_closure" {
     GHC.Event.Manager.loop2_closure:
         const GHC.Event.Manager.loop2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Manager.loop2_entry() //  [R1]
         { info_tbl: [(caH7L,
                       label: GHC.Event.Manager.loop2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH7L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caH7M; else goto caH7N;
       caH7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caH7N: // global
           (_caH7G::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caH7G::I64 == 0) goto caH7I; else goto caH7H;
       caH7I: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caH7H: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caH7G::I64;
           I64[Sp - 24] = block_caH7J_info;
           R2 = lvl9_raAug_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caH7J() //  [R1]
         { info_tbl: [(caH7J,
                       label: block_caH7J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH7J: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.739153241 UTC

[section ""data" . GHC.Event.Manager.loop8_closure" {
     GHC.Event.Manager.loop8_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.740882192 UTC

[section ""data" . GHC.Event.Manager.loop7_closure" {
     GHC.Event.Manager.loop7_closure:
         const (,)_con_info;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Releasing_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.743130221 UTC

[section ""data" . GHC.Event.Manager.loop6_closure" {
     GHC.Event.Manager.loop6_closure:
         const GHC.Event.Manager.loop6_info;
 },
 GHC.Event.Manager.loop6_entry() //  [R2]
         { info_tbl: [(caH8h,
                       label: GHC.Event.Manager.loop6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH8h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caH8i; else goto caH8j;
       caH8i: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caH8j: // global
           I64[Sp - 8] = block_caH89_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaH8x; else goto caH8a;
       uaH8x: // global
           call _caH89(R1) args: 0, res: 0, upd: 0;
       caH8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH89() //  [R1]
         { info_tbl: [(caH89,
                       label: block_caH89_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH89: // global
           _caH8g::P64 = R1 & 7;
           if (_caH8g::P64 == 1) goto caH8e; else goto uaH8w;
       caH8e: // global
           R1 = GHC.Event.Manager.loop8_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaH8w: // global
           if (_caH8g::P64 == 4) goto caH8f; else goto caH8d;
       caH8f: // global
           R1 = GHC.Event.Manager.loop7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caH8d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caH8p; else goto caH8o;
       caH8p: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caH8o: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.751769326 UTC

[section ""data" . GHC.Event.Manager.loop1_closure" {
     GHC.Event.Manager.loop1_closure:
         const GHC.Event.Manager.loop1_info;
         const 0;
 },
 go_saFED_entry() //  [R1]
         { info_tbl: [(caH9k,
                       label: go_saFED_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caH9l; else goto uaH9E;
       caH9l: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       uaH9E: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 16;
           call _caH97() args: 0, res: 0, upd: 0;
     }
 },
 _caH97() //  []
         { info_tbl: [(caH97,
                       label: block_caH97_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH97: // global
           I64[Sp - 16] = block_caH9a_info;
           _saFED::P64 = P64[Sp + 8];
           _saFEi::P64 = P64[_saFED::P64 + 7];
           R2 = _saFEi::P64;
           P64[Sp - 8] = P64[_saFED::P64 + 15];
           P64[Sp] = _saFEi::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.loop3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caH9a() //  [R1]
         { info_tbl: [(caH9a,
                       label: block_caH9a_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9a: // global
           I64[Sp] = block_caH9c_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaH9F; else goto caH9d;
       uaH9F: // global
           call _caH9c(R1) args: 0, res: 0, upd: 0;
       caH9d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH9c() //  [R1]
         { info_tbl: [(caH9c,
                       label: block_caH9c_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9c: // global
           _caH9j::P64 = R1 & 7;
           if (_caH9j::P64 != 2) goto uaH9D; else goto caH9h;
       uaH9D: // global
           if (_caH9j::P64 != 4) goto caH9g; else goto caH9i;
       caH9g: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       caH9i: // global
           I64[Sp + 24] = block_caH9z_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caH9h: // global
           I64[Sp + 16] = block_caH97_info;
           Sp = Sp + 16;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _caH9z() //  []
         { info_tbl: [(caH9z,
                       label: block_caH9z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFFr_entry() //  [R1, R2]
         { info_tbl: [(caH9P,
                       label: sat_saFFr_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9P: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caH9Q; else goto caH9R;
       caH9Q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caH9R: // global
           I64[Sp - 72] = block_caH9M_info;
           _saFEo::P64 = P64[R1 + 14];
           _saFEt::P64 = P64[R1 + 22];
           _saFEu::P64 = P64[R1 + 30];
           _saFEv::P64 = P64[R1 + 38];
           _saFEq::I64 = I64[R1 + 46];
           _saFEr::I64 = I64[R1 + 54];
           _saFEs::I64 = I64[R1 + 62];
           R1 = P64[R1 + 6];
           P64[Sp - 64] = _saFEo::P64;
           I64[Sp - 56] = _saFEq::I64;
           I64[Sp - 48] = _saFEr::I64;
           I64[Sp - 40] = _saFEs::I64;
           P64[Sp - 32] = _saFEt::P64;
           P64[Sp - 24] = _saFEu::P64;
           P64[Sp - 16] = _saFEv::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto uaHaG; else goto caH9N;
       uaHaG: // global
           call _caH9M(R1) args: 0, res: 0, upd: 0;
       caH9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH9M() //  [R1]
         { info_tbl: [(caH9M,
                       label: block_caH9M_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9M: // global
           _saFEo::P64 = P64[Sp + 8];
           _saFEv::P64 = P64[Sp + 56];
           _saFEO::P64 = P64[R1 + 7];
           _saFES::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saFEo::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saFEo::P64);
           I64[Sp] = block_caH9X_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saFEv::P64;
           P64[Sp + 8] = _saFES::P64;
           P64[Sp + 56] = _saFEO::P64;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH9X() //  []
         { info_tbl: [(caH9X,
                       label: block_caH9X_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9X: // global
           _saFES::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caH9Z_info;
           R2 = P64[Sp + 56];
           R1 = _saFES::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH9Z() //  []
         { info_tbl: [(caH9Z,
                       label: block_caH9Z_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH9Z: // global
           I64[Sp] = block_caHa1_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHa1() //  []
         { info_tbl: [(caHa1,
                       label: block_caHa1_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHa1: // global
           _saFEr::I64 = I64[Sp + 16];
           _saFEt::P64 = P64[Sp + 32];
           (_saFF7::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saFFc::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFEr::I64)));
           I64[Sp + 16] = block_caHah_info;
           R1 = _saFEt::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaHaH; else goto caHai;
       uaHaH: // global
           call _caHah(R1) args: 0, res: 0, upd: 0;
       caHai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHah() //  [R1]
         { info_tbl: [(caHah,
                       label: block_caHah_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHah: // global
           _saFEs::I64 = I64[Sp + 8];
           _saFEL::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caHao; else goto caHas;
       caHao: // global
           (_saFFi::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFEs::I64)));
           R1 = _saFEL::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caHas: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saFFq::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFEs::I64)));
           R1 = _saFEL::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.loop1_entry() //  [R2]
         { info_tbl: [(caHaI,
                       label: GHC.Event.Manager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHaI: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caHaJ; else goto caHaK;
       caHaJ: // global
           R2 = R2;
           R1 = GHC.Event.Manager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHaK: // global
           I64[Sp - 8] = block_caH8R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHc2; else goto caH8S;
       uaHc2: // global
           call _caH8R(R1) args: 0, res: 0, upd: 0;
       caH8S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH8R() //  [R1]
         { info_tbl: [(caH8R,
                       label: block_caH8R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH8R: // global
           I64[Sp - 72] = block_caH8W_info;
           _saFEi::P64 = R1;
           _saFEj::P64 = P64[R1 + 7];
           _saFEo::P64 = P64[R1 + 39];
           _saFEt::P64 = P64[R1 + 55];
           _saFEu::P64 = P64[R1 + 63];
           _saFEv::P64 = P64[R1 + 71];
           _saFEq::I64 = I64[R1 + 87];
           _saFEr::I64 = I64[R1 + 95];
           _saFEs::I64 = I64[R1 + 103];
           R1 = _saFEv::P64;
           P64[Sp - 64] = _saFEj::P64;
           P64[Sp - 56] = _saFEo::P64;
           I64[Sp - 48] = _saFEq::I64;
           I64[Sp - 40] = _saFEr::I64;
           I64[Sp - 32] = _saFEs::I64;
           P64[Sp - 24] = _saFEt::P64;
           P64[Sp - 16] = _saFEu::P64;
           P64[Sp - 8] = _saFEv::P64;
           P64[Sp] = _saFEi::P64;
           Sp = Sp - 72;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH8W() //  []
         { info_tbl: [(caH8W,
                       label: block_caH8W_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH8W: // global
           I64[Sp] = block_caH8Y_info;
           R2 = GHC.Event.Manager.loop6_closure+1;
           R1 = P64[Sp + 16];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH8Y() //  [R1]
         { info_tbl: [(caH8Y,
                       label: block_caH8Y_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH8Y: // global
           I64[Sp] = block_caH90_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHc0; else goto caH91;
       uaHc0: // global
           call _caH90(R1) args: 0, res: 0, upd: 0;
       caH91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caH90() //  [R1]
         { info_tbl: [(caH90,
                       label: block_caH90_info
                       rep:StackRep [False, False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH90: // global
           _saFEi::P64 = P64[Sp + 72];
           _saFEj::P64 = P64[Sp + 8];
           _saFEo::P64 = P64[Sp + 16];
           _saFEq::I64 = I64[Sp + 24];
           _saFEr::I64 = I64[Sp + 32];
           _saFEs::I64 = I64[Sp + 40];
           _saFEt::P64 = P64[Sp + 48];
           _saFEu::P64 = P64[Sp + 56];
           _saFEv::P64 = P64[Sp + 64];
           _caHbJ::P64 = R1 & 7;
           if (_caHbJ::P64 < 4) goto uaHbX; else goto uaHbZ;
       uaHbX: // global
           if (_caHbJ::P64 < 3) goto uaHbY; else goto caHbE;
       uaHbY: // global
           _saFEC::P64 = R1;
           if (_caHbJ::P64 < 2) goto caHaP; else goto caHaX;
       caHaX: // global
           I64[Sp + 8] = block_caHaV_info;
           R1 = _saFEj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaHc1; else goto caHaY;
       uaHc1: // global
           call _caHaV(R1) args: 0, res: 0, upd: 0;
       caHaY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caHbE: // global
           R2 = _saFEi::P64;
           Sp = Sp + 80;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
       uaHbZ: // global
           _saFEC::P64 = R1;
           if (_caHbJ::P64 < 5) goto caHaP; else goto caHbI;
       caHaP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caHaS; else goto caHaR;
       caHaS: // global
           HpAlloc = 96;
           R1 = _saFEC::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHaR: // global
           I64[Hp - 88] = go_saFED_info;
           P64[Hp - 80] = _saFEi::P64;
           P64[Hp - 72] = _saFEv::P64;
           I64[Hp - 64] = sat_saFFr_info;
           P64[Hp - 56] = _saFEj::P64;
           P64[Hp - 48] = _saFEo::P64;
           P64[Hp - 40] = _saFEt::P64;
           P64[Hp - 32] = _saFEu::P64;
           P64[Hp - 24] = _saFEv::P64;
           I64[Hp - 16] = _saFEq::I64;
           I64[Hp - 8] = _saFEr::I64;
           I64[Hp] = _saFEs::I64;
           R2 = Hp - 62;
           R1 = Hp - 87;
           Sp = Sp + 80;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       caHbI: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHaV() //  [R1]
         { info_tbl: [(caHaV,
                       label: block_caHaV_info
                       rep:StackRep [False, True, True, True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHaV: // global
           _saFEo::P64 = P64[Sp + 8];
           _saFEv::P64 = P64[Sp + 56];
           _saFFt::P64 = P64[R1 + 7];
           _saFFx::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saFEo::P64 + 8] = GHC.Event.Manager.Finished_closure+5;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saFEo::P64);
           I64[Sp + 8] = block_caHb5_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saFEv::P64;
           P64[Sp + 56] = _saFFx::P64;
           P64[Sp + 64] = _saFFt::P64;
           Sp = Sp + 8;
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHb5() //  []
         { info_tbl: [(caHb5,
                       label: block_caHb5_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHb5: // global
           I64[Sp] = block_caHb7_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHb7() //  []
         { info_tbl: [(caHb7,
                       label: block_caHb7_info
                       rep:StackRep [True, True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHb7: // global
           I64[Sp] = block_caHb9_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHb9() //  []
         { info_tbl: [(caHb9,
                       label: block_caHb9_info
                       rep:StackRep [True, True, True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHb9: // global
           _saFEr::I64 = I64[Sp + 16];
           _saFEt::P64 = P64[Sp + 32];
           (_saFFM::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saFFR::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFEr::I64)));
           I64[Sp + 16] = block_caHbp_info;
           R1 = _saFEt::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaHc3; else goto caHbq;
       uaHc3: // global
           call _caHbp(R1) args: 0, res: 0, upd: 0;
       caHbq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHbp() //  [R1]
         { info_tbl: [(caHbp,
                       label: block_caHbp_info
                       rep:StackRep [True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHbp: // global
           _saFEs::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caHbw; else goto caHbA;
       caHbw: // global
           (_saFFX::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFEs::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caHbA: // global
           call "ccall" arg hints:  [signed]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saFG6::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saFEs::I64)));
           R1 = GHC.Event.Manager.loop2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.796115772 UTC

[section ""data" . GHC.Event.Manager.loop_closure" {
     GHC.Event.Manager.loop_closure:
         const GHC.Event.Manager.loop_info;
         const 0;
 },
 GHC.Event.Manager.loop_entry() //  [R2]
         { info_tbl: [(caHe0,
                       label: GHC.Event.Manager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHe0: // global
           R2 = R2;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.799676632 UTC

[section ""data" . GHC.Event.Manager.closeFd_4_closure" {
     GHC.Event.Manager.closeFd_4_closure:
         const GHC.Event.Manager.closeFd_4_info;
 },
 GHC.Event.Manager.closeFd_4_entry() //  []
         { info_tbl: [(caHeb,
                       label: GHC.Event.Manager.closeFd_4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHeb: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.805370533 UTC

[section ""data" . GHC.Event.Manager.$wcloseFd__closure" {
     GHC.Event.Manager.$wcloseFd__closure:
         const GHC.Event.Manager.$wcloseFd__info;
         const 0;
 },
 $wgo_saFGq_entry() //  [R1, R2]
         { info_tbl: [(caHeO,
                       label: $wgo_saFGq_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHeO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHeP; else goto caHeQ;
       caHeP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHeQ: // global
           I64[Sp - 24] = block_caHeH_info;
           _saFGq::P64 = R1;
           _saFGb::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saFGb::I64;
           P64[Sp - 8] = _saFGq::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaHfd; else goto caHeI;
       uaHfd: // global
           call _caHeH(R1) args: 0, res: 0, upd: 0;
       caHeI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHeH() //  [R1]
         { info_tbl: [(caHeH,
                       label: block_caHeH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHeH: // global
           if (R1 & 7 == 1) goto caHeL; else goto caHeM;
       caHeL: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHeM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHeY; else goto caHeX;
       caHeY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHeX: // global
           _saFGu::P64 = P64[R1 + 6];
           _saFGv::P64 = P64[R1 + 14];
           _saFGt::I64 = I64[R1 + 22];
           if (_saFGt::I64 == I64[Sp + 8]) goto caHfc; else goto caHf6;
       caHfc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFGu::P64;
           R3 = _saFGv::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHf6: // global
           Hp = Hp - 16;
           I64[Sp] = block_caHf2_info;
           R2 = _saFGv::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saFGu::P64;
           I64[Sp + 16] = _saFGt::I64;
           call $wgo_saFGq_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHf2() //  [R1, R2, R3]
         { info_tbl: [(caHf2,
                       label: block_caHf2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHf2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHf9; else goto caHf8;
       caHf9: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHf8: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFHd_entry() //  [R1]
         { info_tbl: [(caHfR,
                       label: sat_saFHd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfR: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFHe_entry() //  [R1]
         { info_tbl: [(caHg1,
                       label: sat_saFHe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHg1: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.closeFd_2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.$wcloseFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caHg4,
                       label: GHC.Event.Manager.$wcloseFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHg4: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caHg5; else goto caHg6;
       caHg5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.$wcloseFd__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caHg6: // global
           I64[Sp - 24] = block_caHeo_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaHh7; else goto caHep;
       uaHh7: // global
           call _caHeo(R1) args: 0, res: 0, upd: 0;
       caHep: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHeo() //  [R1]
         { info_tbl: [(caHeo,
                       label: block_caHeo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHeo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHg9; else goto caHg8;
       caHg9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHg8: // global
           _saFGb::I64 = I64[Sp + 16];
           _saFGh::P64 = P64[R1 + 7];
           _saFGj::P64 = P64[R1 + 15];
           _saFGi::I64 = I64[R1 + 23];
           _saFGk::I64 = _saFGb::I64 & (I64[_saFGh::P64 + 8] - 1);
           _saFGp::P64 = P64[(_saFGh::P64 + 24) + (_saFGk::I64 << 3)];
           I64[Hp - 8] = $wgo_saFGq_info;
           I64[Hp] = _saFGb::I64;
           I64[Sp - 32] = block_caHfe_info;
           R2 = _saFGp::P64;
           R1 = Hp - 7;
           I64[Sp - 24] = _saFGi::I64;
           P64[Sp - 16] = _saFGj::P64;
           I64[Sp - 8] = _saFGk::I64;
           P64[Sp] = _saFGh::P64;
           Sp = Sp - 32;
           call $wgo_saFGq_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHfe() //  [R1, R2, R3]
         { info_tbl: [(caHfe,
                       label: block_caHfe_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfe: // global
           I64[Sp - 16] = block_caHga_info;
           _saFGE::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saFGE::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHh4; else goto caHgx;
       uaHh4: // global
           call _caHga(R1) args: 0, res: 0, upd: 0;
       caHgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHga() //  [R1]
         { info_tbl: [(caHga,
                       label: block_caHga_info
                       rep:StackRep [False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHga: // global
           if (R1 & 7 == 1) goto caHgD; else goto caHgI;
       caHgD: // global
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saFGH() args: 0, res: 0, upd: 0;
       caHgI: // global
           _saFGh::P64 = P64[Sp + 48];
           _saFGk::I64 = I64[Sp + 40];
           _saFGE::P64 = P64[Sp + 16];
           _saFGG::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saFGh::P64 + 24) + (_saFGk::I64 << 3)] = _saFGG::P64;
           I64[_saFGh::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFGh::P64 + 24) + ((I64[_saFGh::P64 + 8] << 3) + (_saFGk::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caHgG_info;
           _saFHf::P64 = R1;
           R1 = _saFGE::P64;
           P64[Sp + 48] = _saFHf::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaHh8; else goto caHgJ;
       uaHh8: // global
           call _caHgG(R1) args: 0, res: 0, upd: 0;
       caHgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHgG() //  [R1]
         { info_tbl: [(caHgG,
                       label: block_caHgG_info
                       rep:StackRep [True, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHgG: // global
           _saFHf::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caHgP; else goto caHgT;
       caHgP: // global
           P64[Sp + 32] = _saFHf::P64;
           Sp = Sp + 32;
           goto uaHhb;
       caHgT: // global
           _saFGi::I64 = I64[Sp + 8];
           _saFGj::P64 = P64[Sp + 16];
           I64[_saFGi::I64] = I64[_saFGi::I64] - 1;
           call MO_Touch(_saFGj::P64);
           P64[Sp + 32] = _saFHf::P64;
           Sp = Sp + 32;
           goto uaHhb;
       uaHhb: // global
           call _saFGH() args: 0, res: 0, upd: 0;
     }
 },
 _saFGH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saFGH: // global
           _saFGJ::P64 = P64[Sp];
           I64[Sp] = block_caHfl_info;
           R1 = _saFGJ::P64;
           if (R1 & 7 != 0) goto uaHhc; else goto caHfm;
       uaHhc: // global
           call _caHfl(R1) args: 0, res: 0, upd: 0;
       caHfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHfl() //  [R1]
         { info_tbl: [(caHfl,
                       label: block_caHfl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfl: // global
           if (R1 & 7 == 1) goto caHgg; else goto caHgi;
       caHgg: // global
           R1 = GHC.Event.Manager.closeFd_4_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caHgi: // global
           I64[Sp - 8] = block_caHfr_info;
           _saFGL::P64 = P64[R1 + 6];
           R2 = _saFGL::P64;
           P64[Sp] = _saFGL::P64;
           Sp = Sp - 8;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHfr() //  [R1]
         { info_tbl: [(caHfr,
                       label: block_caHfr_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfr: // global
           if (R1 == 0) goto caHgt; else goto caHgl;
       caHgt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHgw; else goto caHgv;
       caHgw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caHgv: // global
           I64[Hp - 8] = sat_saFHe_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caHgl: // global
           I64[Sp] = block_caHfv_info;
           _saFGM::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saFGM::I64;
           if (R1 & 7 != 0) goto uaHh5; else goto caHfw;
       uaHh5: // global
           call _caHfv(R1) args: 0, res: 0, upd: 0;
       caHfw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHfv() //  [R1]
         { info_tbl: [(caHfv,
                       label: block_caHfv_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfv: // global
           I64[Sp] = block_caHfA_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uaHh6; else goto caHfB;
       uaHh6: // global
           call _caHfA(R1) args: 0, res: 0, upd: 0;
       caHfB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHfA() //  [R1]
         { info_tbl: [(caHfA,
                       label: block_caHfA_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHgp; else goto caHgo;
       caHgp: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHgo: // global
           _saFH2::P64 = P64[R1 + 7];
           _saFH4::P64 = P64[R1 + 23];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 16] & 7;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_caHfK_info;
           R5 = GHC.Event.Internal.evtNothing_closure;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saFH2::P64;
           R1 = _saFH4::P64;
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caHfK() //  [R1]
         { info_tbl: [(caHfK,
                       label: block_caHfK_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHfK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHgs; else goto caHgr;
       caHgs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHgr: // global
           I64[Hp - 8] = sat_saFHd_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.839578127 UTC

[section ""data" . GHC.Event.Manager.closeFd_1_closure" {
     GHC.Event.Manager.closeFd_1_closure:
         const GHC.Event.Manager.closeFd_1_info;
         const 0;
 },
 GHC.Event.Manager.closeFd_1_entry() //  [R2, R3, R4]
         { info_tbl: [(caHj7,
                       label: GHC.Event.Manager.closeFd_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHj7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHjb; else goto caHjc;
       caHjb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.closeFd_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caHjc: // global
           I64[Sp - 24] = block_caHj4_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaHjk; else goto caHj5;
       uaHjk: // global
           call _caHj4(R1) args: 0, res: 0, upd: 0;
       caHj5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHj4() //  [R1]
         { info_tbl: [(caHj4,
                       label: block_caHj4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHj4: // global
           I64[Sp] = block_caHja_info;
           _saFHu::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _saFHu::P64;
           if (R1 & 7 != 0) goto uaHjj; else goto caHje;
       uaHjj: // global
           call _caHja(R1) args: 0, res: 0, upd: 0;
       caHje: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHja() //  [R1]
         { info_tbl: [(caHja,
                       label: block_caHja_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHja: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.847293952 UTC

[section ""data" . GHC.Event.Manager.closeFd__closure" {
     GHC.Event.Manager.closeFd__closure:
         const GHC.Event.Manager.closeFd__info;
         const 0;
 },
 GHC.Event.Manager.closeFd__entry() //  [R2, R3, R4]
         { info_tbl: [(caHjE,
                       label: GHC.Event.Manager.closeFd__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHjE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.closeFd_1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.850662684 UTC

[section ""data" . lvl10_raAuh_closure" {
     lvl10_raAuh_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.853051778 UTC

[section ""data" . lvl11_raAui_closure" {
     lvl11_raAui_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.854823403 UTC

[section ""data" . lvl12_raAuj_closure" {
     lvl12_raAuj_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:41.866109035 UTC

[section ""data" . registerFd1_raAuk_closure" {
     registerFd1_raAuk_closure:
         const registerFd1_raAuk_info;
         const 0;
 },
 $wgo_saFIY_entry() //  [R1, R2]
         { info_tbl: [(caHm2,
                       label: $wgo_saFIY_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHm2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHm3; else goto caHm4;
       caHm3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHm4: // global
           I64[Sp - 24] = block_caHlV_info;
           _saFIY::P64 = R1;
           _saFI5::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saFI5::I64;
           P64[Sp - 8] = _saFIY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaHmr; else goto caHlW;
       uaHmr: // global
           call _caHlV(R1) args: 0, res: 0, upd: 0;
       caHlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHlV() //  [R1]
         { info_tbl: [(caHlV,
                       label: block_caHlV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHlV: // global
           if (R1 & 7 == 1) goto caHlZ; else goto caHm0;
       caHlZ: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHm0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHmc; else goto caHmb;
       caHmc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHmb: // global
           _saFJ2::P64 = P64[R1 + 6];
           _saFJ3::P64 = P64[R1 + 14];
           _saFJ1::I64 = I64[R1 + 22];
           if (_saFJ1::I64 == I64[Sp + 8]) goto caHmq; else goto caHmk;
       caHmq: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFJ2::P64;
           R3 = _saFJ3::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHmk: // global
           Hp = Hp - 16;
           I64[Sp] = block_caHmg_info;
           R2 = _saFJ3::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saFJ2::P64;
           I64[Sp + 16] = _saFJ1::I64;
           call $wgo_saFIY_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHmg() //  [R1, R2, R3]
         { info_tbl: [(caHmg,
                       label: block_caHmg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHmn; else goto caHmm;
       caHmn: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHmm: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saFJN_entry() //  [R1, R2]
         { info_tbl: [(caHnc,
                       label: $wgo_saFJN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHnc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHnd; else goto caHne;
       caHnd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHne: // global
           I64[Sp - 24] = block_caHn5_info;
           _saFJN::P64 = R1;
           _saFI5::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saFI5::I64;
           P64[Sp - 8] = _saFJN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaHnB; else goto caHn6;
       uaHnB: // global
           call _caHn5(R1) args: 0, res: 0, upd: 0;
       caHn6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHn5() //  [R1]
         { info_tbl: [(caHn5,
                       label: block_caHn5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHn5: // global
           if (R1 & 7 == 1) goto caHn9; else goto caHna;
       caHn9: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHna: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHnm; else goto caHnl;
       caHnm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHnl: // global
           _saFJR::P64 = P64[R1 + 6];
           _saFJS::P64 = P64[R1 + 14];
           _saFJQ::I64 = I64[R1 + 22];
           if (_saFJQ::I64 == I64[Sp + 8]) goto caHnA; else goto caHnu;
       caHnA: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFJR::P64;
           R3 = _saFJS::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHnu: // global
           Hp = Hp - 16;
           I64[Sp] = block_caHnq_info;
           R2 = _saFJS::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saFJR::P64;
           I64[Sp + 16] = _saFJQ::I64;
           call $wgo_saFJN_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHnq() //  [R1, R2, R3]
         { info_tbl: [(caHnq,
                       label: block_caHnq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHnq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHnx; else goto caHnw;
       caHnx: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHnw: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saFIp_entry() //  [R1, R2]
         { info_tbl: [(caHnJ,
                       label: $wio_saFIp_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHnJ: // global
           _saFIq::P64 = R2;
           _saFIp::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caHnK; else goto caHnL;
       caHnL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHnN; else goto caHnM;
       caHnN: // global
           HpAlloc = 64;
           goto caHnK;
       caHnK: // global
           R2 = _saFIq::P64;
           R1 = _saFIp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHnM: // global
           _saFHW::P64 = P64[_saFIp::P64 + 6];
           _saFHY::P64 = P64[_saFIp::P64 + 14];
           _saFHZ::P64 = P64[_saFIp::P64 + 22];
           _saFI4::P64 = P64[_saFIp::P64 + 30];
           _saFIa::P64 = P64[_saFIp::P64 + 38];
           _saFI3::I64 = I64[_saFIp::P64 + 46];
           _saFI5::I64 = I64[_saFIp::P64 + 54];
           _saFI9::I64 = I64[_saFIp::P64 + 62];
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = _saFIa::P64;
           I64[Hp - 40] = _saFI5::I64;
           I64[Hp - 32] = _saFI3::I64;
           I64[Hp - 24] = _saFI9::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caHkY_info;
           R5 = _saFIq::P64;
           R4 = Hp - 14;
           R3 = _saFI5::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saFHW::P64;
           P64[Sp - 48] = _saFHY::P64;
           P64[Sp - 40] = _saFHZ::P64;
           P64[Sp - 32] = _saFI4::P64;
           I64[Sp - 24] = _saFI5::I64;
           I64[Sp - 16] = _saFI9::I64;
           P64[Sp - 8] = _saFIq::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHkY() //  [R1]
         { info_tbl: [(caHkY,
                       label: block_caHkY_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHkY: // global
           I64[Sp - 8] = block_caHnC_info;
           _saFIw::P64 = R1;
           R1 = R1;
           P64[Sp] = _saFIw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHqb; else goto caHnD;
       uaHqb: // global
           call _caHnC(R1) args: 0, res: 0, upd: 0;
       caHnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHnC() //  [R1]
         { info_tbl: [(caHnC,
                       label: block_caHnC_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHnC: // global
           if (R1 & 7 == 1) goto caHnG; else goto caHnH;
       caHnG: // global
           I64[Sp] = 0;
           call _saFIx() args: 0, res: 0, upd: 0;
       caHnH: // global
           I64[Sp] = block_caHpF_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHpF() //  [R1]
         { info_tbl: [(caHpF,
                       label: block_caHpF_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHpF: // global
           I64[Sp] = R1;
           call _saFIx() args: 0, res: 0, upd: 0;
     }
 },
 _saFIx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saFIx: // global
           _saFIz::I64 = I64[Sp] | I64[Sp + 56];
           _saFIA::I64 = _saFIz::I64 & 8;
           if (_saFIA::I64 != 0) goto uaHq4; else goto uaHq3;
       uaHq4: // global
           I64[Sp + 32] = _saFIA::I64;
           I64[Sp + 56] = _saFIz::I64;
           call _caHlc() args: 0, res: 0, upd: 0;
       uaHq3: // global
           I64[Sp + 24] = _saFIA::I64;
           I64[Sp + 56] = _saFIz::I64;
           Sp = Sp + 8;
           call _caHmu() args: 0, res: 0, upd: 0;
     }
 },
 _caHlc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHlc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHnU; else goto caHnT;
       caHnU: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_caHlb_info;
           R1 = I64[Sp + 32];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caHnT: // global
           _saFIy::I64 = I64[Sp];
           _saFIz::I64 = I64[Sp + 56];
           if (_saFIy::I64 == _saFIz::I64) goto caHnW; else goto caHnX;
       caHnW: // global
           Hp = Hp - 32;
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caHnX: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFIz::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFIy::I64 & 7;
           I64[Sp] = block_caHlq_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           I64[Sp - 8] = stg_ap_v_info;
           Sp = Sp - 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caHlb() //  [R1]
         { info_tbl: [(caHlb,
                       label: block_caHlb_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHlb: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caHlc() args: 0, res: 0, upd: 0;
     }
 },
 _caHlq() //  [R1]
         { info_tbl: [(caHlq,
                       label: block_caHlq_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHlq: // global
           I64[Sp] = block_caHls_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHqd; else goto caHlt;
       uaHqd: // global
           call _caHls(R1) args: 0, res: 0, upd: 0;
       caHlt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHls() //  [R1]
         { info_tbl: [(caHls,
                       label: block_caHls_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHls: // global
           if (R1 & 7 == 1) goto caHo1; else goto caHoJ;
       caHo1: // global
           I64[Sp + 40] = block_caHlx_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaHqe; else goto caHly;
       uaHqe: // global
           call _caHlx(R1) args: 0, res: 0, upd: 0;
       caHly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caHoJ: // global
           R1 = lvl12_raAuj_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHlx() //  [R1]
         { info_tbl: [(caHlx,
                       label: block_caHlx_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHlx: // global
           _saFIq::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caHo4; else goto caHoD;
       caHo4: // global
           I64[Sp] = block_caHlC_info;
           R1 = P64[_saFIq::P64 + 8];
           if (R1 & 7 != 0) goto uaHqf; else goto caHlD;
       uaHqf: // global
           call _caHlC(R1) args: 0, res: 0, upd: 0;
       caHlD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caHoD: // global
           I64[Sp + 24] = block_caHoB_info;
           R5 = _saFIq::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHlC() //  [R1]
         { info_tbl: [(caHlC,
                       label: block_caHlC_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHlC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHo7; else goto caHo6;
       caHo7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHo6: // global
           _saFI5::I64 = I64[Sp + 8];
           _saFIP::P64 = P64[R1 + 7];
           _saFIR::P64 = P64[R1 + 15];
           _saFIQ::I64 = I64[R1 + 23];
           _saFIS::I64 = _saFI5::I64 & (I64[_saFIP::P64 + 8] - 1);
           _saFIX::P64 = P64[(_saFIP::P64 + 24) + (_saFIS::I64 << 3)];
           I64[Hp - 8] = $wgo_saFIY_info;
           I64[Hp] = _saFI5::I64;
           I64[Sp - 8] = block_caHo8_info;
           R2 = _saFIX::P64;
           R1 = Hp - 7;
           I64[Sp] = _saFIS::I64;
           P64[Sp + 8] = _saFIR::P64;
           I64[Sp + 16] = _saFIQ::I64;
           P64[Sp + 24] = _saFIP::P64;
           Sp = Sp - 8;
           call $wgo_saFIY_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHo8() //  [R1, R2, R3]
         { info_tbl: [(caHo8,
                       label: block_caHo8_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHo8: // global
           I64[Sp - 16] = block_caHoa_info;
           _saFJc::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saFJc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHql; else goto caHoc;
       uaHql: // global
           call _caHoa(R1) args: 0, res: 0, upd: 0;
       caHoc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHoa() //  [R1]
         { info_tbl: [(caHoa,
                       label: block_caHoa_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHoa: // global
           if (R1 & 7 == 1) goto uaHq6; else goto caHon;
       uaHq6: // global
           Sp = Sp + 56;
           call _caHpk() args: 0, res: 0, upd: 0;
       caHon: // global
           _saFIP::P64 = P64[Sp + 48];
           _saFIS::I64 = I64[Sp + 24];
           _saFJc::P64 = P64[Sp + 16];
           _saFJe::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saFIP::P64 + 24) + (_saFIS::I64 << 3)] = _saFJe::P64;
           I64[_saFIP::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFIP::P64 + 24) + ((I64[_saFIP::P64 + 8] << 3) + (_saFIS::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caHol_info;
           R1 = _saFJc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaHqm; else goto caHoo;
       uaHqm: // global
           call _caHol(R1) args: 0, res: 0, upd: 0;
       caHoo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHol() //  [R1]
         { info_tbl: [(caHol,
                       label: block_caHol_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHol: // global
           if (R1 & 7 == 1) goto uaHq7; else goto caHoy;
       uaHq7: // global
           Sp = Sp + 32;
           call _caHpk() args: 0, res: 0, upd: 0;
       caHoy: // global
           _saFIQ::I64 = I64[Sp + 16];
           _saFIR::P64 = P64[Sp + 8];
           I64[_saFIQ::I64] = I64[_saFIQ::I64] - 1;
           call MO_Touch(_saFIR::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHoB() //  []
         { info_tbl: [(caHoB,
                       label: block_caHoB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHoB: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHmu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHoN; else goto caHoM;
       caHoN: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caHmt_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caHoM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caHmA_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHmt() //  [R1]
         { info_tbl: [(caHmt,
                       label: block_caHmt_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmt: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caHmu() args: 0, res: 0, upd: 0;
     }
 },
 _caHmA() //  [R1]
         { info_tbl: [(caHmA,
                       label: block_caHmA_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmA: // global
           I64[Sp] = block_caHmC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHqh; else goto caHmD;
       uaHqh: // global
           call _caHmC(R1) args: 0, res: 0, upd: 0;
       caHmD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHmC() //  [R1]
         { info_tbl: [(caHmC,
                       label: block_caHmC_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmC: // global
           if (R1 & 7 == 1) goto caHoR; else goto caHpz;
       caHoR: // global
           I64[Sp + 40] = block_caHmH_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaHqi; else goto caHmI;
       uaHqi: // global
           call _caHmH(R1) args: 0, res: 0, upd: 0;
       caHmI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caHpz: // global
           R1 = lvl11_raAui_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHmH() //  [R1]
         { info_tbl: [(caHmH,
                       label: block_caHmH_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmH: // global
           _saFIq::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caHoU; else goto caHpt;
       caHoU: // global
           I64[Sp] = block_caHmM_info;
           R1 = P64[_saFIq::P64 + 8];
           if (R1 & 7 != 0) goto uaHqj; else goto caHmN;
       uaHqj: // global
           call _caHmM(R1) args: 0, res: 0, upd: 0;
       caHmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caHpt: // global
           I64[Sp + 24] = block_caHpr_info;
           R5 = _saFIq::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHmM() //  [R1]
         { info_tbl: [(caHmM,
                       label: block_caHmM_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHmM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHoX; else goto caHoW;
       caHoX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHoW: // global
           _saFI5::I64 = I64[Sp + 8];
           _saFJE::P64 = P64[R1 + 7];
           _saFJG::P64 = P64[R1 + 15];
           _saFJF::I64 = I64[R1 + 23];
           _saFJH::I64 = _saFI5::I64 & (I64[_saFJE::P64 + 8] - 1);
           _saFJM::P64 = P64[(_saFJE::P64 + 24) + (_saFJH::I64 << 3)];
           I64[Hp - 8] = $wgo_saFJN_info;
           I64[Hp] = _saFI5::I64;
           I64[Sp - 8] = block_caHoY_info;
           R2 = _saFJM::P64;
           R1 = Hp - 7;
           I64[Sp] = _saFJH::I64;
           P64[Sp + 8] = _saFJG::P64;
           I64[Sp + 16] = _saFJF::I64;
           P64[Sp + 24] = _saFJE::P64;
           Sp = Sp - 8;
           call $wgo_saFJN_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHoY() //  [R1, R2, R3]
         { info_tbl: [(caHoY,
                       label: block_caHoY_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHoY: // global
           I64[Sp - 16] = block_caHp0_info;
           _saFK1::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saFK1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHqp; else goto caHp2;
       uaHqp: // global
           call _caHp0(R1) args: 0, res: 0, upd: 0;
       caHp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHp0() //  [R1]
         { info_tbl: [(caHp0,
                       label: block_caHp0_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHp0: // global
           if (R1 & 7 == 1) goto uaHq9; else goto caHpd;
       uaHq9: // global
           Sp = Sp + 56;
           call _caHpk() args: 0, res: 0, upd: 0;
       caHpd: // global
           _saFJE::P64 = P64[Sp + 48];
           _saFJH::I64 = I64[Sp + 24];
           _saFK1::P64 = P64[Sp + 16];
           _saFK3::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saFJE::P64 + 24) + (_saFJH::I64 << 3)] = _saFK3::P64;
           I64[_saFJE::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFJE::P64 + 24) + ((I64[_saFJE::P64 + 8] << 3) + (_saFJH::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caHpb_info;
           R1 = _saFK1::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaHqq; else goto caHpe;
       uaHqq: // global
           call _caHpb(R1) args: 0, res: 0, upd: 0;
       caHpe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHpb() //  [R1]
         { info_tbl: [(caHpb,
                       label: block_caHpb_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHpb: // global
           if (R1 & 7 == 1) goto uaHqa; else goto caHpo;
       uaHqa: // global
           Sp = Sp + 32;
           call _caHpk() args: 0, res: 0, upd: 0;
       caHpo: // global
           _saFJF::I64 = I64[Sp + 16];
           _saFJG::P64 = P64[Sp + 8];
           I64[_saFJF::I64] = I64[_saFJF::I64] - 1;
           call MO_Touch(_saFJG::P64);
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHpk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHpk: // global
           R1 = lvl10_raAuh_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHpr() //  []
         { info_tbl: [(caHpr,
                       label: block_caHpr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHpr: // global
           R1 = lvl10_raAuh_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saFKl_entry() //  [R1, R2]
         { info_tbl: [(caHqE,
                       label: io_saFKl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHqE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHqF; else goto caHqG;
       caHqF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHqG: // global
           I64[Sp - 16] = block_caHqB_info;
           _saFIp::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saFIp::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHqK; else goto caHqC;
       uaHqK: // global
           call _caHqB(R1) args: 0, res: 0, upd: 0;
       caHqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHqB() //  [R1]
         { info_tbl: [(caHqB,
                       label: block_caHqB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHqB: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saFIp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFKz_entry() //  [R1, R2]
         { info_tbl: [(caHqW,
                       label: sat_saFKz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHqW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHqX; else goto caHqY;
       caHqX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHqY: // global
           I64[Sp - 16] = block_caHqU_info;
           _saFKw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFKw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHqU() //  []
         { info_tbl: [(caHqU,
                       label: block_caHqU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHqU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFKu_entry() //  [R1]
         { info_tbl: [(caHr5,
                       label: sat_saFKu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHr5: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFKl_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFKv_entry() //  [R1]
         { info_tbl: [(caHrd,
                       label: sat_saFKv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrd: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFKW_entry() //  [R1, R2]
         { info_tbl: [(caHrv,
                       label: sat_saFKW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHrw; else goto caHrx;
       caHrw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHrx: // global
           I64[Sp - 16] = block_caHrt_info;
           _saFKT::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFKT::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHrt() //  []
         { info_tbl: [(caHrt,
                       label: block_caHrt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFKR_entry() //  [R1]
         { info_tbl: [(caHrE,
                       label: sat_saFKR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrE: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFKl_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFKS_entry() //  [R1]
         { info_tbl: [(caHrM,
                       label: sat_saFKS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrM: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFL1_entry() //  [R1]
         { info_tbl: [(caHrT,
                       label: sat_saFL1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHrU; else goto caHrV;
       caHrU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caHrV: // global
           I64[Sp - 24] = block_caHrm_info;
           _saFIn::P64 = P64[R1 + 7];
           _saFKl::P64 = P64[R1 + 15];
           R1 = _saFIn::P64;
           P64[Sp - 16] = _saFIn::P64;
           P64[Sp - 8] = _saFKl::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHrm() //  [R1]
         { info_tbl: [(caHrm,
                       label: block_caHrm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHrY; else goto caHrX;
       caHrY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHrX: // global
           I64[Hp - 56] = sat_saFKW_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFKR_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFKS_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caHrP_info;
           R2 = Hp - 54;
           _saFKQ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFKQ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHrP() //  [R1]
         { info_tbl: [(caHrP,
                       label: block_caHrP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrP: // global
           _saFIn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHrR_info;
           R2 = P64[Sp + 16];
           _saFKZ::P64 = R1;
           R1 = _saFIn::P64;
           P64[Sp + 16] = _saFKZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHrR() //  []
         { info_tbl: [(caHrR,
                       label: block_caHrR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHrR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFLm_entry() //  [R1, R2]
         { info_tbl: [(caHsb,
                       label: sat_saFLm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHsc; else goto caHsd;
       caHsc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHsd: // global
           I64[Sp - 16] = block_caHs9_info;
           _saFLj::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFLj::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHs9() //  []
         { info_tbl: [(caHs9,
                       label: block_caHs9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHs9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFLh_entry() //  [R1]
         { info_tbl: [(caHsk,
                       label: sat_saFLh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsk: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFKl_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFLi_entry() //  [R1]
         { info_tbl: [(caHss,
                       label: sat_saFLi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHss: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 registerFd1_raAuk_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caHsv,
                       label: registerFd1_raAuk_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsv: // global
           if ((Sp + -120) < SpLim) (likely: False) goto caHsw; else goto caHsx;
       caHsw: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = registerFd1_raAuk_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caHsx: // global
           I64[Sp - 40] = block_caHjS_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaHvf; else goto caHjT;
       uaHvf: // global
           call _caHjS(R1) args: 0, res: 0, upd: 0;
       caHjT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHjS() //  [R1]
         { info_tbl: [(caHjS,
                       label: block_caHjS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHjS: // global
           I64[Sp - 32] = block_caHjX_info;
           _saFHE::P64 = P64[R1 + 7];
           _saFHG::P64 = P64[R1 + 23];
           _saFHI::P64 = P64[R1 + 31];
           _saFHK::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _saFHG::P64;
           P64[Sp - 16] = _saFHI::P64;
           P64[Sp - 8] = _saFHK::P64;
           P64[Sp] = _saFHE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaHv8; else goto caHjY;
       uaHv8: // global
           call _caHjX(R1) args: 0, res: 0, upd: 0;
       caHjY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHjX() //  [R1]
         { info_tbl: [(caHjX,
                       label: block_caHjX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHjX: // global
           I64[Sp - 8] = block_caHk2_info;
           _saFHR::P64 = R1;
           _saFHS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saFHS::I64;
           P64[Sp + 8] = _saFHR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHv9; else goto caHk3;
       uaHv9: // global
           call _caHk2(R1) args: 0, res: 0, upd: 0;
       caHk3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHk2() //  [R1]
         { info_tbl: [(caHk2,
                       label: block_caHk2_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHk2: // global
           I64[Sp - 8] = block_caHk7_info;
           _saFHT::P64 = R1;
           _saFHU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saFHU::I64;
           P64[Sp + 40] = _saFHT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHva; else goto caHk8;
       uaHva: // global
           call _caHk7(R1) args: 0, res: 0, upd: 0;
       caHk8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHk7() //  [R1]
         { info_tbl: [(caHk7,
                       label: block_caHk7_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHk7: // global
           _saFHz::P64 = P64[Sp + 64];
           _saFHW::P64 = P64[R1 + 7];
           _saFHY::P64 = P64[R1 + 23];
           _saFHZ::P64 = P64[R1 + 31];
           (_saFI3::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 40] + 16, 1);
           I64[Sp - 16] = block_caHke_info;
           R1 = _saFHz::P64;
           I64[Sp - 8] = _saFI3::I64;
           P64[Sp] = _saFHZ::P64;
           P64[Sp + 40] = _saFHY::P64;
           P64[Sp + 64] = _saFHW::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHvb; else goto caHkf;
       uaHvb: // global
           call _caHke(R1) args: 0, res: 0, upd: 0;
       caHkf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHke() //  [R1]
         { info_tbl: [(caHke,
                       label: block_caHke_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHke: // global
           I64[Sp - 8] = block_caHkj_info;
           _saFI4::P64 = R1;
           _saFI5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saFI5::I64;
           P64[Sp + 88] = _saFI4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHvc; else goto caHkk;
       uaHvc: // global
           call _caHkj(R1) args: 0, res: 0, upd: 0;
       caHkk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHkj() //  [R1]
         { info_tbl: [(caHkj,
                       label: block_caHkj_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHkj: // global
           I64[Sp - 8] = block_caHsD_info;
           _saFI6::P64 = R1;
           _saFI7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 104];
           I64[Sp] = _saFI7::I64;
           P64[Sp + 104] = _saFI6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHvd; else goto caHuR;
       uaHvd: // global
           call _caHsD(R1) args: 0, res: 0, upd: 0;
       caHuR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHsD() //  [R1]
         { info_tbl: [(caHsD,
                       label: block_caHsD_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsD: // global
           _saFHy::P64 = P64[Sp + 88];
           _saFI7::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caHuX; else goto caHv1;
       caHuX: // global
           _saFI9::I64 = _saFI7::I64;
           goto saFI8;
       caHv1: // global
           _saFI9::I64 = _saFI7::I64 | 8;
           goto saFI8;
       saFI8: // global
           I64[Sp + 8] = block_caHkt_info;
           R1 = _saFHy::P64;
           I64[Sp + 88] = _saFI9::I64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHkt() //  [R1]
         { info_tbl: [(caHkt,
                       label: block_caHkt_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHkt: // global
           I64[Sp - 8] = block_caHkv_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caHkv() //  [R1]
         { info_tbl: [(caHkv,
                       label: block_caHkv_info
                       rep:StackRep [False, True, True, False, True, True, False, False,
                                     False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHkv: // global
           _saFHR::P64 = P64[Sp + 56];
           _saFHS::I64 = I64[Sp + 48];
           _saFHT::P64 = P64[Sp + 80];
           _saFIe::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saFHS::I64,
                            _saFIe::I64)) goto caHsL; else goto caHuQ;
       caHuQ: // global
           if (%MO_S_Gt_W64(_saFIe::I64,
                            I64[Sp + 40])) goto caHsL; else goto caHsM;
       caHsL: // global
           R4 = _saFIe::I64;
           R3 = _saFHR::P64;
           R2 = _saFHT::P64;
           Sp = Sp + 120;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caHsM: // global
           _saFIl::P64 = P64[P64[Sp + 64] + ((_saFIe::I64 - _saFHS::I64 << 3) + 24)];
           I64[Sp] = block_caHkL_info;
           _saFId::I64 = R1;
           R1 = _saFIl::P64;
           I64[Sp + 80] = _saFId::I64;
           if (R1 & 7 != 0) goto uaHve; else goto caHkM;
       uaHve: // global
           call _caHkL(R1) args: 0, res: 0, upd: 0;
       caHkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHkL() //  [R1]
         { info_tbl: [(caHkL,
                       label: block_caHkL_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHkL: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto caHsP; else goto caHsO;
       caHsP: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHsO: // global
           _saFIn::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.Event.Manager.FdKey_con_info;
           _saFI5::I64 = I64[Sp + 16];
           I64[Hp - 120] = _saFI5::I64;
           _saFI3::I64 = I64[Sp + 24];
           I64[Hp - 112] = _saFI3::I64;
           I64[Hp - 104] = $wio_saFIp_info;
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = _saFI3::I64;
           I64[Hp - 48] = _saFI5::I64;
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = io_saFKl_info;
           P64[Hp - 24] = Hp - 102;
           _caHkQ::P64 = Hp - 127;
           _caHqw::P64 = Hp - 30;
           _saFKq::I64 = I64[Sp + 80];
           if (_saFKq::I64 != 0) goto uaHv7; else goto caHtB;
       uaHv7: // global
           if (_saFKq::I64 != 1) goto caHsW; else goto caHue;
       caHsW: // global
           Hp = Hp - 24;
           I64[Sp] = block_caHqN_info;
           R1 = _saFIn::P64;
           P64[Sp + 88] = _saFIn::P64;
           P64[Sp + 96] = _caHqw::P64;
           P64[Sp + 104] = _caHkQ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caHue: // global
           Hp = Hp - 24;
           I64[Sp] = block_caHs2_info;
           R1 = _saFIn::P64;
           P64[Sp + 88] = _saFIn::P64;
           P64[Sp + 96] = _caHqw::P64;
           P64[Sp + 104] = _caHkQ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caHtB: // global
           I64[Hp - 16] = sat_saFL1_info;
           P64[Hp - 8] = _saFIn::P64;
           P64[Hp] = _caHqw::P64;
           I64[Sp] = block_caHty_info;
           R1 = Hp - 15;
           P64[Sp + 104] = _caHkQ::P64;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHqN() //  [R1]
         { info_tbl: [(caHqN,
                       label: block_caHqN_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHqN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHsZ; else goto caHsY;
       caHsZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHsY: // global
           I64[Hp - 56] = sat_saFKz_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFKu_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFKv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caHsQ_info;
           R2 = Hp - 54;
           _saFKt::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saFKt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHsQ() //  [R1]
         { info_tbl: [(caHsQ,
                       label: block_caHsQ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsQ: // global
           I64[Sp] = block_caHsS_info;
           R2 = P64[Sp + 96];
           _saFKC::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saFKC::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHsS() //  []
         { info_tbl: [(caHsS,
                       label: block_caHsS_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsS: // global
           I64[Sp] = block_caHsU_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaHvg; else goto caHt2;
       uaHvg: // global
           call _caHsU(R1) args: 0, res: 0, upd: 0;
       caHt2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHsU() //  [R1]
         { info_tbl: [(caHsU,
                       label: block_caHsU_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHsU: // global
           I64[Sp] = block_caHt6_info;
           _saFKF::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saFKF::P64;
           if (R1 & 7 != 0) goto uaHvh; else goto caHt8;
       uaHvh: // global
           call _caHt6(R1) args: 0, res: 0, upd: 0;
       caHt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHt6() //  [R1]
         { info_tbl: [(caHt6,
                       label: block_caHt6_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHt6: // global
           if (R1 & 7 == 1) goto caHth; else goto caHts;
       caHth: // global
           I64[Sp + 88] = block_caHtc_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHts: // global
           _saFKF::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caHtq_info;
           R1 = _saFKF::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaHvi; else goto caHtt;
       uaHvi: // global
           call _caHtq() args: 0, res: 0, upd: 0;
       caHtt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHtc() //  []
         { info_tbl: [(caHtc,
                       label: block_caHtc_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHtc: // global
           _saFKF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHte_info;
           R1 = _saFKF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaHvj; else goto caHtj;
       uaHvj: // global
           call _caHte() args: 0, res: 0, upd: 0;
       caHtj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHte() //  []
         { info_tbl: [(caHte,
                       label: block_caHte_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHte: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHtq() //  []
         { info_tbl: [(caHtq,
                       label: block_caHtq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHtq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHs2() //  [R1]
         { info_tbl: [(caHs2,
                       label: block_caHs2_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHs2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHuh; else goto caHug;
       caHuh: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHug: // global
           I64[Hp - 56] = sat_saFLm_info;
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFLh_info;
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFLi_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caHu9_info;
           R2 = Hp - 54;
           _saFLg::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 96] = _saFLg::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHu9() //  [R1]
         { info_tbl: [(caHu9,
                       label: block_caHu9_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHu9: // global
           I64[Sp] = block_caHub_info;
           R2 = P64[Sp + 96];
           _saFLp::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 96] = _saFLp::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHub() //  []
         { info_tbl: [(caHub,
                       label: block_caHub_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHub: // global
           I64[Sp] = block_caHud_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto uaHvo; else goto caHuk;
       uaHvo: // global
           call _caHud(R1) args: 0, res: 0, upd: 0;
       caHuk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHud() //  [R1]
         { info_tbl: [(caHud,
                       label: block_caHud_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHud: // global
           I64[Sp] = block_caHuo_info;
           _saFLs::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saFLs::P64;
           if (R1 & 7 != 0) goto uaHvp; else goto caHuq;
       uaHvp: // global
           call _caHuo(R1) args: 0, res: 0, upd: 0;
       caHuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHuo() //  [R1]
         { info_tbl: [(caHuo,
                       label: block_caHuo_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHuo: // global
           if (R1 & 7 == 1) goto caHuz; else goto caHuK;
       caHuz: // global
           I64[Sp + 88] = block_caHuu_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHuK: // global
           _saFLs::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caHuI_info;
           R1 = _saFLs::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaHvq; else goto caHuL;
       uaHvq: // global
           call _caHuI() args: 0, res: 0, upd: 0;
       caHuL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHuu() //  []
         { info_tbl: [(caHuu,
                       label: block_caHuu_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHuu: // global
           _saFLs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHuw_info;
           R1 = _saFLs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaHvr; else goto caHuB;
       uaHvr: // global
           call _caHuw() args: 0, res: 0, upd: 0;
       caHuB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHuw() //  []
         { info_tbl: [(caHuw,
                       label: block_caHuw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHuw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHuI() //  []
         { info_tbl: [(caHuI,
                       label: block_caHuI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHuI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHty() //  [R1]
         { info_tbl: [(caHty,
                       label: block_caHty_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHty: // global
           I64[Sp] = block_caHtA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHvk; else goto caHtD;
       uaHvk: // global
           call _caHtA(R1) args: 0, res: 0, upd: 0;
       caHtD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHtA() //  [R1]
         { info_tbl: [(caHtA,
                       label: block_caHtA_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHtA: // global
           I64[Sp] = block_caHtH_info;
           _saFL6::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _saFL6::P64;
           if (R1 & 7 != 0) goto uaHvl; else goto caHtJ;
       uaHvl: // global
           call _caHtH(R1) args: 0, res: 0, upd: 0;
       caHtJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHtH() //  [R1]
         { info_tbl: [(caHtH,
                       label: block_caHtH_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHtH: // global
           if (R1 & 7 == 1) goto caHtS; else goto caHu3;
       caHtS: // global
           I64[Sp + 88] = block_caHtN_info;
           R3 = P64[Sp + 112];
           R2 = P64[Sp + 104];
           R1 = P64[Sp + 8];
           Sp = Sp + 88;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHu3: // global
           _saFL6::P64 = P64[Sp + 96];
           I64[Sp + 96] = block_caHu1_info;
           R1 = _saFL6::P64;
           Sp = Sp + 96;
           if (R1 & 7 != 0) goto uaHvm; else goto caHu4;
       uaHvm: // global
           call _caHu1() args: 0, res: 0, upd: 0;
       caHu4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHtN() //  []
         { info_tbl: [(caHtN,
                       label: block_caHtN_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHtN: // global
           _saFL6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHtP_info;
           R1 = _saFL6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaHvn; else goto caHtU;
       uaHvn: // global
           call _caHtP() args: 0, res: 0, upd: 0;
       caHtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHtP() //  []
         { info_tbl: [(caHtP,
                       label: block_caHtP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHtP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHu1() //  []
         { info_tbl: [(caHu1,
                       label: block_caHu1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHu1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.020243669 UTC

[section ""data" . GHC.Event.Manager.registerFd_closure" {
     GHC.Event.Manager.registerFd_closure:
         const GHC.Event.Manager.registerFd_info;
         const 0;
 },
 GHC.Event.Manager.registerFd_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caHDu,
                       label: GHC.Event.Manager.registerFd_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHDu: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call registerFd1_raAuk_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.024221001 UTC

[section ""cstring" . lvl13_raAul_bytes" {
     lvl13_raAul_bytes:
         I8[] [117,110,114,101,103,105,115,116,101,114,70,100,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.02594246 UTC

[section ""data" . lvl14_raAum_closure" {
     lvl14_raAum_closure:
         const lvl14_raAum_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_raAum_entry() //  [R1]
         { info_tbl: [(caHDI,
                       label: lvl14_raAum_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHDI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHDJ; else goto caHDK;
       caHDJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caHDK: // global
           (_caHDF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caHDF::I64 == 0) goto caHDH; else goto caHDG;
       caHDH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caHDG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caHDF::I64;
           R2 = lvl13_raAul_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.029748643 UTC

[section ""data" . lvl15_raAun_closure" {
     lvl15_raAun_closure:
         const lvl15_raAun_info;
         const 0;
 },
 lvl15_raAun_entry() //  [R2]
         { info_tbl: [(caHDX,
                       label: lvl15_raAun_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHDX: // global
           R3 = R2;
           R2 = lvl14_raAum_closure;
           call $wlvl_raAub_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.040508158 UTC

[section ""data" . GHC.Event.Manager.unregisterFd2_closure" {
     GHC.Event.Manager.unregisterFd2_closure:
         const GHC.Event.Manager.unregisterFd2_info;
         const 0;
 },
 g_saFMA_entry() //  [R1, R2]
         { info_tbl: [(caHFj,
                       label: g_saFMA_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHFj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHFk; else goto caHFl;
       caHFk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHFl: // global
           I64[Sp - 16] = block_caHFg_info;
           _saFM6::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _saFM6::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHFq; else goto caHFh;
       uaHFq: // global
           call _caHFg(R1) args: 0, res: 0, upd: 0;
       caHFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHFg() //  [R1]
         { info_tbl: [(caHFg,
                       label: block_caHFg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHFg: // global
           R1 = I64[((I64[R1 + 23] != I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saFMI_entry() //  [R1, R2]
         { info_tbl: [(caHFD,
                       label: $wgo_saFMI_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHFD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caHFE; else goto caHFF;
       caHFE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHFF: // global
           I64[Sp - 32] = block_caHFw_info;
           _saFMI::P64 = R1;
           _saFMA::P64 = P64[R1 + 7];
           _saFM5::I64 = I64[R1 + 15];
           R1 = R2;
           I64[Sp - 24] = _saFM5::I64;
           P64[Sp - 16] = _saFMA::P64;
           P64[Sp - 8] = _saFMI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaHGi; else goto caHFx;
       uaHGi: // global
           call _caHFw(R1) args: 0, res: 0, upd: 0;
       caHFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHFw() //  [R1]
         { info_tbl: [(caHFw,
                       label: block_caHFw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHFw: // global
           if (R1 & 7 == 1) goto caHFA; else goto caHFB;
       caHFA: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHFB: // global
           _saFMM::P64 = P64[R1 + 6];
           _saFMN::P64 = P64[R1 + 14];
           _saFML::I64 = I64[R1 + 22];
           if (_saFML::I64 == I64[Sp + 8]) goto caHFZ; else goto caHFT;
       caHFZ: // global
           I64[Sp] = block_caHFY_info;
           R3 = _saFMM::P64;
           R2 = P64[Sp + 16];
           P64[Sp + 8] = _saFMN::P64;
           P64[Sp + 16] = _saFMM::P64;
           I64[Sp + 24] = _saFML::I64;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 8;
       caHFT: // global
           I64[Sp + 8] = block_caHFP_info;
           R2 = _saFMN::P64;
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _saFMM::P64;
           I64[Sp + 24] = _saFML::I64;
           Sp = Sp + 8;
           call $wgo_saFMI_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHFY() //  [R1]
         { info_tbl: [(caHFY,
                       label: block_caHFY_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHFY: // global
           _saFMM::P64 = P64[Sp + 16];
           _saFMN::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto caHG5; else goto caHGd;
       caHG5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHG8; else goto caHG7;
       caHG8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHG7: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFMM::P64;
           R3 = _saFMN::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHGd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caHGg; else goto caHGf;
       caHGg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHGf: // global
           I64[Hp - 40] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = _saFMN::P64;
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFMM::P64;
           R3 = Hp - 38;
           R2 = Hp - 6;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHFP() //  [R1, R2, R3]
         { info_tbl: [(caHFP,
                       label: block_caHFP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHFP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHFW; else goto caHFV;
       caHFW: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caHFV: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_saFNL_entry() //  [R1, R2]
         { info_tbl: [(caHGY,
                       label: go_saFNL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHGY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHGZ; else goto uaHHh;
       caHGZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaHHh: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _caHGO() args: 0, res: 0, upd: 0;
     }
 },
 _caHGO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHGO: // global
           _saFM5::I64 = I64[P64[Sp] + 7];
           I64[Sp - 8] = block_caHGR_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saFM5::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHHj; else goto caHGS;
       uaHHj: // global
           call _caHGR(R1) args: 0, res: 0, upd: 0;
       caHGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHGR() //  [R1]
         { info_tbl: [(caHGR,
                       label: block_caHGR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHGR: // global
           if (R1 & 7 == 1) goto caHGV; else goto caHGW;
       caHGV: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caHGW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHH8; else goto caHH7;
       caHH8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHH7: // global
           if (I64[R1 + 22] == I64[Sp + 16]) goto caHHg; else goto caHHc;
       caHHg: // global
           _saFNP::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saFNP::P64;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caHHc: // global
           _saFNQ::P64 = P64[R1 + 14];
           Hp = Hp - 16;
           P64[Sp + 16] = _saFNQ::P64;
           Sp = Sp + 8;
           call _caHGO() args: 0, res: 0, upd: 0;
     }
 },
 $wio_saFMk_entry() //  [R1, R2]
         { info_tbl: [(caHHm,
                       label: $wio_saFMk_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHHm: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caHHn; else goto caHHo;
       caHHn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHHo: // global
           I64[Sp - 56] = block_caHEX_info;
           _saFLZ::P64 = P64[R1 + 6];
           _saFM1::P64 = P64[R1 + 14];
           _saFM2::P64 = P64[R1 + 22];
           _saFM5::I64 = I64[R1 + 30];
           _saFM6::I64 = I64[R1 + 38];
           R1 = P64[R2 + 8];
           P64[Sp - 48] = _saFLZ::P64;
           P64[Sp - 40] = _saFM1::P64;
           P64[Sp - 32] = _saFM2::P64;
           I64[Sp - 24] = _saFM5::I64;
           I64[Sp - 16] = _saFM6::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaHK2; else goto caHEY;
       uaHK2: // global
           call _caHEX(R1) args: 0, res: 0, upd: 0;
       caHEY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHEX() //  [R1]
         { info_tbl: [(caHEX,
                       label: block_caHEX_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caHHr; else goto caHHq;
       caHHr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHHq: // global
           _saFM5::I64 = I64[Sp + 32];
           _saFMr::P64 = P64[R1 + 7];
           _saFMt::P64 = P64[R1 + 15];
           _saFMs::I64 = I64[R1 + 23];
           _saFMu::I64 = _saFM5::I64 & (I64[_saFMr::P64 + 8] - 1);
           _saFMz::P64 = P64[(_saFMr::P64 + 24) + (_saFMu::I64 << 3)];
           I64[Hp - 32] = g_saFMA_info;
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = $wgo_saFMI_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _saFM5::I64;
           I64[Sp - 24] = block_caHGj_info;
           R2 = _saFMz::P64;
           R1 = Hp - 15;
           P64[Sp - 16] = _saFMt::P64;
           I64[Sp - 8] = _saFMu::I64;
           I64[Sp] = _saFMs::I64;
           P64[Sp + 40] = _saFMr::P64;
           Sp = Sp - 24;
           call $wgo_saFMI_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHGj() //  [R1, R2, R3]
         { info_tbl: [(caHGj,
                       label: block_caHGj_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHGj: // global
           I64[Sp - 16] = block_caHHs_info;
           _saFN1::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saFN1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHJZ; else goto caHJh;
       uaHJZ: // global
           call _caHHs(R1) args: 0, res: 0, upd: 0;
       caHJh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHHs() //  [R1]
         { info_tbl: [(caHHs,
                       label: block_caHHs_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHHs: // global
           if (R1 & 7 == 1) goto caHJn; else goto caHJs;
       caHJn: // global
           P64[Sp + 80] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call _saFN4() args: 0, res: 0, upd: 0;
       caHJs: // global
           _saFMr::P64 = P64[Sp + 80];
           _saFMu::I64 = I64[Sp + 32];
           _saFN1::P64 = P64[Sp + 16];
           _saFN3::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saFMr::P64 + 24) + (_saFMu::I64 << 3)] = _saFN3::P64;
           I64[_saFMr::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saFMr::P64 + 24) + ((I64[_saFMr::P64 + 8] << 3) + (_saFMu::I64 >> 7))] = 1 :: W8;
           I64[Sp + 16] = block_caHJq_info;
           _saFNX::P64 = R1;
           R1 = _saFN1::P64;
           P64[Sp + 80] = _saFNX::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaHK3; else goto caHJt;
       uaHK3: // global
           call _caHJq(R1) args: 0, res: 0, upd: 0;
       caHJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHJq() //  [R1]
         { info_tbl: [(caHJq,
                       label: block_caHJq_info
                       rep:StackRep [False, True, True, False, False, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHJq: // global
           _saFNX::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto caHJz; else goto caHJD;
       caHJz: // global
           P64[Sp + 64] = _saFNX::P64;
           Sp = Sp + 32;
           goto uaHKg;
       caHJD: // global
           _saFMs::I64 = I64[Sp + 24];
           _saFMt::P64 = P64[Sp + 8];
           I64[_saFMs::I64] = I64[_saFMs::I64] - 1;
           call MO_Touch(_saFMt::P64);
           P64[Sp + 64] = _saFNX::P64;
           Sp = Sp + 32;
           goto uaHKg;
       uaHKg: // global
           call _saFN4() args: 0, res: 0, upd: 0;
     }
 },
 _saFN4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saFN4: // global
           I64[Sp - 8] = block_caHGs_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHKh; else goto caHGt;
       uaHKh: // global
           call _caHGs(R1) args: 0, res: 0, upd: 0;
       caHGt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHGs() //  [R1]
         { info_tbl: [(caHGs,
                       label: block_caHGs_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHGs: // global
           if (R1 & 7 == 1) goto caHIK; else goto caHIR;
       caHIK: // global
           I64[Sp + 48] = 0;
           I64[Sp + 40] = 0;
           call _caHHv() args: 0, res: 0, upd: 0;
       caHIR: // global
           _saFNA::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp] = block_caHGy_info;
           _saFNx::P64 = P64[R1 + 6];
           R1 = _saFNA::P64;
           P64[Sp + 48] = _saFNx::P64;
           if (R1 & 7 != 0) goto uaHK0; else goto caHGz;
       uaHK0: // global
           call _caHGy(R1) args: 0, res: 0, upd: 0;
       caHGz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHGy() //  [R1]
         { info_tbl: [(caHGy,
                       label: block_caHGy_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHGy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caHIU; else goto caHIT;
       caHIU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHIT: // global
           _saFM5::I64 = I64[Sp + 32];
           _saFNC::P64 = P64[R1 + 7];
           _saFNK::P64 = P64[(_saFNC::P64 + 24) + (_saFM5::I64 & (I64[_saFNC::P64 + 8] - 1) << 3)];
           I64[Hp - 8] = go_saFNL_info;
           I64[Hp] = _saFM5::I64;
           I64[Sp] = block_caHIL_info;
           R2 = _saFNK::P64;
           R1 = Hp - 7;
           call go_saFNL_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHIL() //  [R1]
         { info_tbl: [(caHIL,
                       label: block_caHIL_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHIL: // global
           I64[Sp] = block_caHIP_info;
           R2 = P64[Sp + 48];
           P64[Sp + 48] = R1;
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHIP() //  [R1]
         { info_tbl: [(caHIP,
                       label: block_caHIP_info
                       rep:StackRep [False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHIP: // global
           I64[Sp] = block_caHIZ_info;
           _saFNT::I64 = R1;
           R1 = P64[Sp + 48];
           I64[Sp + 48] = _saFNT::I64;
           if (R1 & 7 != 0) goto uaHKc; else goto caHJ1;
       uaHKc: // global
           call _caHIZ(R1) args: 0, res: 0, upd: 0;
       caHJ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHIZ() //  [R1]
         { info_tbl: [(caHIZ,
                       label: block_caHIZ_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHIZ: // global
           if (R1 & 7 == 1) goto caHJ7; else goto caHJc;
       caHJ7: // global
           I64[Sp + 48] = I64[Sp + 48];
           I64[Sp + 40] = 0;
           call _caHHv() args: 0, res: 0, upd: 0;
       caHJc: // global
           I64[Sp] = block_caHJa_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHJa() //  [R1]
         { info_tbl: [(caHJa,
                       label: block_caHJa_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHJa: // global
           I64[Sp + 40] = R1;
           I64[Sp + 48] = I64[Sp + 48];
           call _caHHv() args: 0, res: 0, upd: 0;
     }
 },
 _caHHv() //  []
         { info_tbl: [(caHHv,
                       label: block_caHHv_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHHv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHHA; else goto caHHz;
       caHHA: // global
           HpAlloc = 32;
           I64[Sp] = block_caHHv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caHHz: // global
           _saFNa::I64 = I64[Sp + 40];
           if (I64[Sp + 48] == _saFNa::I64) goto caHHE; else goto caHIG;
       caHHE: // global
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caHIG: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = I64[Sp + 32];
           _caHHH::P64 = Hp - 23;
           if (_saFNa::I64 & 8 != 0) goto caHIE; else goto caHIF;
       caHIF: // global
           _saFNp::I64 = _saFNa::I64 & 7;
           if (_saFNp::I64 == 0) goto caHIE; else goto caHIr;
       caHIE: // global
           Hp = Hp - 16;
           P64[Sp + 24] = _caHHH::P64;
           call _caHHL() args: 0, res: 0, upd: 0;
       caHIr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFNp::I64;
           _saFM2::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caHIn_info;
           R4 = Hp - 7;
           R3 = _caHHH::P64;
           R2 = P64[Sp + 8];
           R1 = _saFM2::P64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHIn() //  [R1]
         { info_tbl: [(caHIn,
                       label: block_caHIn_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHIn: // global
           I64[Sp] = block_caHIp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHK9; else goto caHIt;
       uaHK9: // global
           call _caHIp(R1) args: 0, res: 0, upd: 0;
       caHIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHIp() //  [R1]
         { info_tbl: [(caHIp,
                       label: block_caHIp_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHIp: // global
           if (R1 & 7 == 1) goto uaHJU; else goto uaHJV;
       uaHJU: // global
           Sp = Sp + 8;
           call _caHIz() args: 0, res: 0, upd: 0;
       uaHJV: // global
           Sp = Sp + 32;
           call _caHID() args: 0, res: 0, upd: 0;
     }
 },
 _caHHL() //  []
         { info_tbl: [(caHHL,
                       label: block_caHHL_info
                       rep:StackRep [False, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHHL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHHP; else goto caHHO;
       caHHP: // global
           HpAlloc = 32;
           I64[Sp] = block_caHHL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caHHO: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 40] & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           _caHHH::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_caHHY_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _caHHH::P64;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_v_info;
           Sp = Sp + 16;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caHHY() //  [R1]
         { info_tbl: [(caHHY,
                       label: block_caHHY_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHHY: // global
           I64[Sp] = block_caHI0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHK6; else goto caHI2;
       uaHK6: // global
           call _caHI0(R1) args: 0, res: 0, upd: 0;
       caHI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHI0() //  [R1]
         { info_tbl: [(caHI0,
                       label: block_caHI0_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHI0: // global
           if (R1 & 7 == 1) goto uaHJX; else goto uaHJY;
       uaHJX: // global
           Sp = Sp + 8;
           call _caHIz() args: 0, res: 0, upd: 0;
       uaHJY: // global
           Sp = Sp + 32;
           call _caHID() args: 0, res: 0, upd: 0;
     }
 },
 _caHIz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHIz: // global
           R2 = I64[Sp];
           Sp = Sp + 24;
           call lvl15_raAun_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caHID() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHID: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saFO7_entry() //  [R1, R2]
         { info_tbl: [(caHKq,
                       label: io_saFO7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHKr; else goto caHKs;
       caHKr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHKs: // global
           I64[Sp - 16] = block_caHKn_info;
           _saFMk::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saFMk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHKw; else goto caHKo;
       uaHKw: // global
           call _caHKn(R1) args: 0, res: 0, upd: 0;
       caHKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHKn() //  [R1]
         { info_tbl: [(caHKn,
                       label: block_caHKn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKn: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saFMk_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOl_entry() //  [R1, R2]
         { info_tbl: [(caHKI,
                       label: sat_saFOl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHKJ; else goto caHKK;
       caHKJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHKK: // global
           I64[Sp - 16] = block_caHKG_info;
           _saFOi::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFOi::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHKG() //  []
         { info_tbl: [(caHKG,
                       label: block_caHKG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOg_entry() //  [R1]
         { info_tbl: [(caHKR,
                       label: sat_saFOg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKR: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFO7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOh_entry() //  [R1]
         { info_tbl: [(caHKZ,
                       label: sat_saFOh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKZ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOz_entry() //  [R1, R2]
         { info_tbl: [(caHLh,
                       label: sat_saFOz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHLi; else goto caHLj;
       caHLi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHLj: // global
           I64[Sp - 16] = block_caHLf_info;
           _saFOw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFOw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHLf() //  []
         { info_tbl: [(caHLf,
                       label: block_caHLf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOu_entry() //  [R1]
         { info_tbl: [(caHLq,
                       label: sat_saFOu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLq: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFO7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOv_entry() //  [R1]
         { info_tbl: [(caHLy,
                       label: sat_saFOv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLy: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOE_entry() //  [R1]
         { info_tbl: [(caHLF,
                       label: sat_saFOE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caHLG; else goto caHLH;
       caHLG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caHLH: // global
           I64[Sp - 24] = block_caHL8_info;
           _saFMj::P64 = P64[R1 + 7];
           _saFO7::P64 = P64[R1 + 15];
           R1 = _saFMj::P64;
           P64[Sp - 16] = _saFMj::P64;
           P64[Sp - 8] = _saFO7::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHL8() //  [R1]
         { info_tbl: [(caHL8,
                       label: block_caHL8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHL8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHLK; else goto caHLJ;
       caHLK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHLJ: // global
           I64[Hp - 56] = sat_saFOz_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFOu_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFOv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caHLB_info;
           R2 = Hp - 54;
           _saFOt::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFOt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHLB() //  [R1]
         { info_tbl: [(caHLB,
                       label: block_caHLB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLB: // global
           _saFMj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHLD_info;
           R2 = P64[Sp + 16];
           _saFOC::P64 = R1;
           R1 = _saFMj::P64;
           P64[Sp + 16] = _saFOC::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHLD() //  []
         { info_tbl: [(caHLD,
                       label: block_caHLD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFON_entry() //  [R1, R2]
         { info_tbl: [(caHLX,
                       label: sat_saFON_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caHLY; else goto caHLZ;
       caHLY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caHLZ: // global
           I64[Sp - 16] = block_caHLV_info;
           _saFOK::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saFOK::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHLV() //  []
         { info_tbl: [(caHLV,
                       label: block_caHLV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOI_entry() //  [R1]
         { info_tbl: [(caHM6,
                       label: sat_saFOI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHM6: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_saFO7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saFOJ_entry() //  [R1]
         { info_tbl: [(caHMe,
                       label: sat_saFOJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHMe: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.unregisterFd2_entry() //  [R2, R3]
         { info_tbl: [(caHMh,
                       label: GHC.Event.Manager.unregisterFd2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHMh: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caHMi; else goto caHMj;
       caHMi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHMj: // global
           I64[Sp - 16] = block_caHE8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHN1; else goto caHE9;
       uaHN1: // global
           call _caHE8(R1) args: 0, res: 0, upd: 0;
       caHE9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHE8() //  [R1]
         { info_tbl: [(caHE8,
                       label: block_caHE8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHE8: // global
           I64[Sp - 24] = block_caHEd_info;
           _saFLH::P64 = P64[R1 + 7];
           _saFLJ::P64 = P64[R1 + 23];
           _saFLL::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _saFLJ::P64;
           P64[Sp - 8] = _saFLL::P64;
           P64[Sp] = _saFLH::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaHMW; else goto caHEe;
       uaHMW: // global
           call _caHEd(R1) args: 0, res: 0, upd: 0;
       caHEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHEd() //  [R1]
         { info_tbl: [(caHEd,
                       label: block_caHEd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEd: // global
           I64[Sp - 8] = block_caHEi_info;
           _saFLU::P64 = R1;
           _saFLV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saFLV::I64;
           P64[Sp + 8] = _saFLU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHMX; else goto caHEj;
       uaHMX: // global
           call _caHEi(R1) args: 0, res: 0, upd: 0;
       caHEj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHEi() //  [R1]
         { info_tbl: [(caHEi,
                       label: block_caHEi_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEi: // global
           I64[Sp - 8] = block_caHEn_info;
           _saFLW::P64 = R1;
           _saFLX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saFLX::I64;
           P64[Sp + 32] = _saFLW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaHMY; else goto caHEo;
       uaHMY: // global
           call _caHEn(R1) args: 0, res: 0, upd: 0;
       caHEo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHEn() //  [R1]
         { info_tbl: [(caHEn,
                       label: block_caHEn_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEn: // global
           I64[Sp - 16] = block_caHEs_info;
           _saFLZ::P64 = P64[R1 + 7];
           _saFM1::P64 = P64[R1 + 23];
           _saFM2::P64 = P64[R1 + 31];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _saFM2::P64;
           P64[Sp] = _saFM1::P64;
           P64[Sp + 48] = _saFLZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaHMZ; else goto caHEt;
       uaHMZ: // global
           call _caHEs(R1) args: 0, res: 0, upd: 0;
       caHEt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHEs() //  [R1]
         { info_tbl: [(caHEs,
                       label: block_caHEs_info
                       rep:StackRep [False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEs: // global
           I64[Sp - 16] = block_caHEx_info;
           I64[Sp - 8] = I64[R1 + 15];
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caHEx() //  [R1]
         { info_tbl: [(caHEx,
                       label: block_caHEx_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEx: // global
           _saFLU::P64 = P64[Sp + 56];
           _saFLV::I64 = I64[Sp + 48];
           _saFLW::P64 = P64[Sp + 72];
           _saFMa::I64 = I64[Sp + 16] & 31;
           if (%MO_S_Gt_W64(_saFLV::I64,
                            _saFMa::I64)) goto caHMt; else goto caHMU;
       caHMU: // global
           if (%MO_S_Gt_W64(_saFMa::I64,
                            I64[Sp + 40])) goto caHMt; else goto caHMu;
       caHMt: // global
           R4 = _saFMa::I64;
           R3 = _saFLU::P64;
           R2 = _saFLW::P64;
           Sp = Sp + 88;
           call lvl3_raAu8_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caHMu: // global
           _saFMh::P64 = P64[P64[Sp + 64] + ((_saFMa::I64 - _saFLV::I64 << 3) + 24)];
           I64[Sp] = block_caHEN_info;
           _saFM9::I64 = R1;
           R1 = _saFMh::P64;
           I64[Sp + 72] = _saFM9::I64;
           if (R1 & 7 != 0) goto uaHN0; else goto caHEO;
       uaHN0: // global
           call _caHEN(R1) args: 0, res: 0, upd: 0;
       caHEO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHEN() //  [R1]
         { info_tbl: [(caHEN,
                       label: block_caHEN_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHEN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caHMx; else goto caHMw;
       caHMx: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHMw: // global
           _saFMj::P64 = P64[R1 + 7];
           I64[Hp - 80] = $wio_saFMk_info;
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io_saFO7_info;
           P64[Hp - 24] = Hp - 78;
           _caHKi::P64 = Hp - 30;
           _saFOc::I64 = I64[Sp + 72];
           if (_saFOc::I64 != 0) goto uaHMV; else goto caHMJ;
       uaHMV: // global
           if (_saFOc::I64 != 1) goto caHMC; else goto caHMN;
       caHMC: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caHKz_info;
           R1 = _saFMj::P64;
           P64[Sp + 72] = _saFMj::P64;
           P64[Sp + 80] = _caHKi::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caHMN: // global
           Hp = Hp - 24;
           I64[Sp + 64] = block_caHLO_info;
           R1 = _saFMj::P64;
           P64[Sp + 72] = _saFMj::P64;
           P64[Sp + 80] = _caHKi::P64;
           Sp = Sp + 64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caHMJ: // global
           I64[Hp - 16] = sat_saFOE_info;
           P64[Hp - 8] = _saFMj::P64;
           P64[Hp] = _caHKi::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHKz() //  [R1]
         { info_tbl: [(caHKz,
                       label: block_caHKz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHKz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHMF; else goto caHME;
       caHMF: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHME: // global
           I64[Hp - 56] = sat_saFOl_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFOg_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFOh_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caHMy_info;
           R2 = Hp - 54;
           _saFOf::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFOf::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHMy() //  [R1]
         { info_tbl: [(caHMy,
                       label: block_caHMy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHMy: // global
           _saFMj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHMA_info;
           R2 = P64[Sp + 16];
           _saFOo::P64 = R1;
           R1 = _saFMj::P64;
           P64[Sp + 16] = _saFOo::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHMA() //  []
         { info_tbl: [(caHMA,
                       label: block_caHMA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHMA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caHLO() //  [R1]
         { info_tbl: [(caHLO,
                       label: block_caHLO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHLO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caHMQ; else goto caHMP;
       caHMQ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caHMP: // global
           I64[Hp - 56] = sat_saFON_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saFOI_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saFOJ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caHMK_info;
           R2 = Hp - 54;
           _saFOH::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saFOH::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHMK() //  [R1]
         { info_tbl: [(caHMK,
                       label: block_caHMK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHMK: // global
           _saFMj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caHMM_info;
           R2 = P64[Sp + 16];
           _saFOQ::P64 = R1;
           R1 = _saFMj::P64;
           P64[Sp + 16] = _saFOQ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHMM() //  []
         { info_tbl: [(caHMM,
                       label: block_caHMM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHMM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.157381577 UTC

[section ""data" . GHC.Event.Manager.unregisterFd__closure" {
     GHC.Event.Manager.unregisterFd__closure:
         const GHC.Event.Manager.unregisterFd__info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd__entry() //  [R2, R3]
         { info_tbl: [(caHT1,
                       label: GHC.Event.Manager.unregisterFd__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHT1: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.161016442 UTC

[section ""data" . GHC.Event.Manager.unregisterFd1_closure" {
     GHC.Event.Manager.unregisterFd1_closure:
         const GHC.Event.Manager.unregisterFd1_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd1_entry() //  [R2, R3]
         { info_tbl: [(caHTh,
                       label: GHC.Event.Manager.unregisterFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHTh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caHTi; else goto caHTj;
       caHTi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.unregisterFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHTj: // global
           I64[Sp - 8] = block_caHTc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caHTc() //  [R1]
         { info_tbl: [(caHTc,
                       label: block_caHTc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHTc: // global
           I64[Sp] = block_caHTe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaHTo; else goto caHTf;
       uaHTo: // global
           call _caHTe() args: 0, res: 0, upd: 0;
       caHTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caHTe() //  []
         { info_tbl: [(caHTe,
                       label: block_caHTe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHTe: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.168262797 UTC

[section ""data" . GHC.Event.Manager.unregisterFd_closure" {
     GHC.Event.Manager.unregisterFd_closure:
         const GHC.Event.Manager.unregisterFd_info;
         const 0;
 },
 GHC.Event.Manager.unregisterFd_entry() //  [R2, R3]
         { info_tbl: [(caHTJ,
                       label: GHC.Event.Manager.unregisterFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHTJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Manager.unregisterFd1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.172035088 UTC

[section ""data" . GHC.Event.Manager.EventManager_closure" {
     GHC.Event.Manager.EventManager_closure:
         const GHC.Event.Manager.EventManager_info;
 },
 GHC.Event.Manager.EventManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHTR: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Manager.EventManager_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 72, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.EventManager_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caHTW,
                       label: GHC.Event.Manager.EventManager_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, False, True, False, False, False,
                                                    True, True, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHTW: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caHU0; else goto caHTZ;
       caHU0: // global
           HpAlloc = 112;
           R1 = GHC.Event.Manager.EventManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 112, res: 0, upd: 8;
       caHTZ: // global
           I64[Hp - 104] = GHC.Event.Manager.EventManager_con_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 56];
           I64[Hp - 24] = R5;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           R1 = Hp - 103;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.177868779 UTC

[section ""data" . GHC.Event.Manager.Created_closure" {
     GHC.Event.Manager.Created_closure:
         const GHC.Event.Manager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.179589188 UTC

[section ""data" . GHC.Event.Manager.Running_closure" {
     GHC.Event.Manager.Running_closure:
         const GHC.Event.Manager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.181883025 UTC

[section ""data" . GHC.Event.Manager.Dying_closure" {
     GHC.Event.Manager.Dying_closure:
         const GHC.Event.Manager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.18347958 UTC

[section ""data" . GHC.Event.Manager.Releasing_closure" {
     GHC.Event.Manager.Releasing_closure:
         const GHC.Event.Manager.Releasing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.18509927 UTC

[section ""data" . GHC.Event.Manager.Finished_closure" {
     GHC.Event.Manager.Finished_closure:
         const GHC.Event.Manager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.187411136 UTC

[section ""data" . GHC.Event.Manager.FdKey_closure" {
     GHC.Event.Manager.FdKey_closure:
         const GHC.Event.Manager.FdKey_info;
 },
 GHC.Event.Manager.FdKey_entry() //  [R2, R3]
         { info_tbl: [(caHUr,
                       label: GHC.Event.Manager.FdKey_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHUr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caHUv; else goto caHUu;
       caHUv: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Manager.FdKey_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHUu: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.191549853 UTC

[section ""data" . GHC.Event.Manager.FdData_closure" {
     GHC.Event.Manager.FdData_closure:
         const GHC.Event.Manager.FdData_info;
 },
 GHC.Event.Manager.FdData_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHUD: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Manager.FdData_entry(R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Manager.FdData_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caHUI,
                       label: GHC.Event.Manager.FdData_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHUI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caHUM; else goto caHUL;
       caHUM: // global
           HpAlloc = 40;
           R1 = GHC.Event.Manager.FdData_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caHUL: // global
           I64[Hp - 32] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.196539174 UTC

[GHC.Event.Manager.EventManager_con_entry() //  [R1]
         { info_tbl: [(caHUV,
                       label: GHC.Event.Manager.EventManager_con_info
                       rep:HeapRep 9 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,69,118,101,110,116,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHUV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.200041327 UTC

[section ""relreadonly" . GHC.Event.Manager.State_closure_tbl" {
     GHC.Event.Manager.State_closure_tbl:
         const GHC.Event.Manager.Created_closure+1;
         const GHC.Event.Manager.Running_closure+2;
         const GHC.Event.Manager.Dying_closure+3;
         const GHC.Event.Manager.Releasing_closure+4;
         const GHC.Event.Manager.Finished_closure+5;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.201828533 UTC

[GHC.Event.Manager.Created_con_entry() //  [R1]
         { info_tbl: [(caHV3,
                       label: GHC.Event.Manager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHV3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.205039063 UTC

[GHC.Event.Manager.Running_con_entry() //  [R1]
         { info_tbl: [(caHVa,
                       label: GHC.Event.Manager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHVa: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.208284717 UTC

[GHC.Event.Manager.Dying_con_entry() //  [R1]
         { info_tbl: [(caHVh,
                       label: GHC.Event.Manager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHVh: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.212119908 UTC

[GHC.Event.Manager.Releasing_con_entry() //  [R1]
         { info_tbl: [(caHVo,
                       label: GHC.Event.Manager.Releasing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,82,101,108,101,97,115,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHVo: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.215452357 UTC

[GHC.Event.Manager.Finished_con_entry() //  [R1]
         { info_tbl: [(caHVv,
                       label: GHC.Event.Manager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHVv: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.218722561 UTC

[GHC.Event.Manager.FdKey_con_entry() //  [R1]
         { info_tbl: [(caHVC,
                       label: GHC.Event.Manager.FdKey_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,75,101,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHVC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.221877966 UTC

[GHC.Event.Manager.FdData_con_entry() //  [R1]
         { info_tbl: [(caHVJ,
                       label: GHC.Event.Manager.FdData_con_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,70,100,68,97,116,97]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHVJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:42.224912891 UTC

[section ""relreadonly" . SaFU9_srt" {
     SaFU9_srt:
         const GHC.Event.Manager.$w$cshowsPrec1_closure;
         const GHC.Event.Manager.$fShowState1_closure;
         const GHC.Event.Manager.$fShowState3_closure;
         const GHC.Event.Manager.$fShowState5_closure;
         const GHC.Event.Manager.$fShowState7_closure;
         const GHC.Event.Manager.$fShowState9_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Manager.$w$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshowsPrec_closure;
         const GHC.Event.Manager.$fShowFdKey_$cshow_closure;
         const GHC.Event.Manager.$fShowFdKey1_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.$fShowState_$cshow_closure;
         const GHC.Arr.$windexError_closure;
         const lvl2_raAu7_closure;
         const lvl3_raAu8_closure;
         const GHC.Event.Manager.callbackTableVar_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.Manager.release1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.Manager.shutdown1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const $wlvl_raAub_closure;
         const lvl7_raAud_closure;
         const GHC.Arr.arrEleBottom_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Manager.new3_closure;
         const GHC.Event.Manager.new1_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.closeFd_3_closure;
         const GHC.Event.Manager.eventsOf_closure;
         const GHC.Event.Manager.closeFd1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.Manager.loop5_closure;
         const GHC.Event.Manager.loop3_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Event.Manager.loop2_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Manager.closeFd_1_closure;
         const registerFd1_raAuk_closure;
         const lvl14_raAum_closure;
         const lvl15_raAun_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const GHC.Event.Manager.unregisterFd1_closure;
 }]

