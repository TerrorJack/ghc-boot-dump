
==================== Output Cmm ====================
2018-03-16 16:03:02.638206397 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:02.639498261 UTC

[section ""data" . GHC.Event.Array.$WAC_closure" {
     GHC.Event.Array.$WAC_closure:
         const GHC.Event.Array.$WAC_info;
 },
 GHC.Event.Array.$WAC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7X0v,
                       label: GHC.Event.Array.$WAC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X0v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7X0J; else goto c7X0K;
       c7X0J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$WAC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X0K: // global
           I64[Sp - 24] = block_c7X0s_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7X0R; else goto c7X0t;
       u7X0R: // global
           call _c7X0s(R1) args: 0, res: 0, upd: 0;
       c7X0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X0s() //  [R1]
         { info_tbl: [(c7X0s,
                       label: block_c7X0s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X0s: // global
           I64[Sp] = block_c7X0y_info;
           _s7WN9::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7WN9::P64;
           if (R1 & 7 != 0) goto u7X0Q; else goto c7X0z;
       u7X0Q: // global
           call _c7X0y(R1) args: 0, res: 0, upd: 0;
       c7X0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X0y() //  [R1]
         { info_tbl: [(c7X0y,
                       label: block_c7X0y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X0y: // global
           I64[Sp] = block_c7X0D_info;
           _s7WNb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7WNb::I64;
           if (R1 & 7 != 0) goto u7X0S; else goto c7X0E;
       u7X0S: // global
           call _c7X0D(R1) args: 0, res: 0, upd: 0;
       c7X0E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X0D() //  [R1]
         { info_tbl: [(c7X0D,
                       label: block_c7X0D_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X0D: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X0P; else goto c7X0O;
       c7X0P: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X0O: // global
           _s7WNd::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _s7WNd::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.64786138 UTC

[section ""data" . GHC.Event.Array.empty1_closure" {
     GHC.Event.Array.empty1_closure:
         const GHC.Event.Array.empty1_info;
 },
 GHC.Event.Array.empty1_entry() //  []
         { info_tbl: [(c7X15,
                       label: GHC.Event.Array.empty1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X15: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7X16; else goto c7X17;
       c7X16: // global
           R1 = GHC.Event.Array.empty1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7X17: // global
           I64[Sp - 8] = block_c7X0X_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X0X() //  [R1]
         { info_tbl: [(c7X0X,
                       label: block_c7X0X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X0X: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7X1a; else goto c7X19;
       c7X1a: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X19: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_c7X12_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X12() //  [R1]
         { info_tbl: [(c7X12,
                       label: block_c7X12_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X12: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7X1d; else goto c7X1c;
       c7X1d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X1c: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.649340521 UTC

[section ""data" . GHC.Event.Array.empty_closure" {
     GHC.Event.Array.empty_closure:
         const GHC.Event.Array.empty_info;
 },
 GHC.Event.Array.empty_entry() //  []
         { info_tbl: [(c7X1i,
                       label: GHC.Event.Array.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1i: // global
           call GHC.Event.Array.empty1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.650380823 UTC

[section ""data" . GHC.Event.Array.length1_closure" {
     GHC.Event.Array.length1_closure:
         const GHC.Event.Array.length1_info;
 },
 GHC.Event.Array.length1_entry() //  [R2]
         { info_tbl: [(c7X1s,
                       label: GHC.Event.Array.length1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7X1B; else goto c7X1C;
       c7X1B: // global
           R2 = R2;
           R1 = GHC.Event.Array.length1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7X1C: // global
           I64[Sp - 8] = block_c7X1p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X1I; else goto c7X1q;
       u7X1I: // global
           call _c7X1p(R1) args: 0, res: 0, upd: 0;
       c7X1q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X1p() //  [R1]
         { info_tbl: [(c7X1p,
                       label: block_c7X1p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1p: // global
           _s7WNv::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7X1v_info;
           R1 = _s7WNv::P64;
           if (R1 & 7 != 0) goto u7X1H; else goto c7X1w;
       u7X1H: // global
           call _c7X1v(R1) args: 0, res: 0, upd: 0;
       c7X1w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X1v() //  [R1]
         { info_tbl: [(c7X1v,
                       label: block_c7X1v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7X1G; else goto c7X1F;
       c7X1G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X1F: // global
           _s7WNy::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7WNy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.651755972 UTC

[section ""data" . GHC.Event.Array.length_closure" {
     GHC.Event.Array.length_closure:
         const GHC.Event.Array.length_info;
 },
 GHC.Event.Array.length_entry() //  [R2]
         { info_tbl: [(c7X1N,
                       label: GHC.Event.Array.length_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1N: // global
           R2 = R2;
           call GHC.Event.Array.length1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.652770835 UTC

[section ""data" . GHC.Event.Array.capacity1_closure" {
     GHC.Event.Array.capacity1_closure:
         const GHC.Event.Array.capacity1_info;
 },
 GHC.Event.Array.capacity1_entry() //  [R2]
         { info_tbl: [(c7X1X,
                       label: GHC.Event.Array.capacity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7X26; else goto c7X27;
       c7X26: // global
           R2 = R2;
           R1 = GHC.Event.Array.capacity1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7X27: // global
           I64[Sp - 8] = block_c7X1U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X2d; else goto c7X1V;
       u7X2d: // global
           call _c7X1U(R1) args: 0, res: 0, upd: 0;
       c7X1V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X1U() //  [R1]
         { info_tbl: [(c7X1U,
                       label: block_c7X1U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X1U: // global
           _s7WNH::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7X20_info;
           R1 = _s7WNH::P64;
           if (R1 & 7 != 0) goto u7X2c; else goto c7X21;
       u7X2c: // global
           call _c7X20(R1) args: 0, res: 0, upd: 0;
       c7X21: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X20() //  [R1]
         { info_tbl: [(c7X20,
                       label: block_c7X20_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X20: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7X2b; else goto c7X2a;
       c7X2b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X2a: // global
           _s7WNL::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7WNL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.654154327 UTC

[section ""data" . GHC.Event.Array.capacity_closure" {
     GHC.Event.Array.capacity_closure:
         const GHC.Event.Array.capacity_info;
 },
 GHC.Event.Array.capacity_entry() //  [R2]
         { info_tbl: [(c7X2i,
                       label: GHC.Event.Array.capacity_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X2i: // global
           R2 = R2;
           call GHC.Event.Array.capacity1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.65490686 UTC

[section ""cstring" . lvl_r7WM4_bytes" {
     lvl_r7WM4_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.655460761 UTC

[section ""cstring" . lvl1_r7WM5_bytes" {
     lvl1_r7WM5_bytes:
         I8[] [117,110,115,97,102,101,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.656022505 UTC

[section ""cstring" . lvl2_r7WM6_bytes" {
     lvl2_r7WM6_bytes:
         I8[] [58,32,98,111,117,110,100,115,32,101,114,114,111,114,44,32,105,110,100,101,120,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.656572255 UTC

[section ""cstring" . lvl3_r7WM7_bytes" {
     lvl3_r7WM7_bytes:
         I8[] [44,32,99,97,112,97,99,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.658345956 UTC

[section ""data" . GHC.Event.Array.$wlvl1_closure" {
     GHC.Event.Array.$wlvl1_closure:
         const GHC.Event.Array.$wlvl1_info;
         const 0;
 },
 sat_s7WNW_entry() //  [R1]
         { info_tbl: [(c7X2O,
                       label: sat_s7WNW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X2O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7X2P; else goto c7X2Q;
       c7X2P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X2Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7X2L_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7X2L() //  [R1, R2]
         { info_tbl: [(c7X2L,
                       label: block_c7X2L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X2L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7X2T; else goto c7X2S;
       c7X2T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7X2S: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WNX_entry() //  [R1]
         { info_tbl: [(c7X2U,
                       label: sat_s7WNX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X2U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7X2Y; else goto c7X2X;
       c7X2Y: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X2X: // global
           _s7WNN::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7WNW_info;
           I64[Hp] = _s7WNN::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7WNY_entry() //  [R1]
         { info_tbl: [(c7X30,
                       label: sat_s7WNY_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X30: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7X31; else goto c7X32;
       c7X31: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7X2B_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7X2B() //  [R1, R2]
         { info_tbl: [(c7X2B,
                       label: block_c7X2B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X2B: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7X35; else goto c7X34;
       c7X35: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7X34: // global
           I64[Hp - 40] = sat_s7WNX_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WNZ_entry() //  [R1]
         { info_tbl: [(c7X36,
                       label: sat_s7WNZ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X36: // global
           _s7WNZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7X37; else goto c7X38;
       c7X38: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X3a; else goto c7X39;
       c7X3a: // global
           HpAlloc = 32;
           goto c7X37;
       c7X37: // global
           R1 = _s7WNZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X39: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WNZ::P64;
           _s7WNN::I64 = I64[_s7WNZ::P64 + 16];
           _s7WNO::I64 = I64[_s7WNZ::P64 + 24];
           I64[Hp - 24] = sat_s7WNY_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WO0_entry() //  [R1]
         { info_tbl: [(c7X3b,
                       label: sat_s7WO0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3b: // global
           _s7WO0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7X3c; else goto c7X3d;
       c7X3d: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X3f; else goto c7X3e;
       c7X3f: // global
           HpAlloc = 32;
           goto c7X3c;
       c7X3c: // global
           R1 = _s7WO0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X3e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WO0::P64;
           _s7WNN::I64 = I64[_s7WO0::P64 + 16];
           _s7WNO::I64 = I64[_s7WO0::P64 + 24];
           I64[Hp - 24] = sat_s7WNZ_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           R3 = Hp - 24;
           R2 = lvl1_r7WM5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl1_entry() //  [R2, R3]
         { info_tbl: [(c7X3i,
                       label: GHC.Event.Array.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3i: // global
           _s7WNO::I64 = R3;
           _s7WNN::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7X3j; else goto c7X3k;
       c7X3k: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X3m; else goto c7X3l;
       c7X3m: // global
           HpAlloc = 32;
           goto c7X3j;
       c7X3j: // global
           R3 = _s7WNO::I64;
           R2 = _s7WNN::I64;
           R1 = GHC.Event.Array.$wlvl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X3l: // global
           I64[Hp - 24] = sat_s7WO0_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           I64[Sp - 8] = block_c7X3g_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7X3g() //  [R1]
         { info_tbl: [(c7X3g,
                       label: block_c7X3g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3g: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.662189118 UTC

[section ""data" . GHC.Event.Array.$wunsafeRead_closure" {
     GHC.Event.Array.$wunsafeRead_closure:
         const GHC.Event.Array.$wunsafeRead_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7X3y,
                       label: GHC.Event.Array.$wunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7X3C; else goto c7X3D;
       c7X3C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X3D: // global
           I64[Sp - 24] = block_c7X3v_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7X45; else goto c7X3w;
       u7X45: // global
           call _c7X3v(R1) args: 0, res: 0, upd: 0;
       c7X3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X3v() //  [R1]
         { info_tbl: [(c7X3v,
                       label: block_c7X3v_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3v: // global
           I64[Sp - 8] = block_c7X3B_info;
           _s7WOc::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WOc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X44; else goto c7X3F;
       u7X44: // global
           call _c7X3B(R1) args: 0, res: 0, upd: 0;
       c7X3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X3B() //  [R1]
         { info_tbl: [(c7X3B,
                       label: block_c7X3B_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X3L; else goto c7X3K;
       c7X3L: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X3K: // global
           _s7WO4::I64 = I64[Sp + 24];
           _s7WOc::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7WO4::I64, 0)) goto c7X42; else goto c7X41;
       c7X41: // global
           if (%MO_S_Ge_W64(_s7WO4::I64,
                            _s7WOc::I64)) goto c7X42; else goto c7X3W;
       c7X42: // global
           Hp = Hp - 32;
           R3 = _s7WO4::I64;
           R2 = _s7WOc::I64;
           Sp = Sp + 32;
           call GHC.Event.Array.$wlvl1_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7X3W: // global
           _s7WOf::P64 = P64[R1 + 7];
           _s7WOe::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WO4::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WOe::I64;
           _s7WO2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7X3U_info;
           R2 = _s7WO2::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = Hp - 23;
           P64[Sp + 24] = _s7WOf::P64;
           Sp = Sp - 8;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c7X3U() //  [R1]
         { info_tbl: [(c7X3U,
                       label: block_c7X3U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X3U: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.664315624 UTC

[section ""data" . GHC.Event.Array.unsafeRead1_closure" {
     GHC.Event.Array.unsafeRead1_closure:
         const GHC.Event.Array.unsafeRead1_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7X4d,
                       label: GHC.Event.Array.unsafeRead1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X4d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7X4h; else goto c7X4i;
       c7X4h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeRead1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X4i: // global
           I64[Sp - 24] = block_c7X4a_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7X4q; else goto c7X4b;
       u7X4q: // global
           call _c7X4a(R1) args: 0, res: 0, upd: 0;
       c7X4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X4a() //  [R1]
         { info_tbl: [(c7X4a,
                       label: block_c7X4a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X4a: // global
           I64[Sp] = block_c7X4g_info;
           _s7WOv::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WOv::P64;
           if (R1 & 7 != 0) goto u7X4p; else goto c7X4k;
       u7X4p: // global
           call _c7X4g(R1) args: 0, res: 0, upd: 0;
       c7X4k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X4g() //  [R1]
         { info_tbl: [(c7X4g,
                       label: block_c7X4g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X4g: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wunsafeRead_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.665770356 UTC

[section ""data" . GHC.Event.Array.unsafeRead_closure" {
     GHC.Event.Array.unsafeRead_closure:
         const GHC.Event.Array.unsafeRead_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7X4v,
                       label: GHC.Event.Array.unsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X4v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeRead1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.666502231 UTC

[section ""cstring" . lvl4_r7WM8_bytes" {
     lvl4_r7WM8_bytes:
         I8[] [117,110,115,97,102,101,87,114,105,116,101,39]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.668201081 UTC

[section ""data" . GHC.Event.Array.$wlvl_closure" {
     GHC.Event.Array.$wlvl_closure:
         const GHC.Event.Array.$wlvl_info;
         const 0;
 },
 sat_s7WOH_entry() //  [R1]
         { info_tbl: [(c7X51,
                       label: sat_s7WOH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X51: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7X52; else goto c7X53;
       c7X52: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X53: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7X4Y_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7X4Y() //  [R1, R2]
         { info_tbl: [(c7X4Y,
                       label: block_c7X4Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X4Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7X56; else goto c7X55;
       c7X56: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7X55: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOI_entry() //  [R1]
         { info_tbl: [(c7X57,
                       label: sat_s7WOI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X57: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7X5b; else goto c7X5a;
       c7X5b: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X5a: // global
           _s7WOy::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7WOH_info;
           I64[Hp] = _s7WOy::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7WOJ_entry() //  [R1]
         { info_tbl: [(c7X5d,
                       label: sat_s7WOJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5d: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7X5e; else goto c7X5f;
       c7X5e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X5f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7X4O_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7X4O() //  [R1, R2]
         { info_tbl: [(c7X4O,
                       label: block_c7X4O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X4O: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7X5i; else goto c7X5h;
       c7X5i: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7X5h: // global
           I64[Hp - 40] = sat_s7WOI_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOK_entry() //  [R1]
         { info_tbl: [(c7X5j,
                       label: sat_s7WOK_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5j: // global
           _s7WOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7X5k; else goto c7X5l;
       c7X5l: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X5n; else goto c7X5m;
       c7X5n: // global
           HpAlloc = 32;
           goto c7X5k;
       c7X5k: // global
           R1 = _s7WOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X5m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WOK::P64;
           _s7WOy::I64 = I64[_s7WOK::P64 + 16];
           _s7WOz::I64 = I64[_s7WOK::P64 + 24];
           I64[Hp - 24] = sat_s7WOJ_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOL_entry() //  [R1]
         { info_tbl: [(c7X5o,
                       label: sat_s7WOL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5o: // global
           _s7WOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7X5p; else goto c7X5q;
       c7X5q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X5s; else goto c7X5r;
       c7X5s: // global
           HpAlloc = 32;
           goto c7X5p;
       c7X5p: // global
           R1 = _s7WOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X5r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WOL::P64;
           _s7WOy::I64 = I64[_s7WOL::P64 + 16];
           _s7WOz::I64 = I64[_s7WOL::P64 + 24];
           I64[Hp - 24] = sat_s7WOK_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           R3 = Hp - 24;
           R2 = lvl4_r7WM8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(c7X5v,
                       label: GHC.Event.Array.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5v: // global
           _s7WOz::I64 = R3;
           _s7WOy::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7X5w; else goto c7X5x;
       c7X5x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X5z; else goto c7X5y;
       c7X5z: // global
           HpAlloc = 32;
           goto c7X5w;
       c7X5w: // global
           R3 = _s7WOz::I64;
           R2 = _s7WOy::I64;
           R1 = GHC.Event.Array.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X5y: // global
           I64[Hp - 24] = sat_s7WOL_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           I64[Sp - 8] = block_c7X5t_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7X5t() //  [R1]
         { info_tbl: [(c7X5t,
                       label: block_c7X5t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5t: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.671946179 UTC

[section ""data" . GHC.Event.Array.$wunsafeWrite'_closure" {
     GHC.Event.Array.$wunsafeWrite'_closure:
         const GHC.Event.Array.$wunsafeWrite'_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeWrite'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5E: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.$wunsafeWrite'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7X5N,
                       label: GHC.Event.Array.$wunsafeWrite'_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5N: // global
           _s7WOR::I64 = R6;
           _s7WOQ::I64 = R5;
           _s7WOP::P64 = R4;
           _s7WOO::I64 = R3;
           _s7WON::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c7X5O; else goto c7X5P;
       c7X5P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X5R; else goto c7X5Q;
       c7X5R: // global
           HpAlloc = 32;
           goto c7X5O;
       c7X5O: // global
           R1 = GHC.Event.Array.$wunsafeWrite'_closure;
           P64[Sp - 40] = _s7WON::P64;
           I64[Sp - 32] = _s7WOO::I64;
           P64[Sp - 24] = _s7WOP::P64;
           I64[Sp - 16] = _s7WOQ::I64;
           I64[Sp - 8] = _s7WOR::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7X5Q: // global
           if (%MO_S_Lt_W64(_s7WOR::I64, 0)) goto c7X5M; else goto c7X5L;
       c7X5L: // global
           if (%MO_S_Ge_W64(_s7WOR::I64,
                            _s7WOQ::I64)) goto c7X5M; else goto c7X60;
       c7X5M: // global
           Hp = Hp - 32;
           R3 = _s7WOR::I64;
           R2 = _s7WOQ::I64;
           Sp = Sp + 8;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7X60: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WOR::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WOO::I64;
           I64[Sp - 8] = block_c7X5Y_info;
           R2 = _s7WON::P64;
           I64[Sp - 40] = stg_ap_pppv_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           P64[Sp - 16] = P64[Sp];
           P64[Sp] = _s7WOP::P64;
           Sp = Sp - 40;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c7X5Y() //  [R1]
         { info_tbl: [(c7X5Y,
                       label: block_c7X5Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X5Y: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.675668919 UTC

[section ""data" . GHC.Event.Array.unsafeWrite2_closure" {
     GHC.Event.Array.unsafeWrite2_closure:
         const GHC.Event.Array.unsafeWrite2_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7X6c,
                       label: GHC.Event.Array.unsafeWrite2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6c: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7X6l; else goto c7X6m;
       c7X6l: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X6m: // global
           I64[Sp - 32] = block_c7X69_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7X6v; else goto c7X6a;
       u7X6v: // global
           call _c7X69(R1) args: 0, res: 0, upd: 0;
       c7X6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X69() //  [R1]
         { info_tbl: [(c7X69,
                       label: block_c7X69_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X69: // global
           I64[Sp - 8] = block_c7X6f_info;
           _s7WPc::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WPc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X6u; else goto c7X6g;
       u7X6u: // global
           call _c7X6f(R1) args: 0, res: 0, upd: 0;
       c7X6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X6f() //  [R1]
         { info_tbl: [(c7X6f,
                       label: block_c7X6f_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6f: // global
           I64[Sp - 8] = block_c7X6k_info;
           _s7WPf::P64 = P64[R1 + 7];
           _s7WPe::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WPf::P64;
           I64[Sp + 24] = _s7WPe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X6w; else goto c7X6p;
       u7X6w: // global
           call _c7X6k(R1) args: 0, res: 0, upd: 0;
       c7X6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X6k() //  [R1]
         { info_tbl: [(c7X6k,
                       label: block_c7X6k_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6k: // global
           R6 = I64[R1 + 7];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 32];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.677739121 UTC

[section ""data" . GHC.Event.Array.unsafeWrite1_closure" {
     GHC.Event.Array.unsafeWrite1_closure:
         const GHC.Event.Array.unsafeWrite1_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7X6E,
                       label: GHC.Event.Array.unsafeWrite1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7X6F; else goto c7X6G;
       c7X6F: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X6G: // global
           I64[Sp - 32] = block_c7X6B_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7X6K; else goto c7X6C;
       u7X6K: // global
           call _c7X6B(R1) args: 0, res: 0, upd: 0;
       c7X6C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X6B() //  [R1]
         { info_tbl: [(c7X6B,
                       label: block_c7X6B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6B: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[P64[R1 + 7] + 8];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Event.Array.unsafeWrite2_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.679074178 UTC

[section ""data" . GHC.Event.Array.unsafeWrite_closure" {
     GHC.Event.Array.unsafeWrite_closure:
         const GHC.Event.Array.unsafeWrite_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7X6P,
                       label: GHC.Event.Array.unsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6P: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeWrite1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.680890171 UTC

[section ""data" . GHC.Event.Array.$wunsafeLoad_closure" {
     GHC.Event.Array.$wunsafeLoad_closure:
         const GHC.Event.Array.$wunsafeLoad_info;
 },
 sat_s7WPN_entry() //  [R1]
         { info_tbl: [(c7X7i,
                       label: sat_s7WPN_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X7i: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7X7m; else goto c7X7n;
       c7X7m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X7n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7X7f_info;
           _s7WPC::P64 = P64[R1 + 16];
           _s7WPB::I64 = I64[R1 + 32];
           R1 = P64[R1 + 24];
           I64[Sp - 32] = _s7WPB::I64;
           P64[Sp - 24] = _s7WPC::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7X7r; else goto c7X7g;
       u7X7r: // global
           call _c7X7f(R1) args: 0, res: 0, upd: 0;
       c7X7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7X7f() //  [R1]
         { info_tbl: [(c7X7f,
                       label: block_c7X7f_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X7f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X7q; else goto c7X7p;
       c7X7q: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7X7p: // global
           _s7WPM::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = _s7WPM::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wunsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7X7s,
                       label: GHC.Event.Array.$wunsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X7s: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7X7t; else goto c7X7u;
       c7X7t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeLoad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X7u: // global
           I64[Sp - 24] = block_c7X6W_info;
           R1 = P64[R2 + 8];
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7X7G; else goto c7X6X;
       u7X7G: // global
           call _c7X6W(R1) args: 0, res: 0, upd: 0;
       c7X6X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X6W() //  [R1]
         { info_tbl: [(c7X6W,
                       label: block_c7X6W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X6W: // global
           I64[Sp - 8] = block_c7X71_info;
           _s7WPB::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WPB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X7F; else goto c7X72;
       u7X7F: // global
           call _c7X71(R1) args: 0, res: 0, upd: 0;
       c7X72: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X71() //  [R1]
         { info_tbl: [(c7X71,
                       label: block_c7X71_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X71: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X7y; else goto c7X7x;
       c7X7y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X7x: // global
           _s7WPE::P64 = P64[R1 + 7];
           _s7WPD::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WPD::I64;
           I64[Sp - 8] = block_c7X78_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           _s7WPC::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WPE::P64;
           P64[Sp + 24] = _s7WPC::P64;
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X78() //  [R1]
         { info_tbl: [(c7X78,
                       label: block_c7X78_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X78: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7X7B; else goto c7X7A;
       c7X7B: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X7A: // global
           _s7WPs::P64 = P64[Sp + 24];
           _s7WPB::I64 = I64[Sp + 16];
           _s7WPC::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = sat_s7WPN_info;
           P64[Hp - 16] = _s7WPC::P64;
           P64[Hp - 8] = R1;
           I64[Hp] = _s7WPB::I64;
           call MO_WriteBarrier();
           P64[_s7WPs::P64 + 8] = Hp - 32;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WPs::P64);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.683841629 UTC

[section ""data" . GHC.Event.Array.unsafeLoad1_closure" {
     GHC.Event.Array.unsafeLoad1_closure:
         const GHC.Event.Array.unsafeLoad1_info;
 },
 GHC.Event.Array.unsafeLoad1_entry() //  [R2, R3]
         { info_tbl: [(c7X7O,
                       label: GHC.Event.Array.unsafeLoad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X7O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7X7P; else goto c7X7Q;
       c7X7P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeLoad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X7Q: // global
           I64[Sp - 16] = block_c7X7L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7X7U; else goto c7X7M;
       u7X7U: // global
           call _c7X7L(R1) args: 0, res: 0, upd: 0;
       c7X7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X7L() //  [R1]
         { info_tbl: [(c7X7L,
                       label: block_c7X7L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X7L: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Event.Array.$wunsafeLoad_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.685068402 UTC

[section ""data" . GHC.Event.Array.unsafeLoad_closure" {
     GHC.Event.Array.unsafeLoad_closure:
         const GHC.Event.Array.unsafeLoad_info;
 },
 GHC.Event.Array.unsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7X7Z,
                       label: GHC.Event.Array.unsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X7Z: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeLoad1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.686438916 UTC

[section ""data" . GHC.Event.Array.useAsPtr1_closure" {
     GHC.Event.Array.useAsPtr1_closure:
         const GHC.Event.Array.useAsPtr1_info;
 },
 GHC.Event.Array.useAsPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7X89,
                       label: GHC.Event.Array.useAsPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X89: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7X8i; else goto c7X8j;
       c7X8i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.useAsPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7X8j: // global
           I64[Sp - 16] = block_c7X86_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7X8A; else goto c7X87;
       u7X8A: // global
           call _c7X86(R1) args: 0, res: 0, upd: 0;
       c7X87: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X86() //  [R1]
         { info_tbl: [(c7X86,
                       label: block_c7X86_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X86: // global
           _s7WQ1::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7X8c_info;
           R1 = _s7WQ1::P64;
           if (R1 & 7 != 0) goto u7X8z; else goto c7X8d;
       u7X8z: // global
           call _c7X8c(R1) args: 0, res: 0, upd: 0;
       c7X8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X8c() //  [R1]
         { info_tbl: [(c7X8c,
                       label: block_c7X8c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X8c: // global
           I64[Sp - 8] = block_c7X8h_info;
           _s7WQ4::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WQ4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X8B; else goto c7X8m;
       u7X8B: // global
           call _c7X8h(R1) args: 0, res: 0, upd: 0;
       c7X8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X8h() //  [R1]
         { info_tbl: [(c7X8h,
                       label: block_c7X8h_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X8h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7X8v; else goto c7X8u;
       c7X8v: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X8u: // global
           _s7WQ8::P64 = P64[R1 + 7];
           _s7WQ7::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WQ7::I64;
           I64[Sp + 8] = block_c7X8s_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WQ8::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X8s() //  [R1]
         { info_tbl: [(c7X8s,
                       label: block_c7X8s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X8s: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.688403213 UTC

[section ""data" . GHC.Event.Array.useAsPtr_closure" {
     GHC.Event.Array.useAsPtr_closure:
         const GHC.Event.Array.useAsPtr_info;
 },
 GHC.Event.Array.useAsPtr_entry() //  [R2, R3]
         { info_tbl: [(c7X8G,
                       label: GHC.Event.Array.useAsPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X8G: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.useAsPtr1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.68954307 UTC

[section ""data" . GHC.Event.Array.clear2_closure" {
     GHC.Event.Array.clear2_closure:
         const GHC.Event.Array.clear2_info;
 },
 GHC.Event.Array.clear2_entry() //  [R2]
         { info_tbl: [(c7X8Q,
                       label: GHC.Event.Array.clear2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X8Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7X8V; else goto c7X8W;
       c7X8V: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7X8W: // global
           I64[Sp - 8] = block_c7X8N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X90; else goto c7X8O;
       u7X90: // global
           call _c7X8N(R1) args: 0, res: 0, upd: 0;
       c7X8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X8N() //  [R1]
         { info_tbl: [(c7X8N,
                       label: block_c7X8N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X8N: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7X8Z; else goto c7X8Y;
       c7X8Z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7X8Y: // global
           _s7WQh::P64 = P64[R1 + 7];
           _s7WQj::I64 = I64[R1 + 23];
           I64[Hp - 48] = GHC.Event.Array.AC_con_info;
           P64[Hp - 40] = _s7WQh::P64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = _s7WQj::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.691137498 UTC

[section ""data" . GHC.Event.Array.clear1_closure" {
     GHC.Event.Array.clear1_closure:
         const GHC.Event.Array.clear1_info;
 },
 GHC.Event.Array.clear1_entry() //  [R2]
         { info_tbl: [(c7X98,
                       label: GHC.Event.Array.clear1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X98: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7X9e; else goto c7X9f;
       c7X9e: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7X9f: // global
           I64[Sp - 8] = block_c7X95_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7X9n; else goto c7X96;
       u7X9n: // global
           call _c7X95(R1) args: 0, res: 0, upd: 0;
       c7X96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X95() //  [R1]
         { info_tbl: [(c7X95,
                       label: block_c7X95_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X95: // global
           I64[Sp] = block_c7X9b_info;
           R2 = GHC.Event.Array.clear2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X9b() //  [R1]
         { info_tbl: [(c7X9b,
                       label: block_c7X9b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X9b: // global
           I64[Sp] = block_c7X9d_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7X9o; else goto c7X9i;
       u7X9o: // global
           call _c7X9d() args: 0, res: 0, upd: 0;
       c7X9i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7X9d() //  []
         { info_tbl: [(c7X9d,
                       label: block_c7X9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X9d: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.692612598 UTC

[section ""data" . GHC.Event.Array.clear_closure" {
     GHC.Event.Array.clear_closure:
         const GHC.Event.Array.clear_info;
 },
 GHC.Event.Array.clear_entry() //  [R2]
         { info_tbl: [(c7X9t,
                       label: GHC.Event.Array.clear_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X9t: // global
           R2 = R2;
           call GHC.Event.Array.clear1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.693423032 UTC

[section ""cstring" . lvl5_r7WM9_bytes" {
     lvl5_r7WM9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.694241318 UTC

[section ""data" . lvl6_r7WMa_closure" {
     lvl6_r7WMa_closure:
         const lvl6_r7WMa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r7WMa_entry() //  [R1]
         { info_tbl: [(c7X9C,
                       label: lvl6_r7WMa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X9C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7X9D; else goto c7X9E;
       c7X9D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X9E: // global
           (_c7X9z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7X9z::I64 == 0) goto c7X9B; else goto c7X9A;
       c7X9B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7X9A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7X9z::I64;
           R2 = lvl5_r7WM9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.695306621 UTC

[section ""cstring" . GHC.Event.Array.$trModule4_bytes" {
     GHC.Event.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.696070608 UTC

[section ""data" . lvl7_r7WMb_closure" {
     lvl7_r7WMb_closure:
         const lvl7_r7WMb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r7WMb_entry() //  [R1]
         { info_tbl: [(c7X9L,
                       label: lvl7_r7WMb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X9L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7X9M; else goto c7X9N;
       c7X9M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X9N: // global
           (_c7X9I::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7X9I::I64 == 0) goto c7X9K; else goto c7X9J;
       c7X9K: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7X9J: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7X9I::I64;
           R2 = GHC.Event.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.69695454 UTC

[section ""cstring" . GHC.Event.Array.$trModule2_bytes" {
     GHC.Event.Array.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.697671158 UTC

[section ""data" . lvl8_r7WMc_closure" {
     lvl8_r7WMc_closure:
         const lvl8_r7WMc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r7WMc_entry() //  [R1]
         { info_tbl: [(c7X9U,
                       label: lvl8_r7WMc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7X9U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7X9V; else goto c7X9W;
       c7X9V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7X9W: // global
           (_c7X9R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7X9R::I64 == 0) goto c7X9T; else goto c7X9S;
       c7X9T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7X9S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7X9R::I64;
           R2 = GHC.Event.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.698528939 UTC

[section ""cstring" . lvl9_r7WMd_bytes" {
     lvl9_r7WMd_bytes:
         I8[] [46,47,71,72,67,47,69,118,101,110,116,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.699296931 UTC

[section ""data" . lvl10_r7WMe_closure" {
     lvl10_r7WMe_closure:
         const lvl10_r7WMe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_r7WMe_entry() //  [R1]
         { info_tbl: [(c7Xa3,
                       label: lvl10_r7WMe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xa3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xa4; else goto c7Xa5;
       c7Xa4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xa5: // global
           (_c7Xa0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xa0::I64 == 0) goto c7Xa2; else goto c7Xa1;
       c7Xa2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xa1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xa0::I64;
           R2 = lvl9_r7WMd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.700189334 UTC

[section ""data" . lvl11_r7WMf_closure" {
     lvl11_r7WMf_closure:
         const GHC.Types.I#_con_info;
         const 179;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.700821223 UTC

[section ""data" . lvl12_r7WMg_closure" {
     lvl12_r7WMg_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.701470604 UTC

[section ""data" . lvl13_r7WMh_closure" {
     lvl13_r7WMh_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.70203417 UTC

[section ""data" . lvl14_r7WMi_closure" {
     lvl14_r7WMi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl11_r7WMf_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl11_r7WMf_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.703677646 UTC

[section ""data" . lvl15_r7WMj_closure" {
     lvl15_r7WMj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl14_r7WMi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.704409321 UTC

[section ""data" . GHC.Event.Array.forM_1_closure" {
     GHC.Event.Array.forM_1_closure:
         const GHC.Event.Array.forM_1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.forM_1_entry() //  [R1]
         { info_tbl: [(c7Xac,
                       label: GHC.Event.Array.forM_1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xac: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xad; else goto c7Xae;
       c7Xad: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xae: // global
           (_c7Xa9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xa9::I64 == 0) goto c7Xab; else goto c7Xaa;
       c7Xab: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xaa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xa9::I64;
           R2 = lvl15_r7WMj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.706698791 UTC

[section ""data" . GHC.Event.Array.forM__closure" {
     GHC.Event.Array.forM__closure:
         const GHC.Event.Array.forM__info;
         const 0;
 },
 size_s7WQu_entry() //  [R1]
         { info_tbl: [(c7Xan,
                       label: size_s7WQu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xan: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Xao; else goto c7Xap;
       c7Xao: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xap: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.forM_1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WR3_entry() //  [R1, R2, R3]
         { info_tbl: [(c7Xay,
                       label: sat_s7WR3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xay: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c7XaM; else goto c7XaN;
       c7XaM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XaN: // global
           I64[Sp - 32] = block_c7Xav_info;
           _s7WQt::P64 = P64[R1 + 5];
           _s7WQu::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s7WQt::P64;
           P64[Sp - 16] = _s7WQu::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Xbz; else goto c7Xaw;
       u7Xbz: // global
           call _c7Xav(R1) args: 0, res: 0, upd: 0;
       c7Xaw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xav() //  [R1]
         { info_tbl: [(c7Xav,
                       label: block_c7Xav_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xav: // global
           _s7WQC::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XaB_info;
           R1 = _s7WQC::P64;
           if (R1 & 7 != 0) goto u7Xby; else goto c7XaC;
       u7Xby: // global
           call _c7XaB(R1) args: 0, res: 0, upd: 0;
       c7XaC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XaB() //  [R1]
         { info_tbl: [(c7XaB,
                       label: block_c7XaB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XaB: // global
           I64[Sp - 8] = block_c7XaG_info;
           _s7WQF::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WQF::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XbA; else goto c7XaH;
       u7XbA: // global
           call _c7XaG(R1) args: 0, res: 0, upd: 0;
       c7XaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XaG() //  [R1]
         { info_tbl: [(c7XaG,
                       label: block_c7XaG_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XaG: // global
           I64[Sp - 8] = block_c7XaL_info;
           _s7WQJ::P64 = P64[R1 + 7];
           _s7WQI::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WQJ::P64;
           I64[Sp + 24] = _s7WQI::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XbB; else goto c7XaR;
       u7XbB: // global
           call _c7XaL(R1) args: 0, res: 0, upd: 0;
       c7XaR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XaL() //  [R1]
         { info_tbl: [(c7XaL,
                       label: block_c7XaL_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XaL: // global
           I64[Sp - 8] = 0;
           _s7WQL::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7WQL::I64;
           I64[Sp + 16] = _s7WQL::I64;
           Sp = Sp - 8;
           call _c7Xb8() args: 0, res: 0, upd: 0;
     }
 },
 _c7Xb8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xb8: // global
           Hp = Hp + 16;
           _s7WQR::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c7Xbc; else goto c7Xbb;
       c7Xbc: // global
           HpAlloc = 16;
           I64[Sp] = block_c7Xb7_info;
           R1 = _s7WQR::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Xbb: // global
           if (%MO_S_Lt_W64(_s7WQR::I64,
                            I64[Sp + 8])) goto c7Xbo; else goto c7Xbs;
       c7Xbo: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 40] + _s7WQR::I64;
           I64[Sp - 8] = block_c7Xbk_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 24;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7Xbs: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xb7() //  [R1]
         { info_tbl: [(c7Xb7,
                       label: block_c7Xb7_info
                       rep:StackRep [True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xb7: // global
           I64[Sp] = R1;
           call _c7Xb8() args: 0, res: 0, upd: 0;
     }
 },
 _c7Xbk() //  [R1]
         { info_tbl: [(c7Xbk,
                       label: block_c7Xbk_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xbk: // global
           I64[Sp] = block_c7Xbm_info;
           R2 = R1;
           R1 = P64[Sp + 56];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xbm() //  []
         { info_tbl: [(c7Xbm,
                       label: block_c7Xbm_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xbm: // global
           I64[Sp + 8] = I64[Sp + 8] + I64[Sp + 32];
           Sp = Sp + 8;
           call _c7Xb8() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.forM__entry() //  [R2]
         { info_tbl: [(c7XbF,
                       label: GHC.Event.Array.forM__info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XbF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XbJ; else goto c7XbI;
       c7XbJ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.forM__closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XbI: // global
           I64[Hp - 40] = size_s7WQu_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WR3_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.709885697 UTC

[section ""data" . lvl16_r7WMk_closure" {
     lvl16_r7WMk_closure:
         const GHC.Types.I#_con_info;
         const 194;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.710461564 UTC

[section ""data" . lvl17_r7WMl_closure" {
     lvl17_r7WMl_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.710979457 UTC

[section ""data" . lvl18_r7WMm_closure" {
     lvl18_r7WMm_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.711556453 UTC

[section ""data" . lvl19_r7WMn_closure" {
     lvl19_r7WMn_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl16_r7WMk_closure+1;
         const lvl17_r7WMl_closure+1;
         const lvl16_r7WMk_closure+1;
         const lvl18_r7WMm_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.712138633 UTC

[section ""data" . lvl20_r7WMo_closure" {
     lvl20_r7WMo_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl19_r7WMn_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.712900869 UTC

[section ""data" . GHC.Event.Array.loop1_closure" {
     GHC.Event.Array.loop1_closure:
         const GHC.Event.Array.loop1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.loop1_entry() //  [R1]
         { info_tbl: [(c7XbQ,
                       label: GHC.Event.Array.loop1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XbR; else goto c7XbS;
       c7XbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XbS: // global
           (_c7XbN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XbN::I64 == 0) goto c7XbP; else goto c7XbO;
       c7XbP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XbO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XbN::I64;
           R2 = lvl20_r7WMo_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.715414039 UTC

[section ""data" . GHC.Event.Array.loop_closure" {
     GHC.Event.Array.loop_closure:
         const GHC.Event.Array.loop_info;
         const 0;
 },
 size_s7WR5_entry() //  [R1]
         { info_tbl: [(c7Xc1,
                       label: size_s7WR5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xc1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Xc2; else goto c7Xc3;
       c7Xc2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xc3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.loop1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WRN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c7Xcc,
                       label: sat_s7WRN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xcc: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7Xcq; else goto c7Xcr;
       c7Xcq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Xcr: // global
           I64[Sp - 40] = block_c7Xc9_info;
           _s7WR4::P64 = P64[R1 + 4];
           _s7WR5::P64 = P64[R1 + 12];
           R1 = R2;
           P64[Sp - 32] = _s7WR4::P64;
           P64[Sp - 24] = _s7WR5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7XdC; else goto c7Xca;
       u7XdC: // global
           call _c7Xc9(R1) args: 0, res: 0, upd: 0;
       c7Xca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xc9() //  [R1]
         { info_tbl: [(c7Xc9,
                       label: block_c7Xc9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xc9: // global
           _s7WRe::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Xcf_info;
           R1 = _s7WRe::P64;
           if (R1 & 7 != 0) goto u7XdB; else goto c7Xcg;
       u7XdB: // global
           call _c7Xcf(R1) args: 0, res: 0, upd: 0;
       c7Xcg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xcf() //  [R1]
         { info_tbl: [(c7Xcf,
                       label: block_c7Xcf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xcf: // global
           I64[Sp - 8] = block_c7Xck_info;
           _s7WRh::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WRh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XdD; else goto c7Xcl;
       u7XdD: // global
           call _c7Xck(R1) args: 0, res: 0, upd: 0;
       c7Xcl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xck() //  [R1]
         { info_tbl: [(c7Xck,
                       label: block_c7Xck_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xck: // global
           I64[Sp - 8] = block_c7Xcp_info;
           _s7WRl::P64 = P64[R1 + 7];
           _s7WRk::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WRl::P64;
           I64[Sp + 24] = _s7WRk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XdE; else goto c7Xcv;
       u7XdE: // global
           call _c7Xcp(R1) args: 0, res: 0, upd: 0;
       c7Xcv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xcp() //  [R1]
         { info_tbl: [(c7Xcp,
                       label: block_c7Xcp_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xcp: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           _s7WRn::I64 = I64[R1 + 7];
           I64[Sp + 16] = I64[Sp + 16] * _s7WRn::I64;
           I64[Sp + 40] = _s7WRn::I64;
           Sp = Sp - 16;
           call _c7XcR() args: 0, res: 0, upd: 0;
     }
 },
 _c7XcR() //  []
         { info_tbl: [(c7XcR,
                       label: block_c7XcR_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XcR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XcW; else goto c7XcV;
       c7XcW: // global
           HpAlloc = 16;
           I64[Sp] = block_c7XcR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7XcV: // global
           _s7WRw::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_s7WRw::I64,
                            I64[Sp + 32])) goto c7Xda; else goto c7Xdu;
       c7Xda: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 48] + _s7WRw::I64;
           I64[Sp] = block_c7Xd4_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7Xdu: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xd4() //  [R1]
         { info_tbl: [(c7Xd4,
                       label: block_c7Xd4_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xd4: // global
           _s7WRx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Xd6_info;
           R3 = R1;
           R2 = _s7WRx::P64;
           R1 = P64[Sp + 64];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xd6() //  [R1]
         { info_tbl: [(c7Xd6,
                       label: block_c7Xd6_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xd6: // global
           I64[Sp] = block_c7Xd8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7XdG; else goto c7Xdd;
       u7XdG: // global
           call _c7Xd8(R1) args: 0, res: 0, upd: 0;
       c7Xdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xd8() //  [R1]
         { info_tbl: [(c7Xd8,
                       label: block_c7Xd8_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xd8: // global
           I64[Sp - 8] = block_c7Xdh_info;
           _s7WRJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s7WRJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XdH; else goto c7Xdj;
       u7XdH: // global
           call _c7Xdh(R1) args: 0, res: 0, upd: 0;
       c7Xdj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xdh() //  [R1]
         { info_tbl: [(c7Xdh,
                       label: block_c7Xdh_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xdh: // global
           if (R1 & 7 == 1) goto c7Xdp; else goto c7Xdt;
       c7Xdp: // global
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xdt: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           call _c7XcR() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.loop_entry() //  [R2]
         { info_tbl: [(c7XdJ,
                       label: GHC.Event.Array.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XdJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XdN; else goto c7XdM;
       c7XdN: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XdM: // global
           I64[Hp - 40] = size_s7WR5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WRN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 12;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.719045989 UTC

[section ""data" . GHC.Event.Array.$trModule3_closure" {
     GHC.Event.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.719646827 UTC

[section ""data" . GHC.Event.Array.$trModule1_closure" {
     GHC.Event.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.720218954 UTC

[section ""data" . GHC.Event.Array.$trModule_closure" {
     GHC.Event.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Array.$trModule3_closure+1;
         const GHC.Event.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.720834423 UTC

[section ""data" . $krep_r7WMp_closure" {
     $krep_r7WMp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.721698174 UTC

[section ""data" . $krep1_r7WMq_closure" {
     $krep1_r7WMq_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.722254201 UTC

[section ""data" . $krep2_r7WMr_closure" {
     $krep2_r7WMr_closure:
         const :_con_info;
         const $krep1_r7WMq_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.722866386 UTC

[section ""data" . $krep3_r7WMs_closure" {
     $krep3_r7WMs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.723457596 UTC

[section ""cstring" . GHC.Event.Array.$tcAC2_bytes" {
     GHC.Event.Array.$tcAC2_bytes:
         I8[] [65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.724050926 UTC

[section ""data" . GHC.Event.Array.$tcAC1_closure" {
     GHC.Event.Array.$tcAC1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcAC2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.724651017 UTC

[section ""data" . GHC.Event.Array.$tcAC_closure" {
     GHC.Event.Array.$tcAC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcAC1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14339520722473255067;
         const 15778732457674388659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.725325193 UTC

[section ""data" . $krep4_r7WMt_closure" {
     $krep4_r7WMt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcAC_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.725948001 UTC

[section ""data" . $krep5_r7WMu_closure" {
     $krep5_r7WMu_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep4_r7WMt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.726533864 UTC

[section ""data" . $krep6_r7WMv_closure" {
     $krep6_r7WMv_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep5_r7WMu_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.727177318 UTC

[section ""data" . GHC.Event.Array.$tc'AC1_closure" {
     GHC.Event.Array.$tc'AC1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7WMs_closure+1;
         const $krep6_r7WMv_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.727754801 UTC

[section ""cstring" . GHC.Event.Array.$tc'AC3_bytes" {
     GHC.Event.Array.$tc'AC3_bytes:
         I8[] [39,65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.72832516 UTC

[section ""data" . GHC.Event.Array.$tc'AC2_closure" {
     GHC.Event.Array.$tc'AC2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'AC3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.728886934 UTC

[section ""data" . GHC.Event.Array.$tc'AC_closure" {
     GHC.Event.Array.$tc'AC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'AC2_closure+1;
         const GHC.Event.Array.$tc'AC1_closure+4;
         const 954782197074941232;
         const 8411064637322477330;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.730445827 UTC

[section ""data" . $krep7_r7WMw_closure" {
     $krep7_r7WMw_closure:
         const :_con_info;
         const $krep4_r7WMt_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.731047974 UTC

[section ""data" . $krep8_r7WMx_closure" {
     $krep8_r7WMx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep7_r7WMw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.731632092 UTC

[section ""cstring" . GHC.Event.Array.$tcArray2_bytes" {
     GHC.Event.Array.$tcArray2_bytes:
         I8[] [65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.732184569 UTC

[section ""data" . GHC.Event.Array.$tcArray1_closure" {
     GHC.Event.Array.$tcArray1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcArray2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.732796638 UTC

[section ""data" . GHC.Event.Array.$tcArray_closure" {
     GHC.Event.Array.$tcArray_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcArray1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18201768782471713089;
         const 1209293416176401920;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.733457321 UTC

[section ""data" . $krep9_r7WMy_closure" {
     $krep9_r7WMy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.734025217 UTC

[section ""data" . GHC.Event.Array.$tc'Array1_closure" {
     GHC.Event.Array.$tc'Array1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r7WMx_closure+1;
         const $krep9_r7WMy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.734598923 UTC

[section ""cstring" . GHC.Event.Array.$tc'Array3_bytes" {
     GHC.Event.Array.$tc'Array3_bytes:
         I8[] [39,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.735133553 UTC

[section ""data" . GHC.Event.Array.$tc'Array2_closure" {
     GHC.Event.Array.$tc'Array2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'Array3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.735752552 UTC

[section ""data" . GHC.Event.Array.$tc'Array_closure" {
     GHC.Event.Array.$tc'Array_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'Array2_closure+1;
         const GHC.Event.Array.$tc'Array1_closure+4;
         const 1928439007980526225;
         const 8720085055779125030;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.736345155 UTC

[section ""data" . lvl21_r7WMz_closure" {
     lvl21_r7WMz_closure:
         const GHC.Types.I#_con_info;
         const 265;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.736941373 UTC

[section ""data" . lvl22_r7WMA_closure" {
     lvl22_r7WMA_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl21_r7WMz_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl21_r7WMz_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.737875017 UTC

[section ""data" . lvl23_r7WMB_closure" {
     lvl23_r7WMB_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl22_r7WMA_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.738799063 UTC

[section ""data" . GHC.Event.Array.removeAt2_closure" {
     GHC.Event.Array.removeAt2_closure:
         const GHC.Event.Array.removeAt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt2_entry() //  [R1]
         { info_tbl: [(c7XdU,
                       label: GHC.Event.Array.removeAt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XdU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XdV; else goto c7XdW;
       c7XdV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XdW: // global
           (_c7XdR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XdR::I64 == 0) goto c7XdT; else goto c7XdS;
       c7XdT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XdS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XdR::I64;
           R2 = lvl23_r7WMB_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.739786925 UTC

[section ""cstring" . lvl24_r7WMC_bytes" {
     lvl24_r7WMC_bytes:
         I8[] [114,101,109,111,118,101,65,116,58,32,105,110,118,97,108,105,100,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.740566311 UTC

[section ""data" . GHC.Event.Array.removeAt1_closure" {
     GHC.Event.Array.removeAt1_closure:
         const GHC.Event.Array.removeAt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt1_entry() //  [R1]
         { info_tbl: [(c7Xe5,
                       label: GHC.Event.Array.removeAt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xe5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Xe6; else goto c7Xe7;
       c7Xe6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xe7: // global
           (_c7Xe0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xe0::I64 == 0) goto c7Xe2; else goto c7Xe1;
       c7Xe2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xe1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xe0::I64;
           I64[Sp - 24] = block_c7Xe3_info;
           R2 = lvl24_r7WMC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Xe3() //  [R1]
         { info_tbl: [(c7Xe3,
                       label: block_c7Xe3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xe3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.743374543 UTC

[section ""data" . GHC.Event.Array.removeAt_closure" {
     GHC.Event.Array.removeAt_closure:
         const GHC.Event.Array.removeAt_info;
         const 0;
 },
 size_s7WRQ_entry() //  [R1]
         { info_tbl: [(c7Xej,
                       label: size_s7WRQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xej: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Xek; else goto c7Xel;
       c7Xek: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xel: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.removeAt2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WSA_entry() //  [R1, R2, R3]
         { info_tbl: [(c7Xeu,
                       label: sat_s7WSA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xeu: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c7XeI; else goto c7XeJ;
       c7XeI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XeJ: // global
           I64[Sp - 24] = block_c7Xer_info;
           _s7WRQ::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s7WRQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Xgb; else goto c7Xes;
       u7Xgb: // global
           call _c7Xer(R1) args: 0, res: 0, upd: 0;
       c7Xes: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xer() //  [R1]
         { info_tbl: [(c7Xer,
                       label: block_c7Xer_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xer: // global
           I64[Sp - 8] = block_c7Xex_info;
           _s7WRV::P64 = P64[R1 + 7];
           R1 = P64[_s7WRV::P64 + 8];
           P64[Sp] = _s7WRV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Xga; else goto c7Xey;
       u7Xga: // global
           call _c7Xex(R1) args: 0, res: 0, upd: 0;
       c7Xey: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xex() //  [R1]
         { info_tbl: [(c7Xex,
                       label: block_c7Xex_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xex: // global
           I64[Sp - 16] = block_c7XeC_info;
           _s7WS1::I64 = I64[R1 + 15];
           _s7WS2::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WS2::I64;
           I64[Sp] = _s7WS1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Xgc; else goto c7XeD;
       u7Xgc: // global
           call _c7XeC(R1) args: 0, res: 0, upd: 0;
       c7XeD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XeC() //  [R1]
         { info_tbl: [(c7XeC,
                       label: block_c7XeC_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XeC: // global
           I64[Sp - 16] = block_c7XeH_info;
           _s7WS3::P64 = R1;
           _s7WS5::P64 = P64[R1 + 7];
           _s7WS4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 40];
           P64[Sp - 8] = _s7WS5::P64;
           I64[Sp] = _s7WS4::I64;
           P64[Sp + 40] = _s7WS3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Xgd; else goto c7XeN;
       u7Xgd: // global
           call _c7XeH(R1) args: 0, res: 0, upd: 0;
       c7XeN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XeH() //  [R1]
         { info_tbl: [(c7XeH,
                       label: block_c7XeH_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XeH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XeT; else goto c7XeS;
       c7XeT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XeS: // global
           _s7WS7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s7WS7::I64, 0)) goto c7Xfu; else goto c7Xft;
       c7Xft: // global
           _s7WS1::I64 = I64[Sp + 32];
           if (%MO_S_Ge_W64(_s7WS7::I64,
                            _s7WS1::I64)) goto c7Xfu; else goto c7Xfq;
       c7Xfu: // global
           Hp = Hp - 32;
           R1 = GHC.Event.Array.removeAt1_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c7Xfq: // global
           _s7WRV::P64 = P64[Sp + 40];
           _s7WS2::I64 = I64[Sp + 24];
           _s7WS3::P64 = P64[Sp + 56];
           _s7WSa::I64 = _s7WS1::I64 - 1;
           if (%MO_S_Le_W64(_s7WSa::I64, 0)) goto c7Xf6; else goto c7Xfo;
       c7Xf6: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xfo: // global
           if (%MO_S_Ge_W64(_s7WS7::I64,
                            _s7WSa::I64)) goto c7Xfc; else goto c7Xfg;
       c7Xfc: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xfg: // global
           Hp = Hp - 32;
           I64[Sp] = block_c7Xff_info;
           R1 = P64[Sp + 48];
           I64[Sp + 32] = _s7WSa::I64;
           I64[Sp + 48] = _s7WS7::I64;
           if (R1 & 7 != 0) goto u7Xge; else goto c7Xfh;
       u7Xge: // global
           call _c7Xff(R1) args: 0, res: 0, upd: 0;
       c7Xfh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xff() //  [R1]
         { info_tbl: [(c7Xff,
                       label: block_c7Xff_info
                       rep:StackRep [False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xff: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Xfn; else goto c7Xfm;
       c7Xfn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xfm: // global
           _s7WRV::P64 = P64[Sp + 40];
           _s7WS2::I64 = I64[Sp + 24];
           _s7WS3::P64 = P64[Sp + 56];
           _s7WS4::I64 = I64[Sp + 16];
           _s7WS5::P64 = P64[Sp + 8];
           _s7WS7::I64 = I64[Sp + 48];
           _s7WSa::I64 = I64[Sp + 32];
           _s7WSi::I64 = I64[R1 + 7];
           (_s7WSu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7WS4::I64 + _s7WSi::I64 * _s7WS7::I64, _s7WS4::I64 + _s7WSi::I64 * (_s7WS7::I64 + 1), _s7WSi::I64 * (_s7WSa::I64 - _s7WS7::I64));
           call MO_Touch(_s7WS5::P64);
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.removeAt_entry() //  [R2]
         { info_tbl: [(c7Xgf,
                       label: GHC.Event.Array.removeAt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xgf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Xgj; else goto c7Xgi;
       c7Xgj: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Event.Array.removeAt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Xgi: // global
           I64[Hp - 32] = size_s7WRQ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7WSA_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.747059142 UTC

[section ""data" . lvl25_r7WMD_closure" {
     lvl25_r7WMD_closure:
         const GHC.Types.I#_con_info;
         const 211;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.747671456 UTC

[section ""data" . lvl26_r7WME_closure" {
     lvl26_r7WME_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.74819488 UTC

[section ""data" . lvl27_r7WMF_closure" {
     lvl27_r7WMF_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.748717726 UTC

[section ""data" . lvl28_r7WMG_closure" {
     lvl28_r7WMG_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl25_r7WMD_closure+1;
         const lvl26_r7WME_closure+1;
         const lvl25_r7WMD_closure+1;
         const lvl27_r7WMF_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.749432672 UTC

[section ""data" . lvl29_r7WMH_closure" {
     lvl29_r7WMH_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl28_r7WMG_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.750479369 UTC

[section ""data" . GHC.Event.Array.findIndex1_closure" {
     GHC.Event.Array.findIndex1_closure:
         const GHC.Event.Array.findIndex1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.findIndex1_entry() //  [R1]
         { info_tbl: [(c7Xgq,
                       label: GHC.Event.Array.findIndex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xgq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xgr; else goto c7Xgs;
       c7Xgr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xgs: // global
           (_c7Xgn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xgn::I64 == 0) goto c7Xgp; else goto c7Xgo;
       c7Xgp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xgo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xgn::I64;
           R2 = lvl29_r7WMH_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.753108584 UTC

[section ""data" . GHC.Event.Array.findIndex_closure" {
     GHC.Event.Array.findIndex_closure:
         const GHC.Event.Array.findIndex_info;
         const 0;
 },
 size_s7WSC_entry() //  [R1]
         { info_tbl: [(c7XgB,
                       label: size_s7WSC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XgB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XgC; else goto c7XgD;
       c7XgC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XgD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.findIndex1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WTj_entry() //  [R1, R2, R3]
         { info_tbl: [(c7XgM,
                       label: sat_s7WTj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XgM: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7Xh0; else goto c7Xh1;
       c7Xh0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Xh1: // global
           I64[Sp - 32] = block_c7XgJ_info;
           _s7WSB::P64 = P64[R1 + 5];
           _s7WSC::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s7WSB::P64;
           P64[Sp - 16] = _s7WSC::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Xib; else goto c7XgK;
       u7Xib: // global
           call _c7XgJ(R1) args: 0, res: 0, upd: 0;
       c7XgK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XgJ() //  [R1]
         { info_tbl: [(c7XgJ,
                       label: block_c7XgJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XgJ: // global
           _s7WSK::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XgP_info;
           R1 = _s7WSK::P64;
           if (R1 & 7 != 0) goto u7Xia; else goto c7XgQ;
       u7Xia: // global
           call _c7XgP(R1) args: 0, res: 0, upd: 0;
       c7XgQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XgP() //  [R1]
         { info_tbl: [(c7XgP,
                       label: block_c7XgP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XgP: // global
           I64[Sp - 8] = block_c7XgU_info;
           _s7WSN::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WSN::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Xic; else goto c7XgV;
       u7Xic: // global
           call _c7XgU(R1) args: 0, res: 0, upd: 0;
       c7XgV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XgU() //  [R1]
         { info_tbl: [(c7XgU,
                       label: block_c7XgU_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XgU: // global
           I64[Sp - 8] = block_c7XgZ_info;
           _s7WSR::P64 = P64[R1 + 7];
           _s7WSQ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WSR::P64;
           I64[Sp + 24] = _s7WSQ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Xid; else goto c7Xh5;
       u7Xid: // global
           call _c7XgZ(R1) args: 0, res: 0, upd: 0;
       c7Xh5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XgZ() //  [R1]
         { info_tbl: [(c7XgZ,
                       label: block_c7XgZ_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XgZ: // global
           I64[Sp - 16] = 0;
           I64[Sp - 8] = 0;
           _s7WST::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7WST::I64;
           I64[Sp + 16] = _s7WST::I64;
           Sp = Sp - 24;
           call _c7Xhx() args: 0, res: 0, upd: 0;
     }
 },
 _c7Xhx() //  []
         { info_tbl: [(c7Xhx,
                       label: block_c7Xhx_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xhx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XhC; else goto c7XhB;
       c7XhC: // global
           HpAlloc = 16;
           I64[Sp] = block_c7Xhx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7XhB: // global
           _s7WT7::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7WT7::I64,
                            I64[Sp + 24])) goto c7XhO; else goto c7Xi0;
       c7XhO: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 56] + _s7WT7::I64;
           I64[Sp] = block_c7XhK_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7Xi0: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 32]);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XhK() //  [R1]
         { info_tbl: [(c7XhK,
                       label: block_c7XhK_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XhK: // global
           I64[Sp - 8] = block_c7XhM_info;
           R2 = R1;
           _s7WTf::P64 = R1;
           R1 = P64[Sp + 64];
           P64[Sp] = _s7WTf::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XhM() //  [R1]
         { info_tbl: [(c7XhM,
                       label: block_c7XhM_info
                       rep:StackRep [False, True, True, True, False, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XhM: // global
           _s7WT8::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7XhV; else goto c7XhZ;
       c7XhV: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 48];
           I64[Sp + 24] = _s7WT8::I64 + 1;
           Sp = Sp + 8;
           call _c7Xhx() args: 0, res: 0, upd: 0;
       c7XhZ: // global
           P64[Sp + 64] = P64[Sp + 8];
           I64[Sp + 72] = _s7WT8::I64;
           Sp = Sp + 32;
           call _c7Xhf() args: 0, res: 0, upd: 0;
     }
 },
 _c7Xhf() //  []
         { info_tbl: [(c7Xhf,
                       label: block_c7Xhf_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xhf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Xho; else goto c7Xhn;
       c7Xho: // global
           HpAlloc = 56;
           I64[Sp] = block_c7Xhf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7Xhn: // global
           _s7WSW::I64 = I64[Sp + 40];
           _s7WSY::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7WSW::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s7WSY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.findIndex_entry() //  [R2]
         { info_tbl: [(c7Xih,
                       label: GHC.Event.Array.findIndex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xih: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Xil; else goto c7Xik;
       c7Xil: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.findIndex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Xik: // global
           I64[Hp - 40] = size_s7WSC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WTj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.757834035 UTC

[section ""data" . lvl30_r7WMI_closure" {
     lvl30_r7WMI_closure:
         const GHC.Types.I#_con_info;
         const 74;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.75845003 UTC

[section ""data" . lvl31_r7WMJ_closure" {
     lvl31_r7WMJ_closure:
         const GHC.Types.I#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.759002575 UTC

[section ""data" . lvl32_r7WMK_closure" {
     lvl32_r7WMK_closure:
         const GHC.Types.I#_con_info;
         const 55;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.759533976 UTC

[section ""data" . lvl33_r7WML_closure" {
     lvl33_r7WML_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl30_r7WMI_closure+1;
         const lvl31_r7WMJ_closure+1;
         const lvl30_r7WMI_closure+1;
         const lvl32_r7WMK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.760147944 UTC

[section ""data" . lvl34_r7WMM_closure" {
     lvl34_r7WMM_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl33_r7WML_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.761006083 UTC

[section ""data" . GHC.Event.Array.ensureCapacity2_closure" {
     GHC.Event.Array.ensureCapacity2_closure:
         const GHC.Event.Array.ensureCapacity2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.ensureCapacity2_entry() //  [R1]
         { info_tbl: [(c7Xis,
                       label: GHC.Event.Array.ensureCapacity2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xit; else goto c7Xiu;
       c7Xit: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xiu: // global
           (_c7Xip::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xip::I64 == 0) goto c7Xir; else goto c7Xiq;
       c7Xir: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xiq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xip::I64;
           R2 = lvl34_r7WMM_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.76362477 UTC

[section ""data" . GHC.Event.Array.$wensureCapacity_closure" {
     GHC.Event.Array.$wensureCapacity_closure:
         const GHC.Event.Array.$wensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.$wensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XiC,
                       label: GHC.Event.Array.$wensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XiC: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c7XiG; else goto c7XiH;
       c7XiG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wensureCapacity_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XiH: // global
           I64[Sp - 32] = block_c7Xiz_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Xl1; else goto c7XiA;
       u7Xl1: // global
           call _c7Xiz(R1) args: 0, res: 0, upd: 0;
       c7XiA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xiz() //  [R1]
         { info_tbl: [(c7Xiz,
                       label: block_c7Xiz_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xiz: // global
           I64[Sp - 16] = block_c7XiF_info;
           _s7WTt::I64 = I64[R1 + 15];
           _s7WTu::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WTu::I64;
           I64[Sp] = _s7WTt::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Xl0; else goto c7XiJ;
       u7Xl0: // global
           call _c7XiF(R1) args: 0, res: 0, upd: 0;
       c7XiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XiF() //  [R1]
         { info_tbl: [(c7XiF,
                       label: block_c7XiF_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XiF: // global
           if (%MO_S_Le_W64(I64[Sp + 40],
                            I64[Sp + 8])) goto c7XiR; else goto c7XiV;
       c7XiR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XiV: // global
           I64[Sp - 8] = block_c7XiU_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7XiU() //  [R1]
         { info_tbl: [(c7XiU,
                       label: block_c7XiU_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XiU: // global
           _s7WTA::I64 = I64[R1 + 7];
           _s7WTB::I64 = I64[Sp + 48] - 1;
           _s7WTC::I64 = _s7WTB::I64 | %MO_S_Shr_W64(_s7WTB::I64, 1);
           _s7WTE::I64 = _s7WTC::I64 | %MO_S_Shr_W64(_s7WTC::I64, 2);
           _s7WTG::I64 = _s7WTE::I64 | %MO_S_Shr_W64(_s7WTE::I64, 4);
           _s7WTI::I64 = _s7WTG::I64 | %MO_S_Shr_W64(_s7WTG::I64, 8);
           _s7WTK::I64 = _s7WTI::I64 | %MO_S_Shr_W64(_s7WTI::I64, 16);
           _s7WTM::I64 = _s7WTK::I64 | %MO_S_Shr_W64(_s7WTK::I64, 32) + 1;
           _s7WTP::I64 = _s7WTM::I64 * _s7WTA::I64;
           if (%MO_S_Ge_W64(_s7WTP::I64, 0)) goto c7XjO; else goto c7XkE;
       c7XjO: // global
           I64[Sp - 8] = block_c7XjM_info;
           R1 = _s7WTP::I64;
           I64[Sp] = _s7WTM::I64;
           I64[Sp + 48] = _s7WTA::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7XkE: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XjM() //  [R1]
         { info_tbl: [(c7XjM,
                       label: block_c7XjM_info
                       rep:StackRep [True, False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XjM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7XjS; else goto c7XjR;
       c7XjS: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XjR: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           _s7WTl::P64 = P64[Sp + 48];
           _s7WTt::I64 = I64[Sp + 32];
           _s7WTu::I64 = I64[Sp + 24];
           _s7WTw::I64 = I64[Sp + 40];
           _s7WTx::P64 = P64[Sp + 16];
           _s7WTM::I64 = I64[Sp + 8];
           _s7WTU::I64 = R1 + 16;
           _c7XjW::P64 = Hp - 61;
           if (_s7WTw::I64 == 0) goto c7XkD; else goto c7Xkv;
       c7XkD: // global
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7XkB; else goto c7XkC;
       c7XkC: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XjW::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xkv: // global
           if (%MO_S_Le_W64(_s7WTu::I64, 0)) goto c7Xka; else goto c7Xkt;
       c7Xka: // global
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7XkB; else goto c7Xk8;
       c7Xk8: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XjW::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xkt: // global
           (_s7WU8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WTU::I64, _s7WTw::I64, _s7WTu::I64 * I64[Sp + 56]);
           call MO_Touch(_c7XjW::P64);
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7XkB; else goto c7Xks;
       c7XkB: // global
           Hp = Hp - 56;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xks: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XjW::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.767175616 UTC

[section ""data" . GHC.Event.Array.ensureCapacity1_closure" {
     GHC.Event.Array.ensureCapacity1_closure:
         const GHC.Event.Array.ensureCapacity1_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Xl9,
                       label: GHC.Event.Array.ensureCapacity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xl9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Xld; else goto c7Xle;
       c7Xld: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.ensureCapacity1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Xle: // global
           I64[Sp - 24] = block_c7Xl6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Xlm; else goto c7Xl7;
       u7Xlm: // global
           call _c7Xl6(R1) args: 0, res: 0, upd: 0;
       c7Xl7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xl6() //  [R1]
         { info_tbl: [(c7Xl6,
                       label: block_c7Xl6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xl6: // global
           I64[Sp] = block_c7Xlc_info;
           _s7WUq::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WUq::P64;
           if (R1 & 7 != 0) goto u7Xll; else goto c7Xlg;
       u7Xll: // global
           call _c7Xlc(R1) args: 0, res: 0, upd: 0;
       c7Xlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xlc() //  [R1]
         { info_tbl: [(c7Xlc,
                       label: block_c7Xlc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xlc: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wensureCapacity_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.768546976 UTC

[section ""data" . GHC.Event.Array.ensureCapacity_closure" {
     GHC.Event.Array.ensureCapacity_closure:
         const GHC.Event.Array.ensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Xlr,
                       label: GHC.Event.Array.ensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xlr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.ensureCapacity1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.77144 UTC

[section ""data" . GHC.Event.Array.$wsnoc_closure" {
     GHC.Event.Array.$wsnoc_closure:
         const GHC.Event.Array.$wsnoc_info;
         const 0;
 },
 GHC.Event.Array.$wsnoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XlB,
                       label: GHC.Event.Array.$wsnoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XlB: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c7XlF; else goto c7XlG;
       c7XlF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wsnoc_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XlG: // global
           I64[Sp - 32] = block_c7Xly_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Xo6; else goto c7Xlz;
       u7Xo6: // global
           call _c7Xly(R1) args: 0, res: 0, upd: 0;
       c7Xlz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xly() //  [R1]
         { info_tbl: [(c7Xly,
                       label: block_c7Xly_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xly: // global
           I64[Sp - 16] = block_c7XlE_info;
           _s7WUC::I64 = I64[R1 + 15];
           _s7WUD::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WUD::I64;
           I64[Sp] = _s7WUC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Xo5; else goto c7XlI;
       u7Xo5: // global
           call _c7XlE(R1) args: 0, res: 0, upd: 0;
       c7XlI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XlE() //  [R1]
         { info_tbl: [(c7XlE,
                       label: block_c7XlE_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XlE: // global
           _s7WUt::P64 = P64[Sp + 24];
           _s7WUC::I64 = I64[Sp + 16];
           _s7WUD::I64 = I64[Sp + 8];
           _s7WUG::P64 = P64[R1 + 7];
           _s7WUF::I64 = I64[R1 + 15];
           _s7WUH::I64 = _s7WUC::I64 + 1;
           if (%MO_S_Le_W64(_s7WUH::I64,
                            _s7WUD::I64)) goto c7XlV; else goto c7Xm2;
       c7XlV: // global
           I64[Sp] = block_c7XlT_info;
           R6 = _s7WUC::I64;
           R5 = _s7WUD::I64;
           R4 = _s7WUG::P64;
           R3 = _s7WUF::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp + 24] = _s7WUH::I64;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7Xm2: // global
           I64[Sp - 24] = block_c7Xm1_info;
           R2 = _s7WUt::P64;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp - 16] = _s7WUG::P64;
           I64[Sp - 8] = _s7WUH::I64;
           I64[Sp] = _s7WUF::I64;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7XlT() //  [R1]
         { info_tbl: [(c7XlT,
                       label: block_c7XlT_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XlT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XlZ; else goto c7XlY;
       c7XlZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XlY: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xm1() //  [R1]
         { info_tbl: [(c7Xm1,
                       label: block_c7Xm1_info
                       rep:StackRep [False, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xm1: // global
           _s7WUP::I64 = I64[R1 + 7];
           _s7WUQ::I64 = I64[Sp + 16] - 1;
           _s7WUR::I64 = _s7WUQ::I64 | %MO_S_Shr_W64(_s7WUQ::I64, 1);
           _s7WUT::I64 = _s7WUR::I64 | %MO_S_Shr_W64(_s7WUR::I64, 2);
           _s7WUV::I64 = _s7WUT::I64 | %MO_S_Shr_W64(_s7WUT::I64, 4);
           _s7WUX::I64 = _s7WUV::I64 | %MO_S_Shr_W64(_s7WUV::I64, 8);
           _s7WUZ::I64 = _s7WUX::I64 | %MO_S_Shr_W64(_s7WUX::I64, 16);
           _s7WV1::I64 = _s7WUZ::I64 | %MO_S_Shr_W64(_s7WUZ::I64, 32) + 1;
           _s7WV4::I64 = _s7WV1::I64 * _s7WUP::I64;
           if (%MO_S_Ge_W64(_s7WV4::I64, 0)) goto c7XmV; else goto c7XnL;
       c7XmV: // global
           I64[Sp - 16] = block_c7XmT_info;
           R1 = _s7WV4::I64;
           I64[Sp - 8] = _s7WV1::I64;
           I64[Sp] = _s7WUP::I64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7XnL: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 72;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XmT() //  [R1]
         { info_tbl: [(c7XmT,
                       label: block_c7XmT_info
                       rep:StackRep [True, True, False, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XmT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XmZ; else goto c7XmY;
       c7XmZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XmY: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7WUt::P64 = P64[Sp + 64];
           _s7WUv::P64 = P64[Sp + 80];
           _s7WUC::I64 = I64[Sp + 56];
           _s7WUF::I64 = I64[Sp + 40];
           _s7WUG::P64 = P64[Sp + 24];
           _s7WV1::I64 = I64[Sp + 8];
           _s7WV9::I64 = R1 + 16;
           _c7Xn3::P64 = Hp - 5;
           if (_s7WUF::I64 == 0) goto c7XnG; else goto c7XnC;
       c7XnG: // global
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7XnF_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7Xn3::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7Xn3::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7XnC: // global
           _s7WUD::I64 = I64[Sp + 48];
           if (%MO_S_Le_W64(_s7WUD::I64, 0)) goto c7Xnd; else goto c7Xnw;
       c7Xnd: // global
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7Xnb_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7Xn3::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7Xn3::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7Xnw: // global
           (_s7WVp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WV9::I64, _s7WUF::I64, _s7WUD::I64 * I64[Sp + 16]);
           call MO_Touch(_c7Xn3::P64);
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7Xnv_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7Xn3::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7Xn3::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7XnF() //  [R1]
         { info_tbl: [(c7XnF,
                       label: block_c7XnF_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XnF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XnK; else goto c7XnJ;
       c7XnK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XnJ: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xnb() //  [R1]
         { info_tbl: [(c7Xnb,
                       label: block_c7Xnb_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xnb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Xnh; else goto c7Xng;
       c7Xnh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xng: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xnv() //  [R1]
         { info_tbl: [(c7Xnv,
                       label: block_c7Xnv_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xnv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XnA; else goto c7Xnz;
       c7XnA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xnz: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.776452686 UTC

[section ""data" . GHC.Event.Array.snoc1_closure" {
     GHC.Event.Array.snoc1_closure:
         const GHC.Event.Array.snoc1_info;
         const 0;
 },
 GHC.Event.Array.snoc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Xoe,
                       label: GHC.Event.Array.snoc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xoe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Xof; else goto c7Xog;
       c7Xof: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.snoc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Xog: // global
           I64[Sp - 24] = block_c7Xob_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Xok; else goto c7Xoc;
       u7Xok: // global
           call _c7Xob(R1) args: 0, res: 0, upd: 0;
       c7Xoc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xob() //  [R1]
         { info_tbl: [(c7Xob,
                       label: block_c7Xob_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xob: // global
           R4 = P64[Sp + 16];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.777857386 UTC

[section ""data" . GHC.Event.Array.snoc_closure" {
     GHC.Event.Array.snoc_closure:
         const GHC.Event.Array.snoc_info;
         const 0;
 },
 GHC.Event.Array.snoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Xop,
                       label: GHC.Event.Array.snoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xop: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.snoc1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.778633905 UTC

[section ""data" . lvl35_r7WMN_closure" {
     lvl35_r7WMN_closure:
         const GHC.Types.I#_con_info;
         const 245;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.779246846 UTC

[section ""data" . lvl36_r7WMO_closure" {
     lvl36_r7WMO_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.779872736 UTC

[section ""data" . lvl37_r7WMP_closure" {
     lvl37_r7WMP_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.780442307 UTC

[section ""data" . lvl38_r7WMQ_closure" {
     lvl38_r7WMQ_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl35_r7WMN_closure+1;
         const lvl36_r7WMO_closure+1;
         const lvl35_r7WMN_closure+1;
         const lvl37_r7WMP_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.781152956 UTC

[section ""data" . lvl39_r7WMR_closure" {
     lvl39_r7WMR_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl38_r7WMQ_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.782141498 UTC

[section ""data" . lvl40_r7WMS_closure" {
     lvl40_r7WMS_closure:
         const lvl40_r7WMS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_r7WMS_entry() //  [R1]
         { info_tbl: [(c7Xoy,
                       label: lvl40_r7WMS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xoy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xoz; else goto c7XoA;
       c7Xoz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XoA: // global
           (_c7Xov::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xov::I64 == 0) goto c7Xox; else goto c7Xow;
       c7Xox: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xow: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xov::I64;
           R2 = lvl39_r7WMR_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.783177667 UTC

[section ""cstring" . lvl41_r7WMT_bytes" {
     lvl41_r7WMT_bytes:
         I8[] [99,111,112,121,58,32,98,97,100,32,111,102,102,115,101,116,115,32,111,114,32,108,101,110,103,116,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.785095202 UTC

[section ""data" . lvl42_r7WMU_closure" {
     lvl42_r7WMU_closure:
         const lvl42_r7WMU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_r7WMU_entry() //  [R1]
         { info_tbl: [(c7XoJ,
                       label: lvl42_r7WMU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XoJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XoK; else goto c7XoL;
       c7XoK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XoL: // global
           (_c7XoE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XoE::I64 == 0) goto c7XoG; else goto c7XoF;
       c7XoG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XoF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XoE::I64;
           I64[Sp - 24] = block_c7XoH_info;
           R2 = lvl41_r7WMT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XoH() //  [R1]
         { info_tbl: [(c7XoH,
                       label: block_c7XoH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XoH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.791286942 UTC

[section ""data" . GHC.Event.Array.concat3_closure" {
     GHC.Event.Array.concat3_closure:
         const GHC.Event.Array.concat3_info;
         const 0;
 },
 sat_s7WWE_entry() //  [R1]
         { info_tbl: [(c7Xqy,
                       label: sat_s7WWE_info
                       rep:HeapRep 2 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xqy: // global
           _s7WWE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xqz; else goto c7XqA;
       c7XqA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XqC; else goto c7XqB;
       c7XqC: // global
           HpAlloc = 32;
           goto c7Xqz;
       c7Xqz: // global
           R1 = _s7WWE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XqB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WWE::P64;
           _s7WWn::I64 = I64[_s7WWE::P64 + 48];
           if (%MO_S_Gt_W64(I64[_s7WWE::P64 + 32],
                            _s7WWn::I64)) goto c7Xqw; else goto c7Xqx;
       c7Xqw: // global
           _s7WVU::P64 = P64[_s7WWE::P64 + 16];
           Hp = Hp - 32;
           R1 = _s7WVU::P64 & (-8);
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c7Xqx: // global
           _s7WVY::P64 = P64[_s7WWE::P64 + 24];
           _s7WVX::I64 = I64[_s7WWE::P64 + 40];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WVY::P64;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WVX::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WXm_entry() //  [R1]
         { info_tbl: [(c7Xsl,
                       label: sat_s7WXm_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xsl: // global
           _s7WXm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xsm; else goto c7Xsn;
       c7Xsn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Xsp; else goto c7Xso;
       c7Xsp: // global
           HpAlloc = 56;
           goto c7Xsm;
       c7Xsm: // global
           R1 = _s7WXm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xso: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WXm::P64;
           _s7WX1::P64 = P64[_s7WXm::P64 + 16];
           _s7WVW::I64 = I64[_s7WXm::P64 + 24];
           _s7WWn::I64 = I64[_s7WXm::P64 + 32];
           _s7WWS::I64 = I64[_s7WXm::P64 + 40];
           _s7WX0::I64 = I64[_s7WXm::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7Xsj; else goto c7Xsk;
       c7Xsj: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Xsk: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WXM_entry() //  [R1]
         { info_tbl: [(c7Xtk,
                       label: sat_s7WXM_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xtk: // global
           _s7WXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xtl; else goto c7Xtm;
       c7Xtm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Xto; else goto c7Xtn;
       c7Xto: // global
           HpAlloc = 56;
           goto c7Xtl;
       c7Xtl: // global
           R1 = _s7WXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xtn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WXM::P64;
           _s7WX1::P64 = P64[_s7WXM::P64 + 16];
           _s7WVW::I64 = I64[_s7WXM::P64 + 24];
           _s7WWn::I64 = I64[_s7WXM::P64 + 32];
           _s7WWS::I64 = I64[_s7WXM::P64 + 40];
           _s7WX0::I64 = I64[_s7WXM::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7Xti; else goto c7Xtj;
       c7Xti: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Xtj: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WY5_entry() //  [R1]
         { info_tbl: [(c7Xu8,
                       label: sat_s7WY5_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xu8: // global
           _s7WY5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xu9; else goto c7Xua;
       c7Xua: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Xuc; else goto c7Xub;
       c7Xuc: // global
           HpAlloc = 56;
           goto c7Xu9;
       c7Xu9: // global
           R1 = _s7WY5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WY5::P64;
           _s7WX1::P64 = P64[_s7WY5::P64 + 16];
           _s7WVW::I64 = I64[_s7WY5::P64 + 24];
           _s7WWn::I64 = I64[_s7WY5::P64 + 32];
           _s7WWS::I64 = I64[_s7WY5::P64 + 40];
           _s7WX0::I64 = I64[_s7WY5::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7Xu6; else goto c7Xu7;
       c7Xu6: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Xu7: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.concat3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Xuj,
                       label: GHC.Event.Array.concat3_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xuj: // global
           if ((Sp + -120) < SpLim) (likely: False) goto c7Xuk; else goto c7Xul;
       c7Xuk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c7Xul: // global
           I64[Sp - 40] = block_c7XoT_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Xvz; else goto c7XoU;
       u7Xvz: // global
           call _c7XoT(R1) args: 0, res: 0, upd: 0;
       c7XoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XoT() //  [R1]
         { info_tbl: [(c7XoT,
                       label: block_c7XoT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XoT: // global
           I64[Sp - 24] = block_c7XoY_info;
           _s7WVU::P64 = R1;
           _s7WVW::I64 = I64[R1 + 15];
           _s7WVX::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _s7WVW::I64;
           I64[Sp - 8] = _s7WVX::I64;
           P64[Sp] = _s7WVU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Xvo; else goto c7XoZ;
       u7Xvo: // global
           call _c7XoY(R1) args: 0, res: 0, upd: 0;
       c7XoZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XoY() //  [R1]
         { info_tbl: [(c7XoY,
                       label: block_c7XoY_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XoY: // global
           I64[Sp - 16] = block_c7Xp3_info;
           _s7WVY::P64 = R1;
           _s7WW0::P64 = P64[R1 + 7];
           _s7WVZ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _s7WW0::P64;
           I64[Sp] = _s7WVZ::I64;
           P64[Sp + 48] = _s7WVY::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Xvp; else goto c7Xp4;
       u7Xvp: // global
           call _c7Xp3(R1) args: 0, res: 0, upd: 0;
       c7Xp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xp3() //  [R1]
         { info_tbl: [(c7Xp3,
                       label: block_c7Xp3_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xp3: // global
           I64[Sp - 8] = block_c7Xp8_info;
           _s7WW3::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WW3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Xvq; else goto c7Xp9;
       u7Xvq: // global
           call _c7Xp8(R1) args: 0, res: 0, upd: 0;
       c7Xp9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xp8() //  [R1]
         { info_tbl: [(c7Xp8,
                       label: block_c7Xp8_info
                       rep:StackRep [True, False, True, True, True, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xp8: // global
           I64[Sp - 8] = block_c7Xpd_info;
           _s7WW7::P64 = P64[R1 + 7];
           _s7WW6::I64 = I64[R1 + 15];
           R1 = P64[Sp + 88];
           P64[Sp] = _s7WW7::P64;
           I64[Sp + 88] = _s7WW6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Xvr; else goto c7Xpe;
       u7Xvr: // global
           call _c7Xpd(R1) args: 0, res: 0, upd: 0;
       c7Xpe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xpd() //  [R1]
         { info_tbl: [(c7Xpd,
                       label: block_c7Xpd_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xpd: // global
           _s7WW9::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WW9::I64, 0)) goto c7Xus; else goto u7Xvj;
       c7Xus: // global
           I64[Sp] = block_c7Xpl_info;
           R1 = P64[Sp + 72];
           I64[Sp + 72] = _s7WW9::I64;
           if (R1 & 7 != 0) goto u7Xvs; else goto c7Xpm;
       u7Xvs: // global
           call _c7Xpl(R1) args: 0, res: 0, upd: 0;
       c7Xpm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7Xvj: // global
           Sp = Sp + 104;
           call _c7Xvi() args: 0, res: 0, upd: 0;
     }
 },
 _c7Xpl() //  [R1]
         { info_tbl: [(c7Xpl,
                       label: block_c7Xpl_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xpl: // global
           _s7WWc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WWc::I64, 0)) goto c7Xvg; else goto u7Xvk;
       c7Xvg: // global
           if (%MO_S_Le_W64(_s7WWc::I64,
                            I64[Sp + 40])) goto c7Xuv; else goto u7Xvl;
       c7Xuv: // global
           I64[Sp] = block_c7Xpw_info;
           R1 = P64[Sp + 88];
           I64[Sp + 88] = _s7WWc::I64;
           if (R1 & 7 != 0) goto u7Xvu; else goto c7Xpx;
       u7Xvu: // global
           call _c7Xpw(R1) args: 0, res: 0, upd: 0;
       c7Xpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7Xvl: // global
           Sp = Sp + 104;
           goto u7Xvw;
       u7Xvk: // global
           Sp = Sp + 104;
           goto u7Xvw;
       u7Xvw: // global
           call _c7Xvi() args: 0, res: 0, upd: 0;
     }
 },
 _c7Xpw() //  [R1]
         { info_tbl: [(c7Xpw,
                       label: block_c7Xpw_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xpw: // global
           _s7WWg::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WWg::I64, 0)) goto c7Xvc; else goto u7Xvm;
       c7Xvc: // global
           _s7WW3::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s7WWg::I64,
                            _s7WW3::I64)) goto c7Xv9; else goto u7Xvn;
       c7Xv9: // global
           _s7WVN::P64 = P64[Sp + 64];
           _s7WVU::P64 = P64[Sp + 56];
           _s7WVX::I64 = I64[Sp + 48];
           _s7WW9::I64 = I64[Sp + 72];
           _s7WWc::I64 = I64[Sp + 88];
           _s7WWj::I64 = _s7WW3::I64 - _s7WWg::I64;
           if (%MO_S_Gt_W64(_s7WW9::I64,
                            _s7WWj::I64)) goto c7Xv6; else goto c7Xv7;
       c7Xv6: // global
           _s7WWl::I64 = _s7WWj::I64;
           goto s7WWk;
       c7Xv7: // global
           _s7WWl::I64 = _s7WW9::I64;
           goto s7WWk;
       s7WWk: // global
           if (_s7WWl::I64 == 0) goto c7Xv2; else goto c7Xv1;
       c7Xv2: // global
           R1 = _s7WVU::P64;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Xv1: // global
           _s7WWn::I64 = _s7WWc::I64 + _s7WWl::I64;
           if (%MO_S_Le_W64(_s7WWn::I64,
                            _s7WVX::I64)) goto c7Xuz; else goto c7XuD;
       c7Xuz: // global
           I64[Sp] = block_c7XpX_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 16] = _s7WWn::I64;
           I64[Sp + 64] = _s7WWl::I64;
           I64[Sp + 72] = _s7WWg::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7XuD: // global
           I64[Sp] = block_c7XqH_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Event.Array.ensureCapacity2_closure;
           I64[Sp + 56] = _s7WWn::I64;
           I64[Sp + 72] = _s7WWl::I64;
           I64[Sp + 80] = _s7WWg::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       u7Xvn: // global
           Sp = Sp + 104;
           goto u7Xvy;
       u7Xvm: // global
           Sp = Sp + 104;
           goto u7Xvy;
       u7Xvy: // global
           call _c7Xvi() args: 0, res: 0, upd: 0;
     }
 },
 _c7XpX() //  [R1]
         { info_tbl: [(c7XpX,
                       label: block_c7XpX_info
                       rep:StackRep [False, True, False, True, True, True, False, True,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XpX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XuC; else goto c7XuB;
       c7XuC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XuB: // global
           _s7WVU::P64 = P64[Sp + 56];
           _s7WVW::I64 = I64[Sp + 40];
           _s7WVX::I64 = I64[Sp + 48];
           _s7WVY::P64 = P64[Sp + 80];
           _s7WW0::P64 = P64[Sp + 24];
           _s7WW7::P64 = P64[Sp + 8];
           _s7WWn::I64 = I64[Sp + 16];
           _s7WWq::I64 = I64[R1 + 7];
           (_s7WWA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 32] + I64[Sp + 88] * _s7WWq::I64, I64[Sp + 96] + I64[Sp + 72] * _s7WWq::I64, I64[Sp + 64] * _s7WWq::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_s7WW0::P64);
           I64[Hp - 48] = sat_s7WWE_info;
           P64[Hp - 32] = _s7WVU::P64;
           P64[Hp - 24] = _s7WVY::P64;
           I64[Hp - 16] = _s7WVW::I64;
           I64[Hp - 8] = _s7WVX::I64;
           I64[Hp] = _s7WWn::I64;
           R1 = Hp - 48;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XqH() //  [R1]
         { info_tbl: [(c7XqH,
                       label: block_c7XqH_info
                       rep:StackRep [False, True, False, True, True, True, True, False,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XqH: // global
           _s7WWG::I64 = I64[R1 + 7];
           _s7WWH::I64 = I64[Sp + 56] - 1;
           _s7WWI::I64 = _s7WWH::I64 | %MO_S_Shr_W64(_s7WWH::I64, 1);
           _s7WWK::I64 = _s7WWI::I64 | %MO_S_Shr_W64(_s7WWI::I64, 2);
           _s7WWM::I64 = _s7WWK::I64 | %MO_S_Shr_W64(_s7WWK::I64, 4);
           _s7WWO::I64 = _s7WWM::I64 | %MO_S_Shr_W64(_s7WWM::I64, 8);
           _s7WWQ::I64 = _s7WWO::I64 | %MO_S_Shr_W64(_s7WWO::I64, 16);
           _s7WWS::I64 = _s7WWQ::I64 | %MO_S_Shr_W64(_s7WWQ::I64, 32) + 1;
           _s7WWV::I64 = _s7WWS::I64 * _s7WWG::I64;
           if (%MO_S_Ge_W64(_s7WWV::I64, 0)) goto c7XuG; else goto c7XuZ;
       c7XuG: // global
           I64[Sp - 8] = block_c7Xrx_info;
           R1 = _s7WWV::I64;
           I64[Sp] = _s7WWS::I64;
           I64[Sp + 16] = _s7WWG::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7XuZ: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 104;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xrx() //  [R1]
         { info_tbl: [(c7Xrx,
                       label: block_c7Xrx_info
                       rep:StackRep [True, False, True, False, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xrx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XuJ; else goto c7XuI;
       c7XuJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XuI: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7WVN::P64 = P64[Sp + 72];
           _s7WVZ::I64 = I64[Sp + 40];
           _s7WW0::P64 = P64[Sp + 32];
           _s7WX0::I64 = R1 + 16;
           _c7XrC::P64 = Hp - 5;
           if (_s7WVZ::I64 == 0) goto c7XuV; else goto c7XuU;
       c7XuV: // global
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7Xtx_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7XrC::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7XuU: // global
           _s7WVX::I64 = I64[Sp + 56];
           if (%MO_S_Le_W64(_s7WVX::I64, 0)) goto c7XuL; else goto c7XuP;
       c7XuL: // global
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7XrK_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7XrC::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7XuP: // global
           (_s7WXs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64, _s7WVZ::I64, _s7WVX::I64 * I64[Sp + 24]);
           call MO_Touch(_c7XrC::P64);
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7XsJ_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7XrC::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Xtx() //  [R1]
         { info_tbl: [(c7Xtx,
                       label: block_c7Xtx_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xtx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XuY; else goto c7XuX;
       c7XuY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XuX: // global
           _c7XrC::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WXP::I64 = I64[R1 + 7];
           (_s7WXZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WXP::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WXP::I64, I64[Sp + 80] * _s7WXP::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7XrC::P64);
           I64[Hp - 48] = sat_s7WY5_info;
           P64[Hp - 32] = _c7XrC::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XrK() //  [R1]
         { info_tbl: [(c7XrK,
                       label: block_c7XrK_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XrK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XuO; else goto c7XuN;
       c7XuO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XuN: // global
           _c7XrC::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WX6::I64 = I64[R1 + 7];
           (_s7WXg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WX6::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WX6::I64, I64[Sp + 80] * _s7WX6::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7XrC::P64);
           I64[Hp - 48] = sat_s7WXm_info;
           P64[Hp - 32] = _c7XrC::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XsJ() //  [R1]
         { info_tbl: [(c7XsJ,
                       label: block_c7XsJ_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XsJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XuS; else goto c7XuR;
       c7XuS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XuR: // global
           _c7XrC::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WXw::I64 = I64[R1 + 7];
           (_s7WXG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WXw::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WXw::I64, I64[Sp + 80] * _s7WXw::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7XrC::P64);
           I64[Hp - 48] = sat_s7WXM_info;
           P64[Hp - 32] = _c7XrC::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xvi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xvi: // global
           R1 = lvl42_r7WMU_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.800964277 UTC

[section ""data" . GHC.Event.Array.concat2_closure" {
     GHC.Event.Array.concat2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.802502044 UTC

[section ""data" . GHC.Event.Array.$wconcat_closure" {
     GHC.Event.Array.$wconcat_closure:
         const GHC.Event.Array.$wconcat_info;
         const 0;
 },
 GHC.Event.Array.$wconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XvH,
                       label: GHC.Event.Array.$wconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XvH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7XvL; else goto c7XvM;
       c7XvL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XvM: // global
           I64[Sp - 32] = block_c7XvE_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Xw4; else goto c7XvF;
       u7Xw4: // global
           call _c7XvE(R1) args: 0, res: 0, upd: 0;
       c7XvF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XvE() //  [R1]
         { info_tbl: [(c7XvE,
                       label: block_c7XvE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XvE: // global
           _s7WYq::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_c7XvK_info;
           _s7WYk::P64 = R1;
           _s7WYm::I64 = I64[R1 + 15];
           R1 = _s7WYq::P64;
           I64[Sp] = _s7WYm::I64;
           P64[Sp + 24] = _s7WYk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Xw3; else goto c7XvO;
       u7Xw3: // global
           call _c7XvK(R1) args: 0, res: 0, upd: 0;
       c7XvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XvK() //  [R1]
         { info_tbl: [(c7XvK,
                       label: block_c7XvK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XvK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XvX; else goto c7XvW;
       c7XvX: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XvW: // global
           _s7WYt::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WYt::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           _s7WYd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7XvU_info;
           R6 = GHC.Event.Array.concat2_closure+1;
           R5 = R1;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = _s7WYd::P64;
           P64[Sp + 8] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7XvU() //  [R1]
         { info_tbl: [(c7XvU,
                       label: block_c7XvU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XvU: // global
           _s7WYe::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7WYe::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WYe::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.804705605 UTC

[section ""data" . GHC.Event.Array.concat1_closure" {
     GHC.Event.Array.concat1_closure:
         const GHC.Event.Array.concat1_info;
         const 0;
 },
 GHC.Event.Array.concat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Xwc,
                       label: GHC.Event.Array.concat1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xwc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Xwg; else goto c7Xwh;
       c7Xwg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Xwh: // global
           I64[Sp - 24] = block_c7Xw9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Xwp; else goto c7Xwa;
       u7Xwp: // global
           call _c7Xw9(R1) args: 0, res: 0, upd: 0;
       c7Xwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xw9() //  [R1]
         { info_tbl: [(c7Xw9,
                       label: block_c7Xw9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xw9: // global
           I64[Sp] = block_c7Xwf_info;
           _s7WYG::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WYG::P64;
           if (R1 & 7 != 0) goto u7Xwo; else goto c7Xwj;
       u7Xwo: // global
           call _c7Xwf(R1) args: 0, res: 0, upd: 0;
       c7Xwj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xwf() //  [R1]
         { info_tbl: [(c7Xwf,
                       label: block_c7Xwf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xwf: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wconcat_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.806292509 UTC

[section ""data" . GHC.Event.Array.concat_closure" {
     GHC.Event.Array.concat_closure:
         const GHC.Event.Array.concat_info;
         const 0;
 },
 GHC.Event.Array.concat_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Xwu,
                       label: GHC.Event.Array.concat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xwu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.concat1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.807594295 UTC

[section ""data" . GHC.Event.Array.copy1_closure" {
     GHC.Event.Array.copy1_closure:
         const GHC.Event.Array.copy1_info;
         const 0;
 },
 GHC.Event.Array.copy1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7XwE,
                       label: GHC.Event.Array.copy1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XwE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7XwI; else goto c7XwJ;
       c7XwI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.copy1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c7XwJ: // global
           I64[Sp - 40] = block_c7XwB_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7XwX; else goto c7XwC;
       u7XwX: // global
           call _c7XwB(R1) args: 0, res: 0, upd: 0;
       c7XwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XwB() //  [R1]
         { info_tbl: [(c7XwB,
                       label: block_c7XwB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XwB: // global
           I64[Sp - 8] = block_c7XwH_info;
           _s7WYR::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp] = P64[_s7WYR::P64 + 8];
           P64[Sp + 24] = _s7WYR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XwW; else goto c7XwL;
       u7XwW: // global
           call _c7XwH(R1) args: 0, res: 0, upd: 0;
       c7XwL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XwH() //  [R1]
         { info_tbl: [(c7XwH,
                       label: block_c7XwH_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XwH: // global
           _s7WYL::P64 = P64[Sp + 24];
           _s7WYZ::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp + 24] = block_c7XwP_info;
           R6 = P64[Sp + 40];
           R5 = _s7WYZ::P64;
           R4 = _s7WYL::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 48];
           Sp = Sp + 16;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7XwP() //  [R1]
         { info_tbl: [(c7XwP,
                       label: block_c7XwP_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XwP: // global
           _s7WYR::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7WYR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WYR::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.809611333 UTC

[section ""data" . GHC.Event.Array.copy_closure" {
     GHC.Event.Array.copy_closure:
         const GHC.Event.Array.copy_info;
         const 0;
 },
 GHC.Event.Array.copy_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Xx2,
                       label: GHC.Event.Array.copy_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xx2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.copy1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.81044632 UTC

[section ""data" . lvl43_r7WMV_closure" {
     lvl43_r7WMV_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.811064359 UTC

[section ""data" . lvl44_r7WMW_closure" {
     lvl44_r7WMW_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.811696528 UTC

[section ""data" . lvl45_r7WMX_closure" {
     lvl45_r7WMX_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.812307979 UTC

[section ""data" . lvl46_r7WMY_closure" {
     lvl46_r7WMY_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl43_r7WMV_closure+1;
         const lvl44_r7WMW_closure+1;
         const lvl43_r7WMV_closure+1;
         const lvl45_r7WMX_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.812936169 UTC

[section ""data" . lvl47_r7WMZ_closure" {
     lvl47_r7WMZ_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl46_r7WMY_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.815040503 UTC

[section ""data" . GHC.Event.Array.duplicate1_closure" {
     GHC.Event.Array.duplicate1_closure:
         const GHC.Event.Array.duplicate1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate1_entry() //  [R1]
         { info_tbl: [(c7Xxb,
                       label: GHC.Event.Array.duplicate1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xxb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Xxc; else goto c7Xxd;
       c7Xxc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xxd: // global
           (_c7Xx8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Xx8::I64 == 0) goto c7Xxa; else goto c7Xx9;
       c7Xxa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Xx9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Xx8::I64;
           R2 = lvl47_r7WMZ_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.816845179 UTC

[section ""data" . GHC.Event.Array.$wnew_closure" {
     GHC.Event.Array.$wnew_closure:
         const GHC.Event.Array.$wnew_info;
         const 0;
 },
 GHC.Event.Array.$wnew_entry() //  [R2, R3]
         { info_tbl: [(c7Xxk,
                       label: GHC.Event.Array.$wnew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xxk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Xxl; else goto c7Xxm;
       c7Xxl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wnew_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Xxm: // global
           I64[Sp - 16] = block_c7Xxi_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Xxi() //  [R1]
         { info_tbl: [(c7Xxi,
                       label: block_c7Xxi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xxi: // global
           _s7WZ9::I64 = I64[Sp + 8] - 1;
           _s7WZa::I64 = _s7WZ9::I64 | %MO_S_Shr_W64(_s7WZ9::I64, 1);
           _s7WZc::I64 = _s7WZa::I64 | %MO_S_Shr_W64(_s7WZa::I64, 2);
           _s7WZe::I64 = _s7WZc::I64 | %MO_S_Shr_W64(_s7WZc::I64, 4);
           _s7WZg::I64 = _s7WZe::I64 | %MO_S_Shr_W64(_s7WZe::I64, 8);
           _s7WZi::I64 = _s7WZg::I64 | %MO_S_Shr_W64(_s7WZg::I64, 16);
           _s7WZk::I64 = _s7WZi::I64 | %MO_S_Shr_W64(_s7WZi::I64, 32) + 1;
           _s7WZn::I64 = _s7WZk::I64 * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WZn::I64, 0)) goto c7Xyo; else goto c7Xyv;
       c7Xyo: // global
           I64[Sp] = block_c7Xyc_info;
           R1 = _s7WZn::I64;
           I64[Sp + 8] = _s7WZk::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7Xyv: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Xyc() //  [R1]
         { info_tbl: [(c7Xyc,
                       label: block_c7Xyc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xyc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Xyr; else goto c7Xyq;
       c7Xyr: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xyq: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 61;
           P64[Hp - 32] = R1 + 16;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 8] = block_c7Xyk_info;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xyk() //  [R1]
         { info_tbl: [(c7Xyk,
                       label: block_c7Xyk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xyk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Xyu; else goto c7Xyt;
       c7Xyu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Xyt: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.81898441 UTC

[section ""data" . GHC.Event.Array.new1_closure" {
     GHC.Event.Array.new1_closure:
         const GHC.Event.Array.new1_info;
         const 0;
 },
 GHC.Event.Array.new1_entry() //  [R2, R3]
         { info_tbl: [(c7XyD,
                       label: GHC.Event.Array.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XyD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XyE; else goto c7XyF;
       c7XyE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XyF: // global
           I64[Sp - 16] = block_c7XyA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XyJ; else goto c7XyB;
       u7XyJ: // global
           call _c7XyA(R1) args: 0, res: 0, upd: 0;
       c7XyB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XyA() //  [R1]
         { info_tbl: [(c7XyA,
                       label: block_c7XyA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XyA: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Array.$wnew_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.820146765 UTC

[section ""data" . GHC.Event.Array.new_closure" {
     GHC.Event.Array.new_closure:
         const GHC.Event.Array.new_info;
         const 0;
 },
 GHC.Event.Array.new_entry() //  [R2, R3]
         { info_tbl: [(c7XyO,
                       label: GHC.Event.Array.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XyO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.new1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.820880034 UTC

[section ""data" . lvl48_r7WN0_closure" {
     lvl48_r7WN0_closure:
         const GHC.Types.I#_con_info;
         const 95;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.821575217 UTC

[section ""data" . lvl49_r7WN1_closure" {
     lvl49_r7WN1_closure:
         const GHC.Types.I#_con_info;
         const 23;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.822155909 UTC

[section ""data" . lvl50_r7WN2_closure" {
     lvl50_r7WN2_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.822768406 UTC

[section ""data" . lvl51_r7WN3_closure" {
     lvl51_r7WN3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl48_r7WN0_closure+1;
         const lvl49_r7WN1_closure+1;
         const lvl48_r7WN0_closure+1;
         const lvl50_r7WN2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.823376343 UTC

[section ""data" . lvl52_r7WN4_closure" {
     lvl52_r7WN4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl51_r7WN3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.824244362 UTC

[section ""data" . GHC.Event.Array.duplicate2_closure" {
     GHC.Event.Array.duplicate2_closure:
         const GHC.Event.Array.duplicate2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate2_entry() //  [R1]
         { info_tbl: [(c7XyX,
                       label: GHC.Event.Array.duplicate2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XyY; else goto c7XyZ;
       c7XyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XyZ: // global
           (_c7XyU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XyU::I64 == 0) goto c7XyW; else goto c7XyV;
       c7XyW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XyV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XyU::I64;
           R2 = lvl52_r7WN4_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.827007859 UTC

[section ""data" . GHC.Event.Array.duplicate_closure" {
     GHC.Event.Array.duplicate_closure:
         const GHC.Event.Array.duplicate_info;
         const 0;
 },
 lvl53_s7WZH_entry() //  [R1]
         { info_tbl: [(c7Xz8,
                       label: lvl53_s7WZH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xz8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Xz9; else goto c7Xza;
       c7Xz9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xza: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl54_s7WZI_entry() //  [R1]
         { info_tbl: [(c7Xzf,
                       label: lvl54_s7WZI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xzf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Xzg; else goto c7Xzh;
       c7Xzg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Xzh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7X0n_entry() //  [R1, R2]
         { info_tbl: [(c7Xzq,
                       label: sat_s7X0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xzq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7XzE; else goto c7XzF;
       c7XzE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XzF: // global
           I64[Sp - 24] = block_c7Xzn_info;
           _s7WZH::P64 = P64[R1 + 6];
           _s7WZI::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s7WZH::P64;
           P64[Sp - 8] = _s7WZI::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XAx; else goto c7Xzo;
       u7XAx: // global
           call _c7Xzn(R1) args: 0, res: 0, upd: 0;
       c7Xzo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xzn() //  [R1]
         { info_tbl: [(c7Xzn,
                       label: block_c7Xzn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xzn: // global
           _s7WZP::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Xzt_info;
           R1 = _s7WZP::P64;
           if (R1 & 7 != 0) goto u7XAw; else goto c7Xzu;
       u7XAw: // global
           call _c7Xzt(R1) args: 0, res: 0, upd: 0;
       c7Xzu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xzt() //  [R1]
         { info_tbl: [(c7Xzt,
                       label: block_c7Xzt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xzt: // global
           I64[Sp - 16] = block_c7Xzy_info;
           _s7WZS::I64 = I64[R1 + 15];
           _s7WZT::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WZT::I64;
           I64[Sp] = _s7WZS::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XAy; else goto c7Xzz;
       u7XAy: // global
           call _c7Xzy(R1) args: 0, res: 0, upd: 0;
       c7Xzz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Xzy() //  [R1]
         { info_tbl: [(c7Xzy,
                       label: block_c7Xzy_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Xzy: // global
           I64[Sp - 8] = block_c7XzD_info;
           _s7WZW::P64 = P64[R1 + 7];
           _s7WZV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _s7WZW::P64;
           I64[Sp + 32] = _s7WZV::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XAz; else goto c7XzJ;
       u7XAz: // global
           call _c7XzD(R1) args: 0, res: 0, upd: 0;
       c7XzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XzD() //  [R1]
         { info_tbl: [(c7XzD,
                       label: block_c7XzD_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XzD: // global
           _s7WZZ::I64 = I64[Sp + 16] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WZZ::I64, 0)) goto c7XAn; else goto c7XAv;
       c7XAn: // global
           I64[Sp] = block_c7XzU_info;
           R1 = _s7WZZ::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7XAv: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XzU() //  [R1]
         { info_tbl: [(c7XzU,
                       label: block_c7XzU_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XzU: // global
           I64[Sp] = block_c7XzW_info;
           _s7X03::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7X03::P64;
           if (R1 & 7 != 0) goto u7XAA; else goto c7XzX;
       u7XAA: // global
           call _c7XzW(R1) args: 0, res: 0, upd: 0;
       c7XzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XzW() //  [R1]
         { info_tbl: [(c7XzW,
                       label: block_c7XzW_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XzW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7XAr; else goto c7XAq;
       c7XAr: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XAq: // global
           _s7WZS::I64 = I64[Sp + 24];
           _s7WZT::I64 = I64[Sp + 16];
           _s7WZW::P64 = P64[Sp + 8];
           _s7X03::P64 = P64[Sp + 32];
           _s7X06::I64 = _s7X03::P64 + 16;
           (_s7X0c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7X06::I64, I64[Sp + 40], _s7WZS::I64 * I64[R1 + 7]);
           call MO_Touch(_s7WZW::P64);
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = _s7X03::P64;
           _c7XAf::P64 = Hp - 61;
           call MO_Touch(_c7XAf::P64);
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XAf::P64;
           I64[Hp - 32] = _s7X06::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WZS::I64;
           I64[Hp] = _s7WZT::I64;
           I64[Sp + 40] = block_c7XAj_info;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XAj() //  [R1]
         { info_tbl: [(c7XAj,
                       label: block_c7XAj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XAj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XAu; else goto c7XAt;
       c7XAu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XAt: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.duplicate_entry() //  [R2]
         { info_tbl: [(c7XAB,
                       label: GHC.Event.Array.duplicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XAB: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7XAF; else goto c7XAE;
       c7XAF: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.Event.Array.duplicate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XAE: // global
           I64[Hp - 64] = lvl53_s7WZH_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl54_s7WZI_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7X0n_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.831058644 UTC

[section ""data" . GHC.Event.Array.AC_closure" {
     GHC.Event.Array.AC_closure:
         const GHC.Event.Array.AC_info;
 },
 GHC.Event.Array.AC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XAL,
                       label: GHC.Event.Array.AC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XAL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XAP; else goto c7XAO;
       c7XAP: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.AC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XAO: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.831997633 UTC

[GHC.Event.Array.AC_con_entry() //  [R1]
         { info_tbl: [(c7XAQ,
                       label: GHC.Event.Array.AC_con_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46,65,67]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XAQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.83270681 UTC

[section ""relreadonly" . S7X3q_srt" {
     S7X3q_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.$wlvl1_closure;
         const GHC.Event.Array.$wunsafeRead_closure;
         const GHC.Event.Array.unsafeRead1_closure;
         const GHC.Event.Array.$wlvl_closure;
         const GHC.Event.Array.$wunsafeWrite'_closure;
         const GHC.Event.Array.unsafeWrite2_closure;
         const GHC.Event.Array.unsafeWrite1_closure;
         const GHC.Err.undefined_closure;
         const lvl15_r7WMj_closure;
         const GHC.Event.Array.forM_1_closure;
         const GHC.Event.Array.forM__closure;
         const lvl20_r7WMo_closure;
         const GHC.Event.Array.loop1_closure;
         const GHC.Event.Array.loop_closure;
         const lvl23_r7WMB_closure;
         const GHC.Event.Array.removeAt2_closure;
         const GHC.Event.Array.removeAt1_closure;
         const GHC.Event.Array.removeAt_closure;
         const lvl29_r7WMH_closure;
         const GHC.Event.Array.findIndex1_closure;
         const GHC.Event.Array.findIndex_closure;
         const lvl34_r7WMM_closure;
         const GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
         const GHC.Event.Array.$wensureCapacity_closure;
         const GHC.Event.Array.ensureCapacity2_closure;
         const GHC.Event.Array.ensureCapacity1_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.snoc1_closure;
         const lvl39_r7WMR_closure;
         const GHC.Event.Array.concat3_closure;
         const lvl40_r7WMS_closure;
         const lvl42_r7WMU_closure;
         const GHC.Event.Array.$wconcat_closure;
         const GHC.Event.Array.concat1_closure;
         const GHC.Event.Array.copy1_closure;
         const lvl47_r7WMZ_closure;
         const GHC.Event.Array.duplicate1_closure;
         const GHC.Event.Array.$wnew_closure;
         const GHC.Event.Array.new1_closure;
         const lvl52_r7WN4_closure;
         const GHC.Err.undefined_closure;
         const GHC.Event.Array.duplicate2_closure;
         const GHC.Event.Array.duplicate_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.833653718 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:02.834714482 UTC

[section ""data" . GHC.Event.Array.$WAC_closure" {
     GHC.Event.Array.$WAC_closure:
         const GHC.Event.Array.$WAC_info;
 },
 GHC.Event.Array.$WAC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XAY,
                       label: GHC.Event.Array.$WAC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XAY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XBc; else goto c7XBd;
       c7XBc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$WAC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XBd: // global
           I64[Sp - 24] = block_c7XAV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XBk; else goto c7XAW;
       u7XBk: // global
           call _c7XAV(R1) args: 0, res: 0, upd: 0;
       c7XAW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XAV() //  [R1]
         { info_tbl: [(c7XAV,
                       label: block_c7XAV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XAV: // global
           I64[Sp] = block_c7XB1_info;
           _s7WN9::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7WN9::P64;
           if (R1 & 7 != 0) goto u7XBj; else goto c7XB2;
       u7XBj: // global
           call _c7XB1(R1) args: 0, res: 0, upd: 0;
       c7XB2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XB1() //  [R1]
         { info_tbl: [(c7XB1,
                       label: block_c7XB1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XB1: // global
           I64[Sp] = block_c7XB6_info;
           _s7WNb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7WNb::I64;
           if (R1 & 7 != 0) goto u7XBl; else goto c7XB7;
       u7XBl: // global
           call _c7XB6(R1) args: 0, res: 0, upd: 0;
       c7XB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XB6() //  [R1]
         { info_tbl: [(c7XB6,
                       label: block_c7XB6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XB6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XBi; else goto c7XBh;
       c7XBi: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XBh: // global
           _s7WNd::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _s7WNd::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.836660284 UTC

[section ""data" . GHC.Event.Array.empty1_closure" {
     GHC.Event.Array.empty1_closure:
         const GHC.Event.Array.empty1_info;
 },
 GHC.Event.Array.empty1_entry() //  []
         { info_tbl: [(c7XBy,
                       label: GHC.Event.Array.empty1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7XBz; else goto c7XBA;
       c7XBz: // global
           R1 = GHC.Event.Array.empty1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7XBA: // global
           I64[Sp - 8] = block_c7XBq_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XBq() //  [R1]
         { info_tbl: [(c7XBq,
                       label: block_c7XBq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7XBD; else goto c7XBC;
       c7XBD: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XBC: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_c7XBv_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XBv() //  [R1]
         { info_tbl: [(c7XBv,
                       label: block_c7XBv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XBG; else goto c7XBF;
       c7XBG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XBF: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.838451384 UTC

[section ""data" . GHC.Event.Array.empty_closure" {
     GHC.Event.Array.empty_closure:
         const GHC.Event.Array.empty_info;
 },
 GHC.Event.Array.empty_entry() //  []
         { info_tbl: [(c7XBL,
                       label: GHC.Event.Array.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBL: // global
           call GHC.Event.Array.empty1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.839663218 UTC

[section ""data" . GHC.Event.Array.length1_closure" {
     GHC.Event.Array.length1_closure:
         const GHC.Event.Array.length1_info;
 },
 GHC.Event.Array.length1_entry() //  [R2]
         { info_tbl: [(c7XBV,
                       label: GHC.Event.Array.length1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7XC4; else goto c7XC5;
       c7XC4: // global
           R2 = R2;
           R1 = GHC.Event.Array.length1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XC5: // global
           I64[Sp - 8] = block_c7XBS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XCb; else goto c7XBT;
       u7XCb: // global
           call _c7XBS(R1) args: 0, res: 0, upd: 0;
       c7XBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XBS() //  [R1]
         { info_tbl: [(c7XBS,
                       label: block_c7XBS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBS: // global
           _s7WNv::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XBY_info;
           R1 = _s7WNv::P64;
           if (R1 & 7 != 0) goto u7XCa; else goto c7XBZ;
       u7XCa: // global
           call _c7XBY(R1) args: 0, res: 0, upd: 0;
       c7XBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XBY() //  [R1]
         { info_tbl: [(c7XBY,
                       label: block_c7XBY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XBY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XC9; else goto c7XC8;
       c7XC9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XC8: // global
           _s7WNy::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7WNy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.841146935 UTC

[section ""data" . GHC.Event.Array.length_closure" {
     GHC.Event.Array.length_closure:
         const GHC.Event.Array.length_info;
 },
 GHC.Event.Array.length_entry() //  [R2]
         { info_tbl: [(c7XCg,
                       label: GHC.Event.Array.length_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XCg: // global
           R2 = R2;
           call GHC.Event.Array.length1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.842417294 UTC

[section ""data" . GHC.Event.Array.capacity1_closure" {
     GHC.Event.Array.capacity1_closure:
         const GHC.Event.Array.capacity1_info;
 },
 GHC.Event.Array.capacity1_entry() //  [R2]
         { info_tbl: [(c7XCq,
                       label: GHC.Event.Array.capacity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XCq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7XCz; else goto c7XCA;
       c7XCz: // global
           R2 = R2;
           R1 = GHC.Event.Array.capacity1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XCA: // global
           I64[Sp - 8] = block_c7XCn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XCG; else goto c7XCo;
       u7XCG: // global
           call _c7XCn(R1) args: 0, res: 0, upd: 0;
       c7XCo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XCn() //  [R1]
         { info_tbl: [(c7XCn,
                       label: block_c7XCn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XCn: // global
           _s7WNH::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XCt_info;
           R1 = _s7WNH::P64;
           if (R1 & 7 != 0) goto u7XCF; else goto c7XCu;
       u7XCF: // global
           call _c7XCt(R1) args: 0, res: 0, upd: 0;
       c7XCu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XCt() //  [R1]
         { info_tbl: [(c7XCt,
                       label: block_c7XCt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XCt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XCE; else goto c7XCD;
       c7XCE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XCD: // global
           _s7WNL::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7WNL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.845123324 UTC

[section ""data" . GHC.Event.Array.capacity_closure" {
     GHC.Event.Array.capacity_closure:
         const GHC.Event.Array.capacity_info;
 },
 GHC.Event.Array.capacity_entry() //  [R2]
         { info_tbl: [(c7XCL,
                       label: GHC.Event.Array.capacity_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XCL: // global
           R2 = R2;
           call GHC.Event.Array.capacity1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.845957407 UTC

[section ""cstring" . lvl_r7WM4_bytes" {
     lvl_r7WM4_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.846522621 UTC

[section ""cstring" . lvl1_r7WM5_bytes" {
     lvl1_r7WM5_bytes:
         I8[] [117,110,115,97,102,101,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.847063233 UTC

[section ""cstring" . lvl2_r7WM6_bytes" {
     lvl2_r7WM6_bytes:
         I8[] [58,32,98,111,117,110,100,115,32,101,114,114,111,114,44,32,105,110,100,101,120,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.847623496 UTC

[section ""cstring" . lvl3_r7WM7_bytes" {
     lvl3_r7WM7_bytes:
         I8[] [44,32,99,97,112,97,99,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.849600558 UTC

[section ""data" . GHC.Event.Array.$wlvl1_closure" {
     GHC.Event.Array.$wlvl1_closure:
         const GHC.Event.Array.$wlvl1_info;
         const 0;
 },
 sat_s7WNW_entry() //  [R1]
         { info_tbl: [(c7XDh,
                       label: sat_s7WNW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XDi; else goto c7XDj;
       c7XDi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XDj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7XDe_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XDe() //  [R1, R2]
         { info_tbl: [(c7XDe,
                       label: block_c7XDe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7XDm; else goto c7XDl;
       c7XDm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7XDl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WNX_entry() //  [R1]
         { info_tbl: [(c7XDn,
                       label: sat_s7WNX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7XDr; else goto c7XDq;
       c7XDr: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XDq: // global
           _s7WNN::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7WNW_info;
           I64[Hp] = _s7WNN::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7WNY_entry() //  [R1]
         { info_tbl: [(c7XDt,
                       label: sat_s7WNY_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XDu; else goto c7XDv;
       c7XDu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XDv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7XD4_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XD4() //  [R1, R2]
         { info_tbl: [(c7XD4,
                       label: block_c7XD4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XD4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XDy; else goto c7XDx;
       c7XDy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7XDx: // global
           I64[Hp - 40] = sat_s7WNX_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WNZ_entry() //  [R1]
         { info_tbl: [(c7XDz,
                       label: sat_s7WNZ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDz: // global
           _s7WNZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7XDA; else goto c7XDB;
       c7XDB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XDD; else goto c7XDC;
       c7XDD: // global
           HpAlloc = 32;
           goto c7XDA;
       c7XDA: // global
           R1 = _s7WNZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XDC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WNZ::P64;
           _s7WNN::I64 = I64[_s7WNZ::P64 + 16];
           _s7WNO::I64 = I64[_s7WNZ::P64 + 24];
           I64[Hp - 24] = sat_s7WNY_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WO0_entry() //  [R1]
         { info_tbl: [(c7XDE,
                       label: sat_s7WO0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDE: // global
           _s7WO0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7XDF; else goto c7XDG;
       c7XDG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XDI; else goto c7XDH;
       c7XDI: // global
           HpAlloc = 32;
           goto c7XDF;
       c7XDF: // global
           R1 = _s7WO0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XDH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WO0::P64;
           _s7WNN::I64 = I64[_s7WO0::P64 + 16];
           _s7WNO::I64 = I64[_s7WO0::P64 + 24];
           I64[Hp - 24] = sat_s7WNZ_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           R3 = Hp - 24;
           R2 = lvl1_r7WM5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl1_entry() //  [R2, R3]
         { info_tbl: [(c7XDL,
                       label: GHC.Event.Array.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDL: // global
           _s7WNO::I64 = R3;
           _s7WNN::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7XDM; else goto c7XDN;
       c7XDN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XDP; else goto c7XDO;
       c7XDP: // global
           HpAlloc = 32;
           goto c7XDM;
       c7XDM: // global
           R3 = _s7WNO::I64;
           R2 = _s7WNN::I64;
           R1 = GHC.Event.Array.$wlvl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XDO: // global
           I64[Hp - 24] = sat_s7WO0_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           I64[Sp - 8] = block_c7XDJ_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7XDJ() //  [R1]
         { info_tbl: [(c7XDJ,
                       label: block_c7XDJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.853919054 UTC

[section ""data" . GHC.Event.Array.$wunsafeRead_closure" {
     GHC.Event.Array.$wunsafeRead_closure:
         const GHC.Event.Array.$wunsafeRead_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XE0,
                       label: GHC.Event.Array.$wunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XE0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7XE4; else goto c7XE5;
       c7XE4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XE5: // global
           I64[Sp - 24] = block_c7XDX_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XEx; else goto c7XDY;
       u7XEx: // global
           call _c7XDX(R1) args: 0, res: 0, upd: 0;
       c7XDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XDX() //  [R1]
         { info_tbl: [(c7XDX,
                       label: block_c7XDX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XDX: // global
           I64[Sp - 8] = block_c7XE3_info;
           _s7WOc::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WOc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XEw; else goto c7XE7;
       u7XEw: // global
           call _c7XE3(R1) args: 0, res: 0, upd: 0;
       c7XE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XE3() //  [R1]
         { info_tbl: [(c7XE3,
                       label: block_c7XE3_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XE3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XEd; else goto c7XEc;
       c7XEd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XEc: // global
           _s7WO4::I64 = I64[Sp + 24];
           _s7WOc::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7WO4::I64, 0)) goto c7XEu; else goto c7XEt;
       c7XEt: // global
           if (%MO_S_Ge_W64(_s7WO4::I64,
                            _s7WOc::I64)) goto c7XEu; else goto c7XEo;
       c7XEu: // global
           Hp = Hp - 32;
           R3 = _s7WO4::I64;
           R2 = _s7WOc::I64;
           Sp = Sp + 32;
           call GHC.Event.Array.$wlvl1_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7XEo: // global
           _s7WOf::P64 = P64[R1 + 7];
           _s7WOe::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WO4::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WOe::I64;
           _s7WO2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7XEm_info;
           R2 = _s7WO2::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = Hp - 23;
           P64[Sp + 24] = _s7WOf::P64;
           Sp = Sp - 8;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c7XEm() //  [R1]
         { info_tbl: [(c7XEm,
                       label: block_c7XEm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XEm: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.856177844 UTC

[section ""data" . GHC.Event.Array.unsafeRead1_closure" {
     GHC.Event.Array.unsafeRead1_closure:
         const GHC.Event.Array.unsafeRead1_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XEF,
                       label: GHC.Event.Array.unsafeRead1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XEF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XEJ; else goto c7XEK;
       c7XEJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeRead1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XEK: // global
           I64[Sp - 24] = block_c7XEC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XES; else goto c7XED;
       u7XES: // global
           call _c7XEC(R1) args: 0, res: 0, upd: 0;
       c7XED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XEC() //  [R1]
         { info_tbl: [(c7XEC,
                       label: block_c7XEC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XEC: // global
           I64[Sp] = block_c7XEI_info;
           _s7WOv::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WOv::P64;
           if (R1 & 7 != 0) goto u7XER; else goto c7XEM;
       u7XER: // global
           call _c7XEI(R1) args: 0, res: 0, upd: 0;
       c7XEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XEI() //  [R1]
         { info_tbl: [(c7XEI,
                       label: block_c7XEI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XEI: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wunsafeRead_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.857663963 UTC

[section ""data" . GHC.Event.Array.unsafeRead_closure" {
     GHC.Event.Array.unsafeRead_closure:
         const GHC.Event.Array.unsafeRead_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XEX,
                       label: GHC.Event.Array.unsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XEX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeRead1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.858408315 UTC

[section ""cstring" . lvl4_r7WM8_bytes" {
     lvl4_r7WM8_bytes:
         I8[] [117,110,115,97,102,101,87,114,105,116,101,39]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.860209444 UTC

[section ""data" . GHC.Event.Array.$wlvl_closure" {
     GHC.Event.Array.$wlvl_closure:
         const GHC.Event.Array.$wlvl_info;
         const 0;
 },
 sat_s7WOH_entry() //  [R1]
         { info_tbl: [(c7XFt,
                       label: sat_s7WOH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XFu; else goto c7XFv;
       c7XFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7XFq_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XFq() //  [R1, R2]
         { info_tbl: [(c7XFq,
                       label: block_c7XFq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7XFy; else goto c7XFx;
       c7XFy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7XFx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOI_entry() //  [R1]
         { info_tbl: [(c7XFz,
                       label: sat_s7WOI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7XFD; else goto c7XFC;
       c7XFD: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XFC: // global
           _s7WOy::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7WOH_info;
           I64[Hp] = _s7WOy::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7WOJ_entry() //  [R1]
         { info_tbl: [(c7XFF,
                       label: sat_s7WOJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XFG; else goto c7XFH;
       c7XFG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XFH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7XFg_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XFg() //  [R1, R2]
         { info_tbl: [(c7XFg,
                       label: block_c7XFg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XFK; else goto c7XFJ;
       c7XFK: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7XFJ: // global
           I64[Hp - 40] = sat_s7WOI_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOK_entry() //  [R1]
         { info_tbl: [(c7XFL,
                       label: sat_s7WOK_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFL: // global
           _s7WOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7XFM; else goto c7XFN;
       c7XFN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XFP; else goto c7XFO;
       c7XFP: // global
           HpAlloc = 32;
           goto c7XFM;
       c7XFM: // global
           R1 = _s7WOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XFO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WOK::P64;
           _s7WOy::I64 = I64[_s7WOK::P64 + 16];
           _s7WOz::I64 = I64[_s7WOK::P64 + 24];
           I64[Hp - 24] = sat_s7WOJ_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOL_entry() //  [R1]
         { info_tbl: [(c7XFQ,
                       label: sat_s7WOL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFQ: // global
           _s7WOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7XFR; else goto c7XFS;
       c7XFS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XFU; else goto c7XFT;
       c7XFU: // global
           HpAlloc = 32;
           goto c7XFR;
       c7XFR: // global
           R1 = _s7WOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XFT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WOL::P64;
           _s7WOy::I64 = I64[_s7WOL::P64 + 16];
           _s7WOz::I64 = I64[_s7WOL::P64 + 24];
           I64[Hp - 24] = sat_s7WOK_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           R3 = Hp - 24;
           R2 = lvl4_r7WM8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(c7XFX,
                       label: GHC.Event.Array.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFX: // global
           _s7WOz::I64 = R3;
           _s7WOy::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7XFY; else goto c7XFZ;
       c7XFZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XG1; else goto c7XG0;
       c7XG1: // global
           HpAlloc = 32;
           goto c7XFY;
       c7XFY: // global
           R3 = _s7WOz::I64;
           R2 = _s7WOy::I64;
           R1 = GHC.Event.Array.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XG0: // global
           I64[Hp - 24] = sat_s7WOL_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           I64[Sp - 8] = block_c7XFV_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7XFV() //  [R1]
         { info_tbl: [(c7XFV,
                       label: block_c7XFV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XFV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.864258242 UTC

[section ""data" . GHC.Event.Array.$wunsafeWrite'_closure" {
     GHC.Event.Array.$wunsafeWrite'_closure:
         const GHC.Event.Array.$wunsafeWrite'_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeWrite'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XG6: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.$wunsafeWrite'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7XGf,
                       label: GHC.Event.Array.$wunsafeWrite'_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XGf: // global
           _s7WOR::I64 = R6;
           _s7WOQ::I64 = R5;
           _s7WOP::P64 = R4;
           _s7WOO::I64 = R3;
           _s7WON::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c7XGg; else goto c7XGh;
       c7XGh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XGj; else goto c7XGi;
       c7XGj: // global
           HpAlloc = 32;
           goto c7XGg;
       c7XGg: // global
           R1 = GHC.Event.Array.$wunsafeWrite'_closure;
           P64[Sp - 40] = _s7WON::P64;
           I64[Sp - 32] = _s7WOO::I64;
           P64[Sp - 24] = _s7WOP::P64;
           I64[Sp - 16] = _s7WOQ::I64;
           I64[Sp - 8] = _s7WOR::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7XGi: // global
           if (%MO_S_Lt_W64(_s7WOR::I64, 0)) goto c7XGe; else goto c7XGd;
       c7XGd: // global
           if (%MO_S_Ge_W64(_s7WOR::I64,
                            _s7WOQ::I64)) goto c7XGe; else goto c7XGs;
       c7XGe: // global
           Hp = Hp - 32;
           R3 = _s7WOR::I64;
           R2 = _s7WOQ::I64;
           Sp = Sp + 8;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7XGs: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WOR::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WOO::I64;
           I64[Sp - 8] = block_c7XGq_info;
           R2 = _s7WON::P64;
           I64[Sp - 40] = stg_ap_pppv_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           P64[Sp - 16] = P64[Sp];
           P64[Sp] = _s7WOP::P64;
           Sp = Sp - 40;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c7XGq() //  [R1]
         { info_tbl: [(c7XGq,
                       label: block_c7XGq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XGq: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.866557388 UTC

[section ""data" . GHC.Event.Array.unsafeWrite2_closure" {
     GHC.Event.Array.unsafeWrite2_closure:
         const GHC.Event.Array.unsafeWrite2_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7XGE,
                       label: GHC.Event.Array.unsafeWrite2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XGE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7XGN; else goto c7XGO;
       c7XGN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XGO: // global
           I64[Sp - 32] = block_c7XGB_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7XGX; else goto c7XGC;
       u7XGX: // global
           call _c7XGB(R1) args: 0, res: 0, upd: 0;
       c7XGC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XGB() //  [R1]
         { info_tbl: [(c7XGB,
                       label: block_c7XGB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XGB: // global
           I64[Sp - 8] = block_c7XGH_info;
           _s7WPc::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WPc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XGW; else goto c7XGI;
       u7XGW: // global
           call _c7XGH(R1) args: 0, res: 0, upd: 0;
       c7XGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XGH() //  [R1]
         { info_tbl: [(c7XGH,
                       label: block_c7XGH_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XGH: // global
           I64[Sp - 8] = block_c7XGM_info;
           _s7WPf::P64 = P64[R1 + 7];
           _s7WPe::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WPf::P64;
           I64[Sp + 24] = _s7WPe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XGY; else goto c7XGR;
       u7XGY: // global
           call _c7XGM(R1) args: 0, res: 0, upd: 0;
       c7XGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XGM() //  [R1]
         { info_tbl: [(c7XGM,
                       label: block_c7XGM_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XGM: // global
           R6 = I64[R1 + 7];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 32];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.868457689 UTC

[section ""data" . GHC.Event.Array.unsafeWrite1_closure" {
     GHC.Event.Array.unsafeWrite1_closure:
         const GHC.Event.Array.unsafeWrite1_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7XH6,
                       label: GHC.Event.Array.unsafeWrite1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XH6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XH7; else goto c7XH8;
       c7XH7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XH8: // global
           I64[Sp - 32] = block_c7XH3_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7XHc; else goto c7XH4;
       u7XHc: // global
           call _c7XH3(R1) args: 0, res: 0, upd: 0;
       c7XH4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XH3() //  [R1]
         { info_tbl: [(c7XH3,
                       label: block_c7XH3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XH3: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[P64[R1 + 7] + 8];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Event.Array.unsafeWrite2_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.870254955 UTC

[section ""data" . GHC.Event.Array.unsafeWrite_closure" {
     GHC.Event.Array.unsafeWrite_closure:
         const GHC.Event.Array.unsafeWrite_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7XHh,
                       label: GHC.Event.Array.unsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeWrite1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.872097643 UTC

[section ""data" . GHC.Event.Array.$wunsafeLoad_closure" {
     GHC.Event.Array.$wunsafeLoad_closure:
         const GHC.Event.Array.$wunsafeLoad_info;
 },
 sat_s7WPN_entry() //  [R1]
         { info_tbl: [(c7XHK,
                       label: sat_s7WPN_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7XHO; else goto c7XHP;
       c7XHO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XHP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7XHH_info;
           _s7WPC::P64 = P64[R1 + 16];
           _s7WPB::I64 = I64[R1 + 32];
           R1 = P64[R1 + 24];
           I64[Sp - 32] = _s7WPB::I64;
           P64[Sp - 24] = _s7WPC::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7XHT; else goto c7XHI;
       u7XHT: // global
           call _c7XHH(R1) args: 0, res: 0, upd: 0;
       c7XHI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7XHH() //  [R1]
         { info_tbl: [(c7XHH,
                       label: block_c7XHH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XHS; else goto c7XHR;
       c7XHS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7XHR: // global
           _s7WPM::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = _s7WPM::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wunsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7XHU,
                       label: GHC.Event.Array.$wunsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7XHV; else goto c7XHW;
       c7XHV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeLoad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XHW: // global
           I64[Sp - 24] = block_c7XHo_info;
           R1 = P64[R2 + 8];
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XI8; else goto c7XHp;
       u7XI8: // global
           call _c7XHo(R1) args: 0, res: 0, upd: 0;
       c7XHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XHo() //  [R1]
         { info_tbl: [(c7XHo,
                       label: block_c7XHo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHo: // global
           I64[Sp - 8] = block_c7XHt_info;
           _s7WPB::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WPB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XI7; else goto c7XHu;
       u7XI7: // global
           call _c7XHt(R1) args: 0, res: 0, upd: 0;
       c7XHu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XHt() //  [R1]
         { info_tbl: [(c7XHt,
                       label: block_c7XHt_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XI0; else goto c7XHZ;
       c7XI0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XHZ: // global
           _s7WPE::P64 = P64[R1 + 7];
           _s7WPD::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WPD::I64;
           I64[Sp - 8] = block_c7XHA_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           _s7WPC::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WPE::P64;
           P64[Sp + 24] = _s7WPC::P64;
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XHA() //  [R1]
         { info_tbl: [(c7XHA,
                       label: block_c7XHA_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XHA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7XI3; else goto c7XI2;
       c7XI3: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XI2: // global
           _s7WPs::P64 = P64[Sp + 24];
           _s7WPB::I64 = I64[Sp + 16];
           _s7WPC::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = sat_s7WPN_info;
           P64[Hp - 16] = _s7WPC::P64;
           P64[Hp - 8] = R1;
           I64[Hp] = _s7WPB::I64;
           call MO_WriteBarrier();
           P64[_s7WPs::P64 + 8] = Hp - 32;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WPs::P64);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.876522012 UTC

[section ""data" . GHC.Event.Array.unsafeLoad1_closure" {
     GHC.Event.Array.unsafeLoad1_closure:
         const GHC.Event.Array.unsafeLoad1_info;
 },
 GHC.Event.Array.unsafeLoad1_entry() //  [R2, R3]
         { info_tbl: [(c7XIg,
                       label: GHC.Event.Array.unsafeLoad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XIh; else goto c7XIi;
       c7XIh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeLoad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XIi: // global
           I64[Sp - 16] = block_c7XId_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XIm; else goto c7XIe;
       u7XIm: // global
           call _c7XId(R1) args: 0, res: 0, upd: 0;
       c7XIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XId() //  [R1]
         { info_tbl: [(c7XId,
                       label: block_c7XId_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XId: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Event.Array.$wunsafeLoad_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.877840906 UTC

[section ""data" . GHC.Event.Array.unsafeLoad_closure" {
     GHC.Event.Array.unsafeLoad_closure:
         const GHC.Event.Array.unsafeLoad_info;
 },
 GHC.Event.Array.unsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7XIr,
                       label: GHC.Event.Array.unsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIr: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeLoad1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.879138754 UTC

[section ""data" . GHC.Event.Array.useAsPtr1_closure" {
     GHC.Event.Array.useAsPtr1_closure:
         const GHC.Event.Array.useAsPtr1_info;
 },
 GHC.Event.Array.useAsPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7XIB,
                       label: GHC.Event.Array.useAsPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XIK; else goto c7XIL;
       c7XIK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.useAsPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XIL: // global
           I64[Sp - 16] = block_c7XIy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XJ2; else goto c7XIz;
       u7XJ2: // global
           call _c7XIy(R1) args: 0, res: 0, upd: 0;
       c7XIz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XIy() //  [R1]
         { info_tbl: [(c7XIy,
                       label: block_c7XIy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIy: // global
           _s7WQ1::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XIE_info;
           R1 = _s7WQ1::P64;
           if (R1 & 7 != 0) goto u7XJ1; else goto c7XIF;
       u7XJ1: // global
           call _c7XIE(R1) args: 0, res: 0, upd: 0;
       c7XIF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XIE() //  [R1]
         { info_tbl: [(c7XIE,
                       label: block_c7XIE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIE: // global
           I64[Sp - 8] = block_c7XIJ_info;
           _s7WQ4::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WQ4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XJ3; else goto c7XIO;
       u7XJ3: // global
           call _c7XIJ(R1) args: 0, res: 0, upd: 0;
       c7XIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XIJ() //  [R1]
         { info_tbl: [(c7XIJ,
                       label: block_c7XIJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XIX; else goto c7XIW;
       c7XIX: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XIW: // global
           _s7WQ8::P64 = P64[R1 + 7];
           _s7WQ7::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WQ7::I64;
           I64[Sp + 8] = block_c7XIU_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WQ8::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XIU() //  [R1]
         { info_tbl: [(c7XIU,
                       label: block_c7XIU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XIU: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.881039865 UTC

[section ""data" . GHC.Event.Array.useAsPtr_closure" {
     GHC.Event.Array.useAsPtr_closure:
         const GHC.Event.Array.useAsPtr_info;
 },
 GHC.Event.Array.useAsPtr_entry() //  [R2, R3]
         { info_tbl: [(c7XJ8,
                       label: GHC.Event.Array.useAsPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJ8: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.useAsPtr1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.882233935 UTC

[section ""data" . GHC.Event.Array.clear2_closure" {
     GHC.Event.Array.clear2_closure:
         const GHC.Event.Array.clear2_info;
 },
 GHC.Event.Array.clear2_entry() //  [R2]
         { info_tbl: [(c7XJi,
                       label: GHC.Event.Array.clear2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7XJn; else goto c7XJo;
       c7XJn: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XJo: // global
           I64[Sp - 8] = block_c7XJf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XJs; else goto c7XJg;
       u7XJs: // global
           call _c7XJf(R1) args: 0, res: 0, upd: 0;
       c7XJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XJf() //  [R1]
         { info_tbl: [(c7XJf,
                       label: block_c7XJf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XJr; else goto c7XJq;
       c7XJr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XJq: // global
           _s7WQh::P64 = P64[R1 + 7];
           _s7WQj::I64 = I64[R1 + 23];
           I64[Hp - 48] = GHC.Event.Array.AC_con_info;
           P64[Hp - 40] = _s7WQh::P64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = _s7WQj::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.883767978 UTC

[section ""data" . GHC.Event.Array.clear1_closure" {
     GHC.Event.Array.clear1_closure:
         const GHC.Event.Array.clear1_info;
 },
 GHC.Event.Array.clear1_entry() //  [R2]
         { info_tbl: [(c7XJA,
                       label: GHC.Event.Array.clear1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7XJG; else goto c7XJH;
       c7XJG: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XJH: // global
           I64[Sp - 8] = block_c7XJx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XJP; else goto c7XJy;
       u7XJP: // global
           call _c7XJx(R1) args: 0, res: 0, upd: 0;
       c7XJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XJx() //  [R1]
         { info_tbl: [(c7XJx,
                       label: block_c7XJx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJx: // global
           I64[Sp] = block_c7XJD_info;
           R2 = GHC.Event.Array.clear2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XJD() //  [R1]
         { info_tbl: [(c7XJD,
                       label: block_c7XJD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJD: // global
           I64[Sp] = block_c7XJF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7XJQ; else goto c7XJK;
       u7XJQ: // global
           call _c7XJF() args: 0, res: 0, upd: 0;
       c7XJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XJF() //  []
         { info_tbl: [(c7XJF,
                       label: block_c7XJF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.885161419 UTC

[section ""data" . GHC.Event.Array.clear_closure" {
     GHC.Event.Array.clear_closure:
         const GHC.Event.Array.clear_info;
 },
 GHC.Event.Array.clear_entry() //  [R2]
         { info_tbl: [(c7XJV,
                       label: GHC.Event.Array.clear_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XJV: // global
           R2 = R2;
           call GHC.Event.Array.clear1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.886210853 UTC

[section ""cstring" . lvl5_r7WM9_bytes" {
     lvl5_r7WM9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.886972258 UTC

[section ""data" . lvl6_r7WMa_closure" {
     lvl6_r7WMa_closure:
         const lvl6_r7WMa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r7WMa_entry() //  [R1]
         { info_tbl: [(c7XK4,
                       label: lvl6_r7WMa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XK4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XK5; else goto c7XK6;
       c7XK5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XK6: // global
           (_c7XK1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XK1::I64 == 0) goto c7XK3; else goto c7XK2;
       c7XK3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XK2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XK1::I64;
           R2 = lvl5_r7WM9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.887878903 UTC

[section ""cstring" . GHC.Event.Array.$trModule4_bytes" {
     GHC.Event.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.888583068 UTC

[section ""data" . lvl7_r7WMb_closure" {
     lvl7_r7WMb_closure:
         const lvl7_r7WMb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r7WMb_entry() //  [R1]
         { info_tbl: [(c7XKd,
                       label: lvl7_r7WMb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XKe; else goto c7XKf;
       c7XKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XKf: // global
           (_c7XKa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XKa::I64 == 0) goto c7XKc; else goto c7XKb;
       c7XKc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XKb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XKa::I64;
           R2 = GHC.Event.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.889558757 UTC

[section ""cstring" . GHC.Event.Array.$trModule2_bytes" {
     GHC.Event.Array.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.890309902 UTC

[section ""data" . lvl8_r7WMc_closure" {
     lvl8_r7WMc_closure:
         const lvl8_r7WMc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r7WMc_entry() //  [R1]
         { info_tbl: [(c7XKm,
                       label: lvl8_r7WMc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XKm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XKn; else goto c7XKo;
       c7XKn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XKo: // global
           (_c7XKj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XKj::I64 == 0) goto c7XKl; else goto c7XKk;
       c7XKl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XKk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XKj::I64;
           R2 = GHC.Event.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.89122664 UTC

[section ""cstring" . lvl9_r7WMd_bytes" {
     lvl9_r7WMd_bytes:
         I8[] [46,47,71,72,67,47,69,118,101,110,116,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.891951053 UTC

[section ""data" . lvl10_r7WMe_closure" {
     lvl10_r7WMe_closure:
         const lvl10_r7WMe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_r7WMe_entry() //  [R1]
         { info_tbl: [(c7XKv,
                       label: lvl10_r7WMe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XKv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XKw; else goto c7XKx;
       c7XKw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XKx: // global
           (_c7XKs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XKs::I64 == 0) goto c7XKu; else goto c7XKt;
       c7XKu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XKt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XKs::I64;
           R2 = lvl9_r7WMd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.892900981 UTC

[section ""data" . lvl11_r7WMf_closure" {
     lvl11_r7WMf_closure:
         const GHC.Types.I#_con_info;
         const 179;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.893590956 UTC

[section ""data" . lvl12_r7WMg_closure" {
     lvl12_r7WMg_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.894170709 UTC

[section ""data" . lvl13_r7WMh_closure" {
     lvl13_r7WMh_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.894769746 UTC

[section ""data" . lvl14_r7WMi_closure" {
     lvl14_r7WMi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl11_r7WMf_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl11_r7WMf_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.895402257 UTC

[section ""data" . lvl15_r7WMj_closure" {
     lvl15_r7WMj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl14_r7WMi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.896278889 UTC

[section ""data" . GHC.Event.Array.forM_1_closure" {
     GHC.Event.Array.forM_1_closure:
         const GHC.Event.Array.forM_1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.forM_1_entry() //  [R1]
         { info_tbl: [(c7XKE,
                       label: GHC.Event.Array.forM_1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XKE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XKF; else goto c7XKG;
       c7XKF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XKG: // global
           (_c7XKB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XKB::I64 == 0) goto c7XKD; else goto c7XKC;
       c7XKD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XKC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XKB::I64;
           R2 = lvl15_r7WMj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.898817138 UTC

[section ""data" . GHC.Event.Array.forM__closure" {
     GHC.Event.Array.forM__closure:
         const GHC.Event.Array.forM__info;
         const 0;
 },
 size_s7WQu_entry() //  [R1]
         { info_tbl: [(c7XKP,
                       label: size_s7WQu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XKP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XKQ; else goto c7XKR;
       c7XKQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XKR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.forM_1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WR3_entry() //  [R1, R2, R3]
         { info_tbl: [(c7XL0,
                       label: sat_s7WR3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XL0: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c7XLe; else goto c7XLf;
       c7XLe: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XLf: // global
           I64[Sp - 32] = block_c7XKX_info;
           _s7WQt::P64 = P64[R1 + 5];
           _s7WQu::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s7WQt::P64;
           P64[Sp - 16] = _s7WQu::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7XM1; else goto c7XKY;
       u7XM1: // global
           call _c7XKX(R1) args: 0, res: 0, upd: 0;
       c7XKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XKX() //  [R1]
         { info_tbl: [(c7XKX,
                       label: block_c7XKX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XKX: // global
           _s7WQC::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XL3_info;
           R1 = _s7WQC::P64;
           if (R1 & 7 != 0) goto u7XM0; else goto c7XL4;
       u7XM0: // global
           call _c7XL3(R1) args: 0, res: 0, upd: 0;
       c7XL4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XL3() //  [R1]
         { info_tbl: [(c7XL3,
                       label: block_c7XL3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XL3: // global
           I64[Sp - 8] = block_c7XL8_info;
           _s7WQF::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WQF::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XM2; else goto c7XL9;
       u7XM2: // global
           call _c7XL8(R1) args: 0, res: 0, upd: 0;
       c7XL9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XL8() //  [R1]
         { info_tbl: [(c7XL8,
                       label: block_c7XL8_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XL8: // global
           I64[Sp - 8] = block_c7XLd_info;
           _s7WQJ::P64 = P64[R1 + 7];
           _s7WQI::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WQJ::P64;
           I64[Sp + 24] = _s7WQI::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XM3; else goto c7XLj;
       u7XM3: // global
           call _c7XLd(R1) args: 0, res: 0, upd: 0;
       c7XLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XLd() //  [R1]
         { info_tbl: [(c7XLd,
                       label: block_c7XLd_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XLd: // global
           I64[Sp - 8] = 0;
           _s7WQL::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7WQL::I64;
           I64[Sp + 16] = _s7WQL::I64;
           Sp = Sp - 8;
           call _c7XLA() args: 0, res: 0, upd: 0;
     }
 },
 _c7XLA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XLA: // global
           Hp = Hp + 16;
           _s7WQR::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c7XLE; else goto c7XLD;
       c7XLE: // global
           HpAlloc = 16;
           I64[Sp] = block_c7XLz_info;
           R1 = _s7WQR::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7XLD: // global
           if (%MO_S_Lt_W64(_s7WQR::I64,
                            I64[Sp + 8])) goto c7XLQ; else goto c7XLU;
       c7XLQ: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 40] + _s7WQR::I64;
           I64[Sp - 8] = block_c7XLM_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 24;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7XLU: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XLz() //  [R1]
         { info_tbl: [(c7XLz,
                       label: block_c7XLz_info
                       rep:StackRep [True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XLz: // global
           I64[Sp] = R1;
           call _c7XLA() args: 0, res: 0, upd: 0;
     }
 },
 _c7XLM() //  [R1]
         { info_tbl: [(c7XLM,
                       label: block_c7XLM_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XLM: // global
           I64[Sp] = block_c7XLO_info;
           R2 = R1;
           R1 = P64[Sp + 56];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XLO() //  []
         { info_tbl: [(c7XLO,
                       label: block_c7XLO_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XLO: // global
           I64[Sp + 8] = I64[Sp + 8] + I64[Sp + 32];
           Sp = Sp + 8;
           call _c7XLA() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.forM__entry() //  [R2]
         { info_tbl: [(c7XM7,
                       label: GHC.Event.Array.forM__info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XM7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XMb; else goto c7XMa;
       c7XMb: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.forM__closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XMa: // global
           I64[Hp - 40] = size_s7WQu_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WR3_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.903062039 UTC

[section ""data" . lvl16_r7WMk_closure" {
     lvl16_r7WMk_closure:
         const GHC.Types.I#_con_info;
         const 194;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.903968764 UTC

[section ""data" . lvl17_r7WMl_closure" {
     lvl17_r7WMl_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.906423819 UTC

[section ""data" . lvl18_r7WMm_closure" {
     lvl18_r7WMm_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.907297779 UTC

[section ""data" . lvl19_r7WMn_closure" {
     lvl19_r7WMn_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl16_r7WMk_closure+1;
         const lvl17_r7WMl_closure+1;
         const lvl16_r7WMk_closure+1;
         const lvl18_r7WMm_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.908311654 UTC

[section ""data" . lvl20_r7WMo_closure" {
     lvl20_r7WMo_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl19_r7WMn_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.909682356 UTC

[section ""data" . GHC.Event.Array.loop1_closure" {
     GHC.Event.Array.loop1_closure:
         const GHC.Event.Array.loop1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.loop1_entry() //  [R1]
         { info_tbl: [(c7XMi,
                       label: GHC.Event.Array.loop1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XMi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XMj; else goto c7XMk;
       c7XMj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XMk: // global
           (_c7XMf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XMf::I64 == 0) goto c7XMh; else goto c7XMg;
       c7XMh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XMg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XMf::I64;
           R2 = lvl20_r7WMo_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.913578908 UTC

[section ""data" . GHC.Event.Array.loop_closure" {
     GHC.Event.Array.loop_closure:
         const GHC.Event.Array.loop_info;
         const 0;
 },
 size_s7WR5_entry() //  [R1]
         { info_tbl: [(c7XMt,
                       label: size_s7WR5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XMt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XMu; else goto c7XMv;
       c7XMu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XMv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.loop1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WRN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c7XME,
                       label: sat_s7WRN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XME: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7XMS; else goto c7XMT;
       c7XMS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XMT: // global
           I64[Sp - 40] = block_c7XMB_info;
           _s7WR4::P64 = P64[R1 + 4];
           _s7WR5::P64 = P64[R1 + 12];
           R1 = R2;
           P64[Sp - 32] = _s7WR4::P64;
           P64[Sp - 24] = _s7WR5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7XO4; else goto c7XMC;
       u7XO4: // global
           call _c7XMB(R1) args: 0, res: 0, upd: 0;
       c7XMC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XMB() //  [R1]
         { info_tbl: [(c7XMB,
                       label: block_c7XMB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XMB: // global
           _s7WRe::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XMH_info;
           R1 = _s7WRe::P64;
           if (R1 & 7 != 0) goto u7XO3; else goto c7XMI;
       u7XO3: // global
           call _c7XMH(R1) args: 0, res: 0, upd: 0;
       c7XMI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XMH() //  [R1]
         { info_tbl: [(c7XMH,
                       label: block_c7XMH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XMH: // global
           I64[Sp - 8] = block_c7XMM_info;
           _s7WRh::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WRh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XO5; else goto c7XMN;
       u7XO5: // global
           call _c7XMM(R1) args: 0, res: 0, upd: 0;
       c7XMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XMM() //  [R1]
         { info_tbl: [(c7XMM,
                       label: block_c7XMM_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XMM: // global
           I64[Sp - 8] = block_c7XMR_info;
           _s7WRl::P64 = P64[R1 + 7];
           _s7WRk::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WRl::P64;
           I64[Sp + 24] = _s7WRk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XO6; else goto c7XMX;
       u7XO6: // global
           call _c7XMR(R1) args: 0, res: 0, upd: 0;
       c7XMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XMR() //  [R1]
         { info_tbl: [(c7XMR,
                       label: block_c7XMR_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XMR: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           _s7WRn::I64 = I64[R1 + 7];
           I64[Sp + 16] = I64[Sp + 16] * _s7WRn::I64;
           I64[Sp + 40] = _s7WRn::I64;
           Sp = Sp - 16;
           call _c7XNj() args: 0, res: 0, upd: 0;
     }
 },
 _c7XNj() //  []
         { info_tbl: [(c7XNj,
                       label: block_c7XNj_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XNj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XNo; else goto c7XNn;
       c7XNo: // global
           HpAlloc = 16;
           I64[Sp] = block_c7XNj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7XNn: // global
           _s7WRw::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_s7WRw::I64,
                            I64[Sp + 32])) goto c7XNC; else goto c7XNW;
       c7XNC: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 48] + _s7WRw::I64;
           I64[Sp] = block_c7XNw_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7XNW: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XNw() //  [R1]
         { info_tbl: [(c7XNw,
                       label: block_c7XNw_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XNw: // global
           _s7WRx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7XNy_info;
           R3 = R1;
           R2 = _s7WRx::P64;
           R1 = P64[Sp + 64];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XNy() //  [R1]
         { info_tbl: [(c7XNy,
                       label: block_c7XNy_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XNy: // global
           I64[Sp] = block_c7XNA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7XO8; else goto c7XNF;
       u7XO8: // global
           call _c7XNA(R1) args: 0, res: 0, upd: 0;
       c7XNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XNA() //  [R1]
         { info_tbl: [(c7XNA,
                       label: block_c7XNA_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XNA: // global
           I64[Sp - 8] = block_c7XNJ_info;
           _s7WRJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s7WRJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XO9; else goto c7XNL;
       u7XO9: // global
           call _c7XNJ(R1) args: 0, res: 0, upd: 0;
       c7XNL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XNJ() //  [R1]
         { info_tbl: [(c7XNJ,
                       label: block_c7XNJ_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XNJ: // global
           if (R1 & 7 == 1) goto c7XNR; else goto c7XNV;
       c7XNR: // global
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XNV: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           call _c7XNj() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.loop_entry() //  [R2]
         { info_tbl: [(c7XOb,
                       label: GHC.Event.Array.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XOf; else goto c7XOe;
       c7XOf: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XOe: // global
           I64[Hp - 40] = size_s7WR5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WRN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 12;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.918882231 UTC

[section ""data" . GHC.Event.Array.$trModule3_closure" {
     GHC.Event.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.919472954 UTC

[section ""data" . GHC.Event.Array.$trModule1_closure" {
     GHC.Event.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.920063073 UTC

[section ""data" . GHC.Event.Array.$trModule_closure" {
     GHC.Event.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Array.$trModule3_closure+1;
         const GHC.Event.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.920655103 UTC

[section ""data" . $krep_r7WMp_closure" {
     $krep_r7WMp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.921288306 UTC

[section ""data" . $krep1_r7WMq_closure" {
     $krep1_r7WMq_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.921887079 UTC

[section ""data" . $krep2_r7WMr_closure" {
     $krep2_r7WMr_closure:
         const :_con_info;
         const $krep1_r7WMq_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.922433619 UTC

[section ""data" . $krep3_r7WMs_closure" {
     $krep3_r7WMs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.922997214 UTC

[section ""cstring" . GHC.Event.Array.$tcAC2_bytes" {
     GHC.Event.Array.$tcAC2_bytes:
         I8[] [65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.923561609 UTC

[section ""data" . GHC.Event.Array.$tcAC1_closure" {
     GHC.Event.Array.$tcAC1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcAC2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.92413806 UTC

[section ""data" . GHC.Event.Array.$tcAC_closure" {
     GHC.Event.Array.$tcAC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcAC1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14339520722473255067;
         const 15778732457674388659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.924702503 UTC

[section ""data" . $krep4_r7WMt_closure" {
     $krep4_r7WMt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcAC_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.925322013 UTC

[section ""data" . $krep5_r7WMu_closure" {
     $krep5_r7WMu_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep4_r7WMt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.925955899 UTC

[section ""data" . $krep6_r7WMv_closure" {
     $krep6_r7WMv_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep5_r7WMu_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.926537574 UTC

[section ""data" . GHC.Event.Array.$tc'AC1_closure" {
     GHC.Event.Array.$tc'AC1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7WMs_closure+1;
         const $krep6_r7WMv_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.927113712 UTC

[section ""cstring" . GHC.Event.Array.$tc'AC3_bytes" {
     GHC.Event.Array.$tc'AC3_bytes:
         I8[] [39,65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.927633803 UTC

[section ""data" . GHC.Event.Array.$tc'AC2_closure" {
     GHC.Event.Array.$tc'AC2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'AC3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.928208835 UTC

[section ""data" . GHC.Event.Array.$tc'AC_closure" {
     GHC.Event.Array.$tc'AC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'AC2_closure+1;
         const GHC.Event.Array.$tc'AC1_closure+4;
         const 954782197074941232;
         const 8411064637322477330;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.92878771 UTC

[section ""data" . $krep7_r7WMw_closure" {
     $krep7_r7WMw_closure:
         const :_con_info;
         const $krep4_r7WMt_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.929395811 UTC

[section ""data" . $krep8_r7WMx_closure" {
     $krep8_r7WMx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep7_r7WMw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.929969384 UTC

[section ""cstring" . GHC.Event.Array.$tcArray2_bytes" {
     GHC.Event.Array.$tcArray2_bytes:
         I8[] [65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.930586904 UTC

[section ""data" . GHC.Event.Array.$tcArray1_closure" {
     GHC.Event.Array.$tcArray1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcArray2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.931154124 UTC

[section ""data" . GHC.Event.Array.$tcArray_closure" {
     GHC.Event.Array.$tcArray_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcArray1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18201768782471713089;
         const 1209293416176401920;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.931808205 UTC

[section ""data" . $krep9_r7WMy_closure" {
     $krep9_r7WMy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.932394992 UTC

[section ""data" . GHC.Event.Array.$tc'Array1_closure" {
     GHC.Event.Array.$tc'Array1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r7WMx_closure+1;
         const $krep9_r7WMy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.932981476 UTC

[section ""cstring" . GHC.Event.Array.$tc'Array3_bytes" {
     GHC.Event.Array.$tc'Array3_bytes:
         I8[] [39,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.933711735 UTC

[section ""data" . GHC.Event.Array.$tc'Array2_closure" {
     GHC.Event.Array.$tc'Array2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'Array3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.9351755 UTC

[section ""data" . GHC.Event.Array.$tc'Array_closure" {
     GHC.Event.Array.$tc'Array_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'Array2_closure+1;
         const GHC.Event.Array.$tc'Array1_closure+4;
         const 1928439007980526225;
         const 8720085055779125030;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.935763634 UTC

[section ""data" . lvl21_r7WMz_closure" {
     lvl21_r7WMz_closure:
         const GHC.Types.I#_con_info;
         const 265;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.936318843 UTC

[section ""data" . lvl22_r7WMA_closure" {
     lvl22_r7WMA_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl21_r7WMz_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl21_r7WMz_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.936933865 UTC

[section ""data" . lvl23_r7WMB_closure" {
     lvl23_r7WMB_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl22_r7WMA_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.93786164 UTC

[section ""data" . GHC.Event.Array.removeAt2_closure" {
     GHC.Event.Array.removeAt2_closure:
         const GHC.Event.Array.removeAt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt2_entry() //  [R1]
         { info_tbl: [(c7XOm,
                       label: GHC.Event.Array.removeAt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XOn; else goto c7XOo;
       c7XOn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XOo: // global
           (_c7XOj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XOj::I64 == 0) goto c7XOl; else goto c7XOk;
       c7XOl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XOk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XOj::I64;
           R2 = lvl23_r7WMB_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.938805686 UTC

[section ""cstring" . lvl24_r7WMC_bytes" {
     lvl24_r7WMC_bytes:
         I8[] [114,101,109,111,118,101,65,116,58,32,105,110,118,97,108,105,100,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.939598746 UTC

[section ""data" . GHC.Event.Array.removeAt1_closure" {
     GHC.Event.Array.removeAt1_closure:
         const GHC.Event.Array.removeAt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt1_entry() //  [R1]
         { info_tbl: [(c7XOx,
                       label: GHC.Event.Array.removeAt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XOy; else goto c7XOz;
       c7XOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XOz: // global
           (_c7XOs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XOs::I64 == 0) goto c7XOu; else goto c7XOt;
       c7XOu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XOt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XOs::I64;
           I64[Sp - 24] = block_c7XOv_info;
           R2 = lvl24_r7WMC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XOv() //  [R1]
         { info_tbl: [(c7XOv,
                       label: block_c7XOv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.942362829 UTC

[section ""data" . GHC.Event.Array.removeAt_closure" {
     GHC.Event.Array.removeAt_closure:
         const GHC.Event.Array.removeAt_info;
         const 0;
 },
 size_s7WRQ_entry() //  [R1]
         { info_tbl: [(c7XOL,
                       label: size_s7WRQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XOM; else goto c7XON;
       c7XOM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.removeAt2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WSA_entry() //  [R1, R2, R3]
         { info_tbl: [(c7XOW,
                       label: sat_s7WSA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOW: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c7XPa; else goto c7XPb;
       c7XPa: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XPb: // global
           I64[Sp - 24] = block_c7XOT_info;
           _s7WRQ::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s7WRQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XQD; else goto c7XOU;
       u7XQD: // global
           call _c7XOT(R1) args: 0, res: 0, upd: 0;
       c7XOU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XOT() //  [R1]
         { info_tbl: [(c7XOT,
                       label: block_c7XOT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOT: // global
           I64[Sp - 8] = block_c7XOZ_info;
           _s7WRV::P64 = P64[R1 + 7];
           R1 = P64[_s7WRV::P64 + 8];
           P64[Sp] = _s7WRV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XQC; else goto c7XP0;
       u7XQC: // global
           call _c7XOZ(R1) args: 0, res: 0, upd: 0;
       c7XP0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XOZ() //  [R1]
         { info_tbl: [(c7XOZ,
                       label: block_c7XOZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XOZ: // global
           I64[Sp - 16] = block_c7XP4_info;
           _s7WS1::I64 = I64[R1 + 15];
           _s7WS2::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WS2::I64;
           I64[Sp] = _s7WS1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XQE; else goto c7XP5;
       u7XQE: // global
           call _c7XP4(R1) args: 0, res: 0, upd: 0;
       c7XP5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XP4() //  [R1]
         { info_tbl: [(c7XP4,
                       label: block_c7XP4_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XP4: // global
           I64[Sp - 16] = block_c7XP9_info;
           _s7WS3::P64 = R1;
           _s7WS5::P64 = P64[R1 + 7];
           _s7WS4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 40];
           P64[Sp - 8] = _s7WS5::P64;
           I64[Sp] = _s7WS4::I64;
           P64[Sp + 40] = _s7WS3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XQF; else goto c7XPf;
       u7XQF: // global
           call _c7XP9(R1) args: 0, res: 0, upd: 0;
       c7XPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XP9() //  [R1]
         { info_tbl: [(c7XP9,
                       label: block_c7XP9_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XP9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XPl; else goto c7XPk;
       c7XPl: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XPk: // global
           _s7WS7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s7WS7::I64, 0)) goto c7XPW; else goto c7XPV;
       c7XPV: // global
           _s7WS1::I64 = I64[Sp + 32];
           if (%MO_S_Ge_W64(_s7WS7::I64,
                            _s7WS1::I64)) goto c7XPW; else goto c7XPS;
       c7XPW: // global
           Hp = Hp - 32;
           R1 = GHC.Event.Array.removeAt1_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c7XPS: // global
           _s7WRV::P64 = P64[Sp + 40];
           _s7WS2::I64 = I64[Sp + 24];
           _s7WS3::P64 = P64[Sp + 56];
           _s7WSa::I64 = _s7WS1::I64 - 1;
           if (%MO_S_Le_W64(_s7WSa::I64, 0)) goto c7XPy; else goto c7XPQ;
       c7XPy: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XPQ: // global
           if (%MO_S_Ge_W64(_s7WS7::I64,
                            _s7WSa::I64)) goto c7XPE; else goto c7XPI;
       c7XPE: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XPI: // global
           Hp = Hp - 32;
           I64[Sp] = block_c7XPH_info;
           R1 = P64[Sp + 48];
           I64[Sp + 32] = _s7WSa::I64;
           I64[Sp + 48] = _s7WS7::I64;
           if (R1 & 7 != 0) goto u7XQG; else goto c7XPJ;
       u7XQG: // global
           call _c7XPH(R1) args: 0, res: 0, upd: 0;
       c7XPJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XPH() //  [R1]
         { info_tbl: [(c7XPH,
                       label: block_c7XPH_info
                       rep:StackRep [False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XPH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XPP; else goto c7XPO;
       c7XPP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XPO: // global
           _s7WRV::P64 = P64[Sp + 40];
           _s7WS2::I64 = I64[Sp + 24];
           _s7WS3::P64 = P64[Sp + 56];
           _s7WS4::I64 = I64[Sp + 16];
           _s7WS5::P64 = P64[Sp + 8];
           _s7WS7::I64 = I64[Sp + 48];
           _s7WSa::I64 = I64[Sp + 32];
           _s7WSi::I64 = I64[R1 + 7];
           (_s7WSu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7WS4::I64 + _s7WSi::I64 * _s7WS7::I64, _s7WS4::I64 + _s7WSi::I64 * (_s7WS7::I64 + 1), _s7WSi::I64 * (_s7WSa::I64 - _s7WS7::I64));
           call MO_Touch(_s7WS5::P64);
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.removeAt_entry() //  [R2]
         { info_tbl: [(c7XQH,
                       label: GHC.Event.Array.removeAt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XQH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7XQL; else goto c7XQK;
       c7XQL: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Event.Array.removeAt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XQK: // global
           I64[Hp - 32] = size_s7WRQ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7WSA_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.946094801 UTC

[section ""data" . lvl25_r7WMD_closure" {
     lvl25_r7WMD_closure:
         const GHC.Types.I#_con_info;
         const 211;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.946743284 UTC

[section ""data" . lvl26_r7WME_closure" {
     lvl26_r7WME_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.947297596 UTC

[section ""data" . lvl27_r7WMF_closure" {
     lvl27_r7WMF_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.947855982 UTC

[section ""data" . lvl28_r7WMG_closure" {
     lvl28_r7WMG_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl25_r7WMD_closure+1;
         const lvl26_r7WME_closure+1;
         const lvl25_r7WMD_closure+1;
         const lvl27_r7WMF_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.948496002 UTC

[section ""data" . lvl29_r7WMH_closure" {
     lvl29_r7WMH_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl28_r7WMG_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.949438001 UTC

[section ""data" . GHC.Event.Array.findIndex1_closure" {
     GHC.Event.Array.findIndex1_closure:
         const GHC.Event.Array.findIndex1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.findIndex1_entry() //  [R1]
         { info_tbl: [(c7XQS,
                       label: GHC.Event.Array.findIndex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XQT; else goto c7XQU;
       c7XQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XQU: // global
           (_c7XQP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XQP::I64 == 0) goto c7XQR; else goto c7XQQ;
       c7XQR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XQQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XQP::I64;
           R2 = lvl29_r7WMH_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.951994351 UTC

[section ""data" . GHC.Event.Array.findIndex_closure" {
     GHC.Event.Array.findIndex_closure:
         const GHC.Event.Array.findIndex_info;
         const 0;
 },
 size_s7WSC_entry() //  [R1]
         { info_tbl: [(c7XR3,
                       label: size_s7WSC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XR3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7XR4; else goto c7XR5;
       c7XR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.findIndex1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WTj_entry() //  [R1, R2, R3]
         { info_tbl: [(c7XRe,
                       label: sat_s7WTj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRe: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7XRs; else goto c7XRt;
       c7XRs: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XRt: // global
           I64[Sp - 32] = block_c7XRb_info;
           _s7WSB::P64 = P64[R1 + 5];
           _s7WSC::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s7WSB::P64;
           P64[Sp - 16] = _s7WSC::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7XSD; else goto c7XRc;
       u7XSD: // global
           call _c7XRb(R1) args: 0, res: 0, upd: 0;
       c7XRc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XRb() //  [R1]
         { info_tbl: [(c7XRb,
                       label: block_c7XRb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRb: // global
           _s7WSK::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7XRh_info;
           R1 = _s7WSK::P64;
           if (R1 & 7 != 0) goto u7XSC; else goto c7XRi;
       u7XSC: // global
           call _c7XRh(R1) args: 0, res: 0, upd: 0;
       c7XRi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XRh() //  [R1]
         { info_tbl: [(c7XRh,
                       label: block_c7XRh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRh: // global
           I64[Sp - 8] = block_c7XRm_info;
           _s7WSN::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WSN::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XSE; else goto c7XRn;
       u7XSE: // global
           call _c7XRm(R1) args: 0, res: 0, upd: 0;
       c7XRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XRm() //  [R1]
         { info_tbl: [(c7XRm,
                       label: block_c7XRm_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRm: // global
           I64[Sp - 8] = block_c7XRr_info;
           _s7WSR::P64 = P64[R1 + 7];
           _s7WSQ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WSR::P64;
           I64[Sp + 24] = _s7WSQ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7XSF; else goto c7XRx;
       u7XSF: // global
           call _c7XRr(R1) args: 0, res: 0, upd: 0;
       c7XRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XRr() //  [R1]
         { info_tbl: [(c7XRr,
                       label: block_c7XRr_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRr: // global
           I64[Sp - 16] = 0;
           I64[Sp - 8] = 0;
           _s7WST::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7WST::I64;
           I64[Sp + 16] = _s7WST::I64;
           Sp = Sp - 24;
           call _c7XRZ() args: 0, res: 0, upd: 0;
     }
 },
 _c7XRZ() //  []
         { info_tbl: [(c7XRZ,
                       label: block_c7XRZ_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XS4; else goto c7XS3;
       c7XS4: // global
           HpAlloc = 16;
           I64[Sp] = block_c7XRZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7XS3: // global
           _s7WT7::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7WT7::I64,
                            I64[Sp + 24])) goto c7XSg; else goto c7XSs;
       c7XSg: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 56] + _s7WT7::I64;
           I64[Sp] = block_c7XSc_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7XSs: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 32]);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XSc() //  [R1]
         { info_tbl: [(c7XSc,
                       label: block_c7XSc_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XSc: // global
           I64[Sp - 8] = block_c7XSe_info;
           R2 = R1;
           _s7WTf::P64 = R1;
           R1 = P64[Sp + 64];
           P64[Sp] = _s7WTf::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XSe() //  [R1]
         { info_tbl: [(c7XSe,
                       label: block_c7XSe_info
                       rep:StackRep [False, True, True, True, False, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XSe: // global
           _s7WT8::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7XSn; else goto c7XSr;
       c7XSn: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 48];
           I64[Sp + 24] = _s7WT8::I64 + 1;
           Sp = Sp + 8;
           call _c7XRZ() args: 0, res: 0, upd: 0;
       c7XSr: // global
           P64[Sp + 64] = P64[Sp + 8];
           I64[Sp + 72] = _s7WT8::I64;
           Sp = Sp + 32;
           call _c7XRH() args: 0, res: 0, upd: 0;
     }
 },
 _c7XRH() //  []
         { info_tbl: [(c7XRH,
                       label: block_c7XRH_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XRH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XRQ; else goto c7XRP;
       c7XRQ: // global
           HpAlloc = 56;
           I64[Sp] = block_c7XRH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7XRP: // global
           _s7WSW::I64 = I64[Sp + 40];
           _s7WSY::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7WSW::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s7WSY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.findIndex_entry() //  [R2]
         { info_tbl: [(c7XSJ,
                       label: GHC.Event.Array.findIndex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XSJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7XSN; else goto c7XSM;
       c7XSN: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.findIndex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7XSM: // global
           I64[Hp - 40] = size_s7WSC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WTj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.955603618 UTC

[section ""data" . lvl30_r7WMI_closure" {
     lvl30_r7WMI_closure:
         const GHC.Types.I#_con_info;
         const 74;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.956176441 UTC

[section ""data" . lvl31_r7WMJ_closure" {
     lvl31_r7WMJ_closure:
         const GHC.Types.I#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.95678592 UTC

[section ""data" . lvl32_r7WMK_closure" {
     lvl32_r7WMK_closure:
         const GHC.Types.I#_con_info;
         const 55;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.957335809 UTC

[section ""data" . lvl33_r7WML_closure" {
     lvl33_r7WML_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl30_r7WMI_closure+1;
         const lvl31_r7WMJ_closure+1;
         const lvl30_r7WMI_closure+1;
         const lvl32_r7WMK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.958020674 UTC

[section ""data" . lvl34_r7WMM_closure" {
     lvl34_r7WMM_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl33_r7WML_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.958955878 UTC

[section ""data" . GHC.Event.Array.ensureCapacity2_closure" {
     GHC.Event.Array.ensureCapacity2_closure:
         const GHC.Event.Array.ensureCapacity2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.ensureCapacity2_entry() //  [R1]
         { info_tbl: [(c7XSU,
                       label: GHC.Event.Array.ensureCapacity2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XSU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XSV; else goto c7XSW;
       c7XSV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XSW: // global
           (_c7XSR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XSR::I64 == 0) goto c7XST; else goto c7XSS;
       c7XST: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XSS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XSR::I64;
           R2 = lvl34_r7WMM_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.962177844 UTC

[section ""data" . GHC.Event.Array.$wensureCapacity_closure" {
     GHC.Event.Array.$wensureCapacity_closure:
         const GHC.Event.Array.$wensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.$wensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XT4,
                       label: GHC.Event.Array.$wensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XT4: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c7XT8; else goto c7XT9;
       c7XT8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wensureCapacity_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XT9: // global
           I64[Sp - 32] = block_c7XT1_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7XVt; else goto c7XT2;
       u7XVt: // global
           call _c7XT1(R1) args: 0, res: 0, upd: 0;
       c7XT2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XT1() //  [R1]
         { info_tbl: [(c7XT1,
                       label: block_c7XT1_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XT1: // global
           I64[Sp - 16] = block_c7XT7_info;
           _s7WTt::I64 = I64[R1 + 15];
           _s7WTu::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WTu::I64;
           I64[Sp] = _s7WTt::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XVs; else goto c7XTb;
       u7XVs: // global
           call _c7XT7(R1) args: 0, res: 0, upd: 0;
       c7XTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XT7() //  [R1]
         { info_tbl: [(c7XT7,
                       label: block_c7XT7_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XT7: // global
           if (%MO_S_Le_W64(I64[Sp + 40],
                            I64[Sp + 8])) goto c7XTj; else goto c7XTn;
       c7XTj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XTn: // global
           I64[Sp - 8] = block_c7XTm_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7XTm() //  [R1]
         { info_tbl: [(c7XTm,
                       label: block_c7XTm_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XTm: // global
           _s7WTA::I64 = I64[R1 + 7];
           _s7WTB::I64 = I64[Sp + 48] - 1;
           _s7WTC::I64 = _s7WTB::I64 | %MO_S_Shr_W64(_s7WTB::I64, 1);
           _s7WTE::I64 = _s7WTC::I64 | %MO_S_Shr_W64(_s7WTC::I64, 2);
           _s7WTG::I64 = _s7WTE::I64 | %MO_S_Shr_W64(_s7WTE::I64, 4);
           _s7WTI::I64 = _s7WTG::I64 | %MO_S_Shr_W64(_s7WTG::I64, 8);
           _s7WTK::I64 = _s7WTI::I64 | %MO_S_Shr_W64(_s7WTI::I64, 16);
           _s7WTM::I64 = _s7WTK::I64 | %MO_S_Shr_W64(_s7WTK::I64, 32) + 1;
           _s7WTP::I64 = _s7WTM::I64 * _s7WTA::I64;
           if (%MO_S_Ge_W64(_s7WTP::I64, 0)) goto c7XUg; else goto c7XV6;
       c7XUg: // global
           I64[Sp - 8] = block_c7XUe_info;
           R1 = _s7WTP::I64;
           I64[Sp] = _s7WTM::I64;
           I64[Sp + 48] = _s7WTA::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7XV6: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XUe() //  [R1]
         { info_tbl: [(c7XUe,
                       label: block_c7XUe_info
                       rep:StackRep [True, False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XUe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7XUk; else goto c7XUj;
       c7XUk: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XUj: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           _s7WTl::P64 = P64[Sp + 48];
           _s7WTt::I64 = I64[Sp + 32];
           _s7WTu::I64 = I64[Sp + 24];
           _s7WTw::I64 = I64[Sp + 40];
           _s7WTx::P64 = P64[Sp + 16];
           _s7WTM::I64 = I64[Sp + 8];
           _s7WTU::I64 = R1 + 16;
           _c7XUo::P64 = Hp - 61;
           if (_s7WTw::I64 == 0) goto c7XV5; else goto c7XUX;
       c7XV5: // global
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7XV3; else goto c7XV4;
       c7XV4: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XUo::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XUX: // global
           if (%MO_S_Le_W64(_s7WTu::I64, 0)) goto c7XUC; else goto c7XUV;
       c7XUC: // global
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7XV3; else goto c7XUA;
       c7XUA: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XUo::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XUV: // global
           (_s7WU8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WTU::I64, _s7WTw::I64, _s7WTu::I64 * I64[Sp + 56]);
           call MO_Touch(_c7XUo::P64);
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7XV3; else goto c7XUU;
       c7XV3: // global
           Hp = Hp - 56;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7XUU: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7XUo::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.971861658 UTC

[section ""data" . GHC.Event.Array.ensureCapacity1_closure" {
     GHC.Event.Array.ensureCapacity1_closure:
         const GHC.Event.Array.ensureCapacity1_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XVB,
                       label: GHC.Event.Array.ensureCapacity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XVB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XVF; else goto c7XVG;
       c7XVF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.ensureCapacity1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XVG: // global
           I64[Sp - 24] = block_c7XVy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XVO; else goto c7XVz;
       u7XVO: // global
           call _c7XVy(R1) args: 0, res: 0, upd: 0;
       c7XVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XVy() //  [R1]
         { info_tbl: [(c7XVy,
                       label: block_c7XVy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XVy: // global
           I64[Sp] = block_c7XVE_info;
           _s7WUq::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WUq::P64;
           if (R1 & 7 != 0) goto u7XVN; else goto c7XVI;
       u7XVN: // global
           call _c7XVE(R1) args: 0, res: 0, upd: 0;
       c7XVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XVE() //  [R1]
         { info_tbl: [(c7XVE,
                       label: block_c7XVE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XVE: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wensureCapacity_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.974570838 UTC

[section ""data" . GHC.Event.Array.ensureCapacity_closure" {
     GHC.Event.Array.ensureCapacity_closure:
         const GHC.Event.Array.ensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XVT,
                       label: GHC.Event.Array.ensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XVT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.ensureCapacity1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.979866063 UTC

[section ""data" . GHC.Event.Array.$wsnoc_closure" {
     GHC.Event.Array.$wsnoc_closure:
         const GHC.Event.Array.$wsnoc_info;
         const 0;
 },
 GHC.Event.Array.$wsnoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XW3,
                       label: GHC.Event.Array.$wsnoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XW3: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c7XW7; else goto c7XW8;
       c7XW7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wsnoc_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XW8: // global
           I64[Sp - 32] = block_c7XW0_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7XYy; else goto c7XW1;
       u7XYy: // global
           call _c7XW0(R1) args: 0, res: 0, upd: 0;
       c7XW1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XW0() //  [R1]
         { info_tbl: [(c7XW0,
                       label: block_c7XW0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XW0: // global
           I64[Sp - 16] = block_c7XW6_info;
           _s7WUC::I64 = I64[R1 + 15];
           _s7WUD::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WUD::I64;
           I64[Sp] = _s7WUC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7XYx; else goto c7XWa;
       u7XYx: // global
           call _c7XW6(R1) args: 0, res: 0, upd: 0;
       c7XWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XW6() //  [R1]
         { info_tbl: [(c7XW6,
                       label: block_c7XW6_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XW6: // global
           _s7WUt::P64 = P64[Sp + 24];
           _s7WUC::I64 = I64[Sp + 16];
           _s7WUD::I64 = I64[Sp + 8];
           _s7WUG::P64 = P64[R1 + 7];
           _s7WUF::I64 = I64[R1 + 15];
           _s7WUH::I64 = _s7WUC::I64 + 1;
           if (%MO_S_Le_W64(_s7WUH::I64,
                            _s7WUD::I64)) goto c7XWn; else goto c7XWu;
       c7XWn: // global
           I64[Sp] = block_c7XWl_info;
           R6 = _s7WUC::I64;
           R5 = _s7WUD::I64;
           R4 = _s7WUG::P64;
           R3 = _s7WUF::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp + 24] = _s7WUH::I64;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7XWu: // global
           I64[Sp - 24] = block_c7XWt_info;
           R2 = _s7WUt::P64;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp - 16] = _s7WUG::P64;
           I64[Sp - 8] = _s7WUH::I64;
           I64[Sp] = _s7WUF::I64;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7XWl() //  [R1]
         { info_tbl: [(c7XWl,
                       label: block_c7XWl_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XWl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7XWr; else goto c7XWq;
       c7XWr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XWq: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XWt() //  [R1]
         { info_tbl: [(c7XWt,
                       label: block_c7XWt_info
                       rep:StackRep [False, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XWt: // global
           _s7WUP::I64 = I64[R1 + 7];
           _s7WUQ::I64 = I64[Sp + 16] - 1;
           _s7WUR::I64 = _s7WUQ::I64 | %MO_S_Shr_W64(_s7WUQ::I64, 1);
           _s7WUT::I64 = _s7WUR::I64 | %MO_S_Shr_W64(_s7WUR::I64, 2);
           _s7WUV::I64 = _s7WUT::I64 | %MO_S_Shr_W64(_s7WUT::I64, 4);
           _s7WUX::I64 = _s7WUV::I64 | %MO_S_Shr_W64(_s7WUV::I64, 8);
           _s7WUZ::I64 = _s7WUX::I64 | %MO_S_Shr_W64(_s7WUX::I64, 16);
           _s7WV1::I64 = _s7WUZ::I64 | %MO_S_Shr_W64(_s7WUZ::I64, 32) + 1;
           _s7WV4::I64 = _s7WV1::I64 * _s7WUP::I64;
           if (%MO_S_Ge_W64(_s7WV4::I64, 0)) goto c7XXn; else goto c7XYd;
       c7XXn: // global
           I64[Sp - 16] = block_c7XXl_info;
           R1 = _s7WV4::I64;
           I64[Sp - 8] = _s7WV1::I64;
           I64[Sp] = _s7WUP::I64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7XYd: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 72;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XXl() //  [R1]
         { info_tbl: [(c7XXl,
                       label: block_c7XXl_info
                       rep:StackRep [True, True, False, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XXl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7XXr; else goto c7XXq;
       c7XXr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XXq: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7WUt::P64 = P64[Sp + 64];
           _s7WUv::P64 = P64[Sp + 80];
           _s7WUC::I64 = I64[Sp + 56];
           _s7WUF::I64 = I64[Sp + 40];
           _s7WUG::P64 = P64[Sp + 24];
           _s7WV1::I64 = I64[Sp + 8];
           _s7WV9::I64 = R1 + 16;
           _c7XXv::P64 = Hp - 5;
           if (_s7WUF::I64 == 0) goto c7XY8; else goto c7XY4;
       c7XY8: // global
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7XY7_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7XXv::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7XXv::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7XY4: // global
           _s7WUD::I64 = I64[Sp + 48];
           if (%MO_S_Le_W64(_s7WUD::I64, 0)) goto c7XXF; else goto c7XXY;
       c7XXF: // global
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7XXD_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7XXv::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7XXv::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7XXY: // global
           (_s7WVp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WV9::I64, _s7WUF::I64, _s7WUD::I64 * I64[Sp + 16]);
           call MO_Touch(_c7XXv::P64);
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7XXX_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7XXv::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7XXv::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7XY7() //  [R1]
         { info_tbl: [(c7XY7,
                       label: block_c7XY7_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XY7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XYc; else goto c7XYb;
       c7XYc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XYb: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XXD() //  [R1]
         { info_tbl: [(c7XXD,
                       label: block_c7XXD_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XXD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XXJ; else goto c7XXI;
       c7XXJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XXI: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7XXX() //  [R1]
         { info_tbl: [(c7XXX,
                       label: block_c7XXX_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XXX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7XY2; else goto c7XY1;
       c7XY2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7XY1: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.990379951 UTC

[section ""data" . GHC.Event.Array.snoc1_closure" {
     GHC.Event.Array.snoc1_closure:
         const GHC.Event.Array.snoc1_info;
         const 0;
 },
 GHC.Event.Array.snoc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XYG,
                       label: GHC.Event.Array.snoc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XYG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XYH; else goto c7XYI;
       c7XYH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.snoc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7XYI: // global
           I64[Sp - 24] = block_c7XYD_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7XYM; else goto c7XYE;
       u7XYM: // global
           call _c7XYD(R1) args: 0, res: 0, upd: 0;
       c7XYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XYD() //  [R1]
         { info_tbl: [(c7XYD,
                       label: block_c7XYD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XYD: // global
           R4 = P64[Sp + 16];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.991779814 UTC

[section ""data" . GHC.Event.Array.snoc_closure" {
     GHC.Event.Array.snoc_closure:
         const GHC.Event.Array.snoc_info;
         const 0;
 },
 GHC.Event.Array.snoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7XYR,
                       label: GHC.Event.Array.snoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XYR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.snoc1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.992623368 UTC

[section ""data" . lvl35_r7WMN_closure" {
     lvl35_r7WMN_closure:
         const GHC.Types.I#_con_info;
         const 245;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.993208362 UTC

[section ""data" . lvl36_r7WMO_closure" {
     lvl36_r7WMO_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.993852119 UTC

[section ""data" . lvl37_r7WMP_closure" {
     lvl37_r7WMP_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.994537807 UTC

[section ""data" . lvl38_r7WMQ_closure" {
     lvl38_r7WMQ_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl35_r7WMN_closure+1;
         const lvl36_r7WMO_closure+1;
         const lvl35_r7WMN_closure+1;
         const lvl37_r7WMP_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.995180673 UTC

[section ""data" . lvl39_r7WMR_closure" {
     lvl39_r7WMR_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl38_r7WMQ_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.996067406 UTC

[section ""data" . lvl40_r7WMS_closure" {
     lvl40_r7WMS_closure:
         const lvl40_r7WMS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_r7WMS_entry() //  [R1]
         { info_tbl: [(c7XZ0,
                       label: lvl40_r7WMS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7XZ1; else goto c7XZ2;
       c7XZ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XZ2: // global
           (_c7XYX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XYX::I64 == 0) goto c7XYZ; else goto c7XYY;
       c7XYZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XYY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XYX::I64;
           R2 = lvl39_r7WMR_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.997104384 UTC

[section ""cstring" . lvl41_r7WMT_bytes" {
     lvl41_r7WMT_bytes:
         I8[] [99,111,112,121,58,32,98,97,100,32,111,102,102,115,101,116,115,32,111,114,32,108,101,110,103,116,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:02.997959406 UTC

[section ""data" . lvl42_r7WMU_closure" {
     lvl42_r7WMU_closure:
         const lvl42_r7WMU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_r7WMU_entry() //  [R1]
         { info_tbl: [(c7XZb,
                       label: lvl42_r7WMU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7XZc; else goto c7XZd;
       c7XZc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7XZd: // global
           (_c7XZ6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7XZ6::I64 == 0) goto c7XZ8; else goto c7XZ7;
       c7XZ8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7XZ7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7XZ6::I64;
           I64[Sp - 24] = block_c7XZ9_info;
           R2 = lvl41_r7WMT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7XZ9() //  [R1]
         { info_tbl: [(c7XZ9,
                       label: block_c7XZ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZ9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.004446257 UTC

[section ""data" . GHC.Event.Array.concat3_closure" {
     GHC.Event.Array.concat3_closure:
         const GHC.Event.Array.concat3_info;
         const 0;
 },
 sat_s7WWE_entry() //  [R1]
         { info_tbl: [(c7Y10,
                       label: sat_s7WWE_info
                       rep:HeapRep 2 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y10: // global
           _s7WWE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y11; else goto c7Y12;
       c7Y12: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Y14; else goto c7Y13;
       c7Y14: // global
           HpAlloc = 32;
           goto c7Y11;
       c7Y11: // global
           R1 = _s7WWE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y13: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WWE::P64;
           _s7WWn::I64 = I64[_s7WWE::P64 + 48];
           if (%MO_S_Gt_W64(I64[_s7WWE::P64 + 32],
                            _s7WWn::I64)) goto c7Y0Y; else goto c7Y0Z;
       c7Y0Y: // global
           _s7WVU::P64 = P64[_s7WWE::P64 + 16];
           Hp = Hp - 32;
           R1 = _s7WVU::P64 & (-8);
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c7Y0Z: // global
           _s7WVY::P64 = P64[_s7WWE::P64 + 24];
           _s7WVX::I64 = I64[_s7WWE::P64 + 40];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WVY::P64;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WVX::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WXm_entry() //  [R1]
         { info_tbl: [(c7Y2N,
                       label: sat_s7WXm_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y2N: // global
           _s7WXm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y2O; else goto c7Y2P;
       c7Y2P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y2R; else goto c7Y2Q;
       c7Y2R: // global
           HpAlloc = 56;
           goto c7Y2O;
       c7Y2O: // global
           R1 = _s7WXm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y2Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WXm::P64;
           _s7WX1::P64 = P64[_s7WXm::P64 + 16];
           _s7WVW::I64 = I64[_s7WXm::P64 + 24];
           _s7WWn::I64 = I64[_s7WXm::P64 + 32];
           _s7WWS::I64 = I64[_s7WXm::P64 + 40];
           _s7WX0::I64 = I64[_s7WXm::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7Y2L; else goto c7Y2M;
       c7Y2L: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Y2M: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WXM_entry() //  [R1]
         { info_tbl: [(c7Y3M,
                       label: sat_s7WXM_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y3M: // global
           _s7WXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y3N; else goto c7Y3O;
       c7Y3O: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y3Q; else goto c7Y3P;
       c7Y3Q: // global
           HpAlloc = 56;
           goto c7Y3N;
       c7Y3N: // global
           R1 = _s7WXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y3P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WXM::P64;
           _s7WX1::P64 = P64[_s7WXM::P64 + 16];
           _s7WVW::I64 = I64[_s7WXM::P64 + 24];
           _s7WWn::I64 = I64[_s7WXM::P64 + 32];
           _s7WWS::I64 = I64[_s7WXM::P64 + 40];
           _s7WX0::I64 = I64[_s7WXM::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7Y3K; else goto c7Y3L;
       c7Y3K: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Y3L: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WY5_entry() //  [R1]
         { info_tbl: [(c7Y4A,
                       label: sat_s7WY5_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y4A: // global
           _s7WY5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y4B; else goto c7Y4C;
       c7Y4C: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y4E; else goto c7Y4D;
       c7Y4E: // global
           HpAlloc = 56;
           goto c7Y4B;
       c7Y4B: // global
           R1 = _s7WY5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y4D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WY5::P64;
           _s7WX1::P64 = P64[_s7WY5::P64 + 16];
           _s7WVW::I64 = I64[_s7WY5::P64 + 24];
           _s7WWn::I64 = I64[_s7WY5::P64 + 32];
           _s7WWS::I64 = I64[_s7WY5::P64 + 40];
           _s7WX0::I64 = I64[_s7WY5::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7Y4y; else goto c7Y4z;
       c7Y4y: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Y4z: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.concat3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Y4L,
                       label: GHC.Event.Array.concat3_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y4L: // global
           if ((Sp + -120) < SpLim) (likely: False) goto c7Y4M; else goto c7Y4N;
       c7Y4M: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c7Y4N: // global
           I64[Sp - 40] = block_c7XZl_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Y61; else goto c7XZm;
       u7Y61: // global
           call _c7XZl(R1) args: 0, res: 0, upd: 0;
       c7XZm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XZl() //  [R1]
         { info_tbl: [(c7XZl,
                       label: block_c7XZl_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZl: // global
           I64[Sp - 24] = block_c7XZq_info;
           _s7WVU::P64 = R1;
           _s7WVW::I64 = I64[R1 + 15];
           _s7WVX::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _s7WVW::I64;
           I64[Sp - 8] = _s7WVX::I64;
           P64[Sp] = _s7WVU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Y5Q; else goto c7XZr;
       u7Y5Q: // global
           call _c7XZq(R1) args: 0, res: 0, upd: 0;
       c7XZr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XZq() //  [R1]
         { info_tbl: [(c7XZq,
                       label: block_c7XZq_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZq: // global
           I64[Sp - 16] = block_c7XZv_info;
           _s7WVY::P64 = R1;
           _s7WW0::P64 = P64[R1 + 7];
           _s7WVZ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _s7WW0::P64;
           I64[Sp] = _s7WVZ::I64;
           P64[Sp + 48] = _s7WVY::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Y5R; else goto c7XZw;
       u7Y5R: // global
           call _c7XZv(R1) args: 0, res: 0, upd: 0;
       c7XZw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XZv() //  [R1]
         { info_tbl: [(c7XZv,
                       label: block_c7XZv_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZv: // global
           I64[Sp - 8] = block_c7XZA_info;
           _s7WW3::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WW3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Y5S; else goto c7XZB;
       u7Y5S: // global
           call _c7XZA(R1) args: 0, res: 0, upd: 0;
       c7XZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XZA() //  [R1]
         { info_tbl: [(c7XZA,
                       label: block_c7XZA_info
                       rep:StackRep [True, False, True, True, True, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZA: // global
           I64[Sp - 8] = block_c7XZF_info;
           _s7WW7::P64 = P64[R1 + 7];
           _s7WW6::I64 = I64[R1 + 15];
           R1 = P64[Sp + 88];
           P64[Sp] = _s7WW7::P64;
           I64[Sp + 88] = _s7WW6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Y5T; else goto c7XZG;
       u7Y5T: // global
           call _c7XZF(R1) args: 0, res: 0, upd: 0;
       c7XZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7XZF() //  [R1]
         { info_tbl: [(c7XZF,
                       label: block_c7XZF_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZF: // global
           _s7WW9::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WW9::I64, 0)) goto c7Y4U; else goto u7Y5L;
       c7Y4U: // global
           I64[Sp] = block_c7XZN_info;
           R1 = P64[Sp + 72];
           I64[Sp + 72] = _s7WW9::I64;
           if (R1 & 7 != 0) goto u7Y5U; else goto c7XZO;
       u7Y5U: // global
           call _c7XZN(R1) args: 0, res: 0, upd: 0;
       c7XZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7Y5L: // global
           Sp = Sp + 104;
           call _c7Y5K() args: 0, res: 0, upd: 0;
     }
 },
 _c7XZN() //  [R1]
         { info_tbl: [(c7XZN,
                       label: block_c7XZN_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZN: // global
           _s7WWc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WWc::I64, 0)) goto c7Y5I; else goto u7Y5M;
       c7Y5I: // global
           if (%MO_S_Le_W64(_s7WWc::I64,
                            I64[Sp + 40])) goto c7Y4X; else goto u7Y5N;
       c7Y4X: // global
           I64[Sp] = block_c7XZY_info;
           R1 = P64[Sp + 88];
           I64[Sp + 88] = _s7WWc::I64;
           if (R1 & 7 != 0) goto u7Y5W; else goto c7XZZ;
       u7Y5W: // global
           call _c7XZY(R1) args: 0, res: 0, upd: 0;
       c7XZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7Y5N: // global
           Sp = Sp + 104;
           goto u7Y5Y;
       u7Y5M: // global
           Sp = Sp + 104;
           goto u7Y5Y;
       u7Y5Y: // global
           call _c7Y5K() args: 0, res: 0, upd: 0;
     }
 },
 _c7XZY() //  [R1]
         { info_tbl: [(c7XZY,
                       label: block_c7XZY_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7XZY: // global
           _s7WWg::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WWg::I64, 0)) goto c7Y5E; else goto u7Y5O;
       c7Y5E: // global
           _s7WW3::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s7WWg::I64,
                            _s7WW3::I64)) goto c7Y5B; else goto u7Y5P;
       c7Y5B: // global
           _s7WVN::P64 = P64[Sp + 64];
           _s7WVU::P64 = P64[Sp + 56];
           _s7WVX::I64 = I64[Sp + 48];
           _s7WW9::I64 = I64[Sp + 72];
           _s7WWc::I64 = I64[Sp + 88];
           _s7WWj::I64 = _s7WW3::I64 - _s7WWg::I64;
           if (%MO_S_Gt_W64(_s7WW9::I64,
                            _s7WWj::I64)) goto c7Y5y; else goto c7Y5z;
       c7Y5y: // global
           _s7WWl::I64 = _s7WWj::I64;
           goto s7WWk;
       c7Y5z: // global
           _s7WWl::I64 = _s7WW9::I64;
           goto s7WWk;
       s7WWk: // global
           if (_s7WWl::I64 == 0) goto c7Y5u; else goto c7Y5t;
       c7Y5u: // global
           R1 = _s7WVU::P64;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Y5t: // global
           _s7WWn::I64 = _s7WWc::I64 + _s7WWl::I64;
           if (%MO_S_Le_W64(_s7WWn::I64,
                            _s7WVX::I64)) goto c7Y51; else goto c7Y55;
       c7Y51: // global
           I64[Sp] = block_c7Y0p_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 16] = _s7WWn::I64;
           I64[Sp + 64] = _s7WWl::I64;
           I64[Sp + 72] = _s7WWg::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7Y55: // global
           I64[Sp] = block_c7Y19_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Event.Array.ensureCapacity2_closure;
           I64[Sp + 56] = _s7WWn::I64;
           I64[Sp + 72] = _s7WWl::I64;
           I64[Sp + 80] = _s7WWg::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       u7Y5P: // global
           Sp = Sp + 104;
           goto u7Y60;
       u7Y5O: // global
           Sp = Sp + 104;
           goto u7Y60;
       u7Y60: // global
           call _c7Y5K() args: 0, res: 0, upd: 0;
     }
 },
 _c7Y0p() //  [R1]
         { info_tbl: [(c7Y0p,
                       label: block_c7Y0p_info
                       rep:StackRep [False, True, False, True, True, True, False, True,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y0p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y54; else goto c7Y53;
       c7Y54: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y53: // global
           _s7WVU::P64 = P64[Sp + 56];
           _s7WVW::I64 = I64[Sp + 40];
           _s7WVX::I64 = I64[Sp + 48];
           _s7WVY::P64 = P64[Sp + 80];
           _s7WW0::P64 = P64[Sp + 24];
           _s7WW7::P64 = P64[Sp + 8];
           _s7WWn::I64 = I64[Sp + 16];
           _s7WWq::I64 = I64[R1 + 7];
           (_s7WWA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 32] + I64[Sp + 88] * _s7WWq::I64, I64[Sp + 96] + I64[Sp + 72] * _s7WWq::I64, I64[Sp + 64] * _s7WWq::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_s7WW0::P64);
           I64[Hp - 48] = sat_s7WWE_info;
           P64[Hp - 32] = _s7WVU::P64;
           P64[Hp - 24] = _s7WVY::P64;
           I64[Hp - 16] = _s7WVW::I64;
           I64[Hp - 8] = _s7WVX::I64;
           I64[Hp] = _s7WWn::I64;
           R1 = Hp - 48;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Y19() //  [R1]
         { info_tbl: [(c7Y19,
                       label: block_c7Y19_info
                       rep:StackRep [False, True, False, True, True, True, True, False,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y19: // global
           _s7WWG::I64 = I64[R1 + 7];
           _s7WWH::I64 = I64[Sp + 56] - 1;
           _s7WWI::I64 = _s7WWH::I64 | %MO_S_Shr_W64(_s7WWH::I64, 1);
           _s7WWK::I64 = _s7WWI::I64 | %MO_S_Shr_W64(_s7WWI::I64, 2);
           _s7WWM::I64 = _s7WWK::I64 | %MO_S_Shr_W64(_s7WWK::I64, 4);
           _s7WWO::I64 = _s7WWM::I64 | %MO_S_Shr_W64(_s7WWM::I64, 8);
           _s7WWQ::I64 = _s7WWO::I64 | %MO_S_Shr_W64(_s7WWO::I64, 16);
           _s7WWS::I64 = _s7WWQ::I64 | %MO_S_Shr_W64(_s7WWQ::I64, 32) + 1;
           _s7WWV::I64 = _s7WWS::I64 * _s7WWG::I64;
           if (%MO_S_Ge_W64(_s7WWV::I64, 0)) goto c7Y58; else goto c7Y5r;
       c7Y58: // global
           I64[Sp - 8] = block_c7Y1Z_info;
           R1 = _s7WWV::I64;
           I64[Sp] = _s7WWS::I64;
           I64[Sp + 16] = _s7WWG::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7Y5r: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 104;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Y1Z() //  [R1]
         { info_tbl: [(c7Y1Z,
                       label: block_c7Y1Z_info
                       rep:StackRep [True, False, True, False, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y1Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Y5b; else goto c7Y5a;
       c7Y5b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y5a: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7WVN::P64 = P64[Sp + 72];
           _s7WVZ::I64 = I64[Sp + 40];
           _s7WW0::P64 = P64[Sp + 32];
           _s7WX0::I64 = R1 + 16;
           _c7Y24::P64 = Hp - 5;
           if (_s7WVZ::I64 == 0) goto c7Y5n; else goto c7Y5m;
       c7Y5n: // global
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7Y3Z_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7Y24::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7Y5m: // global
           _s7WVX::I64 = I64[Sp + 56];
           if (%MO_S_Le_W64(_s7WVX::I64, 0)) goto c7Y5d; else goto c7Y5h;
       c7Y5d: // global
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7Y2c_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7Y24::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7Y5h: // global
           (_s7WXs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64, _s7WVZ::I64, _s7WVX::I64 * I64[Sp + 24]);
           call MO_Touch(_c7Y24::P64);
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7Y3b_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7Y24::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Y3Z() //  [R1]
         { info_tbl: [(c7Y3Z,
                       label: block_c7Y3Z_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y3Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y5q; else goto c7Y5p;
       c7Y5q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y5p: // global
           _c7Y24::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WXP::I64 = I64[R1 + 7];
           (_s7WXZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WXP::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WXP::I64, I64[Sp + 80] * _s7WXP::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7Y24::P64);
           I64[Hp - 48] = sat_s7WY5_info;
           P64[Hp - 32] = _c7Y24::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Y2c() //  [R1]
         { info_tbl: [(c7Y2c,
                       label: block_c7Y2c_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y2c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y5g; else goto c7Y5f;
       c7Y5g: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y5f: // global
           _c7Y24::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WX6::I64 = I64[R1 + 7];
           (_s7WXg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WX6::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WX6::I64, I64[Sp + 80] * _s7WX6::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7Y24::P64);
           I64[Hp - 48] = sat_s7WXm_info;
           P64[Hp - 32] = _c7Y24::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Y3b() //  [R1]
         { info_tbl: [(c7Y3b,
                       label: block_c7Y3b_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y3b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Y5k; else goto c7Y5j;
       c7Y5k: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y5j: // global
           _c7Y24::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WXw::I64 = I64[R1 + 7];
           (_s7WXG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WXw::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WXw::I64, I64[Sp + 80] * _s7WXw::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7Y24::P64);
           I64[Hp - 48] = sat_s7WXM_info;
           P64[Hp - 32] = _c7Y24::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Y5K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y5K: // global
           R1 = lvl42_r7WMU_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.017135444 UTC

[section ""data" . GHC.Event.Array.concat2_closure" {
     GHC.Event.Array.concat2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.018775106 UTC

[section ""data" . GHC.Event.Array.$wconcat_closure" {
     GHC.Event.Array.$wconcat_closure:
         const GHC.Event.Array.$wconcat_info;
         const 0;
 },
 GHC.Event.Array.$wconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Y69,
                       label: GHC.Event.Array.$wconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y69: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Y6d; else goto c7Y6e;
       c7Y6d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Y6e: // global
           I64[Sp - 32] = block_c7Y66_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Y6w; else goto c7Y67;
       u7Y6w: // global
           call _c7Y66(R1) args: 0, res: 0, upd: 0;
       c7Y67: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y66() //  [R1]
         { info_tbl: [(c7Y66,
                       label: block_c7Y66_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y66: // global
           _s7WYq::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_c7Y6c_info;
           _s7WYk::P64 = R1;
           _s7WYm::I64 = I64[R1 + 15];
           R1 = _s7WYq::P64;
           I64[Sp] = _s7WYm::I64;
           P64[Sp + 24] = _s7WYk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Y6v; else goto c7Y6g;
       u7Y6v: // global
           call _c7Y6c(R1) args: 0, res: 0, upd: 0;
       c7Y6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y6c() //  [R1]
         { info_tbl: [(c7Y6c,
                       label: block_c7Y6c_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y6c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Y6p; else goto c7Y6o;
       c7Y6p: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y6o: // global
           _s7WYt::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WYt::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           _s7WYd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7Y6m_info;
           R6 = GHC.Event.Array.concat2_closure+1;
           R5 = R1;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = _s7WYd::P64;
           P64[Sp + 8] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7Y6m() //  [R1]
         { info_tbl: [(c7Y6m,
                       label: block_c7Y6m_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y6m: // global
           _s7WYe::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7WYe::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WYe::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.021157187 UTC

[section ""data" . GHC.Event.Array.concat1_closure" {
     GHC.Event.Array.concat1_closure:
         const GHC.Event.Array.concat1_info;
         const 0;
 },
 GHC.Event.Array.concat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Y6E,
                       label: GHC.Event.Array.concat1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y6E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Y6I; else goto c7Y6J;
       c7Y6I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Y6J: // global
           I64[Sp - 24] = block_c7Y6B_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Y6R; else goto c7Y6C;
       u7Y6R: // global
           call _c7Y6B(R1) args: 0, res: 0, upd: 0;
       c7Y6C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y6B() //  [R1]
         { info_tbl: [(c7Y6B,
                       label: block_c7Y6B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y6B: // global
           I64[Sp] = block_c7Y6H_info;
           _s7WYG::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WYG::P64;
           if (R1 & 7 != 0) goto u7Y6Q; else goto c7Y6L;
       u7Y6Q: // global
           call _c7Y6H(R1) args: 0, res: 0, upd: 0;
       c7Y6L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y6H() //  [R1]
         { info_tbl: [(c7Y6H,
                       label: block_c7Y6H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y6H: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wconcat_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.022744196 UTC

[section ""data" . GHC.Event.Array.concat_closure" {
     GHC.Event.Array.concat_closure:
         const GHC.Event.Array.concat_info;
         const 0;
 },
 GHC.Event.Array.concat_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Y6W,
                       label: GHC.Event.Array.concat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y6W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.concat1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.024623473 UTC

[section ""data" . GHC.Event.Array.copy1_closure" {
     GHC.Event.Array.copy1_closure:
         const GHC.Event.Array.copy1_info;
         const 0;
 },
 GHC.Event.Array.copy1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Y76,
                       label: GHC.Event.Array.copy1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y76: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Y7a; else goto c7Y7b;
       c7Y7a: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.copy1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c7Y7b: // global
           I64[Sp - 40] = block_c7Y73_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Y7p; else goto c7Y74;
       u7Y7p: // global
           call _c7Y73(R1) args: 0, res: 0, upd: 0;
       c7Y74: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y73() //  [R1]
         { info_tbl: [(c7Y73,
                       label: block_c7Y73_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y73: // global
           I64[Sp - 8] = block_c7Y79_info;
           _s7WYR::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp] = P64[_s7WYR::P64 + 8];
           P64[Sp + 24] = _s7WYR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Y7o; else goto c7Y7d;
       u7Y7o: // global
           call _c7Y79(R1) args: 0, res: 0, upd: 0;
       c7Y7d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y79() //  [R1]
         { info_tbl: [(c7Y79,
                       label: block_c7Y79_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y79: // global
           _s7WYL::P64 = P64[Sp + 24];
           _s7WYZ::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp + 24] = block_c7Y7h_info;
           R6 = P64[Sp + 40];
           R5 = _s7WYZ::P64;
           R4 = _s7WYL::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 48];
           Sp = Sp + 16;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7Y7h() //  [R1]
         { info_tbl: [(c7Y7h,
                       label: block_c7Y7h_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y7h: // global
           _s7WYR::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7WYR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WYR::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.026721959 UTC

[section ""data" . GHC.Event.Array.copy_closure" {
     GHC.Event.Array.copy_closure:
         const GHC.Event.Array.copy_info;
         const 0;
 },
 GHC.Event.Array.copy_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Y7u,
                       label: GHC.Event.Array.copy_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y7u: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.copy1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.027514091 UTC

[section ""data" . lvl43_r7WMV_closure" {
     lvl43_r7WMV_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.028087115 UTC

[section ""data" . lvl44_r7WMW_closure" {
     lvl44_r7WMW_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.028696065 UTC

[section ""data" . lvl45_r7WMX_closure" {
     lvl45_r7WMX_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.029346494 UTC

[section ""data" . lvl46_r7WMY_closure" {
     lvl46_r7WMY_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl43_r7WMV_closure+1;
         const lvl44_r7WMW_closure+1;
         const lvl43_r7WMV_closure+1;
         const lvl45_r7WMX_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.029950093 UTC

[section ""data" . lvl47_r7WMZ_closure" {
     lvl47_r7WMZ_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl46_r7WMY_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.030740599 UTC

[section ""data" . GHC.Event.Array.duplicate1_closure" {
     GHC.Event.Array.duplicate1_closure:
         const GHC.Event.Array.duplicate1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate1_entry() //  [R1]
         { info_tbl: [(c7Y7D,
                       label: GHC.Event.Array.duplicate1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y7E; else goto c7Y7F;
       c7Y7E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y7F: // global
           (_c7Y7A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Y7A::I64 == 0) goto c7Y7C; else goto c7Y7B;
       c7Y7C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Y7B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Y7A::I64;
           R2 = lvl47_r7WMZ_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.032568135 UTC

[section ""data" . GHC.Event.Array.$wnew_closure" {
     GHC.Event.Array.$wnew_closure:
         const GHC.Event.Array.$wnew_info;
         const 0;
 },
 GHC.Event.Array.$wnew_entry() //  [R2, R3]
         { info_tbl: [(c7Y7M,
                       label: GHC.Event.Array.$wnew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y7M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Y7N; else goto c7Y7O;
       c7Y7N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wnew_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Y7O: // global
           I64[Sp - 16] = block_c7Y7K_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Y7K() //  [R1]
         { info_tbl: [(c7Y7K,
                       label: block_c7Y7K_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y7K: // global
           _s7WZ9::I64 = I64[Sp + 8] - 1;
           _s7WZa::I64 = _s7WZ9::I64 | %MO_S_Shr_W64(_s7WZ9::I64, 1);
           _s7WZc::I64 = _s7WZa::I64 | %MO_S_Shr_W64(_s7WZa::I64, 2);
           _s7WZe::I64 = _s7WZc::I64 | %MO_S_Shr_W64(_s7WZc::I64, 4);
           _s7WZg::I64 = _s7WZe::I64 | %MO_S_Shr_W64(_s7WZe::I64, 8);
           _s7WZi::I64 = _s7WZg::I64 | %MO_S_Shr_W64(_s7WZg::I64, 16);
           _s7WZk::I64 = _s7WZi::I64 | %MO_S_Shr_W64(_s7WZi::I64, 32) + 1;
           _s7WZn::I64 = _s7WZk::I64 * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WZn::I64, 0)) goto c7Y8Q; else goto c7Y8X;
       c7Y8Q: // global
           I64[Sp] = block_c7Y8E_info;
           R1 = _s7WZn::I64;
           I64[Sp + 8] = _s7WZk::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7Y8X: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Y8E() //  [R1]
         { info_tbl: [(c7Y8E,
                       label: block_c7Y8E_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y8E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Y8T; else goto c7Y8S;
       c7Y8T: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y8S: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 61;
           P64[Hp - 32] = R1 + 16;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 8] = block_c7Y8M_info;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y8M() //  [R1]
         { info_tbl: [(c7Y8M,
                       label: block_c7Y8M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y8M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Y8W; else goto c7Y8V;
       c7Y8W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Y8V: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.034775727 UTC

[section ""data" . GHC.Event.Array.new1_closure" {
     GHC.Event.Array.new1_closure:
         const GHC.Event.Array.new1_info;
         const 0;
 },
 GHC.Event.Array.new1_entry() //  [R2, R3]
         { info_tbl: [(c7Y95,
                       label: GHC.Event.Array.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y95: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y96; else goto c7Y97;
       c7Y96: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Y97: // global
           I64[Sp - 16] = block_c7Y92_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Y9b; else goto c7Y93;
       u7Y9b: // global
           call _c7Y92(R1) args: 0, res: 0, upd: 0;
       c7Y93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y92() //  [R1]
         { info_tbl: [(c7Y92,
                       label: block_c7Y92_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y92: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Array.$wnew_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.035987059 UTC

[section ""data" . GHC.Event.Array.new_closure" {
     GHC.Event.Array.new_closure:
         const GHC.Event.Array.new_info;
         const 0;
 },
 GHC.Event.Array.new_entry() //  [R2, R3]
         { info_tbl: [(c7Y9g,
                       label: GHC.Event.Array.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9g: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.new1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.036730803 UTC

[section ""data" . lvl48_r7WN0_closure" {
     lvl48_r7WN0_closure:
         const GHC.Types.I#_con_info;
         const 95;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.037364452 UTC

[section ""data" . lvl49_r7WN1_closure" {
     lvl49_r7WN1_closure:
         const GHC.Types.I#_con_info;
         const 23;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.038994849 UTC

[section ""data" . lvl50_r7WN2_closure" {
     lvl50_r7WN2_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.03958596 UTC

[section ""data" . lvl51_r7WN3_closure" {
     lvl51_r7WN3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl48_r7WN0_closure+1;
         const lvl49_r7WN1_closure+1;
         const lvl48_r7WN0_closure+1;
         const lvl50_r7WN2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.040195619 UTC

[section ""data" . lvl52_r7WN4_closure" {
     lvl52_r7WN4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl51_r7WN3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.041012337 UTC

[section ""data" . GHC.Event.Array.duplicate2_closure" {
     GHC.Event.Array.duplicate2_closure:
         const GHC.Event.Array.duplicate2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate2_entry() //  [R1]
         { info_tbl: [(c7Y9p,
                       label: GHC.Event.Array.duplicate2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Y9q; else goto c7Y9r;
       c7Y9q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y9r: // global
           (_c7Y9m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Y9m::I64 == 0) goto c7Y9o; else goto c7Y9n;
       c7Y9o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Y9n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Y9m::I64;
           R2 = lvl52_r7WN4_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.043415694 UTC

[section ""data" . GHC.Event.Array.duplicate_closure" {
     GHC.Event.Array.duplicate_closure:
         const GHC.Event.Array.duplicate_info;
         const 0;
 },
 lvl53_s7WZH_entry() //  [R1]
         { info_tbl: [(c7Y9A,
                       label: lvl53_s7WZH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Y9B; else goto c7Y9C;
       c7Y9B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y9C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl54_s7WZI_entry() //  [R1]
         { info_tbl: [(c7Y9H,
                       label: lvl54_s7WZI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Y9I; else goto c7Y9J;
       c7Y9I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Y9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7X0n_entry() //  [R1, R2]
         { info_tbl: [(c7Y9S,
                       label: sat_s7X0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9S: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Ya6; else goto c7Ya7;
       c7Ya6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ya7: // global
           I64[Sp - 24] = block_c7Y9P_info;
           _s7WZH::P64 = P64[R1 + 6];
           _s7WZI::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s7WZH::P64;
           P64[Sp - 8] = _s7WZI::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YaZ; else goto c7Y9Q;
       u7YaZ: // global
           call _c7Y9P(R1) args: 0, res: 0, upd: 0;
       c7Y9Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y9P() //  [R1]
         { info_tbl: [(c7Y9P,
                       label: block_c7Y9P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9P: // global
           _s7WZP::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Y9V_info;
           R1 = _s7WZP::P64;
           if (R1 & 7 != 0) goto u7YaY; else goto c7Y9W;
       u7YaY: // global
           call _c7Y9V(R1) args: 0, res: 0, upd: 0;
       c7Y9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Y9V() //  [R1]
         { info_tbl: [(c7Y9V,
                       label: block_c7Y9V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Y9V: // global
           I64[Sp - 16] = block_c7Ya0_info;
           _s7WZS::I64 = I64[R1 + 15];
           _s7WZT::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WZT::I64;
           I64[Sp] = _s7WZS::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Yb0; else goto c7Ya1;
       u7Yb0: // global
           call _c7Ya0(R1) args: 0, res: 0, upd: 0;
       c7Ya1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ya0() //  [R1]
         { info_tbl: [(c7Ya0,
                       label: block_c7Ya0_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ya0: // global
           I64[Sp - 8] = block_c7Ya5_info;
           _s7WZW::P64 = P64[R1 + 7];
           _s7WZV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _s7WZW::P64;
           I64[Sp + 32] = _s7WZV::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Yb1; else goto c7Yab;
       u7Yb1: // global
           call _c7Ya5(R1) args: 0, res: 0, upd: 0;
       c7Yab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ya5() //  [R1]
         { info_tbl: [(c7Ya5,
                       label: block_c7Ya5_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ya5: // global
           _s7WZZ::I64 = I64[Sp + 16] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WZZ::I64, 0)) goto c7YaP; else goto c7YaX;
       c7YaP: // global
           I64[Sp] = block_c7Yam_info;
           R1 = _s7WZZ::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7YaX: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Yam() //  [R1]
         { info_tbl: [(c7Yam,
                       label: block_c7Yam_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yam: // global
           I64[Sp] = block_c7Yao_info;
           _s7X03::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7X03::P64;
           if (R1 & 7 != 0) goto u7Yb2; else goto c7Yap;
       u7Yb2: // global
           call _c7Yao(R1) args: 0, res: 0, upd: 0;
       c7Yap: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yao() //  [R1]
         { info_tbl: [(c7Yao,
                       label: block_c7Yao_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yao: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7YaT; else goto c7YaS;
       c7YaT: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YaS: // global
           _s7WZS::I64 = I64[Sp + 24];
           _s7WZT::I64 = I64[Sp + 16];
           _s7WZW::P64 = P64[Sp + 8];
           _s7X03::P64 = P64[Sp + 32];
           _s7X06::I64 = _s7X03::P64 + 16;
           (_s7X0c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7X06::I64, I64[Sp + 40], _s7WZS::I64 * I64[R1 + 7]);
           call MO_Touch(_s7WZW::P64);
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = _s7X03::P64;
           _c7YaH::P64 = Hp - 61;
           call MO_Touch(_c7YaH::P64);
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7YaH::P64;
           I64[Hp - 32] = _s7X06::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WZS::I64;
           I64[Hp] = _s7WZT::I64;
           I64[Sp + 40] = block_c7YaL_info;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YaL() //  [R1]
         { info_tbl: [(c7YaL,
                       label: block_c7YaL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YaL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7YaW; else goto c7YaV;
       c7YaW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YaV: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.duplicate_entry() //  [R2]
         { info_tbl: [(c7Yb3,
                       label: GHC.Event.Array.duplicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yb3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Yb7; else goto c7Yb6;
       c7Yb7: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.Event.Array.duplicate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Yb6: // global
           I64[Hp - 64] = lvl53_s7WZH_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl54_s7WZI_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7X0n_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.047268732 UTC

[section ""data" . GHC.Event.Array.AC_closure" {
     GHC.Event.Array.AC_closure:
         const GHC.Event.Array.AC_info;
 },
 GHC.Event.Array.AC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ybd,
                       label: GHC.Event.Array.AC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ybd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ybh; else goto c7Ybg;
       c7Ybh: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.AC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ybg: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.048153286 UTC

[GHC.Event.Array.AC_con_entry() //  [R1]
         { info_tbl: [(c7Ybi,
                       label: GHC.Event.Array.AC_con_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46,65,67]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ybi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.048826927 UTC

[section ""relreadonly" . S7X3q_srt" {
     S7X3q_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.$wlvl1_closure;
         const GHC.Event.Array.$wunsafeRead_closure;
         const GHC.Event.Array.unsafeRead1_closure;
         const GHC.Event.Array.$wlvl_closure;
         const GHC.Event.Array.$wunsafeWrite'_closure;
         const GHC.Event.Array.unsafeWrite2_closure;
         const GHC.Event.Array.unsafeWrite1_closure;
         const GHC.Err.undefined_closure;
         const lvl15_r7WMj_closure;
         const GHC.Event.Array.forM_1_closure;
         const GHC.Event.Array.forM__closure;
         const lvl20_r7WMo_closure;
         const GHC.Event.Array.loop1_closure;
         const GHC.Event.Array.loop_closure;
         const lvl23_r7WMB_closure;
         const GHC.Event.Array.removeAt2_closure;
         const GHC.Event.Array.removeAt1_closure;
         const GHC.Event.Array.removeAt_closure;
         const lvl29_r7WMH_closure;
         const GHC.Event.Array.findIndex1_closure;
         const GHC.Event.Array.findIndex_closure;
         const lvl34_r7WMM_closure;
         const GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
         const GHC.Event.Array.$wensureCapacity_closure;
         const GHC.Event.Array.ensureCapacity2_closure;
         const GHC.Event.Array.ensureCapacity1_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.snoc1_closure;
         const lvl39_r7WMR_closure;
         const GHC.Event.Array.concat3_closure;
         const lvl40_r7WMS_closure;
         const lvl42_r7WMU_closure;
         const GHC.Event.Array.$wconcat_closure;
         const GHC.Event.Array.concat1_closure;
         const GHC.Event.Array.copy1_closure;
         const lvl47_r7WMZ_closure;
         const GHC.Event.Array.duplicate1_closure;
         const GHC.Event.Array.$wnew_closure;
         const GHC.Event.Array.new1_closure;
         const lvl52_r7WN4_closure;
         const GHC.Err.undefined_closure;
         const GHC.Event.Array.duplicate2_closure;
         const GHC.Event.Array.duplicate_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.049974368 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:03.051511711 UTC

[section ""data" . GHC.Event.Array.$WAC_closure" {
     GHC.Event.Array.$WAC_closure:
         const GHC.Event.Array.$WAC_info;
 },
 GHC.Event.Array.$WAC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ybr,
                       label: GHC.Event.Array.$WAC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ybr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YbF; else goto c7YbG;
       c7YbF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$WAC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YbG: // global
           I64[Sp - 24] = block_c7Ybo_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YbN; else goto c7Ybp;
       u7YbN: // global
           call _c7Ybo(R1) args: 0, res: 0, upd: 0;
       c7Ybp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ybo() //  [R1]
         { info_tbl: [(c7Ybo,
                       label: block_c7Ybo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ybo: // global
           I64[Sp] = block_c7Ybu_info;
           _s7WN9::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7WN9::P64;
           if (R1 & 7 != 0) goto u7YbM; else goto c7Ybv;
       u7YbM: // global
           call _c7Ybu(R1) args: 0, res: 0, upd: 0;
       c7Ybv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ybu() //  [R1]
         { info_tbl: [(c7Ybu,
                       label: block_c7Ybu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ybu: // global
           I64[Sp] = block_c7Ybz_info;
           _s7WNb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7WNb::I64;
           if (R1 & 7 != 0) goto u7YbO; else goto c7YbA;
       u7YbO: // global
           call _c7Ybz(R1) args: 0, res: 0, upd: 0;
       c7YbA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ybz() //  [R1]
         { info_tbl: [(c7Ybz,
                       label: block_c7Ybz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ybz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YbL; else goto c7YbK;
       c7YbL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YbK: // global
           _s7WNd::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _s7WNd::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.061661947 UTC

[section ""data" . GHC.Event.Array.empty1_closure" {
     GHC.Event.Array.empty1_closure:
         const GHC.Event.Array.empty1_info;
 },
 GHC.Event.Array.empty1_entry() //  []
         { info_tbl: [(c7Ycl,
                       label: GHC.Event.Array.empty1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ycl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Ycm; else goto c7Ycn;
       c7Ycm: // global
           R1 = GHC.Event.Array.empty1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7Ycn: // global
           I64[Sp - 8] = block_c7Ycd_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ycd() //  [R1]
         { info_tbl: [(c7Ycd,
                       label: block_c7Ycd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ycd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Ycq; else goto c7Ycp;
       c7Ycq: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ycp: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_c7Yci_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yci() //  [R1]
         { info_tbl: [(c7Yci,
                       label: block_c7Yci_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yci: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Yct; else goto c7Ycs;
       c7Yct: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ycs: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.071538801 UTC

[section ""data" . GHC.Event.Array.empty_closure" {
     GHC.Event.Array.empty_closure:
         const GHC.Event.Array.empty_info;
 },
 GHC.Event.Array.empty_entry() //  []
         { info_tbl: [(c7YcM,
                       label: GHC.Event.Array.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YcM: // global
           call GHC.Event.Array.empty1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.075137092 UTC

[section ""data" . GHC.Event.Array.length1_closure" {
     GHC.Event.Array.length1_closure:
         const GHC.Event.Array.length1_info;
 },
 GHC.Event.Array.length1_entry() //  [R2]
         { info_tbl: [(c7Yd0,
                       label: GHC.Event.Array.length1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yd0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Yd9; else goto c7Yda;
       c7Yd9: // global
           R2 = R2;
           R1 = GHC.Event.Array.length1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Yda: // global
           I64[Sp - 8] = block_c7YcX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ydg; else goto c7YcY;
       u7Ydg: // global
           call _c7YcX(R1) args: 0, res: 0, upd: 0;
       c7YcY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YcX() //  [R1]
         { info_tbl: [(c7YcX,
                       label: block_c7YcX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YcX: // global
           _s7WNv::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Yd3_info;
           R1 = _s7WNv::P64;
           if (R1 & 7 != 0) goto u7Ydf; else goto c7Yd4;
       u7Ydf: // global
           call _c7Yd3(R1) args: 0, res: 0, upd: 0;
       c7Yd4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yd3() //  [R1]
         { info_tbl: [(c7Yd3,
                       label: block_c7Yd3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yd3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Yde; else goto c7Ydd;
       c7Yde: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ydd: // global
           _s7WNy::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7WNy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.082513869 UTC

[section ""data" . GHC.Event.Array.length_closure" {
     GHC.Event.Array.length_closure:
         const GHC.Event.Array.length_info;
 },
 GHC.Event.Array.length_entry() //  [R2]
         { info_tbl: [(c7YdA,
                       label: GHC.Event.Array.length_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YdA: // global
           R2 = R2;
           call GHC.Event.Array.length1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.086057303 UTC

[section ""data" . GHC.Event.Array.capacity1_closure" {
     GHC.Event.Array.capacity1_closure:
         const GHC.Event.Array.capacity1_info;
 },
 GHC.Event.Array.capacity1_entry() //  [R2]
         { info_tbl: [(c7YdO,
                       label: GHC.Event.Array.capacity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YdO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7YdX; else goto c7YdY;
       c7YdX: // global
           R2 = R2;
           R1 = GHC.Event.Array.capacity1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7YdY: // global
           I64[Sp - 8] = block_c7YdL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ye4; else goto c7YdM;
       u7Ye4: // global
           call _c7YdL(R1) args: 0, res: 0, upd: 0;
       c7YdM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YdL() //  [R1]
         { info_tbl: [(c7YdL,
                       label: block_c7YdL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YdL: // global
           _s7WNH::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7YdR_info;
           R1 = _s7WNH::P64;
           if (R1 & 7 != 0) goto u7Ye3; else goto c7YdS;
       u7Ye3: // global
           call _c7YdR(R1) args: 0, res: 0, upd: 0;
       c7YdS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YdR() //  [R1]
         { info_tbl: [(c7YdR,
                       label: block_c7YdR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YdR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Ye2; else goto c7Ye1;
       c7Ye2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ye1: // global
           _s7WNL::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7WNL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.094131362 UTC

[section ""data" . GHC.Event.Array.capacity_closure" {
     GHC.Event.Array.capacity_closure:
         const GHC.Event.Array.capacity_info;
 },
 GHC.Event.Array.capacity_entry() //  [R2]
         { info_tbl: [(c7Yeo,
                       label: GHC.Event.Array.capacity_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yeo: // global
           R2 = R2;
           call GHC.Event.Array.capacity1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.097286392 UTC

[section ""cstring" . lvl_r7WM4_bytes" {
     lvl_r7WM4_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.098876467 UTC

[section ""cstring" . lvl1_r7WM5_bytes" {
     lvl1_r7WM5_bytes:
         I8[] [117,110,115,97,102,101,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.100504135 UTC

[section ""cstring" . lvl2_r7WM6_bytes" {
     lvl2_r7WM6_bytes:
         I8[] [58,32,98,111,117,110,100,115,32,101,114,114,111,114,44,32,105,110,100,101,120,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.102169281 UTC

[section ""cstring" . lvl3_r7WM7_bytes" {
     lvl3_r7WM7_bytes:
         I8[] [44,32,99,97,112,97,99,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.105101731 UTC

[section ""data" . GHC.Event.Array.$wlvl1_closure" {
     GHC.Event.Array.$wlvl1_closure:
         const GHC.Event.Array.$wlvl1_info;
         const 0;
 },
 sat_s7WNW_entry() //  [R1]
         { info_tbl: [(c7Yf2,
                       label: sat_s7WNW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yf2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Yf3; else goto c7Yf4;
       c7Yf3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yf4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7YeZ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7YeZ() //  [R1, R2]
         { info_tbl: [(c7YeZ,
                       label: block_c7YeZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YeZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Yf7; else goto c7Yf6;
       c7Yf7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Yf6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WNX_entry() //  [R1]
         { info_tbl: [(c7Yf8,
                       label: sat_s7WNX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yf8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Yfc; else goto c7Yfb;
       c7Yfc: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yfb: // global
           _s7WNN::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7WNW_info;
           I64[Hp] = _s7WNN::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7WNY_entry() //  [R1]
         { info_tbl: [(c7Yfe,
                       label: sat_s7WNY_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yfe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Yff; else goto c7Yfg;
       c7Yff: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yfg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7YeP_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7YeP() //  [R1, R2]
         { info_tbl: [(c7YeP,
                       label: block_c7YeP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YeP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Yfj; else goto c7Yfi;
       c7Yfj: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Yfi: // global
           I64[Hp - 40] = sat_s7WNX_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WNZ_entry() //  [R1]
         { info_tbl: [(c7Yfk,
                       label: sat_s7WNZ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yfk: // global
           _s7WNZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yfl; else goto c7Yfm;
       c7Yfm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Yfo; else goto c7Yfn;
       c7Yfo: // global
           HpAlloc = 32;
           goto c7Yfl;
       c7Yfl: // global
           R1 = _s7WNZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yfn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WNZ::P64;
           _s7WNN::I64 = I64[_s7WNZ::P64 + 16];
           _s7WNO::I64 = I64[_s7WNZ::P64 + 24];
           I64[Hp - 24] = sat_s7WNY_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WO0_entry() //  [R1]
         { info_tbl: [(c7Yfp,
                       label: sat_s7WO0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yfp: // global
           _s7WO0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yfq; else goto c7Yfr;
       c7Yfr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Yft; else goto c7Yfs;
       c7Yft: // global
           HpAlloc = 32;
           goto c7Yfq;
       c7Yfq: // global
           R1 = _s7WO0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WO0::P64;
           _s7WNN::I64 = I64[_s7WO0::P64 + 16];
           _s7WNO::I64 = I64[_s7WO0::P64 + 24];
           I64[Hp - 24] = sat_s7WNZ_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           R3 = Hp - 24;
           R2 = lvl1_r7WM5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl1_entry() //  [R2, R3]
         { info_tbl: [(c7Yfw,
                       label: GHC.Event.Array.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yfw: // global
           _s7WNO::I64 = R3;
           _s7WNN::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7Yfx; else goto c7Yfy;
       c7Yfy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YfA; else goto c7Yfz;
       c7YfA: // global
           HpAlloc = 32;
           goto c7Yfx;
       c7Yfx: // global
           R3 = _s7WNO::I64;
           R2 = _s7WNN::I64;
           R1 = GHC.Event.Array.$wlvl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yfz: // global
           I64[Hp - 24] = sat_s7WO0_info;
           I64[Hp - 8] = _s7WNN::I64;
           I64[Hp] = _s7WNO::I64;
           I64[Sp - 8] = block_c7Yfu_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yfu() //  [R1]
         { info_tbl: [(c7Yfu,
                       label: block_c7Yfu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yfu: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.126888803 UTC

[section ""data" . GHC.Event.Array.$wunsafeRead_closure" {
     GHC.Event.Array.$wunsafeRead_closure:
         const GHC.Event.Array.$wunsafeRead_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ygl,
                       label: GHC.Event.Array.$wunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ygl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Ygp; else goto c7Ygq;
       c7Ygp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ygq: // global
           I64[Sp - 24] = block_c7Ygi_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YgS; else goto c7Ygj;
       u7YgS: // global
           call _c7Ygi(R1) args: 0, res: 0, upd: 0;
       c7Ygj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ygi() //  [R1]
         { info_tbl: [(c7Ygi,
                       label: block_c7Ygi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ygi: // global
           I64[Sp - 8] = block_c7Ygo_info;
           _s7WOc::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WOc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YgR; else goto c7Ygs;
       u7YgR: // global
           call _c7Ygo(R1) args: 0, res: 0, upd: 0;
       c7Ygs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ygo() //  [R1]
         { info_tbl: [(c7Ygo,
                       label: block_c7Ygo_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ygo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ygy; else goto c7Ygx;
       c7Ygy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ygx: // global
           _s7WO4::I64 = I64[Sp + 24];
           _s7WOc::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7WO4::I64, 0)) goto c7YgP; else goto c7YgO;
       c7YgO: // global
           if (%MO_S_Ge_W64(_s7WO4::I64,
                            _s7WOc::I64)) goto c7YgP; else goto c7YgJ;
       c7YgP: // global
           Hp = Hp - 32;
           R3 = _s7WO4::I64;
           R2 = _s7WOc::I64;
           Sp = Sp + 32;
           call GHC.Event.Array.$wlvl1_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7YgJ: // global
           _s7WOf::P64 = P64[R1 + 7];
           _s7WOe::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WO4::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WOe::I64;
           _s7WO2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7YgH_info;
           R2 = _s7WO2::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = Hp - 23;
           P64[Sp + 24] = _s7WOf::P64;
           Sp = Sp - 8;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c7YgH() //  [R1]
         { info_tbl: [(c7YgH,
                       label: block_c7YgH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YgH: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.137135273 UTC

[section ""data" . GHC.Event.Array.unsafeRead1_closure" {
     GHC.Event.Array.unsafeRead1_closure:
         const GHC.Event.Array.unsafeRead1_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Yhj,
                       label: GHC.Event.Array.unsafeRead1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yhj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Yhn; else goto c7Yho;
       c7Yhn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeRead1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yho: // global
           I64[Sp - 24] = block_c7Yhg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Yhw; else goto c7Yhh;
       u7Yhw: // global
           call _c7Yhg(R1) args: 0, res: 0, upd: 0;
       c7Yhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yhg() //  [R1]
         { info_tbl: [(c7Yhg,
                       label: block_c7Yhg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yhg: // global
           I64[Sp] = block_c7Yhm_info;
           _s7WOv::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WOv::P64;
           if (R1 & 7 != 0) goto u7Yhv; else goto c7Yhq;
       u7Yhv: // global
           call _c7Yhm(R1) args: 0, res: 0, upd: 0;
       c7Yhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yhm() //  [R1]
         { info_tbl: [(c7Yhm,
                       label: block_c7Yhm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yhm: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wunsafeRead_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.145122165 UTC

[section ""data" . GHC.Event.Array.unsafeRead_closure" {
     GHC.Event.Array.unsafeRead_closure:
         const GHC.Event.Array.unsafeRead_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YhO,
                       label: GHC.Event.Array.unsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YhO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeRead1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.148737044 UTC

[section ""cstring" . lvl4_r7WM8_bytes" {
     lvl4_r7WM8_bytes:
         I8[] [117,110,115,97,102,101,87,114,105,116,101,39]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.15161104 UTC

[section ""data" . GHC.Event.Array.$wlvl_closure" {
     GHC.Event.Array.$wlvl_closure:
         const GHC.Event.Array.$wlvl_info;
         const 0;
 },
 sat_s7WOH_entry() //  [R1]
         { info_tbl: [(c7Yip,
                       label: sat_s7WOH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yip: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Yiq; else goto c7Yir;
       c7Yiq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yir: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7Yim_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Yim() //  [R1, R2]
         { info_tbl: [(c7Yim,
                       label: block_c7Yim_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yim: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Yiu; else goto c7Yit;
       c7Yiu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Yit: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOI_entry() //  [R1]
         { info_tbl: [(c7Yiv,
                       label: sat_s7WOI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yiv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Yiz; else goto c7Yiy;
       c7Yiz: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yiy: // global
           _s7WOy::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7WOH_info;
           I64[Hp] = _s7WOy::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7WOJ_entry() //  [R1]
         { info_tbl: [(c7YiB,
                       label: sat_s7WOJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YiB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7YiC; else goto c7YiD;
       c7YiC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YiD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7Yic_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Yic() //  [R1, R2]
         { info_tbl: [(c7Yic,
                       label: block_c7Yic_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yic: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7YiG; else goto c7YiF;
       c7YiG: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7YiF: // global
           I64[Hp - 40] = sat_s7WOI_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOK_entry() //  [R1]
         { info_tbl: [(c7YiH,
                       label: sat_s7WOK_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YiH: // global
           _s7WOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7YiI; else goto c7YiJ;
       c7YiJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YiL; else goto c7YiK;
       c7YiL: // global
           HpAlloc = 32;
           goto c7YiI;
       c7YiI: // global
           R1 = _s7WOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YiK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WOK::P64;
           _s7WOy::I64 = I64[_s7WOK::P64 + 16];
           _s7WOz::I64 = I64[_s7WOK::P64 + 24];
           I64[Hp - 24] = sat_s7WOJ_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WOL_entry() //  [R1]
         { info_tbl: [(c7YiM,
                       label: sat_s7WOL_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YiM: // global
           _s7WOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7YiN; else goto c7YiO;
       c7YiO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YiQ; else goto c7YiP;
       c7YiQ: // global
           HpAlloc = 32;
           goto c7YiN;
       c7YiN: // global
           R1 = _s7WOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YiP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WOL::P64;
           _s7WOy::I64 = I64[_s7WOL::P64 + 16];
           _s7WOz::I64 = I64[_s7WOL::P64 + 24];
           I64[Hp - 24] = sat_s7WOK_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           R3 = Hp - 24;
           R2 = lvl4_r7WM8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(c7YiT,
                       label: GHC.Event.Array.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YiT: // global
           _s7WOz::I64 = R3;
           _s7WOy::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7YiU; else goto c7YiV;
       c7YiV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YiX; else goto c7YiW;
       c7YiX: // global
           HpAlloc = 32;
           goto c7YiU;
       c7YiU: // global
           R3 = _s7WOz::I64;
           R2 = _s7WOy::I64;
           R1 = GHC.Event.Array.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YiW: // global
           I64[Hp - 24] = sat_s7WOL_info;
           I64[Hp - 8] = _s7WOy::I64;
           I64[Hp] = _s7WOz::I64;
           I64[Sp - 8] = block_c7YiR_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7YiR() //  [R1]
         { info_tbl: [(c7YiR,
                       label: block_c7YiR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YiR: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.172545747 UTC

[section ""data" . GHC.Event.Array.$wunsafeWrite'_closure" {
     GHC.Event.Array.$wunsafeWrite'_closure:
         const GHC.Event.Array.$wunsafeWrite'_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeWrite'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YjC: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.$wunsafeWrite'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7YjL,
                       label: GHC.Event.Array.$wunsafeWrite'_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YjL: // global
           _s7WOR::I64 = R6;
           _s7WOQ::I64 = R5;
           _s7WOP::P64 = R4;
           _s7WOO::I64 = R3;
           _s7WON::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c7YjM; else goto c7YjN;
       c7YjN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YjP; else goto c7YjO;
       c7YjP: // global
           HpAlloc = 32;
           goto c7YjM;
       c7YjM: // global
           R1 = GHC.Event.Array.$wunsafeWrite'_closure;
           P64[Sp - 40] = _s7WON::P64;
           I64[Sp - 32] = _s7WOO::I64;
           P64[Sp - 24] = _s7WOP::P64;
           I64[Sp - 16] = _s7WOQ::I64;
           I64[Sp - 8] = _s7WOR::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7YjO: // global
           if (%MO_S_Lt_W64(_s7WOR::I64, 0)) goto c7YjK; else goto c7YjJ;
       c7YjJ: // global
           if (%MO_S_Ge_W64(_s7WOR::I64,
                            _s7WOQ::I64)) goto c7YjK; else goto c7YjY;
       c7YjK: // global
           Hp = Hp - 32;
           R3 = _s7WOR::I64;
           R2 = _s7WOQ::I64;
           Sp = Sp + 8;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7YjY: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WOR::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WOO::I64;
           I64[Sp - 8] = block_c7YjW_info;
           R2 = _s7WON::P64;
           I64[Sp - 40] = stg_ap_pppv_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           P64[Sp - 16] = P64[Sp];
           P64[Sp] = _s7WOP::P64;
           Sp = Sp - 40;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c7YjW() //  [R1]
         { info_tbl: [(c7YjW,
                       label: block_c7YjW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YjW: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.180843843 UTC

[section ""data" . GHC.Event.Array.unsafeWrite2_closure" {
     GHC.Event.Array.unsafeWrite2_closure:
         const GHC.Event.Array.unsafeWrite2_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7Yko,
                       label: GHC.Event.Array.unsafeWrite2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yko: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Ykx; else goto c7Yky;
       c7Ykx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yky: // global
           I64[Sp - 32] = block_c7Ykl_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7YkH; else goto c7Ykm;
       u7YkH: // global
           call _c7Ykl(R1) args: 0, res: 0, upd: 0;
       c7Ykm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ykl() //  [R1]
         { info_tbl: [(c7Ykl,
                       label: block_c7Ykl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ykl: // global
           I64[Sp - 8] = block_c7Ykr_info;
           _s7WPc::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WPc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YkG; else goto c7Yks;
       u7YkG: // global
           call _c7Ykr(R1) args: 0, res: 0, upd: 0;
       c7Yks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ykr() //  [R1]
         { info_tbl: [(c7Ykr,
                       label: block_c7Ykr_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ykr: // global
           I64[Sp - 8] = block_c7Ykw_info;
           _s7WPf::P64 = P64[R1 + 7];
           _s7WPe::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WPf::P64;
           I64[Sp + 24] = _s7WPe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YkI; else goto c7YkB;
       u7YkI: // global
           call _c7Ykw(R1) args: 0, res: 0, upd: 0;
       c7YkB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ykw() //  [R1]
         { info_tbl: [(c7Ykw,
                       label: block_c7Ykw_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ykw: // global
           R6 = I64[R1 + 7];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 32];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.190708826 UTC

[section ""data" . GHC.Event.Array.unsafeWrite1_closure" {
     GHC.Event.Array.unsafeWrite1_closure:
         const GHC.Event.Array.unsafeWrite1_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7Yl7,
                       label: GHC.Event.Array.unsafeWrite1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yl7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Yl8; else goto c7Yl9;
       c7Yl8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yl9: // global
           I64[Sp - 32] = block_c7Yl4_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Yld; else goto c7Yl5;
       u7Yld: // global
           call _c7Yl4(R1) args: 0, res: 0, upd: 0;
       c7Yl5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yl4() //  [R1]
         { info_tbl: [(c7Yl4,
                       label: block_c7Yl4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yl4: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[P64[R1 + 7] + 8];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Event.Array.unsafeWrite2_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.19753753 UTC

[section ""data" . GHC.Event.Array.unsafeWrite_closure" {
     GHC.Event.Array.unsafeWrite_closure:
         const GHC.Event.Array.unsafeWrite_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7Yls,
                       label: GHC.Event.Array.unsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yls: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeWrite1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.201733572 UTC

[section ""data" . GHC.Event.Array.$wunsafeLoad_closure" {
     GHC.Event.Array.$wunsafeLoad_closure:
         const GHC.Event.Array.$wunsafeLoad_info;
 },
 sat_s7WPN_entry() //  [R1]
         { info_tbl: [(c7YlZ,
                       label: sat_s7WPN_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YlZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Ym3; else goto c7Ym4;
       c7Ym3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ym4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7YlW_info;
           _s7WPC::P64 = P64[R1 + 16];
           _s7WPB::I64 = I64[R1 + 32];
           R1 = P64[R1 + 24];
           I64[Sp - 32] = _s7WPB::I64;
           P64[Sp - 24] = _s7WPC::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Ym8; else goto c7YlX;
       u7Ym8: // global
           call _c7YlW(R1) args: 0, res: 0, upd: 0;
       c7YlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7YlW() //  [R1]
         { info_tbl: [(c7YlW,
                       label: block_c7YlW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YlW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ym7; else goto c7Ym6;
       c7Ym7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7Ym6: // global
           _s7WPM::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = _s7WPM::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wunsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7Ym9,
                       label: GHC.Event.Array.$wunsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ym9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Yma; else goto c7Ymb;
       c7Yma: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeLoad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ymb: // global
           I64[Sp - 24] = block_c7YlD_info;
           R1 = P64[R2 + 8];
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Ymn; else goto c7YlE;
       u7Ymn: // global
           call _c7YlD(R1) args: 0, res: 0, upd: 0;
       c7YlE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YlD() //  [R1]
         { info_tbl: [(c7YlD,
                       label: block_c7YlD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YlD: // global
           I64[Sp - 8] = block_c7YlI_info;
           _s7WPB::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WPB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ymm; else goto c7YlJ;
       u7Ymm: // global
           call _c7YlI(R1) args: 0, res: 0, upd: 0;
       c7YlJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YlI() //  [R1]
         { info_tbl: [(c7YlI,
                       label: block_c7YlI_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YlI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ymf; else goto c7Yme;
       c7Ymf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Yme: // global
           _s7WPE::P64 = P64[R1 + 7];
           _s7WPD::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WPD::I64;
           I64[Sp - 8] = block_c7YlP_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           _s7WPC::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WPE::P64;
           P64[Sp + 24] = _s7WPC::P64;
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YlP() //  [R1]
         { info_tbl: [(c7YlP,
                       label: block_c7YlP_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YlP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Ymi; else goto c7Ymh;
       c7Ymi: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ymh: // global
           _s7WPs::P64 = P64[Sp + 24];
           _s7WPB::I64 = I64[Sp + 16];
           _s7WPC::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = sat_s7WPN_info;
           P64[Hp - 16] = _s7WPC::P64;
           P64[Hp - 8] = R1;
           I64[Hp] = _s7WPB::I64;
           call MO_WriteBarrier();
           P64[_s7WPs::P64 + 8] = Hp - 32;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WPs::P64);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.216307749 UTC

[section ""data" . GHC.Event.Array.unsafeLoad1_closure" {
     GHC.Event.Array.unsafeLoad1_closure:
         const GHC.Event.Array.unsafeLoad1_info;
 },
 GHC.Event.Array.unsafeLoad1_entry() //  [R2, R3]
         { info_tbl: [(c7Yn0,
                       label: GHC.Event.Array.unsafeLoad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yn0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yn1; else goto c7Yn2;
       c7Yn1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeLoad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yn2: // global
           I64[Sp - 16] = block_c7YmX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Yn6; else goto c7YmY;
       u7Yn6: // global
           call _c7YmX(R1) args: 0, res: 0, upd: 0;
       c7YmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YmX() //  [R1]
         { info_tbl: [(c7YmX,
                       label: block_c7YmX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YmX: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Event.Array.$wunsafeLoad_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.222889708 UTC

[section ""data" . GHC.Event.Array.unsafeLoad_closure" {
     GHC.Event.Array.unsafeLoad_closure:
         const GHC.Event.Array.unsafeLoad_info;
 },
 GHC.Event.Array.unsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7Ynk,
                       label: GHC.Event.Array.unsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ynk: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeLoad1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.226712099 UTC

[section ""data" . GHC.Event.Array.useAsPtr1_closure" {
     GHC.Event.Array.useAsPtr1_closure:
         const GHC.Event.Array.useAsPtr1_info;
 },
 GHC.Event.Array.useAsPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7Yny,
                       label: GHC.Event.Array.useAsPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yny: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YnH; else goto c7YnI;
       c7YnH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.useAsPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YnI: // global
           I64[Sp - 16] = block_c7Ynv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7YnZ; else goto c7Ynw;
       u7YnZ: // global
           call _c7Ynv(R1) args: 0, res: 0, upd: 0;
       c7Ynw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ynv() //  [R1]
         { info_tbl: [(c7Ynv,
                       label: block_c7Ynv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ynv: // global
           _s7WQ1::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7YnB_info;
           R1 = _s7WQ1::P64;
           if (R1 & 7 != 0) goto u7YnY; else goto c7YnC;
       u7YnY: // global
           call _c7YnB(R1) args: 0, res: 0, upd: 0;
       c7YnC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YnB() //  [R1]
         { info_tbl: [(c7YnB,
                       label: block_c7YnB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YnB: // global
           I64[Sp - 8] = block_c7YnG_info;
           _s7WQ4::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WQ4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Yo0; else goto c7YnL;
       u7Yo0: // global
           call _c7YnG(R1) args: 0, res: 0, upd: 0;
       c7YnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YnG() //  [R1]
         { info_tbl: [(c7YnG,
                       label: block_c7YnG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YnG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YnU; else goto c7YnT;
       c7YnU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YnT: // global
           _s7WQ8::P64 = P64[R1 + 7];
           _s7WQ7::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7WQ7::I64;
           I64[Sp + 8] = block_c7YnR_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WQ8::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YnR() //  [R1]
         { info_tbl: [(c7YnR,
                       label: block_c7YnR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YnR: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.237909502 UTC

[section ""data" . GHC.Event.Array.useAsPtr_closure" {
     GHC.Event.Array.useAsPtr_closure:
         const GHC.Event.Array.useAsPtr_info;
 },
 GHC.Event.Array.useAsPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Yos,
                       label: GHC.Event.Array.useAsPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yos: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.useAsPtr1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.242503777 UTC

[section ""data" . GHC.Event.Array.clear2_closure" {
     GHC.Event.Array.clear2_closure:
         const GHC.Event.Array.clear2_info;
 },
 GHC.Event.Array.clear2_entry() //  [R2]
         { info_tbl: [(c7YoG,
                       label: GHC.Event.Array.clear2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YoG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7YoL; else goto c7YoM;
       c7YoL: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7YoM: // global
           I64[Sp - 8] = block_c7YoD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YoQ; else goto c7YoE;
       u7YoQ: // global
           call _c7YoD(R1) args: 0, res: 0, upd: 0;
       c7YoE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YoD() //  [R1]
         { info_tbl: [(c7YoD,
                       label: block_c7YoD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YoD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YoP; else goto c7YoO;
       c7YoP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YoO: // global
           _s7WQh::P64 = P64[R1 + 7];
           _s7WQj::I64 = I64[R1 + 23];
           I64[Hp - 48] = GHC.Event.Array.AC_con_info;
           P64[Hp - 40] = _s7WQh::P64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = _s7WQj::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.24941419 UTC

[section ""data" . GHC.Event.Array.clear1_closure" {
     GHC.Event.Array.clear1_closure:
         const GHC.Event.Array.clear1_info;
 },
 GHC.Event.Array.clear1_entry() //  [R2]
         { info_tbl: [(c7Yp9,
                       label: GHC.Event.Array.clear1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yp9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Ypf; else goto c7Ypg;
       c7Ypf: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ypg: // global
           I64[Sp - 8] = block_c7Yp6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ypo; else goto c7Yp7;
       u7Ypo: // global
           call _c7Yp6(R1) args: 0, res: 0, upd: 0;
       c7Yp7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yp6() //  [R1]
         { info_tbl: [(c7Yp6,
                       label: block_c7Yp6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yp6: // global
           I64[Sp] = block_c7Ypc_info;
           R2 = GHC.Event.Array.clear2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ypc() //  [R1]
         { info_tbl: [(c7Ypc,
                       label: block_c7Ypc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ypc: // global
           I64[Sp] = block_c7Ype_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7Ypp; else goto c7Ypj;
       u7Ypp: // global
           call _c7Ype() args: 0, res: 0, upd: 0;
       c7Ypj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ype() //  []
         { info_tbl: [(c7Ype,
                       label: block_c7Ype_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ype: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.258206219 UTC

[section ""data" . GHC.Event.Array.clear_closure" {
     GHC.Event.Array.clear_closure:
         const GHC.Event.Array.clear_info;
 },
 GHC.Event.Array.clear_entry() //  [R2]
         { info_tbl: [(c7YpL,
                       label: GHC.Event.Array.clear_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YpL: // global
           R2 = R2;
           call GHC.Event.Array.clear1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.261354671 UTC

[section ""cstring" . lvl5_r7WM9_bytes" {
     lvl5_r7WM9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.263241813 UTC

[section ""data" . lvl6_r7WMa_closure" {
     lvl6_r7WMa_closure:
         const lvl6_r7WMa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r7WMa_entry() //  [R1]
         { info_tbl: [(c7YpZ,
                       label: lvl6_r7WMa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YpZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yq0; else goto c7Yq1;
       c7Yq0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yq1: // global
           (_c7YpW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YpW::I64 == 0) goto c7YpY; else goto c7YpX;
       c7YpY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YpX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YpW::I64;
           R2 = lvl5_r7WM9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.267231396 UTC

[section ""cstring" . GHC.Event.Array.$trModule4_bytes" {
     GHC.Event.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.269199609 UTC

[section ""data" . lvl7_r7WMb_closure" {
     lvl7_r7WMb_closure:
         const lvl7_r7WMb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r7WMb_entry() //  [R1]
         { info_tbl: [(c7Yqg,
                       label: lvl7_r7WMb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yqg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yqh; else goto c7Yqi;
       c7Yqh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yqi: // global
           (_c7Yqd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Yqd::I64 == 0) goto c7Yqf; else goto c7Yqe;
       c7Yqf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Yqe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Yqd::I64;
           R2 = GHC.Event.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.2735514 UTC

[section ""cstring" . GHC.Event.Array.$trModule2_bytes" {
     GHC.Event.Array.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.275341957 UTC

[section ""data" . lvl8_r7WMc_closure" {
     lvl8_r7WMc_closure:
         const lvl8_r7WMc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r7WMc_entry() //  [R1]
         { info_tbl: [(c7Yqx,
                       label: lvl8_r7WMc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yqx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yqy; else goto c7Yqz;
       c7Yqy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yqz: // global
           (_c7Yqu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Yqu::I64 == 0) goto c7Yqw; else goto c7Yqv;
       c7Yqw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Yqv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Yqu::I64;
           R2 = GHC.Event.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.279839944 UTC

[section ""cstring" . lvl9_r7WMd_bytes" {
     lvl9_r7WMd_bytes:
         I8[] [46,47,71,72,67,47,69,118,101,110,116,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.281755907 UTC

[section ""data" . lvl10_r7WMe_closure" {
     lvl10_r7WMe_closure:
         const lvl10_r7WMe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_r7WMe_entry() //  [R1]
         { info_tbl: [(c7YqO,
                       label: lvl10_r7WMe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YqO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7YqP; else goto c7YqQ;
       c7YqP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YqQ: // global
           (_c7YqL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YqL::I64 == 0) goto c7YqN; else goto c7YqM;
       c7YqN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YqM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YqL::I64;
           R2 = lvl9_r7WMd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.285684466 UTC

[section ""data" . lvl11_r7WMf_closure" {
     lvl11_r7WMf_closure:
         const GHC.Types.I#_con_info;
         const 179;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.287369655 UTC

[section ""data" . lvl12_r7WMg_closure" {
     lvl12_r7WMg_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.289006238 UTC

[section ""data" . lvl13_r7WMh_closure" {
     lvl13_r7WMh_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.291215679 UTC

[section ""data" . lvl14_r7WMi_closure" {
     lvl14_r7WMi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl11_r7WMf_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl11_r7WMf_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.293180292 UTC

[section ""data" . lvl15_r7WMj_closure" {
     lvl15_r7WMj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl14_r7WMi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.295834027 UTC

[section ""data" . GHC.Event.Array.forM_1_closure" {
     GHC.Event.Array.forM_1_closure:
         const GHC.Event.Array.forM_1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.forM_1_entry() //  [R1]
         { info_tbl: [(c7Yr9,
                       label: GHC.Event.Array.forM_1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yr9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yra; else goto c7Yrb;
       c7Yra: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yrb: // global
           (_c7Yr6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Yr6::I64 == 0) goto c7Yr8; else goto c7Yr7;
       c7Yr8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Yr7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Yr6::I64;
           R2 = lvl15_r7WMj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.301179292 UTC

[section ""data" . GHC.Event.Array.forM__closure" {
     GHC.Event.Array.forM__closure:
         const GHC.Event.Array.forM__info;
         const 0;
 },
 size_s7WQu_entry() //  [R1]
         { info_tbl: [(c7Yrr,
                       label: size_s7WQu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yrr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Yrs; else goto c7Yrt;
       c7Yrs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yrt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.forM_1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WR3_entry() //  [R1, R2, R3]
         { info_tbl: [(c7YrC,
                       label: sat_s7WR3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YrC: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c7YrQ; else goto c7YrR;
       c7YrQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YrR: // global
           I64[Sp - 32] = block_c7Yrz_info;
           _s7WQt::P64 = P64[R1 + 5];
           _s7WQu::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s7WQt::P64;
           P64[Sp - 16] = _s7WQu::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7YsD; else goto c7YrA;
       u7YsD: // global
           call _c7Yrz(R1) args: 0, res: 0, upd: 0;
       c7YrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yrz() //  [R1]
         { info_tbl: [(c7Yrz,
                       label: block_c7Yrz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yrz: // global
           _s7WQC::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7YrF_info;
           R1 = _s7WQC::P64;
           if (R1 & 7 != 0) goto u7YsC; else goto c7YrG;
       u7YsC: // global
           call _c7YrF(R1) args: 0, res: 0, upd: 0;
       c7YrG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YrF() //  [R1]
         { info_tbl: [(c7YrF,
                       label: block_c7YrF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YrF: // global
           I64[Sp - 8] = block_c7YrK_info;
           _s7WQF::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WQF::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YsE; else goto c7YrL;
       u7YsE: // global
           call _c7YrK(R1) args: 0, res: 0, upd: 0;
       c7YrL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YrK() //  [R1]
         { info_tbl: [(c7YrK,
                       label: block_c7YrK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YrK: // global
           I64[Sp - 8] = block_c7YrP_info;
           _s7WQJ::P64 = P64[R1 + 7];
           _s7WQI::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WQJ::P64;
           I64[Sp + 24] = _s7WQI::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YsF; else goto c7YrV;
       u7YsF: // global
           call _c7YrP(R1) args: 0, res: 0, upd: 0;
       c7YrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YrP() //  [R1]
         { info_tbl: [(c7YrP,
                       label: block_c7YrP_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YrP: // global
           I64[Sp - 8] = 0;
           _s7WQL::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7WQL::I64;
           I64[Sp + 16] = _s7WQL::I64;
           Sp = Sp - 8;
           call _c7Ysc() args: 0, res: 0, upd: 0;
     }
 },
 _c7Ysc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ysc: // global
           Hp = Hp + 16;
           _s7WQR::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c7Ysg; else goto c7Ysf;
       c7Ysg: // global
           HpAlloc = 16;
           I64[Sp] = block_c7Ysb_info;
           R1 = _s7WQR::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ysf: // global
           if (%MO_S_Lt_W64(_s7WQR::I64,
                            I64[Sp + 8])) goto c7Yss; else goto c7Ysw;
       c7Yss: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 40] + _s7WQR::I64;
           I64[Sp - 8] = block_c7Yso_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 24;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7Ysw: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ysb() //  [R1]
         { info_tbl: [(c7Ysb,
                       label: block_c7Ysb_info
                       rep:StackRep [True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ysb: // global
           I64[Sp] = R1;
           call _c7Ysc() args: 0, res: 0, upd: 0;
     }
 },
 _c7Yso() //  [R1]
         { info_tbl: [(c7Yso,
                       label: block_c7Yso_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yso: // global
           I64[Sp] = block_c7Ysq_info;
           R2 = R1;
           R1 = P64[Sp + 56];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ysq() //  []
         { info_tbl: [(c7Ysq,
                       label: block_c7Ysq_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ysq: // global
           I64[Sp + 8] = I64[Sp + 8] + I64[Sp + 32];
           Sp = Sp + 8;
           call _c7Ysc() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.forM__entry() //  [R2]
         { info_tbl: [(c7YsJ,
                       label: GHC.Event.Array.forM__info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YsJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7YsN; else goto c7YsM;
       c7YsN: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.forM__closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7YsM: // global
           I64[Hp - 40] = size_s7WQu_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WR3_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.322745894 UTC

[section ""data" . lvl16_r7WMk_closure" {
     lvl16_r7WMk_closure:
         const GHC.Types.I#_con_info;
         const 194;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.324441517 UTC

[section ""data" . lvl17_r7WMl_closure" {
     lvl17_r7WMl_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.326086016 UTC

[section ""data" . lvl18_r7WMm_closure" {
     lvl18_r7WMm_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.327646627 UTC

[section ""data" . lvl19_r7WMn_closure" {
     lvl19_r7WMn_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl16_r7WMk_closure+1;
         const lvl17_r7WMl_closure+1;
         const lvl16_r7WMk_closure+1;
         const lvl18_r7WMm_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.329834055 UTC

[section ""data" . lvl20_r7WMo_closure" {
     lvl20_r7WMo_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl19_r7WMn_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.331787218 UTC

[section ""data" . GHC.Event.Array.loop1_closure" {
     GHC.Event.Array.loop1_closure:
         const GHC.Event.Array.loop1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.loop1_entry() //  [R1]
         { info_tbl: [(c7YtN,
                       label: GHC.Event.Array.loop1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YtN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7YtO; else goto c7YtP;
       c7YtO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YtP: // global
           (_c7YtK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YtK::I64 == 0) goto c7YtM; else goto c7YtL;
       c7YtM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YtL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YtK::I64;
           R2 = lvl20_r7WMo_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.337403963 UTC

[section ""data" . GHC.Event.Array.loop_closure" {
     GHC.Event.Array.loop_closure:
         const GHC.Event.Array.loop_info;
         const 0;
 },
 size_s7WR5_entry() //  [R1]
         { info_tbl: [(c7Yu5,
                       label: size_s7WR5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yu5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Yu6; else goto c7Yu7;
       c7Yu6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yu7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.loop1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WRN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c7Yug,
                       label: sat_s7WRN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yug: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7Yuu; else goto c7Yuv;
       c7Yuu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yuv: // global
           I64[Sp - 40] = block_c7Yud_info;
           _s7WR4::P64 = P64[R1 + 4];
           _s7WR5::P64 = P64[R1 + 12];
           R1 = R2;
           P64[Sp - 32] = _s7WR4::P64;
           P64[Sp - 24] = _s7WR5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7YvG; else goto c7Yue;
       u7YvG: // global
           call _c7Yud(R1) args: 0, res: 0, upd: 0;
       c7Yue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yud() //  [R1]
         { info_tbl: [(c7Yud,
                       label: block_c7Yud_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yud: // global
           _s7WRe::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Yuj_info;
           R1 = _s7WRe::P64;
           if (R1 & 7 != 0) goto u7YvF; else goto c7Yuk;
       u7YvF: // global
           call _c7Yuj(R1) args: 0, res: 0, upd: 0;
       c7Yuk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yuj() //  [R1]
         { info_tbl: [(c7Yuj,
                       label: block_c7Yuj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yuj: // global
           I64[Sp - 8] = block_c7Yuo_info;
           _s7WRh::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WRh::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YvH; else goto c7Yup;
       u7YvH: // global
           call _c7Yuo(R1) args: 0, res: 0, upd: 0;
       c7Yup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yuo() //  [R1]
         { info_tbl: [(c7Yuo,
                       label: block_c7Yuo_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yuo: // global
           I64[Sp - 8] = block_c7Yut_info;
           _s7WRl::P64 = P64[R1 + 7];
           _s7WRk::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WRl::P64;
           I64[Sp + 24] = _s7WRk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YvI; else goto c7Yuz;
       u7YvI: // global
           call _c7Yut(R1) args: 0, res: 0, upd: 0;
       c7Yuz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yut() //  [R1]
         { info_tbl: [(c7Yut,
                       label: block_c7Yut_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yut: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           _s7WRn::I64 = I64[R1 + 7];
           I64[Sp + 16] = I64[Sp + 16] * _s7WRn::I64;
           I64[Sp + 40] = _s7WRn::I64;
           Sp = Sp - 16;
           call _c7YuV() args: 0, res: 0, upd: 0;
     }
 },
 _c7YuV() //  []
         { info_tbl: [(c7YuV,
                       label: block_c7YuV_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YuV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Yv0; else goto c7YuZ;
       c7Yv0: // global
           HpAlloc = 16;
           I64[Sp] = block_c7YuV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7YuZ: // global
           _s7WRw::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_s7WRw::I64,
                            I64[Sp + 32])) goto c7Yve; else goto c7Yvy;
       c7Yve: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 48] + _s7WRw::I64;
           I64[Sp] = block_c7Yv8_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7Yvy: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Yv8() //  [R1]
         { info_tbl: [(c7Yv8,
                       label: block_c7Yv8_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yv8: // global
           _s7WRx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Yva_info;
           R3 = R1;
           R2 = _s7WRx::P64;
           R1 = P64[Sp + 64];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yva() //  [R1]
         { info_tbl: [(c7Yva,
                       label: block_c7Yva_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yva: // global
           I64[Sp] = block_c7Yvc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7YvK; else goto c7Yvh;
       u7YvK: // global
           call _c7Yvc(R1) args: 0, res: 0, upd: 0;
       c7Yvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yvc() //  [R1]
         { info_tbl: [(c7Yvc,
                       label: block_c7Yvc_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yvc: // global
           I64[Sp - 8] = block_c7Yvl_info;
           _s7WRJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s7WRJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YvL; else goto c7Yvn;
       u7YvL: // global
           call _c7Yvl(R1) args: 0, res: 0, upd: 0;
       c7Yvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yvl() //  [R1]
         { info_tbl: [(c7Yvl,
                       label: block_c7Yvl_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yvl: // global
           if (R1 & 7 == 1) goto c7Yvt; else goto c7Yvx;
       c7Yvt: // global
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Yvx: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           call _c7YuV() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.loop_entry() //  [R2]
         { info_tbl: [(c7YvN,
                       label: GHC.Event.Array.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YvN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7YvR; else goto c7YvQ;
       c7YvR: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7YvQ: // global
           I64[Hp - 40] = size_s7WR5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WRN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 12;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.362683512 UTC

[section ""data" . GHC.Event.Array.$trModule3_closure" {
     GHC.Event.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.364395583 UTC

[section ""data" . GHC.Event.Array.$trModule1_closure" {
     GHC.Event.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.366391481 UTC

[section ""data" . GHC.Event.Array.$trModule_closure" {
     GHC.Event.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Array.$trModule3_closure+1;
         const GHC.Event.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.368394112 UTC

[section ""data" . $krep_r7WMp_closure" {
     $krep_r7WMp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.370228751 UTC

[section ""data" . $krep1_r7WMq_closure" {
     $krep1_r7WMq_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.372397558 UTC

[section ""data" . $krep2_r7WMr_closure" {
     $krep2_r7WMr_closure:
         const :_con_info;
         const $krep1_r7WMq_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.374238464 UTC

[section ""data" . $krep3_r7WMs_closure" {
     $krep3_r7WMs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.375892827 UTC

[section ""cstring" . GHC.Event.Array.$tcAC2_bytes" {
     GHC.Event.Array.$tcAC2_bytes:
         I8[] [65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.377940446 UTC

[section ""data" . GHC.Event.Array.$tcAC1_closure" {
     GHC.Event.Array.$tcAC1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcAC2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.379652839 UTC

[section ""data" . GHC.Event.Array.$tcAC_closure" {
     GHC.Event.Array.$tcAC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcAC1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14339520722473255067;
         const 15778732457674388659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.381613373 UTC

[section ""data" . $krep4_r7WMt_closure" {
     $krep4_r7WMt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcAC_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.38345938 UTC

[section ""data" . $krep5_r7WMu_closure" {
     $krep5_r7WMu_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep4_r7WMt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.385196111 UTC

[section ""data" . $krep6_r7WMv_closure" {
     $krep6_r7WMv_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep5_r7WMu_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.38723752 UTC

[section ""data" . GHC.Event.Array.$tc'AC1_closure" {
     GHC.Event.Array.$tc'AC1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7WMs_closure+1;
         const $krep6_r7WMv_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.388983275 UTC

[section ""cstring" . GHC.Event.Array.$tc'AC3_bytes" {
     GHC.Event.Array.$tc'AC3_bytes:
         I8[] [39,65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.390805372 UTC

[section ""data" . GHC.Event.Array.$tc'AC2_closure" {
     GHC.Event.Array.$tc'AC2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'AC3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.392625566 UTC

[section ""data" . GHC.Event.Array.$tc'AC_closure" {
     GHC.Event.Array.$tc'AC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'AC2_closure+1;
         const GHC.Event.Array.$tc'AC1_closure+4;
         const 954782197074941232;
         const 8411064637322477330;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.395075935 UTC

[section ""data" . $krep7_r7WMw_closure" {
     $krep7_r7WMw_closure:
         const :_con_info;
         const $krep4_r7WMt_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.396837214 UTC

[section ""data" . $krep8_r7WMx_closure" {
     $krep8_r7WMx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep7_r7WMw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.398617811 UTC

[section ""cstring" . GHC.Event.Array.$tcArray2_bytes" {
     GHC.Event.Array.$tcArray2_bytes:
         I8[] [65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.400213978 UTC

[section ""data" . GHC.Event.Array.$tcArray1_closure" {
     GHC.Event.Array.$tcArray1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcArray2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.402350318 UTC

[section ""data" . GHC.Event.Array.$tcArray_closure" {
     GHC.Event.Array.$tcArray_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcArray1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18201768782471713089;
         const 1209293416176401920;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.404204497 UTC

[section ""data" . $krep9_r7WMy_closure" {
     $krep9_r7WMy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.405897242 UTC

[section ""data" . GHC.Event.Array.$tc'Array1_closure" {
     GHC.Event.Array.$tc'Array1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r7WMx_closure+1;
         const $krep9_r7WMy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.407725334 UTC

[section ""cstring" . GHC.Event.Array.$tc'Array3_bytes" {
     GHC.Event.Array.$tc'Array3_bytes:
         I8[] [39,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.409444948 UTC

[section ""data" . GHC.Event.Array.$tc'Array2_closure" {
     GHC.Event.Array.$tc'Array2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'Array3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.411214741 UTC

[section ""data" . GHC.Event.Array.$tc'Array_closure" {
     GHC.Event.Array.$tc'Array_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'Array2_closure+1;
         const GHC.Event.Array.$tc'Array1_closure+4;
         const 1928439007980526225;
         const 8720085055779125030;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.413210592 UTC

[section ""data" . lvl21_r7WMz_closure" {
     lvl21_r7WMz_closure:
         const GHC.Types.I#_con_info;
         const 265;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.415008195 UTC

[section ""data" . lvl22_r7WMA_closure" {
     lvl22_r7WMA_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl21_r7WMz_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl21_r7WMz_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.417954663 UTC

[section ""data" . lvl23_r7WMB_closure" {
     lvl23_r7WMB_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl22_r7WMA_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.419946203 UTC

[section ""data" . GHC.Event.Array.removeAt2_closure" {
     GHC.Event.Array.removeAt2_closure:
         const GHC.Event.Array.removeAt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt2_entry() //  [R1]
         { info_tbl: [(c7Yxr,
                       label: GHC.Event.Array.removeAt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yxr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Yxs; else goto c7Yxt;
       c7Yxs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yxt: // global
           (_c7Yxo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Yxo::I64 == 0) goto c7Yxq; else goto c7Yxp;
       c7Yxq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Yxp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Yxo::I64;
           R2 = lvl23_r7WMB_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.424062625 UTC

[section ""cstring" . lvl24_r7WMC_bytes" {
     lvl24_r7WMC_bytes:
         I8[] [114,101,109,111,118,101,65,116,58,32,105,110,118,97,108,105,100,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.426065343 UTC

[section ""data" . GHC.Event.Array.removeAt1_closure" {
     GHC.Event.Array.removeAt1_closure:
         const GHC.Event.Array.removeAt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt1_entry() //  [R1]
         { info_tbl: [(c7YxK,
                       label: GHC.Event.Array.removeAt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YxK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YxL; else goto c7YxM;
       c7YxL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YxM: // global
           (_c7YxF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YxF::I64 == 0) goto c7YxH; else goto c7YxG;
       c7YxH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YxG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YxF::I64;
           I64[Sp - 24] = block_c7YxI_info;
           R2 = lvl24_r7WMC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7YxI() //  [R1]
         { info_tbl: [(c7YxI,
                       label: block_c7YxI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YxI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.433821129 UTC

[section ""data" . GHC.Event.Array.removeAt_closure" {
     GHC.Event.Array.removeAt_closure:
         const GHC.Event.Array.removeAt_info;
         const 0;
 },
 size_s7WRQ_entry() //  [R1]
         { info_tbl: [(c7Yy8,
                       label: size_s7WRQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yy8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Yy9; else goto c7Yya;
       c7Yy9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Yya: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.removeAt2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WSA_entry() //  [R1, R2, R3]
         { info_tbl: [(c7Yyj,
                       label: sat_s7WSA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yyj: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c7Yyx; else goto c7Yyy;
       c7Yyx: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Yyy: // global
           I64[Sp - 24] = block_c7Yyg_info;
           _s7WRQ::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s7WRQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YA0; else goto c7Yyh;
       u7YA0: // global
           call _c7Yyg(R1) args: 0, res: 0, upd: 0;
       c7Yyh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yyg() //  [R1]
         { info_tbl: [(c7Yyg,
                       label: block_c7Yyg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yyg: // global
           I64[Sp - 8] = block_c7Yym_info;
           _s7WRV::P64 = P64[R1 + 7];
           R1 = P64[_s7WRV::P64 + 8];
           P64[Sp] = _s7WRV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YzZ; else goto c7Yyn;
       u7YzZ: // global
           call _c7Yym(R1) args: 0, res: 0, upd: 0;
       c7Yyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yym() //  [R1]
         { info_tbl: [(c7Yym,
                       label: block_c7Yym_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yym: // global
           I64[Sp - 16] = block_c7Yyr_info;
           _s7WS1::I64 = I64[R1 + 15];
           _s7WS2::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WS2::I64;
           I64[Sp] = _s7WS1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7YA1; else goto c7Yys;
       u7YA1: // global
           call _c7Yyr(R1) args: 0, res: 0, upd: 0;
       c7Yys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yyr() //  [R1]
         { info_tbl: [(c7Yyr,
                       label: block_c7Yyr_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yyr: // global
           I64[Sp - 16] = block_c7Yyw_info;
           _s7WS3::P64 = R1;
           _s7WS5::P64 = P64[R1 + 7];
           _s7WS4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 40];
           P64[Sp - 8] = _s7WS5::P64;
           I64[Sp] = _s7WS4::I64;
           P64[Sp + 40] = _s7WS3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7YA2; else goto c7YyC;
       u7YA2: // global
           call _c7Yyw(R1) args: 0, res: 0, upd: 0;
       c7YyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yyw() //  [R1]
         { info_tbl: [(c7Yyw,
                       label: block_c7Yyw_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yyw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YyI; else goto c7YyH;
       c7YyI: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YyH: // global
           _s7WS7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s7WS7::I64, 0)) goto c7Yzj; else goto c7Yzi;
       c7Yzi: // global
           _s7WS1::I64 = I64[Sp + 32];
           if (%MO_S_Ge_W64(_s7WS7::I64,
                            _s7WS1::I64)) goto c7Yzj; else goto c7Yzf;
       c7Yzj: // global
           Hp = Hp - 32;
           R1 = GHC.Event.Array.removeAt1_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c7Yzf: // global
           _s7WRV::P64 = P64[Sp + 40];
           _s7WS2::I64 = I64[Sp + 24];
           _s7WS3::P64 = P64[Sp + 56];
           _s7WSa::I64 = _s7WS1::I64 - 1;
           if (%MO_S_Le_W64(_s7WSa::I64, 0)) goto c7YyV; else goto c7Yzd;
       c7YyV: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Yzd: // global
           if (%MO_S_Ge_W64(_s7WS7::I64,
                            _s7WSa::I64)) goto c7Yz1; else goto c7Yz5;
       c7Yz1: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Yz5: // global
           Hp = Hp - 32;
           I64[Sp] = block_c7Yz4_info;
           R1 = P64[Sp + 48];
           I64[Sp + 32] = _s7WSa::I64;
           I64[Sp + 48] = _s7WS7::I64;
           if (R1 & 7 != 0) goto u7YA3; else goto c7Yz6;
       u7YA3: // global
           call _c7Yz4(R1) args: 0, res: 0, upd: 0;
       c7Yz6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Yz4() //  [R1]
         { info_tbl: [(c7Yz4,
                       label: block_c7Yz4_info
                       rep:StackRep [False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Yz4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Yzc; else goto c7Yzb;
       c7Yzc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Yzb: // global
           _s7WRV::P64 = P64[Sp + 40];
           _s7WS2::I64 = I64[Sp + 24];
           _s7WS3::P64 = P64[Sp + 56];
           _s7WS4::I64 = I64[Sp + 16];
           _s7WS5::P64 = P64[Sp + 8];
           _s7WS7::I64 = I64[Sp + 48];
           _s7WSa::I64 = I64[Sp + 32];
           _s7WSi::I64 = I64[R1 + 7];
           (_s7WSu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7WS4::I64 + _s7WSi::I64 * _s7WS7::I64, _s7WS4::I64 + _s7WSi::I64 * (_s7WS7::I64 + 1), _s7WSi::I64 * (_s7WSa::I64 - _s7WS7::I64));
           call MO_Touch(_s7WS5::P64);
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WS3::P64;
           I64[Hp - 8] = _s7WSa::I64;
           I64[Hp] = _s7WS2::I64;
           call MO_WriteBarrier();
           P64[_s7WRV::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WRV::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.removeAt_entry() //  [R2]
         { info_tbl: [(c7YA4,
                       label: GHC.Event.Array.removeAt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YA4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7YA8; else goto c7YA7;
       c7YA8: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Event.Array.removeAt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7YA7: // global
           I64[Hp - 32] = size_s7WRQ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7WSA_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.457368058 UTC

[section ""data" . lvl25_r7WMD_closure" {
     lvl25_r7WMD_closure:
         const GHC.Types.I#_con_info;
         const 211;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.459193247 UTC

[section ""data" . lvl26_r7WME_closure" {
     lvl26_r7WME_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.460851233 UTC

[section ""data" . lvl27_r7WMF_closure" {
     lvl27_r7WMF_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.463202714 UTC

[section ""data" . lvl28_r7WMG_closure" {
     lvl28_r7WMG_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl25_r7WMD_closure+1;
         const lvl26_r7WME_closure+1;
         const lvl25_r7WMD_closure+1;
         const lvl27_r7WMF_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.465220802 UTC

[section ""data" . lvl29_r7WMH_closure" {
     lvl29_r7WMH_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl28_r7WMG_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.467619282 UTC

[section ""data" . GHC.Event.Array.findIndex1_closure" {
     GHC.Event.Array.findIndex1_closure:
         const GHC.Event.Array.findIndex1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.findIndex1_entry() //  [R1]
         { info_tbl: [(c7YBd,
                       label: GHC.Event.Array.findIndex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7YBe; else goto c7YBf;
       c7YBe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YBf: // global
           (_c7YBa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YBa::I64 == 0) goto c7YBc; else goto c7YBb;
       c7YBc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YBb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YBa::I64;
           R2 = lvl29_r7WMH_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.473887609 UTC

[section ""data" . GHC.Event.Array.findIndex_closure" {
     GHC.Event.Array.findIndex_closure:
         const GHC.Event.Array.findIndex_info;
         const 0;
 },
 size_s7WSC_entry() //  [R1]
         { info_tbl: [(c7YBv,
                       label: size_s7WSC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7YBw; else goto c7YBx;
       c7YBw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YBx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.findIndex1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7WTj_entry() //  [R1, R2, R3]
         { info_tbl: [(c7YBG,
                       label: sat_s7WTj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBG: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7YBU; else goto c7YBV;
       c7YBU: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YBV: // global
           I64[Sp - 32] = block_c7YBD_info;
           _s7WSB::P64 = P64[R1 + 5];
           _s7WSC::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s7WSB::P64;
           P64[Sp - 16] = _s7WSC::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7YD5; else goto c7YBE;
       u7YD5: // global
           call _c7YBD(R1) args: 0, res: 0, upd: 0;
       c7YBE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YBD() //  [R1]
         { info_tbl: [(c7YBD,
                       label: block_c7YBD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBD: // global
           _s7WSK::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7YBJ_info;
           R1 = _s7WSK::P64;
           if (R1 & 7 != 0) goto u7YD4; else goto c7YBK;
       u7YD4: // global
           call _c7YBJ(R1) args: 0, res: 0, upd: 0;
       c7YBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YBJ() //  [R1]
         { info_tbl: [(c7YBJ,
                       label: block_c7YBJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBJ: // global
           I64[Sp - 8] = block_c7YBO_info;
           _s7WSN::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WSN::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YD6; else goto c7YBP;
       u7YD6: // global
           call _c7YBO(R1) args: 0, res: 0, upd: 0;
       c7YBP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YBO() //  [R1]
         { info_tbl: [(c7YBO,
                       label: block_c7YBO_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBO: // global
           I64[Sp - 8] = block_c7YBT_info;
           _s7WSR::P64 = P64[R1 + 7];
           _s7WSQ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7WSR::P64;
           I64[Sp + 24] = _s7WSQ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YD7; else goto c7YBZ;
       u7YD7: // global
           call _c7YBT(R1) args: 0, res: 0, upd: 0;
       c7YBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YBT() //  [R1]
         { info_tbl: [(c7YBT,
                       label: block_c7YBT_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YBT: // global
           I64[Sp - 16] = 0;
           I64[Sp - 8] = 0;
           _s7WST::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7WST::I64;
           I64[Sp + 16] = _s7WST::I64;
           Sp = Sp - 24;
           call _c7YCr() args: 0, res: 0, upd: 0;
     }
 },
 _c7YCr() //  []
         { info_tbl: [(c7YCr,
                       label: block_c7YCr_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YCr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7YCw; else goto c7YCv;
       c7YCw: // global
           HpAlloc = 16;
           I64[Sp] = block_c7YCr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7YCv: // global
           _s7WT7::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7WT7::I64,
                            I64[Sp + 24])) goto c7YCI; else goto c7YCU;
       c7YCI: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 56] + _s7WT7::I64;
           I64[Sp] = block_c7YCE_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7YCU: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 32]);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YCE() //  [R1]
         { info_tbl: [(c7YCE,
                       label: block_c7YCE_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YCE: // global
           I64[Sp - 8] = block_c7YCG_info;
           R2 = R1;
           _s7WTf::P64 = R1;
           R1 = P64[Sp + 64];
           P64[Sp] = _s7WTf::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YCG() //  [R1]
         { info_tbl: [(c7YCG,
                       label: block_c7YCG_info
                       rep:StackRep [False, True, True, True, False, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YCG: // global
           _s7WT8::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7YCP; else goto c7YCT;
       c7YCP: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 48];
           I64[Sp + 24] = _s7WT8::I64 + 1;
           Sp = Sp + 8;
           call _c7YCr() args: 0, res: 0, upd: 0;
       c7YCT: // global
           P64[Sp + 64] = P64[Sp + 8];
           I64[Sp + 72] = _s7WT8::I64;
           Sp = Sp + 32;
           call _c7YC9() args: 0, res: 0, upd: 0;
     }
 },
 _c7YC9() //  []
         { info_tbl: [(c7YC9,
                       label: block_c7YC9_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YC9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YCi; else goto c7YCh;
       c7YCi: // global
           HpAlloc = 56;
           I64[Sp] = block_c7YC9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7YCh: // global
           _s7WSW::I64 = I64[Sp + 40];
           _s7WSY::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7WSW::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s7WSY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.findIndex_entry() //  [R2]
         { info_tbl: [(c7YDb,
                       label: GHC.Event.Array.findIndex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YDb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7YDf; else goto c7YDe;
       c7YDf: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.findIndex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7YDe: // global
           I64[Hp - 40] = size_s7WSC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7WTj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.500434716 UTC

[section ""data" . lvl30_r7WMI_closure" {
     lvl30_r7WMI_closure:
         const GHC.Types.I#_con_info;
         const 74;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.502559961 UTC

[section ""data" . lvl31_r7WMJ_closure" {
     lvl31_r7WMJ_closure:
         const GHC.Types.I#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.504189805 UTC

[section ""data" . lvl32_r7WMK_closure" {
     lvl32_r7WMK_closure:
         const GHC.Types.I#_con_info;
         const 55;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.505867069 UTC

[section ""data" . lvl33_r7WML_closure" {
     lvl33_r7WML_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl30_r7WMI_closure+1;
         const lvl31_r7WMJ_closure+1;
         const lvl30_r7WMI_closure+1;
         const lvl32_r7WMK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.507540205 UTC

[section ""data" . lvl34_r7WMM_closure" {
     lvl34_r7WMM_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl33_r7WML_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.509672708 UTC

[section ""data" . GHC.Event.Array.ensureCapacity2_closure" {
     GHC.Event.Array.ensureCapacity2_closure:
         const GHC.Event.Array.ensureCapacity2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.ensureCapacity2_entry() //  [R1]
         { info_tbl: [(c7YEn,
                       label: GHC.Event.Array.ensureCapacity2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YEn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7YEo; else goto c7YEp;
       c7YEo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YEp: // global
           (_c7YEk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YEk::I64 == 0) goto c7YEm; else goto c7YEl;
       c7YEm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YEl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YEk::I64;
           R2 = lvl34_r7WMM_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.515410822 UTC

[section ""data" . GHC.Event.Array.$wensureCapacity_closure" {
     GHC.Event.Array.$wensureCapacity_closure:
         const GHC.Event.Array.$wensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.$wensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YEE,
                       label: GHC.Event.Array.$wensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YEE: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c7YEI; else goto c7YEJ;
       c7YEI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wensureCapacity_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YEJ: // global
           I64[Sp - 32] = block_c7YEB_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7YH3; else goto c7YEC;
       u7YH3: // global
           call _c7YEB(R1) args: 0, res: 0, upd: 0;
       c7YEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YEB() //  [R1]
         { info_tbl: [(c7YEB,
                       label: block_c7YEB_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YEB: // global
           I64[Sp - 16] = block_c7YEH_info;
           _s7WTt::I64 = I64[R1 + 15];
           _s7WTu::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WTu::I64;
           I64[Sp] = _s7WTt::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7YH2; else goto c7YEL;
       u7YH2: // global
           call _c7YEH(R1) args: 0, res: 0, upd: 0;
       c7YEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YEH() //  [R1]
         { info_tbl: [(c7YEH,
                       label: block_c7YEH_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YEH: // global
           if (%MO_S_Le_W64(I64[Sp + 40],
                            I64[Sp + 8])) goto c7YET; else goto c7YEX;
       c7YET: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7YEX: // global
           I64[Sp - 8] = block_c7YEW_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7YEW() //  [R1]
         { info_tbl: [(c7YEW,
                       label: block_c7YEW_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YEW: // global
           _s7WTA::I64 = I64[R1 + 7];
           _s7WTB::I64 = I64[Sp + 48] - 1;
           _s7WTC::I64 = _s7WTB::I64 | %MO_S_Shr_W64(_s7WTB::I64, 1);
           _s7WTE::I64 = _s7WTC::I64 | %MO_S_Shr_W64(_s7WTC::I64, 2);
           _s7WTG::I64 = _s7WTE::I64 | %MO_S_Shr_W64(_s7WTE::I64, 4);
           _s7WTI::I64 = _s7WTG::I64 | %MO_S_Shr_W64(_s7WTG::I64, 8);
           _s7WTK::I64 = _s7WTI::I64 | %MO_S_Shr_W64(_s7WTI::I64, 16);
           _s7WTM::I64 = _s7WTK::I64 | %MO_S_Shr_W64(_s7WTK::I64, 32) + 1;
           _s7WTP::I64 = _s7WTM::I64 * _s7WTA::I64;
           if (%MO_S_Ge_W64(_s7WTP::I64, 0)) goto c7YFQ; else goto c7YGG;
       c7YFQ: // global
           I64[Sp - 8] = block_c7YFO_info;
           R1 = _s7WTP::I64;
           I64[Sp] = _s7WTM::I64;
           I64[Sp + 48] = _s7WTA::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7YGG: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YFO() //  [R1]
         { info_tbl: [(c7YFO,
                       label: block_c7YFO_info
                       rep:StackRep [True, False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YFO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7YFU; else goto c7YFT;
       c7YFU: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YFT: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           _s7WTl::P64 = P64[Sp + 48];
           _s7WTt::I64 = I64[Sp + 32];
           _s7WTu::I64 = I64[Sp + 24];
           _s7WTw::I64 = I64[Sp + 40];
           _s7WTx::P64 = P64[Sp + 16];
           _s7WTM::I64 = I64[Sp + 8];
           _s7WTU::I64 = R1 + 16;
           _c7YFY::P64 = Hp - 61;
           if (_s7WTw::I64 == 0) goto c7YGF; else goto c7YGx;
       c7YGF: // global
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7YGD; else goto c7YGE;
       c7YGE: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7YFY::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7YGx: // global
           if (%MO_S_Le_W64(_s7WTu::I64, 0)) goto c7YGc; else goto c7YGv;
       c7YGc: // global
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7YGD; else goto c7YGa;
       c7YGa: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7YFY::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7YGv: // global
           (_s7WU8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WTU::I64, _s7WTw::I64, _s7WTu::I64 * I64[Sp + 56]);
           call MO_Touch(_c7YFY::P64);
           call MO_Touch(_s7WTx::P64);
           if (_s7WTM::I64 == _s7WTu::I64) goto c7YGD; else goto c7YGu;
       c7YGD: // global
           Hp = Hp - 56;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7YGu: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7YFY::P64;
           I64[Hp - 32] = _s7WTU::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WTt::I64;
           I64[Hp] = _s7WTM::I64;
           call MO_WriteBarrier();
           P64[_s7WTl::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WTl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.532139431 UTC

[section ""data" . GHC.Event.Array.ensureCapacity1_closure" {
     GHC.Event.Array.ensureCapacity1_closure:
         const GHC.Event.Array.ensureCapacity1_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YI3,
                       label: GHC.Event.Array.ensureCapacity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YI3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YI7; else goto c7YI8;
       c7YI7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.ensureCapacity1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YI8: // global
           I64[Sp - 24] = block_c7YI0_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YIg; else goto c7YI1;
       u7YIg: // global
           call _c7YI0(R1) args: 0, res: 0, upd: 0;
       c7YI1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YI0() //  [R1]
         { info_tbl: [(c7YI0,
                       label: block_c7YI0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YI0: // global
           I64[Sp] = block_c7YI6_info;
           _s7WUq::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WUq::P64;
           if (R1 & 7 != 0) goto u7YIf; else goto c7YIa;
       u7YIf: // global
           call _c7YI6(R1) args: 0, res: 0, upd: 0;
       c7YIa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YI6() //  [R1]
         { info_tbl: [(c7YI6,
                       label: block_c7YI6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YI6: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wensureCapacity_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.539750632 UTC

[section ""data" . GHC.Event.Array.ensureCapacity_closure" {
     GHC.Event.Array.ensureCapacity_closure:
         const GHC.Event.Array.ensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YIy,
                       label: GHC.Event.Array.ensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YIy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.ensureCapacity1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.545303878 UTC

[section ""data" . GHC.Event.Array.$wsnoc_closure" {
     GHC.Event.Array.$wsnoc_closure:
         const GHC.Event.Array.$wsnoc_info;
         const 0;
 },
 GHC.Event.Array.$wsnoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YIM,
                       label: GHC.Event.Array.$wsnoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YIM: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c7YIQ; else goto c7YIR;
       c7YIQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wsnoc_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YIR: // global
           I64[Sp - 32] = block_c7YIJ_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7YLh; else goto c7YIK;
       u7YLh: // global
           call _c7YIJ(R1) args: 0, res: 0, upd: 0;
       c7YIK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YIJ() //  [R1]
         { info_tbl: [(c7YIJ,
                       label: block_c7YIJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YIJ: // global
           I64[Sp - 16] = block_c7YIP_info;
           _s7WUC::I64 = I64[R1 + 15];
           _s7WUD::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WUD::I64;
           I64[Sp] = _s7WUC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7YLg; else goto c7YIT;
       u7YLg: // global
           call _c7YIP(R1) args: 0, res: 0, upd: 0;
       c7YIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YIP() //  [R1]
         { info_tbl: [(c7YIP,
                       label: block_c7YIP_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YIP: // global
           _s7WUt::P64 = P64[Sp + 24];
           _s7WUC::I64 = I64[Sp + 16];
           _s7WUD::I64 = I64[Sp + 8];
           _s7WUG::P64 = P64[R1 + 7];
           _s7WUF::I64 = I64[R1 + 15];
           _s7WUH::I64 = _s7WUC::I64 + 1;
           if (%MO_S_Le_W64(_s7WUH::I64,
                            _s7WUD::I64)) goto c7YJ6; else goto c7YJd;
       c7YJ6: // global
           I64[Sp] = block_c7YJ4_info;
           R6 = _s7WUC::I64;
           R5 = _s7WUD::I64;
           R4 = _s7WUG::P64;
           R3 = _s7WUF::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp + 24] = _s7WUH::I64;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7YJd: // global
           I64[Sp - 24] = block_c7YJc_info;
           R2 = _s7WUt::P64;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp - 16] = _s7WUG::P64;
           I64[Sp - 8] = _s7WUH::I64;
           I64[Sp] = _s7WUF::I64;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7YJ4() //  [R1]
         { info_tbl: [(c7YJ4,
                       label: block_c7YJ4_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YJ4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YJa; else goto c7YJ9;
       c7YJa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YJ9: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YJc() //  [R1]
         { info_tbl: [(c7YJc,
                       label: block_c7YJc_info
                       rep:StackRep [False, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YJc: // global
           _s7WUP::I64 = I64[R1 + 7];
           _s7WUQ::I64 = I64[Sp + 16] - 1;
           _s7WUR::I64 = _s7WUQ::I64 | %MO_S_Shr_W64(_s7WUQ::I64, 1);
           _s7WUT::I64 = _s7WUR::I64 | %MO_S_Shr_W64(_s7WUR::I64, 2);
           _s7WUV::I64 = _s7WUT::I64 | %MO_S_Shr_W64(_s7WUT::I64, 4);
           _s7WUX::I64 = _s7WUV::I64 | %MO_S_Shr_W64(_s7WUV::I64, 8);
           _s7WUZ::I64 = _s7WUX::I64 | %MO_S_Shr_W64(_s7WUX::I64, 16);
           _s7WV1::I64 = _s7WUZ::I64 | %MO_S_Shr_W64(_s7WUZ::I64, 32) + 1;
           _s7WV4::I64 = _s7WV1::I64 * _s7WUP::I64;
           if (%MO_S_Ge_W64(_s7WV4::I64, 0)) goto c7YK6; else goto c7YKW;
       c7YK6: // global
           I64[Sp - 16] = block_c7YK4_info;
           R1 = _s7WV4::I64;
           I64[Sp - 8] = _s7WV1::I64;
           I64[Sp] = _s7WUP::I64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7YKW: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 72;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YK4() //  [R1]
         { info_tbl: [(c7YK4,
                       label: block_c7YK4_info
                       rep:StackRep [True, True, False, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YK4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7YKa; else goto c7YK9;
       c7YKa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YK9: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7WUt::P64 = P64[Sp + 64];
           _s7WUv::P64 = P64[Sp + 80];
           _s7WUC::I64 = I64[Sp + 56];
           _s7WUF::I64 = I64[Sp + 40];
           _s7WUG::P64 = P64[Sp + 24];
           _s7WV1::I64 = I64[Sp + 8];
           _s7WV9::I64 = R1 + 16;
           _c7YKe::P64 = Hp - 5;
           if (_s7WUF::I64 == 0) goto c7YKR; else goto c7YKN;
       c7YKR: // global
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7YKQ_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7YKe::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7YKe::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7YKN: // global
           _s7WUD::I64 = I64[Sp + 48];
           if (%MO_S_Le_W64(_s7WUD::I64, 0)) goto c7YKo; else goto c7YKH;
       c7YKo: // global
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7YKm_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7YKe::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7YKe::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7YKH: // global
           (_s7WVp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WV9::I64, _s7WUF::I64, _s7WUD::I64 * I64[Sp + 16]);
           call MO_Touch(_c7YKe::P64);
           call MO_Touch(_s7WUG::P64);
           I64[Sp] = block_c7YKG_info;
           R6 = _s7WUC::I64;
           R5 = _s7WV1::I64;
           R4 = _c7YKe::P64;
           R3 = _s7WV9::I64;
           R2 = _s7WUt::P64;
           P64[Sp - 8] = _s7WUv::P64;
           I64[Sp + 64] = _s7WV9::I64;
           P64[Sp + 80] = _c7YKe::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7YKQ() //  [R1]
         { info_tbl: [(c7YKQ,
                       label: block_c7YKQ_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YKQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YKV; else goto c7YKU;
       c7YKV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YKU: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YKm() //  [R1]
         { info_tbl: [(c7YKm,
                       label: block_c7YKm_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YKm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YKs; else goto c7YKr;
       c7YKs: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YKr: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YKG() //  [R1]
         { info_tbl: [(c7YKG,
                       label: block_c7YKG_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YKG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YKL; else goto c7YKK;
       c7YKL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YKK: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7WUu::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7WUu::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WUu::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.57093394 UTC

[section ""data" . GHC.Event.Array.snoc1_closure" {
     GHC.Event.Array.snoc1_closure:
         const GHC.Event.Array.snoc1_info;
         const 0;
 },
 GHC.Event.Array.snoc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YMH,
                       label: GHC.Event.Array.snoc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YMH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YMI; else goto c7YMJ;
       c7YMI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.snoc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YMJ: // global
           I64[Sp - 24] = block_c7YME_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YMN; else goto c7YMF;
       u7YMN: // global
           call _c7YME(R1) args: 0, res: 0, upd: 0;
       c7YMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YME() //  [R1]
         { info_tbl: [(c7YME,
                       label: block_c7YME_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YME: // global
           R4 = P64[Sp + 16];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.577336412 UTC

[section ""data" . GHC.Event.Array.snoc_closure" {
     GHC.Event.Array.snoc_closure:
         const GHC.Event.Array.snoc_info;
         const 0;
 },
 GHC.Event.Array.snoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YN1,
                       label: GHC.Event.Array.snoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YN1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.snoc1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.580697657 UTC

[section ""data" . lvl35_r7WMN_closure" {
     lvl35_r7WMN_closure:
         const GHC.Types.I#_con_info;
         const 245;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.582435946 UTC

[section ""data" . lvl36_r7WMO_closure" {
     lvl36_r7WMO_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.584137369 UTC

[section ""data" . lvl37_r7WMP_closure" {
     lvl37_r7WMP_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.585927503 UTC

[section ""data" . lvl38_r7WMQ_closure" {
     lvl38_r7WMQ_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl35_r7WMN_closure+1;
         const lvl36_r7WMO_closure+1;
         const lvl35_r7WMN_closure+1;
         const lvl37_r7WMP_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.587788223 UTC

[section ""data" . lvl39_r7WMR_closure" {
     lvl39_r7WMR_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl38_r7WMQ_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.590334395 UTC

[section ""data" . lvl40_r7WMS_closure" {
     lvl40_r7WMS_closure:
         const lvl40_r7WMS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_r7WMS_entry() //  [R1]
         { info_tbl: [(c7YNj,
                       label: lvl40_r7WMS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YNj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7YNk; else goto c7YNl;
       c7YNk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YNl: // global
           (_c7YNg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YNg::I64 == 0) goto c7YNi; else goto c7YNh;
       c7YNi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YNh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YNg::I64;
           R2 = lvl39_r7WMR_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.594496035 UTC

[section ""cstring" . lvl41_r7WMT_bytes" {
     lvl41_r7WMT_bytes:
         I8[] [99,111,112,121,58,32,98,97,100,32,111,102,102,115,101,116,115,32,111,114,32,108,101,110,103,116,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.59650527 UTC

[section ""data" . lvl42_r7WMU_closure" {
     lvl42_r7WMU_closure:
         const lvl42_r7WMU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_r7WMU_entry() //  [R1]
         { info_tbl: [(c7YNC,
                       label: lvl42_r7WMU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YNC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YND; else goto c7YNE;
       c7YND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YNE: // global
           (_c7YNx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YNx::I64 == 0) goto c7YNz; else goto c7YNy;
       c7YNz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YNy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YNx::I64;
           I64[Sp - 24] = block_c7YNA_info;
           R2 = lvl41_r7WMT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7YNA() //  [R1]
         { info_tbl: [(c7YNA,
                       label: block_c7YNA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YNA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.607820477 UTC

[section ""data" . GHC.Event.Array.concat3_closure" {
     GHC.Event.Array.concat3_closure:
         const GHC.Event.Array.concat3_info;
         const 0;
 },
 sat_s7WWE_entry() //  [R1]
         { info_tbl: [(c7YPB,
                       label: sat_s7WWE_info
                       rep:HeapRep 2 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YPB: // global
           _s7WWE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7YPC; else goto c7YPD;
       c7YPD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YPF; else goto c7YPE;
       c7YPF: // global
           HpAlloc = 32;
           goto c7YPC;
       c7YPC: // global
           R1 = _s7WWE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YPE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WWE::P64;
           _s7WWn::I64 = I64[_s7WWE::P64 + 48];
           if (%MO_S_Gt_W64(I64[_s7WWE::P64 + 32],
                            _s7WWn::I64)) goto c7YPz; else goto c7YPA;
       c7YPz: // global
           _s7WVU::P64 = P64[_s7WWE::P64 + 16];
           Hp = Hp - 32;
           R1 = _s7WVU::P64 & (-8);
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c7YPA: // global
           _s7WVY::P64 = P64[_s7WWE::P64 + 24];
           _s7WVX::I64 = I64[_s7WWE::P64 + 40];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7WVY::P64;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WVX::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WXm_entry() //  [R1]
         { info_tbl: [(c7YRo,
                       label: sat_s7WXm_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YRo: // global
           _s7WXm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7YRp; else goto c7YRq;
       c7YRq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YRs; else goto c7YRr;
       c7YRs: // global
           HpAlloc = 56;
           goto c7YRp;
       c7YRp: // global
           R1 = _s7WXm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YRr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WXm::P64;
           _s7WX1::P64 = P64[_s7WXm::P64 + 16];
           _s7WVW::I64 = I64[_s7WXm::P64 + 24];
           _s7WWn::I64 = I64[_s7WXm::P64 + 32];
           _s7WWS::I64 = I64[_s7WXm::P64 + 40];
           _s7WX0::I64 = I64[_s7WXm::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7YRm; else goto c7YRn;
       c7YRm: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7YRn: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WXM_entry() //  [R1]
         { info_tbl: [(c7YSn,
                       label: sat_s7WXM_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YSn: // global
           _s7WXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7YSo; else goto c7YSp;
       c7YSp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YSr; else goto c7YSq;
       c7YSr: // global
           HpAlloc = 56;
           goto c7YSo;
       c7YSo: // global
           R1 = _s7WXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YSq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WXM::P64;
           _s7WX1::P64 = P64[_s7WXM::P64 + 16];
           _s7WVW::I64 = I64[_s7WXM::P64 + 24];
           _s7WWn::I64 = I64[_s7WXM::P64 + 32];
           _s7WWS::I64 = I64[_s7WXM::P64 + 40];
           _s7WX0::I64 = I64[_s7WXM::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7YSl; else goto c7YSm;
       c7YSl: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7YSm: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7WY5_entry() //  [R1]
         { info_tbl: [(c7YTb,
                       label: sat_s7WY5_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YTb: // global
           _s7WY5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7YTc; else goto c7YTd;
       c7YTd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YTf; else goto c7YTe;
       c7YTf: // global
           HpAlloc = 56;
           goto c7YTc;
       c7YTc: // global
           R1 = _s7WY5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YTe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7WY5::P64;
           _s7WX1::P64 = P64[_s7WY5::P64 + 16];
           _s7WVW::I64 = I64[_s7WY5::P64 + 24];
           _s7WWn::I64 = I64[_s7WY5::P64 + 32];
           _s7WWS::I64 = I64[_s7WY5::P64 + 40];
           _s7WX0::I64 = I64[_s7WY5::P64 + 48];
           if (%MO_S_Gt_W64(_s7WVW::I64,
                            _s7WWn::I64)) goto c7YT9; else goto c7YTa;
       c7YT9: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WVW::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7YTa: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7WX1::P64;
           I64[Hp - 32] = _s7WX0::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WWn::I64;
           I64[Hp] = _s7WWS::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.concat3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7YTm,
                       label: GHC.Event.Array.concat3_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YTm: // global
           if ((Sp + -120) < SpLim) (likely: False) goto c7YTn; else goto c7YTo;
       c7YTn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c7YTo: // global
           I64[Sp - 40] = block_c7YNW_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7YUC; else goto c7YNX;
       u7YUC: // global
           call _c7YNW(R1) args: 0, res: 0, upd: 0;
       c7YNX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YNW() //  [R1]
         { info_tbl: [(c7YNW,
                       label: block_c7YNW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YNW: // global
           I64[Sp - 24] = block_c7YO1_info;
           _s7WVU::P64 = R1;
           _s7WVW::I64 = I64[R1 + 15];
           _s7WVX::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _s7WVW::I64;
           I64[Sp - 8] = _s7WVX::I64;
           P64[Sp] = _s7WVU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YUr; else goto c7YO2;
       u7YUr: // global
           call _c7YO1(R1) args: 0, res: 0, upd: 0;
       c7YO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YO1() //  [R1]
         { info_tbl: [(c7YO1,
                       label: block_c7YO1_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YO1: // global
           I64[Sp - 16] = block_c7YO6_info;
           _s7WVY::P64 = R1;
           _s7WW0::P64 = P64[R1 + 7];
           _s7WVZ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _s7WW0::P64;
           I64[Sp] = _s7WVZ::I64;
           P64[Sp + 48] = _s7WVY::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7YUs; else goto c7YO7;
       u7YUs: // global
           call _c7YO6(R1) args: 0, res: 0, upd: 0;
       c7YO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YO6() //  [R1]
         { info_tbl: [(c7YO6,
                       label: block_c7YO6_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YO6: // global
           I64[Sp - 8] = block_c7YOb_info;
           _s7WW3::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7WW3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YUt; else goto c7YOc;
       u7YUt: // global
           call _c7YOb(R1) args: 0, res: 0, upd: 0;
       c7YOc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YOb() //  [R1]
         { info_tbl: [(c7YOb,
                       label: block_c7YOb_info
                       rep:StackRep [True, False, True, True, True, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YOb: // global
           I64[Sp - 8] = block_c7YOg_info;
           _s7WW7::P64 = P64[R1 + 7];
           _s7WW6::I64 = I64[R1 + 15];
           R1 = P64[Sp + 88];
           P64[Sp] = _s7WW7::P64;
           I64[Sp + 88] = _s7WW6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YUu; else goto c7YOh;
       u7YUu: // global
           call _c7YOg(R1) args: 0, res: 0, upd: 0;
       c7YOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YOg() //  [R1]
         { info_tbl: [(c7YOg,
                       label: block_c7YOg_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YOg: // global
           _s7WW9::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WW9::I64, 0)) goto c7YTv; else goto u7YUm;
       c7YTv: // global
           I64[Sp] = block_c7YOo_info;
           R1 = P64[Sp + 72];
           I64[Sp + 72] = _s7WW9::I64;
           if (R1 & 7 != 0) goto u7YUv; else goto c7YOp;
       u7YUv: // global
           call _c7YOo(R1) args: 0, res: 0, upd: 0;
       c7YOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7YUm: // global
           Sp = Sp + 104;
           call _c7YUl() args: 0, res: 0, upd: 0;
     }
 },
 _c7YOo() //  [R1]
         { info_tbl: [(c7YOo,
                       label: block_c7YOo_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YOo: // global
           _s7WWc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WWc::I64, 0)) goto c7YUj; else goto u7YUn;
       c7YUj: // global
           if (%MO_S_Le_W64(_s7WWc::I64,
                            I64[Sp + 40])) goto c7YTy; else goto u7YUo;
       c7YTy: // global
           I64[Sp] = block_c7YOz_info;
           R1 = P64[Sp + 88];
           I64[Sp + 88] = _s7WWc::I64;
           if (R1 & 7 != 0) goto u7YUx; else goto c7YOA;
       u7YUx: // global
           call _c7YOz(R1) args: 0, res: 0, upd: 0;
       c7YOA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u7YUo: // global
           Sp = Sp + 104;
           goto u7YUz;
       u7YUn: // global
           Sp = Sp + 104;
           goto u7YUz;
       u7YUz: // global
           call _c7YUl() args: 0, res: 0, upd: 0;
     }
 },
 _c7YOz() //  [R1]
         { info_tbl: [(c7YOz,
                       label: block_c7YOz_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YOz: // global
           _s7WWg::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WWg::I64, 0)) goto c7YUf; else goto u7YUp;
       c7YUf: // global
           _s7WW3::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s7WWg::I64,
                            _s7WW3::I64)) goto c7YUc; else goto u7YUq;
       c7YUc: // global
           _s7WVN::P64 = P64[Sp + 64];
           _s7WVU::P64 = P64[Sp + 56];
           _s7WVX::I64 = I64[Sp + 48];
           _s7WW9::I64 = I64[Sp + 72];
           _s7WWc::I64 = I64[Sp + 88];
           _s7WWj::I64 = _s7WW3::I64 - _s7WWg::I64;
           if (%MO_S_Gt_W64(_s7WW9::I64,
                            _s7WWj::I64)) goto c7YU9; else goto c7YUa;
       c7YU9: // global
           _s7WWl::I64 = _s7WWj::I64;
           goto s7WWk;
       c7YUa: // global
           _s7WWl::I64 = _s7WW9::I64;
           goto s7WWk;
       s7WWk: // global
           if (_s7WWl::I64 == 0) goto c7YU5; else goto c7YU4;
       c7YU5: // global
           R1 = _s7WVU::P64;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7YU4: // global
           _s7WWn::I64 = _s7WWc::I64 + _s7WWl::I64;
           if (%MO_S_Le_W64(_s7WWn::I64,
                            _s7WVX::I64)) goto c7YTC; else goto c7YTG;
       c7YTC: // global
           I64[Sp] = block_c7YP0_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 16] = _s7WWn::I64;
           I64[Sp + 64] = _s7WWl::I64;
           I64[Sp + 72] = _s7WWg::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7YTG: // global
           I64[Sp] = block_c7YPK_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Event.Array.ensureCapacity2_closure;
           I64[Sp + 56] = _s7WWn::I64;
           I64[Sp + 72] = _s7WWl::I64;
           I64[Sp + 80] = _s7WWg::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       u7YUq: // global
           Sp = Sp + 104;
           goto u7YUB;
       u7YUp: // global
           Sp = Sp + 104;
           goto u7YUB;
       u7YUB: // global
           call _c7YUl() args: 0, res: 0, upd: 0;
     }
 },
 _c7YP0() //  [R1]
         { info_tbl: [(c7YP0,
                       label: block_c7YP0_info
                       rep:StackRep [False, True, False, True, True, True, False, True,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YP0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YTF; else goto c7YTE;
       c7YTF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YTE: // global
           _s7WVU::P64 = P64[Sp + 56];
           _s7WVW::I64 = I64[Sp + 40];
           _s7WVX::I64 = I64[Sp + 48];
           _s7WVY::P64 = P64[Sp + 80];
           _s7WW0::P64 = P64[Sp + 24];
           _s7WW7::P64 = P64[Sp + 8];
           _s7WWn::I64 = I64[Sp + 16];
           _s7WWq::I64 = I64[R1 + 7];
           (_s7WWA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 32] + I64[Sp + 88] * _s7WWq::I64, I64[Sp + 96] + I64[Sp + 72] * _s7WWq::I64, I64[Sp + 64] * _s7WWq::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_s7WW0::P64);
           I64[Hp - 48] = sat_s7WWE_info;
           P64[Hp - 32] = _s7WVU::P64;
           P64[Hp - 24] = _s7WVY::P64;
           I64[Hp - 16] = _s7WVW::I64;
           I64[Hp - 8] = _s7WVX::I64;
           I64[Hp] = _s7WWn::I64;
           R1 = Hp - 48;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YPK() //  [R1]
         { info_tbl: [(c7YPK,
                       label: block_c7YPK_info
                       rep:StackRep [False, True, False, True, True, True, True, False,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YPK: // global
           _s7WWG::I64 = I64[R1 + 7];
           _s7WWH::I64 = I64[Sp + 56] - 1;
           _s7WWI::I64 = _s7WWH::I64 | %MO_S_Shr_W64(_s7WWH::I64, 1);
           _s7WWK::I64 = _s7WWI::I64 | %MO_S_Shr_W64(_s7WWI::I64, 2);
           _s7WWM::I64 = _s7WWK::I64 | %MO_S_Shr_W64(_s7WWK::I64, 4);
           _s7WWO::I64 = _s7WWM::I64 | %MO_S_Shr_W64(_s7WWM::I64, 8);
           _s7WWQ::I64 = _s7WWO::I64 | %MO_S_Shr_W64(_s7WWO::I64, 16);
           _s7WWS::I64 = _s7WWQ::I64 | %MO_S_Shr_W64(_s7WWQ::I64, 32) + 1;
           _s7WWV::I64 = _s7WWS::I64 * _s7WWG::I64;
           if (%MO_S_Ge_W64(_s7WWV::I64, 0)) goto c7YTJ; else goto c7YU2;
       c7YTJ: // global
           I64[Sp - 8] = block_c7YQA_info;
           R1 = _s7WWV::I64;
           I64[Sp] = _s7WWS::I64;
           I64[Sp + 16] = _s7WWG::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7YU2: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 104;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YQA() //  [R1]
         { info_tbl: [(c7YQA,
                       label: block_c7YQA_info
                       rep:StackRep [True, False, True, False, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YQA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7YTM; else goto c7YTL;
       c7YTM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YTL: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7WVN::P64 = P64[Sp + 72];
           _s7WVZ::I64 = I64[Sp + 40];
           _s7WW0::P64 = P64[Sp + 32];
           _s7WX0::I64 = R1 + 16;
           _c7YQF::P64 = Hp - 5;
           if (_s7WVZ::I64 == 0) goto c7YTY; else goto c7YTX;
       c7YTY: // global
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7YSA_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7YQF::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7YTX: // global
           _s7WVX::I64 = I64[Sp + 56];
           if (%MO_S_Le_W64(_s7WVX::I64, 0)) goto c7YTO; else goto c7YTS;
       c7YTO: // global
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7YQN_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7YQF::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c7YTS: // global
           (_s7WXs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64, _s7WVZ::I64, _s7WVX::I64 * I64[Sp + 24]);
           call MO_Touch(_c7YQF::P64);
           call MO_Touch(_s7WW0::P64);
           I64[Sp] = block_c7YRM_info;
           R2 = _s7WVN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7WX0::I64;
           P64[Sp + 72] = _c7YQF::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7YSA() //  [R1]
         { info_tbl: [(c7YSA,
                       label: block_c7YSA_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YSA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YU1; else goto c7YU0;
       c7YU1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YU0: // global
           _c7YQF::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WXP::I64 = I64[R1 + 7];
           (_s7WXZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WXP::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WXP::I64, I64[Sp + 80] * _s7WXP::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7YQF::P64);
           I64[Hp - 48] = sat_s7WY5_info;
           P64[Hp - 32] = _c7YQF::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YQN() //  [R1]
         { info_tbl: [(c7YQN,
                       label: block_c7YQN_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YQN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YTR; else goto c7YTQ;
       c7YTR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YTQ: // global
           _c7YQF::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WX6::I64 = I64[R1 + 7];
           (_s7WXg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WX6::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WX6::I64, I64[Sp + 80] * _s7WX6::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7YQF::P64);
           I64[Hp - 48] = sat_s7WXm_info;
           P64[Hp - 32] = _c7YQF::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YRM() //  [R1]
         { info_tbl: [(c7YRM,
                       label: block_c7YRM_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YRM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7YTV; else goto c7YTU;
       c7YTV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YTU: // global
           _c7YQF::P64 = P64[Sp + 72];
           _s7WVW::I64 = I64[Sp + 48];
           _s7WW7::P64 = P64[Sp + 16];
           _s7WWn::I64 = I64[Sp + 64];
           _s7WWS::I64 = I64[Sp + 8];
           _s7WX0::I64 = I64[Sp + 56];
           _s7WXw::I64 = I64[R1 + 7];
           (_s7WXG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7WX0::I64 + I64[Sp + 96] * _s7WXw::I64, I64[Sp + 104] + I64[Sp + 88] * _s7WXw::I64, I64[Sp + 80] * _s7WXw::I64);
           call MO_Touch(_s7WW7::P64);
           call MO_Touch(_c7YQF::P64);
           I64[Hp - 48] = sat_s7WXM_info;
           P64[Hp - 32] = _c7YQF::P64;
           I64[Hp - 24] = _s7WVW::I64;
           I64[Hp - 16] = _s7WWn::I64;
           I64[Hp - 8] = _s7WWS::I64;
           I64[Hp] = _s7WX0::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7YUl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YUl: // global
           R1 = lvl42_r7WMU_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.658102354 UTC

[section ""data" . GHC.Event.Array.concat2_closure" {
     GHC.Event.Array.concat2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.660603867 UTC

[section ""data" . GHC.Event.Array.$wconcat_closure" {
     GHC.Event.Array.$wconcat_closure:
         const GHC.Event.Array.$wconcat_info;
         const 0;
 },
 GHC.Event.Array.$wconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YX7,
                       label: GHC.Event.Array.$wconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YX7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7YXb; else goto c7YXc;
       c7YXb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YXc: // global
           I64[Sp - 32] = block_c7YX4_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7YXu; else goto c7YX5;
       u7YXu: // global
           call _c7YX4(R1) args: 0, res: 0, upd: 0;
       c7YX5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YX4() //  [R1]
         { info_tbl: [(c7YX4,
                       label: block_c7YX4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YX4: // global
           _s7WYq::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_c7YXa_info;
           _s7WYk::P64 = R1;
           _s7WYm::I64 = I64[R1 + 15];
           R1 = _s7WYq::P64;
           I64[Sp] = _s7WYm::I64;
           P64[Sp + 24] = _s7WYk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YXt; else goto c7YXe;
       u7YXt: // global
           call _c7YXa(R1) args: 0, res: 0, upd: 0;
       c7YXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YXa() //  [R1]
         { info_tbl: [(c7YXa,
                       label: block_c7YXa_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YXa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7YXn; else goto c7YXm;
       c7YXn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7YXm: // global
           _s7WYt::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7WYt::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           _s7WYd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7YXk_info;
           R6 = GHC.Event.Array.concat2_closure+1;
           R5 = R1;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = _s7WYd::P64;
           P64[Sp + 8] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7YXk() //  [R1]
         { info_tbl: [(c7YXk,
                       label: block_c7YXk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YXk: // global
           _s7WYe::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7WYe::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WYe::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.671287893 UTC

[section ""data" . GHC.Event.Array.concat1_closure" {
     GHC.Event.Array.concat1_closure:
         const GHC.Event.Array.concat1_info;
         const 0;
 },
 GHC.Event.Array.concat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YXX,
                       label: GHC.Event.Array.concat1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YXX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7YY1; else goto c7YY2;
       c7YY1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YY2: // global
           I64[Sp - 24] = block_c7YXU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7YYa; else goto c7YXV;
       u7YYa: // global
           call _c7YXU(R1) args: 0, res: 0, upd: 0;
       c7YXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YXU() //  [R1]
         { info_tbl: [(c7YXU,
                       label: block_c7YXU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YXU: // global
           I64[Sp] = block_c7YY0_info;
           _s7WYG::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WYG::P64;
           if (R1 & 7 != 0) goto u7YY9; else goto c7YY4;
       u7YY9: // global
           call _c7YY0(R1) args: 0, res: 0, upd: 0;
       c7YY4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YY0() //  [R1]
         { info_tbl: [(c7YY0,
                       label: block_c7YY0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YY0: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wconcat_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.679439285 UTC

[section ""data" . GHC.Event.Array.concat_closure" {
     GHC.Event.Array.concat_closure:
         const GHC.Event.Array.concat_info;
         const 0;
 },
 GHC.Event.Array.concat_entry() //  [R2, R3, R4]
         { info_tbl: [(c7YYs,
                       label: GHC.Event.Array.concat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YYs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.concat1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.683737345 UTC

[section ""data" . GHC.Event.Array.copy1_closure" {
     GHC.Event.Array.copy1_closure:
         const GHC.Event.Array.copy1_info;
         const 0;
 },
 GHC.Event.Array.copy1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7YYG,
                       label: GHC.Event.Array.copy1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YYG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7YYK; else goto c7YYL;
       c7YYK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.copy1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c7YYL: // global
           I64[Sp - 40] = block_c7YYD_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7YYZ; else goto c7YYE;
       u7YYZ: // global
           call _c7YYD(R1) args: 0, res: 0, upd: 0;
       c7YYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YYD() //  [R1]
         { info_tbl: [(c7YYD,
                       label: block_c7YYD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YYD: // global
           I64[Sp - 8] = block_c7YYJ_info;
           _s7WYR::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp] = P64[_s7WYR::P64 + 8];
           P64[Sp + 24] = _s7WYR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7YYY; else goto c7YYN;
       u7YYY: // global
           call _c7YYJ(R1) args: 0, res: 0, upd: 0;
       c7YYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7YYJ() //  [R1]
         { info_tbl: [(c7YYJ,
                       label: block_c7YYJ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YYJ: // global
           _s7WYL::P64 = P64[Sp + 24];
           _s7WYZ::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp + 24] = block_c7YYR_info;
           R6 = P64[Sp + 40];
           R5 = _s7WYZ::P64;
           R4 = _s7WYL::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 48];
           Sp = Sp + 16;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7YYR() //  [R1]
         { info_tbl: [(c7YYR,
                       label: block_c7YYR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YYR: // global
           _s7WYR::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7WYR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7WYR::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.693754859 UTC

[section ""data" . GHC.Event.Array.copy_closure" {
     GHC.Event.Array.copy_closure:
         const GHC.Event.Array.copy_info;
         const 0;
 },
 GHC.Event.Array.copy_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7YZp,
                       label: GHC.Event.Array.copy_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YZp: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.copy1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.697142635 UTC

[section ""data" . lvl43_r7WMV_closure" {
     lvl43_r7WMV_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.698951748 UTC

[section ""data" . lvl44_r7WMW_closure" {
     lvl44_r7WMW_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.70078286 UTC

[section ""data" . lvl45_r7WMX_closure" {
     lvl45_r7WMX_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.703012381 UTC

[section ""data" . lvl46_r7WMY_closure" {
     lvl46_r7WMY_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl43_r7WMV_closure+1;
         const lvl44_r7WMW_closure+1;
         const lvl43_r7WMV_closure+1;
         const lvl45_r7WMX_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.704800085 UTC

[section ""data" . lvl47_r7WMZ_closure" {
     lvl47_r7WMZ_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl46_r7WMY_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.707139655 UTC

[section ""data" . GHC.Event.Array.duplicate1_closure" {
     GHC.Event.Array.duplicate1_closure:
         const GHC.Event.Array.duplicate1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate1_entry() //  [R1]
         { info_tbl: [(c7YZH,
                       label: GHC.Event.Array.duplicate1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YZH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7YZI; else goto c7YZJ;
       c7YZI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7YZJ: // global
           (_c7YZE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7YZE::I64 == 0) goto c7YZG; else goto c7YZF;
       c7YZG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7YZF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7YZE::I64;
           R2 = lvl47_r7WMZ_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.712037539 UTC

[section ""data" . GHC.Event.Array.$wnew_closure" {
     GHC.Event.Array.$wnew_closure:
         const GHC.Event.Array.$wnew_info;
         const 0;
 },
 GHC.Event.Array.$wnew_entry() //  [R2, R3]
         { info_tbl: [(c7YZX,
                       label: GHC.Event.Array.$wnew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YZX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7YZY; else goto c7YZZ;
       c7YZY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wnew_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7YZZ: // global
           I64[Sp - 16] = block_c7YZV_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7YZV() //  [R1]
         { info_tbl: [(c7YZV,
                       label: block_c7YZV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7YZV: // global
           _s7WZ9::I64 = I64[Sp + 8] - 1;
           _s7WZa::I64 = _s7WZ9::I64 | %MO_S_Shr_W64(_s7WZ9::I64, 1);
           _s7WZc::I64 = _s7WZa::I64 | %MO_S_Shr_W64(_s7WZa::I64, 2);
           _s7WZe::I64 = _s7WZc::I64 | %MO_S_Shr_W64(_s7WZc::I64, 4);
           _s7WZg::I64 = _s7WZe::I64 | %MO_S_Shr_W64(_s7WZe::I64, 8);
           _s7WZi::I64 = _s7WZg::I64 | %MO_S_Shr_W64(_s7WZg::I64, 16);
           _s7WZk::I64 = _s7WZi::I64 | %MO_S_Shr_W64(_s7WZi::I64, 32) + 1;
           _s7WZn::I64 = _s7WZk::I64 * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WZn::I64, 0)) goto c7Z11; else goto c7Z18;
       c7Z11: // global
           I64[Sp] = block_c7Z0P_info;
           R1 = _s7WZn::I64;
           I64[Sp + 8] = _s7WZk::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7Z18: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Z0P() //  [R1]
         { info_tbl: [(c7Z0P,
                       label: block_c7Z0P_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z0P: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Z14; else goto c7Z13;
       c7Z14: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Z13: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 61;
           P64[Hp - 32] = R1 + 16;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 8] = block_c7Z0X_info;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z0X() //  [R1]
         { info_tbl: [(c7Z0X,
                       label: block_c7Z0X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z0X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Z17; else goto c7Z16;
       c7Z17: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Z16: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.722931119 UTC

[section ""data" . GHC.Event.Array.new1_closure" {
     GHC.Event.Array.new1_closure:
         const GHC.Event.Array.new1_info;
         const 0;
 },
 GHC.Event.Array.new1_entry() //  [R2, R3]
         { info_tbl: [(c7Z1P,
                       label: GHC.Event.Array.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z1P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Z1Q; else goto c7Z1R;
       c7Z1Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Z1R: // global
           I64[Sp - 16] = block_c7Z1M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Z1V; else goto c7Z1N;
       u7Z1V: // global
           call _c7Z1M(R1) args: 0, res: 0, upd: 0;
       c7Z1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z1M() //  [R1]
         { info_tbl: [(c7Z1M,
                       label: block_c7Z1M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z1M: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Array.$wnew_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.729309538 UTC

[section ""data" . GHC.Event.Array.new_closure" {
     GHC.Event.Array.new_closure:
         const GHC.Event.Array.new_info;
         const 0;
 },
 GHC.Event.Array.new_entry() //  [R2, R3]
         { info_tbl: [(c7Z29,
                       label: GHC.Event.Array.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z29: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.new1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.732611088 UTC

[section ""data" . lvl48_r7WN0_closure" {
     lvl48_r7WN0_closure:
         const GHC.Types.I#_con_info;
         const 95;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.734287804 UTC

[section ""data" . lvl49_r7WN1_closure" {
     lvl49_r7WN1_closure:
         const GHC.Types.I#_con_info;
         const 23;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.735974431 UTC

[section ""data" . lvl50_r7WN2_closure" {
     lvl50_r7WN2_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.737910744 UTC

[section ""data" . lvl51_r7WN3_closure" {
     lvl51_r7WN3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl48_r7WN0_closure+1;
         const lvl49_r7WN1_closure+1;
         const lvl48_r7WN0_closure+1;
         const lvl50_r7WN2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.739719017 UTC

[section ""data" . lvl52_r7WN4_closure" {
     lvl52_r7WN4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl51_r7WN3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.741843774 UTC

[section ""data" . GHC.Event.Array.duplicate2_closure" {
     GHC.Event.Array.duplicate2_closure:
         const GHC.Event.Array.duplicate2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate2_entry() //  [R1]
         { info_tbl: [(c7Z2r,
                       label: GHC.Event.Array.duplicate2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z2r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Z2s; else goto c7Z2t;
       c7Z2s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Z2t: // global
           (_c7Z2o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Z2o::I64 == 0) goto c7Z2q; else goto c7Z2p;
       c7Z2q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Z2p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Z2o::I64;
           R2 = lvl52_r7WN4_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.747425148 UTC

[section ""data" . GHC.Event.Array.duplicate_closure" {
     GHC.Event.Array.duplicate_closure:
         const GHC.Event.Array.duplicate_info;
         const 0;
 },
 lvl53_s7WZH_entry() //  [R1]
         { info_tbl: [(c7Z2J,
                       label: lvl53_s7WZH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z2J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Z2K; else goto c7Z2L;
       c7Z2K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Z2L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl54_s7WZI_entry() //  [R1]
         { info_tbl: [(c7Z2Q,
                       label: lvl54_s7WZI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z2Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Z2R; else goto c7Z2S;
       c7Z2R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Z2S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7X0n_entry() //  [R1, R2]
         { info_tbl: [(c7Z31,
                       label: sat_s7X0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z31: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Z3f; else goto c7Z3g;
       c7Z3f: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Z3g: // global
           I64[Sp - 24] = block_c7Z2Y_info;
           _s7WZH::P64 = P64[R1 + 6];
           _s7WZI::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s7WZH::P64;
           P64[Sp - 8] = _s7WZI::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Z48; else goto c7Z2Z;
       u7Z48: // global
           call _c7Z2Y(R1) args: 0, res: 0, upd: 0;
       c7Z2Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z2Y() //  [R1]
         { info_tbl: [(c7Z2Y,
                       label: block_c7Z2Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z2Y: // global
           _s7WZP::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Z34_info;
           R1 = _s7WZP::P64;
           if (R1 & 7 != 0) goto u7Z47; else goto c7Z35;
       u7Z47: // global
           call _c7Z34(R1) args: 0, res: 0, upd: 0;
       c7Z35: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z34() //  [R1]
         { info_tbl: [(c7Z34,
                       label: block_c7Z34_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z34: // global
           I64[Sp - 16] = block_c7Z39_info;
           _s7WZS::I64 = I64[R1 + 15];
           _s7WZT::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7WZT::I64;
           I64[Sp] = _s7WZS::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Z49; else goto c7Z3a;
       u7Z49: // global
           call _c7Z39(R1) args: 0, res: 0, upd: 0;
       c7Z3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z39() //  [R1]
         { info_tbl: [(c7Z39,
                       label: block_c7Z39_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z39: // global
           I64[Sp - 8] = block_c7Z3e_info;
           _s7WZW::P64 = P64[R1 + 7];
           _s7WZV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _s7WZW::P64;
           I64[Sp + 32] = _s7WZV::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Z4a; else goto c7Z3k;
       u7Z4a: // global
           call _c7Z3e(R1) args: 0, res: 0, upd: 0;
       c7Z3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z3e() //  [R1]
         { info_tbl: [(c7Z3e,
                       label: block_c7Z3e_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z3e: // global
           _s7WZZ::I64 = I64[Sp + 16] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7WZZ::I64, 0)) goto c7Z3Y; else goto c7Z46;
       c7Z3Y: // global
           I64[Sp] = block_c7Z3v_info;
           R1 = _s7WZZ::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7Z46: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Z3v() //  [R1]
         { info_tbl: [(c7Z3v,
                       label: block_c7Z3v_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z3v: // global
           I64[Sp] = block_c7Z3x_info;
           _s7X03::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7X03::P64;
           if (R1 & 7 != 0) goto u7Z4b; else goto c7Z3y;
       u7Z4b: // global
           call _c7Z3x(R1) args: 0, res: 0, upd: 0;
       c7Z3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z3x() //  [R1]
         { info_tbl: [(c7Z3x,
                       label: block_c7Z3x_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z3x: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Z42; else goto c7Z41;
       c7Z42: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Z41: // global
           _s7WZS::I64 = I64[Sp + 24];
           _s7WZT::I64 = I64[Sp + 16];
           _s7WZW::P64 = P64[Sp + 8];
           _s7X03::P64 = P64[Sp + 32];
           _s7X06::I64 = _s7X03::P64 + 16;
           (_s7X0c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7X06::I64, I64[Sp + 40], _s7WZS::I64 * I64[R1 + 7]);
           call MO_Touch(_s7WZW::P64);
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = _s7X03::P64;
           _c7Z3Q::P64 = Hp - 61;
           call MO_Touch(_c7Z3Q::P64);
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7Z3Q::P64;
           I64[Hp - 32] = _s7X06::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7WZS::I64;
           I64[Hp] = _s7WZT::I64;
           I64[Sp + 40] = block_c7Z3U_info;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Z3U() //  [R1]
         { info_tbl: [(c7Z3U,
                       label: block_c7Z3U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z3U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Z45; else goto c7Z44;
       c7Z45: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Z44: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.duplicate_entry() //  [R2]
         { info_tbl: [(c7Z4c,
                       label: GHC.Event.Array.duplicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z4c: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Z4g; else goto c7Z4f;
       c7Z4g: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.Event.Array.duplicate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Z4f: // global
           I64[Hp - 64] = lvl53_s7WZH_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl54_s7WZI_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7X0n_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.774040139 UTC

[section ""data" . GHC.Event.Array.AC_closure" {
     GHC.Event.Array.AC_closure:
         const GHC.Event.Array.AC_info;
 },
 GHC.Event.Array.AC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Z5d,
                       label: GHC.Event.Array.AC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z5d: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Z5h; else goto c7Z5g;
       c7Z5h: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.AC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Z5g: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.778155434 UTC

[GHC.Event.Array.AC_con_entry() //  [R1]
         { info_tbl: [(c7Z5n,
                       label: GHC.Event.Array.AC_con_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46,65,67]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Z5n: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:03.782268444 UTC

[section ""relreadonly" . S7X3q_srt" {
     S7X3q_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.$wlvl1_closure;
         const GHC.Event.Array.$wunsafeRead_closure;
         const GHC.Event.Array.unsafeRead1_closure;
         const GHC.Event.Array.$wlvl_closure;
         const GHC.Event.Array.$wunsafeWrite'_closure;
         const GHC.Event.Array.unsafeWrite2_closure;
         const GHC.Event.Array.unsafeWrite1_closure;
         const GHC.Err.undefined_closure;
         const lvl15_r7WMj_closure;
         const GHC.Event.Array.forM_1_closure;
         const GHC.Event.Array.forM__closure;
         const lvl20_r7WMo_closure;
         const GHC.Event.Array.loop1_closure;
         const GHC.Event.Array.loop_closure;
         const lvl23_r7WMB_closure;
         const GHC.Event.Array.removeAt2_closure;
         const GHC.Event.Array.removeAt1_closure;
         const GHC.Event.Array.removeAt_closure;
         const lvl29_r7WMH_closure;
         const GHC.Event.Array.findIndex1_closure;
         const GHC.Event.Array.findIndex_closure;
         const lvl34_r7WMM_closure;
         const GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
         const GHC.Event.Array.$wensureCapacity_closure;
         const GHC.Event.Array.ensureCapacity2_closure;
         const GHC.Event.Array.ensureCapacity1_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.snoc1_closure;
         const lvl39_r7WMR_closure;
         const GHC.Event.Array.concat3_closure;
         const lvl40_r7WMS_closure;
         const lvl42_r7WMU_closure;
         const GHC.Event.Array.$wconcat_closure;
         const GHC.Event.Array.concat1_closure;
         const GHC.Event.Array.copy1_closure;
         const lvl47_r7WMZ_closure;
         const GHC.Event.Array.duplicate1_closure;
         const GHC.Event.Array.$wnew_closure;
         const GHC.Event.Array.new1_closure;
         const lvl52_r7WN4_closure;
         const GHC.Err.undefined_closure;
         const GHC.Event.Array.duplicate2_closure;
         const GHC.Event.Array.duplicate_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.173498689 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:07.175259065 UTC

[section ""data" . GHC.Event.Array.$WAC_closure" {
     GHC.Event.Array.$WAC_closure:
         const GHC.Event.Array.$WAC_info;
 },
 GHC.Event.Array.$WAC_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZiT,
                       label: GHC.Event.Array.$WAC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZiT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Zj7; else goto c7Zj8;
       c7Zj7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$WAC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zj8: // global
           I64[Sp - 24] = block_c7ZiQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Zjf; else goto c7ZiR;
       u7Zjf: // global
           call _c7ZiQ(R1) args: 0, res: 0, upd: 0;
       c7ZiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZiQ() //  [R1]
         { info_tbl: [(c7ZiQ,
                       label: block_c7ZiQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZiQ: // global
           I64[Sp] = block_c7ZiW_info;
           _s7Z5x::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Z5x::P64;
           if (R1 & 7 != 0) goto u7Zje; else goto c7ZiX;
       u7Zje: // global
           call _c7ZiW(R1) args: 0, res: 0, upd: 0;
       c7ZiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZiW() //  [R1]
         { info_tbl: [(c7ZiW,
                       label: block_c7ZiW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZiW: // global
           I64[Sp] = block_c7Zj1_info;
           _s7Z5z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7Z5z::I64;
           if (R1 & 7 != 0) goto u7Zjg; else goto c7Zj2;
       u7Zjg: // global
           call _c7Zj1(R1) args: 0, res: 0, upd: 0;
       c7Zj2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zj1() //  [R1]
         { info_tbl: [(c7Zj1,
                       label: block_c7Zj1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zj1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Zjd; else goto c7Zjc;
       c7Zjd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Zjc: // global
           _s7Z5B::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _s7Z5B::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.186933265 UTC

[section ""data" . GHC.Event.Array.empty1_closure" {
     GHC.Event.Array.empty1_closure:
         const GHC.Event.Array.empty1_info;
 },
 GHC.Event.Array.empty1_entry() //  []
         { info_tbl: [(c7ZjR,
                       label: GHC.Event.Array.empty1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZjR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7ZjS; else goto c7ZjT;
       c7ZjS: // global
           R1 = GHC.Event.Array.empty1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7ZjT: // global
           I64[Sp - 8] = block_c7ZjJ_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZjJ() //  [R1]
         { info_tbl: [(c7ZjJ,
                       label: block_c7ZjJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZjJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7ZjW; else goto c7ZjV;
       c7ZjW: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZjV: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_c7ZjO_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZjO() //  [R1]
         { info_tbl: [(c7ZjO,
                       label: block_c7ZjO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZjO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ZjZ; else goto c7ZjY;
       c7ZjZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZjY: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.194429955 UTC

[section ""data" . GHC.Event.Array.empty_closure" {
     GHC.Event.Array.empty_closure:
         const GHC.Event.Array.empty_info;
 },
 GHC.Event.Array.empty_entry() //  []
         { info_tbl: [(c7Zkp,
                       label: GHC.Event.Array.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zkp: // global
           call GHC.Event.Array.empty1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.197811842 UTC

[section ""data" . GHC.Event.Array.length1_closure" {
     GHC.Event.Array.length1_closure:
         const GHC.Event.Array.length1_info;
 },
 GHC.Event.Array.length1_entry() //  [R2]
         { info_tbl: [(c7ZkD,
                       label: GHC.Event.Array.length1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZkD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7ZkM; else goto c7ZkN;
       c7ZkM: // global
           R2 = R2;
           R1 = GHC.Event.Array.length1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ZkN: // global
           I64[Sp - 8] = block_c7ZkA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZkT; else goto c7ZkB;
       u7ZkT: // global
           call _c7ZkA(R1) args: 0, res: 0, upd: 0;
       c7ZkB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZkA() //  [R1]
         { info_tbl: [(c7ZkA,
                       label: block_c7ZkA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZkA: // global
           _s7Z5T::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7ZkG_info;
           R1 = _s7Z5T::P64;
           if (R1 & 7 != 0) goto u7ZkS; else goto c7ZkH;
       u7ZkS: // global
           call _c7ZkG(R1) args: 0, res: 0, upd: 0;
       c7ZkH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZkG() //  [R1]
         { info_tbl: [(c7ZkG,
                       label: block_c7ZkG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZkG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ZkR; else goto c7ZkQ;
       c7ZkR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZkQ: // global
           _s7Z5W::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Z5W::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.204814463 UTC

[section ""data" . GHC.Event.Array.length_closure" {
     GHC.Event.Array.length_closure:
         const GHC.Event.Array.length_info;
 },
 GHC.Event.Array.length_entry() //  [R2]
         { info_tbl: [(c7Zlg,
                       label: GHC.Event.Array.length_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zlg: // global
           R2 = R2;
           call GHC.Event.Array.length1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.208132449 UTC

[section ""data" . GHC.Event.Array.capacity1_closure" {
     GHC.Event.Array.capacity1_closure:
         const GHC.Event.Array.capacity1_info;
 },
 GHC.Event.Array.capacity1_entry() //  [R2]
         { info_tbl: [(c7Zlu,
                       label: GHC.Event.Array.capacity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zlu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7ZlD; else goto c7ZlE;
       c7ZlD: // global
           R2 = R2;
           R1 = GHC.Event.Array.capacity1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ZlE: // global
           I64[Sp - 8] = block_c7Zlr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZlK; else goto c7Zls;
       u7ZlK: // global
           call _c7Zlr(R1) args: 0, res: 0, upd: 0;
       c7Zls: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zlr() //  [R1]
         { info_tbl: [(c7Zlr,
                       label: block_c7Zlr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zlr: // global
           _s7Z65::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Zlx_info;
           R1 = _s7Z65::P64;
           if (R1 & 7 != 0) goto u7ZlJ; else goto c7Zly;
       u7ZlJ: // global
           call _c7Zlx(R1) args: 0, res: 0, upd: 0;
       c7Zly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zlx() //  [R1]
         { info_tbl: [(c7Zlx,
                       label: block_c7Zlx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zlx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ZlI; else goto c7ZlH;
       c7ZlI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZlH: // global
           _s7Z69::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Z69::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.215612592 UTC

[section ""data" . GHC.Event.Array.capacity_closure" {
     GHC.Event.Array.capacity_closure:
         const GHC.Event.Array.capacity_info;
 },
 GHC.Event.Array.capacity_entry() //  [R2]
         { info_tbl: [(c7Zm7,
                       label: GHC.Event.Array.capacity_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zm7: // global
           R2 = R2;
           call GHC.Event.Array.capacity1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.2193624 UTC

[section ""cstring" . lvl_r7WM4_bytes" {
     lvl_r7WM4_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.220964211 UTC

[section ""cstring" . lvl1_r7WM5_bytes" {
     lvl1_r7WM5_bytes:
         I8[] [117,110,115,97,102,101,82,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.223122785 UTC

[section ""cstring" . lvl2_r7WM6_bytes" {
     lvl2_r7WM6_bytes:
         I8[] [58,32,98,111,117,110,100,115,32,101,114,114,111,114,44,32,105,110,100,101,120,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.224683518 UTC

[section ""cstring" . lvl3_r7WM7_bytes" {
     lvl3_r7WM7_bytes:
         I8[] [44,32,99,97,112,97,99,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.227534876 UTC

[section ""data" . GHC.Event.Array.$wlvl1_closure" {
     GHC.Event.Array.$wlvl1_closure:
         const GHC.Event.Array.$wlvl1_info;
         const 0;
 },
 sat_s7Z6k_entry() //  [R1]
         { info_tbl: [(c7ZmL,
                       label: sat_s7Z6k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZmL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7ZmM; else goto c7ZmN;
       c7ZmM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZmN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7ZmI_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7ZmI() //  [R1, R2]
         { info_tbl: [(c7ZmI,
                       label: block_c7ZmI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZmI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7ZmQ; else goto c7ZmP;
       c7ZmQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7ZmP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Z6l_entry() //  [R1]
         { info_tbl: [(c7ZmR,
                       label: sat_s7Z6l_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZmR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7ZmV; else goto c7ZmU;
       c7ZmV: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZmU: // global
           _s7Z6b::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7Z6k_info;
           I64[Hp] = _s7Z6b::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Z6m_entry() //  [R1]
         { info_tbl: [(c7ZmX,
                       label: sat_s7Z6m_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZmX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZmY; else goto c7ZmZ;
       c7ZmY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZmZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7Zmy_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Zmy() //  [R1, R2]
         { info_tbl: [(c7Zmy,
                       label: block_c7Zmy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zmy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Zn2; else goto c7Zn1;
       c7Zn2: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Zn1: // global
           I64[Hp - 40] = sat_s7Z6l_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Z6n_entry() //  [R1]
         { info_tbl: [(c7Zn3,
                       label: sat_s7Z6n_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zn3: // global
           _s7Z6n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Zn4; else goto c7Zn5;
       c7Zn5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Zn7; else goto c7Zn6;
       c7Zn7: // global
           HpAlloc = 32;
           goto c7Zn4;
       c7Zn4: // global
           R1 = _s7Z6n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Zn6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Z6n::P64;
           _s7Z6b::I64 = I64[_s7Z6n::P64 + 16];
           _s7Z6c::I64 = I64[_s7Z6n::P64 + 24];
           I64[Hp - 24] = sat_s7Z6m_info;
           I64[Hp - 8] = _s7Z6b::I64;
           I64[Hp] = _s7Z6c::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Z6o_entry() //  [R1]
         { info_tbl: [(c7Zn8,
                       label: sat_s7Z6o_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zn8: // global
           _s7Z6o::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Zn9; else goto c7Zna;
       c7Zna: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Znc; else goto c7Znb;
       c7Znc: // global
           HpAlloc = 32;
           goto c7Zn9;
       c7Zn9: // global
           R1 = _s7Z6o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Znb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Z6o::P64;
           _s7Z6b::I64 = I64[_s7Z6o::P64 + 16];
           _s7Z6c::I64 = I64[_s7Z6o::P64 + 24];
           I64[Hp - 24] = sat_s7Z6n_info;
           I64[Hp - 8] = _s7Z6b::I64;
           I64[Hp] = _s7Z6c::I64;
           R3 = Hp - 24;
           R2 = lvl1_r7WM5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl1_entry() //  [R2, R3]
         { info_tbl: [(c7Znf,
                       label: GHC.Event.Array.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Znf: // global
           _s7Z6c::I64 = R3;
           _s7Z6b::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7Zng; else goto c7Znh;
       c7Znh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Znj; else goto c7Zni;
       c7Znj: // global
           HpAlloc = 32;
           goto c7Zng;
       c7Zng: // global
           R3 = _s7Z6c::I64;
           R2 = _s7Z6b::I64;
           R1 = GHC.Event.Array.$wlvl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zni: // global
           I64[Hp - 24] = sat_s7Z6o_info;
           I64[Hp - 8] = _s7Z6b::I64;
           I64[Hp] = _s7Z6c::I64;
           I64[Sp - 8] = block_c7Znd_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7Znd() //  [R1]
         { info_tbl: [(c7Znd,
                       label: block_c7Znd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Znd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.247924605 UTC

[section ""data" . GHC.Event.Array.$wunsafeRead_closure" {
     GHC.Event.Array.$wunsafeRead_closure:
         const GHC.Event.Array.$wunsafeRead_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Zol,
                       label: GHC.Event.Array.$wunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zol: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Zop; else goto c7Zoq;
       c7Zop: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zoq: // global
           I64[Sp - 24] = block_c7Zoi_info;
           R1 = P64[R3 + 8];
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7ZoS; else goto c7Zoj;
       u7ZoS: // global
           call _c7Zoi(R1) args: 0, res: 0, upd: 0;
       c7Zoj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zoi() //  [R1]
         { info_tbl: [(c7Zoi,
                       label: block_c7Zoi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zoi: // global
           I64[Sp - 8] = block_c7Zoo_info;
           _s7Z6A::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Z6A::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZoR; else goto c7Zos;
       u7ZoR: // global
           call _c7Zoo(R1) args: 0, res: 0, upd: 0;
       c7Zos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zoo() //  [R1]
         { info_tbl: [(c7Zoo,
                       label: block_c7Zoo_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zoo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Zoy; else goto c7Zox;
       c7Zoy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Zox: // global
           _s7Z6s::I64 = I64[Sp + 24];
           _s7Z6A::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7Z6s::I64, 0)) goto c7ZoP; else goto c7ZoO;
       c7ZoO: // global
           if (%MO_S_Ge_W64(_s7Z6s::I64,
                            _s7Z6A::I64)) goto c7ZoP; else goto c7ZoJ;
       c7ZoP: // global
           Hp = Hp - 32;
           R3 = _s7Z6s::I64;
           R2 = _s7Z6A::I64;
           Sp = Sp + 32;
           call GHC.Event.Array.$wlvl1_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7ZoJ: // global
           _s7Z6D::P64 = P64[R1 + 7];
           _s7Z6C::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7Z6s::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7Z6C::I64;
           _s7Z6q::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c7ZoH_info;
           R2 = _s7Z6q::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = Hp - 23;
           P64[Sp + 24] = _s7Z6D::P64;
           Sp = Sp - 8;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c7ZoH() //  [R1]
         { info_tbl: [(c7ZoH,
                       label: block_c7ZoH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZoH: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.258960422 UTC

[section ""data" . GHC.Event.Array.unsafeRead1_closure" {
     GHC.Event.Array.unsafeRead1_closure:
         const GHC.Event.Array.unsafeRead1_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Zpp,
                       label: GHC.Event.Array.unsafeRead1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zpp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Zpt; else goto c7Zpu;
       c7Zpt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeRead1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zpu: // global
           I64[Sp - 24] = block_c7Zpm_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7ZpC; else goto c7Zpn;
       u7ZpC: // global
           call _c7Zpm(R1) args: 0, res: 0, upd: 0;
       c7Zpn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zpm() //  [R1]
         { info_tbl: [(c7Zpm,
                       label: block_c7Zpm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zpm: // global
           I64[Sp] = block_c7Zps_info;
           _s7Z6T::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Z6T::P64;
           if (R1 & 7 != 0) goto u7ZpB; else goto c7Zpw;
       u7ZpB: // global
           call _c7Zps(R1) args: 0, res: 0, upd: 0;
       c7Zpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zps() //  [R1]
         { info_tbl: [(c7Zps,
                       label: block_c7Zps_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zps: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wunsafeRead_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.266282586 UTC

[section ""data" . GHC.Event.Array.unsafeRead_closure" {
     GHC.Event.Array.unsafeRead_closure:
         const GHC.Event.Array.unsafeRead_info;
         const 0;
 },
 GHC.Event.Array.unsafeRead_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZpW,
                       label: GHC.Event.Array.unsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZpW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeRead1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.269612166 UTC

[section ""cstring" . lvl4_r7WM8_bytes" {
     lvl4_r7WM8_bytes:
         I8[] [117,110,115,97,102,101,87,114,105,116,101,39]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.272473379 UTC

[section ""data" . GHC.Event.Array.$wlvl_closure" {
     GHC.Event.Array.$wlvl_closure:
         const GHC.Event.Array.$wlvl_info;
         const 0;
 },
 sat_s7Z75_entry() //  [R1]
         { info_tbl: [(c7Zqx,
                       label: sat_s7Z75_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zqx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Zqy; else goto c7Zqz;
       c7Zqy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Zqz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7Zqu_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Zqu() //  [R1, R2]
         { info_tbl: [(c7Zqu,
                       label: block_c7Zqu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zqu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7ZqC; else goto c7ZqB;
       c7ZqC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7ZqB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Z76_entry() //  [R1]
         { info_tbl: [(c7ZqD,
                       label: sat_s7Z76_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZqD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7ZqH; else goto c7ZqG;
       c7ZqH: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZqG: // global
           _s7Z6W::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7Z75_info;
           I64[Hp] = _s7Z6W::I64;
           R3 = Hp - 16;
           R2 = lvl3_r7WM7_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Z77_entry() //  [R1]
         { info_tbl: [(c7ZqJ,
                       label: sat_s7Z77_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZqJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZqK; else goto c7ZqL;
       c7ZqK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZqL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7Zqk_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Zqk() //  [R1, R2]
         { info_tbl: [(c7Zqk,
                       label: block_c7Zqk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zqk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7ZqO; else goto c7ZqN;
       c7ZqO: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7ZqN: // global
           I64[Hp - 40] = sat_s7Z76_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Z78_entry() //  [R1]
         { info_tbl: [(c7ZqP,
                       label: sat_s7Z78_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZqP: // global
           _s7Z78::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZqQ; else goto c7ZqR;
       c7ZqR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZqT; else goto c7ZqS;
       c7ZqT: // global
           HpAlloc = 32;
           goto c7ZqQ;
       c7ZqQ: // global
           R1 = _s7Z78::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZqS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Z78::P64;
           _s7Z6W::I64 = I64[_s7Z78::P64 + 16];
           _s7Z6X::I64 = I64[_s7Z78::P64 + 24];
           I64[Hp - 24] = sat_s7Z77_info;
           I64[Hp - 8] = _s7Z6W::I64;
           I64[Hp] = _s7Z6X::I64;
           R3 = Hp - 24;
           R2 = lvl2_r7WM6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Z79_entry() //  [R1]
         { info_tbl: [(c7ZqU,
                       label: sat_s7Z79_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZqU: // global
           _s7Z79::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZqV; else goto c7ZqW;
       c7ZqW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZqY; else goto c7ZqX;
       c7ZqY: // global
           HpAlloc = 32;
           goto c7ZqV;
       c7ZqV: // global
           R1 = _s7Z79::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZqX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Z79::P64;
           _s7Z6W::I64 = I64[_s7Z79::P64 + 16];
           _s7Z6X::I64 = I64[_s7Z79::P64 + 24];
           I64[Hp - 24] = sat_s7Z78_info;
           I64[Hp - 8] = _s7Z6W::I64;
           I64[Hp] = _s7Z6X::I64;
           R3 = Hp - 24;
           R2 = lvl4_r7WM8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wlvl_entry() //  [R2, R3]
         { info_tbl: [(c7Zr1,
                       label: GHC.Event.Array.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zr1: // global
           _s7Z6X::I64 = R3;
           _s7Z6W::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7Zr2; else goto c7Zr3;
       c7Zr3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Zr5; else goto c7Zr4;
       c7Zr5: // global
           HpAlloc = 32;
           goto c7Zr2;
       c7Zr2: // global
           R3 = _s7Z6X::I64;
           R2 = _s7Z6W::I64;
           R1 = GHC.Event.Array.$wlvl_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zr4: // global
           I64[Hp - 24] = sat_s7Z79_info;
           I64[Hp - 8] = _s7Z6W::I64;
           I64[Hp] = _s7Z6X::I64;
           I64[Sp - 8] = block_c7ZqZ_info;
           R3 = Hp - 24;
           R2 = lvl_r7WM4_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZqZ() //  [R1]
         { info_tbl: [(c7ZqZ,
                       label: block_c7ZqZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZqZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.293099066 UTC

[section ""data" . GHC.Event.Array.$wunsafeWrite'_closure" {
     GHC.Event.Array.$wunsafeWrite'_closure:
         const GHC.Event.Array.$wunsafeWrite'_info;
         const 0;
 },
 GHC.Event.Array.$wunsafeWrite'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zs0: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.$wunsafeWrite'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Zs9,
                       label: GHC.Event.Array.$wunsafeWrite'_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zs9: // global
           _s7Z7f::I64 = R6;
           _s7Z7e::I64 = R5;
           _s7Z7d::P64 = R4;
           _s7Z7c::I64 = R3;
           _s7Z7b::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c7Zsa; else goto c7Zsb;
       c7Zsb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Zsd; else goto c7Zsc;
       c7Zsd: // global
           HpAlloc = 32;
           goto c7Zsa;
       c7Zsa: // global
           R1 = GHC.Event.Array.$wunsafeWrite'_closure;
           P64[Sp - 40] = _s7Z7b::P64;
           I64[Sp - 32] = _s7Z7c::I64;
           P64[Sp - 24] = _s7Z7d::P64;
           I64[Sp - 16] = _s7Z7e::I64;
           I64[Sp - 8] = _s7Z7f::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7Zsc: // global
           if (%MO_S_Lt_W64(_s7Z7f::I64, 0)) goto c7Zs8; else goto c7Zs7;
       c7Zs7: // global
           if (%MO_S_Ge_W64(_s7Z7f::I64,
                            _s7Z7e::I64)) goto c7Zs8; else goto c7Zsm;
       c7Zs8: // global
           Hp = Hp - 32;
           R3 = _s7Z7f::I64;
           R2 = _s7Z7e::I64;
           Sp = Sp + 8;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7Zsm: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7Z7f::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7Z7c::I64;
           I64[Sp - 8] = block_c7Zsk_info;
           R2 = _s7Z7b::P64;
           I64[Sp - 40] = stg_ap_pppv_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           P64[Sp - 16] = P64[Sp];
           P64[Sp] = _s7Z7d::P64;
           Sp = Sp - 40;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c7Zsk() //  [R1]
         { info_tbl: [(c7Zsk,
                       label: block_c7Zsk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zsk: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.301214231 UTC

[section ""data" . GHC.Event.Array.unsafeWrite2_closure" {
     GHC.Event.Array.unsafeWrite2_closure:
         const GHC.Event.Array.unsafeWrite2_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7ZsQ,
                       label: GHC.Event.Array.unsafeWrite2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZsQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7ZsZ; else goto c7Zt0;
       c7ZsZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zt0: // global
           I64[Sp - 32] = block_c7ZsN_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Zt9; else goto c7ZsO;
       u7Zt9: // global
           call _c7ZsN(R1) args: 0, res: 0, upd: 0;
       c7ZsO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZsN() //  [R1]
         { info_tbl: [(c7ZsN,
                       label: block_c7ZsN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZsN: // global
           I64[Sp - 8] = block_c7ZsT_info;
           _s7Z7A::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Z7A::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Zt8; else goto c7ZsU;
       u7Zt8: // global
           call _c7ZsT(R1) args: 0, res: 0, upd: 0;
       c7ZsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZsT() //  [R1]
         { info_tbl: [(c7ZsT,
                       label: block_c7ZsT_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZsT: // global
           I64[Sp - 8] = block_c7ZsY_info;
           _s7Z7D::P64 = P64[R1 + 7];
           _s7Z7C::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7Z7D::P64;
           I64[Sp + 24] = _s7Z7C::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Zta; else goto c7Zt3;
       u7Zta: // global
           call _c7ZsY(R1) args: 0, res: 0, upd: 0;
       c7Zt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZsY() //  [R1]
         { info_tbl: [(c7ZsY,
                       label: block_c7ZsY_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZsY: // global
           R6 = I64[R1 + 7];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 32];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.310889529 UTC

[section ""data" . GHC.Event.Array.unsafeWrite1_closure" {
     GHC.Event.Array.unsafeWrite1_closure:
         const GHC.Event.Array.unsafeWrite1_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7ZtC,
                       label: GHC.Event.Array.unsafeWrite1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZtC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZtD; else goto c7ZtE;
       c7ZtD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeWrite1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZtE: // global
           I64[Sp - 32] = block_c7Ztz_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7ZtI; else goto c7ZtA;
       u7ZtI: // global
           call _c7Ztz(R1) args: 0, res: 0, upd: 0;
       c7ZtA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ztz() //  [R1]
         { info_tbl: [(c7Ztz,
                       label: block_c7Ztz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ztz: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[P64[R1 + 7] + 8];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Event.Array.unsafeWrite2_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.316494455 UTC

[section ""data" . GHC.Event.Array.unsafeWrite_closure" {
     GHC.Event.Array.unsafeWrite_closure:
         const GHC.Event.Array.unsafeWrite_info;
         const 0;
 },
 GHC.Event.Array.unsafeWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7ZtY,
                       label: GHC.Event.Array.unsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZtY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeWrite1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.320652909 UTC

[section ""data" . GHC.Event.Array.$wunsafeLoad_closure" {
     GHC.Event.Array.$wunsafeLoad_closure:
         const GHC.Event.Array.$wunsafeLoad_info;
 },
 sat_s7Z8b_entry() //  [R1]
         { info_tbl: [(c7Zuv,
                       label: sat_s7Z8b_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zuv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Zuz; else goto c7ZuA;
       c7Zuz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZuA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7Zus_info;
           _s7Z80::P64 = P64[R1 + 16];
           _s7Z7Z::I64 = I64[R1 + 32];
           R1 = P64[R1 + 24];
           I64[Sp - 32] = _s7Z7Z::I64;
           P64[Sp - 24] = _s7Z80::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7ZuE; else goto c7Zut;
       u7ZuE: // global
           call _c7Zus(R1) args: 0, res: 0, upd: 0;
       c7Zut: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7Zus() //  [R1]
         { info_tbl: [(c7Zus,
                       label: block_c7Zus_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zus: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZuD; else goto c7ZuC;
       c7ZuD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7ZuC: // global
           _s7Z8a::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = _s7Z8a::I64;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.$wunsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7ZuF,
                       label: GHC.Event.Array.$wunsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZuF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7ZuG; else goto c7ZuH;
       c7ZuG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wunsafeLoad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZuH: // global
           I64[Sp - 24] = block_c7Zu9_info;
           R1 = P64[R2 + 8];
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7ZuT; else goto c7Zua;
       u7ZuT: // global
           call _c7Zu9(R1) args: 0, res: 0, upd: 0;
       c7Zua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zu9() //  [R1]
         { info_tbl: [(c7Zu9,
                       label: block_c7Zu9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zu9: // global
           I64[Sp - 8] = block_c7Zue_info;
           _s7Z7Z::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Z7Z::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZuS; else goto c7Zuf;
       u7ZuS: // global
           call _c7Zue(R1) args: 0, res: 0, upd: 0;
       c7Zuf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zue() //  [R1]
         { info_tbl: [(c7Zue,
                       label: block_c7Zue_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zue: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZuL; else goto c7ZuK;
       c7ZuL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZuK: // global
           _s7Z82::P64 = P64[R1 + 7];
           _s7Z81::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7Z81::I64;
           I64[Sp - 8] = block_c7Zul_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           _s7Z80::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _s7Z82::P64;
           P64[Sp + 24] = _s7Z80::P64;
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zul() //  [R1]
         { info_tbl: [(c7Zul,
                       label: block_c7Zul_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zul: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7ZuO; else goto c7ZuN;
       c7ZuO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZuN: // global
           _s7Z7Q::P64 = P64[Sp + 24];
           _s7Z7Z::I64 = I64[Sp + 16];
           _s7Z80::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = sat_s7Z8b_info;
           P64[Hp - 16] = _s7Z80::P64;
           P64[Hp - 8] = R1;
           I64[Hp] = _s7Z7Z::I64;
           call MO_WriteBarrier();
           P64[_s7Z7Q::P64 + 8] = Hp - 32;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7Z7Q::P64);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.335792805 UTC

[section ""data" . GHC.Event.Array.unsafeLoad1_closure" {
     GHC.Event.Array.unsafeLoad1_closure:
         const GHC.Event.Array.unsafeLoad1_info;
 },
 GHC.Event.Array.unsafeLoad1_entry() //  [R2, R3]
         { info_tbl: [(c7ZvF,
                       label: GHC.Event.Array.unsafeLoad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZvF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZvG; else goto c7ZvH;
       c7ZvG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.unsafeLoad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZvH: // global
           I64[Sp - 16] = block_c7ZvC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ZvL; else goto c7ZvD;
       u7ZvL: // global
           call _c7ZvC(R1) args: 0, res: 0, upd: 0;
       c7ZvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZvC() //  [R1]
         { info_tbl: [(c7ZvC,
                       label: block_c7ZvC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZvC: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Event.Array.$wunsafeLoad_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.341186626 UTC

[section ""data" . GHC.Event.Array.unsafeLoad_closure" {
     GHC.Event.Array.unsafeLoad_closure:
         const GHC.Event.Array.unsafeLoad_info;
 },
 GHC.Event.Array.unsafeLoad_entry() //  [R2, R3]
         { info_tbl: [(c7Zw0,
                       label: GHC.Event.Array.unsafeLoad_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zw0: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.unsafeLoad1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.345160114 UTC

[section ""data" . GHC.Event.Array.useAsPtr1_closure" {
     GHC.Event.Array.useAsPtr1_closure:
         const GHC.Event.Array.useAsPtr1_info;
 },
 GHC.Event.Array.useAsPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7Zwe,
                       label: GHC.Event.Array.useAsPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zwe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Zwn; else goto c7Zwo;
       c7Zwn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.useAsPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Zwo: // global
           I64[Sp - 16] = block_c7Zwb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ZwF; else goto c7Zwc;
       u7ZwF: // global
           call _c7Zwb(R1) args: 0, res: 0, upd: 0;
       c7Zwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zwb() //  [R1]
         { info_tbl: [(c7Zwb,
                       label: block_c7Zwb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zwb: // global
           _s7Z8p::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7Zwh_info;
           R1 = _s7Z8p::P64;
           if (R1 & 7 != 0) goto u7ZwE; else goto c7Zwi;
       u7ZwE: // global
           call _c7Zwh(R1) args: 0, res: 0, upd: 0;
       c7Zwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zwh() //  [R1]
         { info_tbl: [(c7Zwh,
                       label: block_c7Zwh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zwh: // global
           I64[Sp - 8] = block_c7Zwm_info;
           _s7Z8s::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Z8s::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZwG; else goto c7Zwr;
       u7ZwG: // global
           call _c7Zwm(R1) args: 0, res: 0, upd: 0;
       c7Zwr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zwm() //  [R1]
         { info_tbl: [(c7Zwm,
                       label: block_c7Zwm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zwm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZwA; else goto c7Zwz;
       c7ZwA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Zwz: // global
           _s7Z8w::P64 = P64[R1 + 7];
           _s7Z8v::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7Z8v::I64;
           I64[Sp + 8] = block_c7Zwx_info;
           R3 = Hp - 23;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Z8w::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zwx() //  [R1]
         { info_tbl: [(c7Zwx,
                       label: block_c7Zwx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zwx: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.356141722 UTC

[section ""data" . GHC.Event.Array.useAsPtr_closure" {
     GHC.Event.Array.useAsPtr_closure:
         const GHC.Event.Array.useAsPtr_info;
 },
 GHC.Event.Array.useAsPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Zxe,
                       label: GHC.Event.Array.useAsPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zxe: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.useAsPtr1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.359929423 UTC

[section ""data" . GHC.Event.Array.clear2_closure" {
     GHC.Event.Array.clear2_closure:
         const GHC.Event.Array.clear2_info;
 },
 GHC.Event.Array.clear2_entry() //  [R2]
         { info_tbl: [(c7Zxs,
                       label: GHC.Event.Array.clear2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zxs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Zxx; else goto c7Zxy;
       c7Zxx: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Zxy: // global
           I64[Sp - 8] = block_c7Zxp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZxC; else goto c7Zxq;
       u7ZxC: // global
           call _c7Zxp(R1) args: 0, res: 0, upd: 0;
       c7Zxq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zxp() //  [R1]
         { info_tbl: [(c7Zxp,
                       label: block_c7Zxp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zxp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7ZxB; else goto c7ZxA;
       c7ZxB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZxA: // global
           _s7Z8F::P64 = P64[R1 + 7];
           _s7Z8H::I64 = I64[R1 + 23];
           I64[Hp - 48] = GHC.Event.Array.AC_con_info;
           P64[Hp - 40] = _s7Z8F::P64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = _s7Z8H::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.365940087 UTC

[section ""data" . GHC.Event.Array.clear1_closure" {
     GHC.Event.Array.clear1_closure:
         const GHC.Event.Array.clear1_info;
 },
 GHC.Event.Array.clear1_entry() //  [R2]
         { info_tbl: [(c7Zy0,
                       label: GHC.Event.Array.clear1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zy0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Zy6; else goto c7Zy7;
       c7Zy6: // global
           R2 = R2;
           R1 = GHC.Event.Array.clear1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Zy7: // global
           I64[Sp - 8] = block_c7ZxX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Zyf; else goto c7ZxY;
       u7Zyf: // global
           call _c7ZxX(R1) args: 0, res: 0, upd: 0;
       c7ZxY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZxX() //  [R1]
         { info_tbl: [(c7ZxX,
                       label: block_c7ZxX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZxX: // global
           I64[Sp] = block_c7Zy3_info;
           R2 = GHC.Event.Array.clear2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zy3() //  [R1]
         { info_tbl: [(c7Zy3,
                       label: block_c7Zy3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zy3: // global
           I64[Sp] = block_c7Zy5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7Zyg; else goto c7Zya;
       u7Zyg: // global
           call _c7Zy5() args: 0, res: 0, upd: 0;
       c7Zya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Zy5() //  []
         { info_tbl: [(c7Zy5,
                       label: block_c7Zy5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zy5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.374665899 UTC

[section ""data" . GHC.Event.Array.clear_closure" {
     GHC.Event.Array.clear_closure:
         const GHC.Event.Array.clear_info;
 },
 GHC.Event.Array.clear_entry() //  [R2]
         { info_tbl: [(c7ZyG,
                       label: GHC.Event.Array.clear_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZyG: // global
           R2 = R2;
           call GHC.Event.Array.clear1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.377815331 UTC

[section ""cstring" . lvl5_r7WM9_bytes" {
     lvl5_r7WM9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.379728255 UTC

[section ""data" . lvl6_r7WMa_closure" {
     lvl6_r7WMa_closure:
         const lvl6_r7WMa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r7WMa_entry() //  [R1]
         { info_tbl: [(c7ZyU,
                       label: lvl6_r7WMa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZyU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZyV; else goto c7ZyW;
       c7ZyV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZyW: // global
           (_c7ZyR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZyR::I64 == 0) goto c7ZyT; else goto c7ZyS;
       c7ZyT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZyS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZyR::I64;
           R2 = lvl5_r7WM9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.383848937 UTC

[section ""cstring" . GHC.Event.Array.$trModule4_bytes" {
     GHC.Event.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.386079909 UTC

[section ""data" . lvl7_r7WMb_closure" {
     lvl7_r7WMb_closure:
         const lvl7_r7WMb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r7WMb_entry() //  [R1]
         { info_tbl: [(c7Zzc,
                       label: lvl7_r7WMb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zzc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Zzd; else goto c7Zze;
       c7Zzd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Zze: // global
           (_c7Zz9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Zz9::I64 == 0) goto c7Zzb; else goto c7Zza;
       c7Zzb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Zza: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Zz9::I64;
           R2 = GHC.Event.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.389772135 UTC

[section ""cstring" . GHC.Event.Array.$trModule2_bytes" {
     GHC.Event.Array.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.391633752 UTC

[section ""data" . lvl8_r7WMc_closure" {
     lvl8_r7WMc_closure:
         const lvl8_r7WMc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r7WMc_entry() //  [R1]
         { info_tbl: [(c7Zzu,
                       label: lvl8_r7WMc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Zzu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Zzv; else goto c7Zzw;
       c7Zzv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Zzw: // global
           (_c7Zzr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Zzr::I64 == 0) goto c7Zzt; else goto c7Zzs;
       c7Zzt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Zzs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Zzr::I64;
           R2 = GHC.Event.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.39534624 UTC

[section ""cstring" . lvl9_r7WMd_bytes" {
     lvl9_r7WMd_bytes:
         I8[] [46,47,71,72,67,47,69,118,101,110,116,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.397057837 UTC

[section ""data" . lvl10_r7WMe_closure" {
     lvl10_r7WMe_closure:
         const lvl10_r7WMe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_r7WMe_entry() //  [R1]
         { info_tbl: [(c7ZzM,
                       label: lvl10_r7WMe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZzM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZzN; else goto c7ZzO;
       c7ZzN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZzO: // global
           (_c7ZzJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZzJ::I64 == 0) goto c7ZzL; else goto c7ZzK;
       c7ZzL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZzK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZzJ::I64;
           R2 = lvl9_r7WMd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.401679405 UTC

[section ""data" . lvl11_r7WMf_closure" {
     lvl11_r7WMf_closure:
         const GHC.Types.I#_con_info;
         const 179;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.403360892 UTC

[section ""data" . lvl12_r7WMg_closure" {
     lvl12_r7WMg_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.405012265 UTC

[section ""data" . lvl13_r7WMh_closure" {
     lvl13_r7WMh_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.406674341 UTC

[section ""data" . lvl14_r7WMi_closure" {
     lvl14_r7WMi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl11_r7WMf_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl11_r7WMf_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.408482618 UTC

[section ""data" . lvl15_r7WMj_closure" {
     lvl15_r7WMj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl14_r7WMi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.412795089 UTC

[section ""data" . GHC.Event.Array.forM_1_closure" {
     GHC.Event.Array.forM_1_closure:
         const GHC.Event.Array.forM_1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.forM_1_entry() //  [R1]
         { info_tbl: [(c7ZA8,
                       label: GHC.Event.Array.forM_1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZA8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZA9; else goto c7ZAa;
       c7ZA9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZAa: // global
           (_c7ZA5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZA5::I64 == 0) goto c7ZA7; else goto c7ZA6;
       c7ZA7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZA6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZA5::I64;
           R2 = lvl15_r7WMj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.418253736 UTC

[section ""data" . GHC.Event.Array.forM__closure" {
     GHC.Event.Array.forM__closure:
         const GHC.Event.Array.forM__info;
         const 0;
 },
 size_s7Z8S_entry() //  [R1]
         { info_tbl: [(c7ZAr,
                       label: size_s7Z8S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZAr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZAs; else goto c7ZAt;
       c7ZAs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZAt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.forM_1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7Z9r_entry() //  [R1, R2, R3]
         { info_tbl: [(c7ZAC,
                       label: sat_s7Z9r_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZAC: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c7ZAQ; else goto c7ZAR;
       c7ZAQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZAR: // global
           I64[Sp - 32] = block_c7ZAz_info;
           _s7Z8R::P64 = P64[R1 + 5];
           _s7Z8S::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s7Z8R::P64;
           P64[Sp - 16] = _s7Z8S::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7ZBD; else goto c7ZAA;
       u7ZBD: // global
           call _c7ZAz(R1) args: 0, res: 0, upd: 0;
       c7ZAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZAz() //  [R1]
         { info_tbl: [(c7ZAz,
                       label: block_c7ZAz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZAz: // global
           _s7Z90::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7ZAF_info;
           R1 = _s7Z90::P64;
           if (R1 & 7 != 0) goto u7ZBC; else goto c7ZAG;
       u7ZBC: // global
           call _c7ZAF(R1) args: 0, res: 0, upd: 0;
       c7ZAG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZAF() //  [R1]
         { info_tbl: [(c7ZAF,
                       label: block_c7ZAF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZAF: // global
           I64[Sp - 8] = block_c7ZAK_info;
           _s7Z93::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Z93::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZBE; else goto c7ZAL;
       u7ZBE: // global
           call _c7ZAK(R1) args: 0, res: 0, upd: 0;
       c7ZAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZAK() //  [R1]
         { info_tbl: [(c7ZAK,
                       label: block_c7ZAK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZAK: // global
           I64[Sp - 8] = block_c7ZAP_info;
           _s7Z97::P64 = P64[R1 + 7];
           _s7Z96::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7Z97::P64;
           I64[Sp + 24] = _s7Z96::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZBF; else goto c7ZAV;
       u7ZBF: // global
           call _c7ZAP(R1) args: 0, res: 0, upd: 0;
       c7ZAV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZAP() //  [R1]
         { info_tbl: [(c7ZAP,
                       label: block_c7ZAP_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZAP: // global
           I64[Sp - 8] = 0;
           _s7Z99::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7Z99::I64;
           I64[Sp + 16] = _s7Z99::I64;
           Sp = Sp - 8;
           call _c7ZBc() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZBc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZBc: // global
           Hp = Hp + 16;
           _s7Z9f::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c7ZBg; else goto c7ZBf;
       c7ZBg: // global
           HpAlloc = 16;
           I64[Sp] = block_c7ZBb_info;
           R1 = _s7Z9f::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7ZBf: // global
           if (%MO_S_Lt_W64(_s7Z9f::I64,
                            I64[Sp + 8])) goto c7ZBs; else goto c7ZBw;
       c7ZBs: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 40] + _s7Z9f::I64;
           I64[Sp - 8] = block_c7ZBo_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 24;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7ZBw: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZBb() //  [R1]
         { info_tbl: [(c7ZBb,
                       label: block_c7ZBb_info
                       rep:StackRep [True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZBb: // global
           I64[Sp] = R1;
           call _c7ZBc() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZBo() //  [R1]
         { info_tbl: [(c7ZBo,
                       label: block_c7ZBo_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZBo: // global
           I64[Sp] = block_c7ZBq_info;
           R2 = R1;
           R1 = P64[Sp + 56];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZBq() //  []
         { info_tbl: [(c7ZBq,
                       label: block_c7ZBq_info
                       rep:StackRep [True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZBq: // global
           I64[Sp + 8] = I64[Sp + 8] + I64[Sp + 32];
           Sp = Sp + 8;
           call _c7ZBc() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.forM__entry() //  [R2]
         { info_tbl: [(c7ZBJ,
                       label: GHC.Event.Array.forM__info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZBJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7ZBN; else goto c7ZBM;
       c7ZBN: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.forM__closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ZBM: // global
           I64[Hp - 40] = size_s7Z8S_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7Z9r_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.439565861 UTC

[section ""data" . lvl16_r7WMk_closure" {
     lvl16_r7WMk_closure:
         const GHC.Types.I#_con_info;
         const 194;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.441458309 UTC

[section ""data" . lvl17_r7WMl_closure" {
     lvl17_r7WMl_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.443097719 UTC

[section ""data" . lvl18_r7WMm_closure" {
     lvl18_r7WMm_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.444695686 UTC

[section ""data" . lvl19_r7WMn_closure" {
     lvl19_r7WMn_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl16_r7WMk_closure+1;
         const lvl17_r7WMl_closure+1;
         const lvl16_r7WMk_closure+1;
         const lvl18_r7WMm_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.446361139 UTC

[section ""data" . lvl20_r7WMo_closure" {
     lvl20_r7WMo_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl19_r7WMn_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.448335463 UTC

[section ""data" . GHC.Event.Array.loop1_closure" {
     GHC.Event.Array.loop1_closure:
         const GHC.Event.Array.loop1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.loop1_entry() //  [R1]
         { info_tbl: [(c7ZD2,
                       label: GHC.Event.Array.loop1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZD2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZD3; else goto c7ZD4;
       c7ZD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZD4: // global
           (_c7ZCZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZCZ::I64 == 0) goto c7ZD1; else goto c7ZD0;
       c7ZD1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZD0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZCZ::I64;
           R2 = lvl20_r7WMo_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.454342983 UTC

[section ""data" . GHC.Event.Array.loop_closure" {
     GHC.Event.Array.loop_closure:
         const GHC.Event.Array.loop_info;
         const 0;
 },
 size_s7Z9t_entry() //  [R1]
         { info_tbl: [(c7ZDl,
                       label: size_s7Z9t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZDl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZDm; else goto c7ZDn;
       c7ZDm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZDn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.loop1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7Zab_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c7ZDw,
                       label: sat_s7Zab_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZDw: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7ZDK; else goto c7ZDL;
       c7ZDK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZDL: // global
           I64[Sp - 40] = block_c7ZDt_info;
           _s7Z9s::P64 = P64[R1 + 4];
           _s7Z9t::P64 = P64[R1 + 12];
           R1 = R2;
           P64[Sp - 32] = _s7Z9s::P64;
           P64[Sp - 24] = _s7Z9t::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7ZEW; else goto c7ZDu;
       u7ZEW: // global
           call _c7ZDt(R1) args: 0, res: 0, upd: 0;
       c7ZDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZDt() //  [R1]
         { info_tbl: [(c7ZDt,
                       label: block_c7ZDt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZDt: // global
           _s7Z9C::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7ZDz_info;
           R1 = _s7Z9C::P64;
           if (R1 & 7 != 0) goto u7ZEV; else goto c7ZDA;
       u7ZEV: // global
           call _c7ZDz(R1) args: 0, res: 0, upd: 0;
       c7ZDA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZDz() //  [R1]
         { info_tbl: [(c7ZDz,
                       label: block_c7ZDz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZDz: // global
           I64[Sp - 8] = block_c7ZDE_info;
           _s7Z9F::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Z9F::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZEX; else goto c7ZDF;
       u7ZEX: // global
           call _c7ZDE(R1) args: 0, res: 0, upd: 0;
       c7ZDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZDE() //  [R1]
         { info_tbl: [(c7ZDE,
                       label: block_c7ZDE_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZDE: // global
           I64[Sp - 8] = block_c7ZDJ_info;
           _s7Z9J::P64 = P64[R1 + 7];
           _s7Z9I::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7Z9J::P64;
           I64[Sp + 24] = _s7Z9I::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZEY; else goto c7ZDP;
       u7ZEY: // global
           call _c7ZDJ(R1) args: 0, res: 0, upd: 0;
       c7ZDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZDJ() //  [R1]
         { info_tbl: [(c7ZDJ,
                       label: block_c7ZDJ_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZDJ: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           _s7Z9L::I64 = I64[R1 + 7];
           I64[Sp + 16] = I64[Sp + 16] * _s7Z9L::I64;
           I64[Sp + 40] = _s7Z9L::I64;
           Sp = Sp - 16;
           call _c7ZEb() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZEb() //  []
         { info_tbl: [(c7ZEb,
                       label: block_c7ZEb_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZEb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ZEg; else goto c7ZEf;
       c7ZEg: // global
           HpAlloc = 16;
           I64[Sp] = block_c7ZEb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7ZEf: // global
           _s7Z9U::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_s7Z9U::I64,
                            I64[Sp + 32])) goto c7ZEu; else goto c7ZEO;
       c7ZEu: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 48] + _s7Z9U::I64;
           I64[Sp] = block_c7ZEo_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7ZEO: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZEo() //  [R1]
         { info_tbl: [(c7ZEo,
                       label: block_c7ZEo_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZEo: // global
           _s7Z9V::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7ZEq_info;
           R3 = R1;
           R2 = _s7Z9V::P64;
           R1 = P64[Sp + 64];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZEq() //  [R1]
         { info_tbl: [(c7ZEq,
                       label: block_c7ZEq_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZEq: // global
           I64[Sp] = block_c7ZEs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u7ZF0; else goto c7ZEx;
       u7ZF0: // global
           call _c7ZEs(R1) args: 0, res: 0, upd: 0;
       c7ZEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZEs() //  [R1]
         { info_tbl: [(c7ZEs,
                       label: block_c7ZEs_info
                       rep:StackRep [True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZEs: // global
           I64[Sp - 8] = block_c7ZEB_info;
           _s7Za7::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s7Za7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZF1; else goto c7ZED;
       u7ZF1: // global
           call _c7ZEB(R1) args: 0, res: 0, upd: 0;
       c7ZED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZEB() //  [R1]
         { info_tbl: [(c7ZEB,
                       label: block_c7ZEB_info
                       rep:StackRep [False, True, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZEB: // global
           if (R1 & 7 == 1) goto c7ZEJ; else goto c7ZEN;
       c7ZEJ: // global
           call MO_Touch(P64[Sp + 24]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZEN: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           call _c7ZEb() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Array.loop_entry() //  [R2]
         { info_tbl: [(c7ZF3,
                       label: GHC.Event.Array.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZF3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7ZF7; else goto c7ZF6;
       c7ZF7: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ZF6: // global
           I64[Hp - 40] = size_s7Z9t_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7Zab_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 12;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.478506795 UTC

[section ""data" . GHC.Event.Array.$trModule3_closure" {
     GHC.Event.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.480147137 UTC

[section ""data" . GHC.Event.Array.$trModule1_closure" {
     GHC.Event.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.481781343 UTC

[section ""data" . GHC.Event.Array.$trModule_closure" {
     GHC.Event.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Array.$trModule3_closure+1;
         const GHC.Event.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.483436898 UTC

[section ""data" . $krep_r7WMp_closure" {
     $krep_r7WMp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.485080336 UTC

[section ""data" . $krep1_r7WMq_closure" {
     $krep1_r7WMq_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.486947136 UTC

[section ""data" . $krep2_r7WMr_closure" {
     $krep2_r7WMr_closure:
         const :_con_info;
         const $krep1_r7WMq_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.488581695 UTC

[section ""data" . $krep3_r7WMs_closure" {
     $krep3_r7WMs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.490255872 UTC

[section ""cstring" . GHC.Event.Array.$tcAC2_bytes" {
     GHC.Event.Array.$tcAC2_bytes:
         I8[] [65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.491800072 UTC

[section ""data" . GHC.Event.Array.$tcAC1_closure" {
     GHC.Event.Array.$tcAC1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcAC2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.493471405 UTC

[section ""data" . GHC.Event.Array.$tcAC_closure" {
     GHC.Event.Array.$tcAC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcAC1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14339520722473255067;
         const 15778732457674388659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.49522127 UTC

[section ""data" . $krep4_r7WMt_closure" {
     $krep4_r7WMt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcAC_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.496876781 UTC

[section ""data" . $krep5_r7WMu_closure" {
     $krep5_r7WMu_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep4_r7WMt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.498951242 UTC

[section ""data" . $krep6_r7WMv_closure" {
     $krep6_r7WMv_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7WMp_closure+1;
         const $krep5_r7WMu_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.500536199 UTC

[section ""data" . GHC.Event.Array.$tc'AC1_closure" {
     GHC.Event.Array.$tc'AC1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7WMs_closure+1;
         const $krep6_r7WMv_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.502669013 UTC

[section ""cstring" . GHC.Event.Array.$tc'AC3_bytes" {
     GHC.Event.Array.$tc'AC3_bytes:
         I8[] [39,65,67]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.504246831 UTC

[section ""data" . GHC.Event.Array.$tc'AC2_closure" {
     GHC.Event.Array.$tc'AC2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'AC3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.505879195 UTC

[section ""data" . GHC.Event.Array.$tc'AC_closure" {
     GHC.Event.Array.$tc'AC_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'AC2_closure+1;
         const GHC.Event.Array.$tc'AC1_closure+4;
         const 954782197074941232;
         const 8411064637322477330;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.507580995 UTC

[section ""data" . $krep7_r7WMw_closure" {
     $krep7_r7WMw_closure:
         const :_con_info;
         const $krep4_r7WMt_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.509838578 UTC

[section ""data" . $krep8_r7WMx_closure" {
     $krep8_r7WMx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep7_r7WMw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.511501641 UTC

[section ""cstring" . GHC.Event.Array.$tcArray2_bytes" {
     GHC.Event.Array.$tcArray2_bytes:
         I8[] [65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.513202613 UTC

[section ""data" . GHC.Event.Array.$tcArray1_closure" {
     GHC.Event.Array.$tcArray1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tcArray2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.514878605 UTC

[section ""data" . GHC.Event.Array.$tcArray_closure" {
     GHC.Event.Array.$tcArray_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tcArray1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18201768782471713089;
         const 1209293416176401920;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.516631183 UTC

[section ""data" . $krep9_r7WMy_closure" {
     $krep9_r7WMy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure+1;
         const $krep2_r7WMr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.518401898 UTC

[section ""data" . GHC.Event.Array.$tc'Array1_closure" {
     GHC.Event.Array.$tc'Array1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r7WMx_closure+1;
         const $krep9_r7WMy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.520049194 UTC

[section ""cstring" . GHC.Event.Array.$tc'Array3_bytes" {
     GHC.Event.Array.$tc'Array3_bytes:
         I8[] [39,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.521705896 UTC

[section ""data" . GHC.Event.Array.$tc'Array2_closure" {
     GHC.Event.Array.$tc'Array2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Array.$tc'Array3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.523953988 UTC

[section ""data" . GHC.Event.Array.$tc'Array_closure" {
     GHC.Event.Array.$tc'Array_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Array.$trModule_closure+1;
         const GHC.Event.Array.$tc'Array2_closure+1;
         const GHC.Event.Array.$tc'Array1_closure+4;
         const 1928439007980526225;
         const 8720085055779125030;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.525790441 UTC

[section ""data" . lvl21_r7WMz_closure" {
     lvl21_r7WMz_closure:
         const GHC.Types.I#_con_info;
         const 265;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.52739368 UTC

[section ""data" . lvl22_r7WMA_closure" {
     lvl22_r7WMA_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl21_r7WMz_closure+1;
         const lvl12_r7WMg_closure+1;
         const lvl21_r7WMz_closure+1;
         const lvl13_r7WMh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.529227619 UTC

[section ""data" . lvl23_r7WMB_closure" {
     lvl23_r7WMB_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl22_r7WMA_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.531506474 UTC

[section ""data" . GHC.Event.Array.removeAt2_closure" {
     GHC.Event.Array.removeAt2_closure:
         const GHC.Event.Array.removeAt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt2_entry() //  [R1]
         { info_tbl: [(c7ZGZ,
                       label: GHC.Event.Array.removeAt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZGZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZH0; else goto c7ZH1;
       c7ZH0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZH1: // global
           (_c7ZGW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZGW::I64 == 0) goto c7ZGY; else goto c7ZGX;
       c7ZGY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZGX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZGW::I64;
           R2 = lvl23_r7WMB_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.535616617 UTC

[section ""cstring" . lvl24_r7WMC_bytes" {
     lvl24_r7WMC_bytes:
         I8[] [114,101,109,111,118,101,65,116,58,32,105,110,118,97,108,105,100,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.537521441 UTC

[section ""data" . GHC.Event.Array.removeAt1_closure" {
     GHC.Event.Array.removeAt1_closure:
         const GHC.Event.Array.removeAt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.removeAt1_entry() //  [R1]
         { info_tbl: [(c7ZHj,
                       label: GHC.Event.Array.removeAt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZHj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7ZHk; else goto c7ZHl;
       c7ZHk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZHl: // global
           (_c7ZHe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZHe::I64 == 0) goto c7ZHg; else goto c7ZHf;
       c7ZHg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZHf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZHe::I64;
           I64[Sp - 24] = block_c7ZHh_info;
           R2 = lvl24_r7WMC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7ZHh() //  [R1]
         { info_tbl: [(c7ZHh,
                       label: block_c7ZHh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZHh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.544401593 UTC

[section ""data" . GHC.Event.Array.removeAt_closure" {
     GHC.Event.Array.removeAt_closure:
         const GHC.Event.Array.removeAt_info;
         const 0;
 },
 size_s7Zae_entry() //  [R1]
         { info_tbl: [(c7ZHJ,
                       label: size_s7Zae_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZHJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZHK; else goto c7ZHL;
       c7ZHK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZHL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.removeAt2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7ZaY_entry() //  [R1, R2, R3]
         { info_tbl: [(c7ZHU,
                       label: sat_s7ZaY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZHU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c7ZI8; else goto c7ZI9;
       c7ZI8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZI9: // global
           I64[Sp - 24] = block_c7ZHR_info;
           _s7Zae::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s7Zae::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7ZJB; else goto c7ZHS;
       u7ZJB: // global
           call _c7ZHR(R1) args: 0, res: 0, upd: 0;
       c7ZHS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZHR() //  [R1]
         { info_tbl: [(c7ZHR,
                       label: block_c7ZHR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZHR: // global
           I64[Sp - 8] = block_c7ZHX_info;
           _s7Zaj::P64 = P64[R1 + 7];
           R1 = P64[_s7Zaj::P64 + 8];
           P64[Sp] = _s7Zaj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZJA; else goto c7ZHY;
       u7ZJA: // global
           call _c7ZHX(R1) args: 0, res: 0, upd: 0;
       c7ZHY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZHX() //  [R1]
         { info_tbl: [(c7ZHX,
                       label: block_c7ZHX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZHX: // global
           I64[Sp - 16] = block_c7ZI2_info;
           _s7Zap::I64 = I64[R1 + 15];
           _s7Zaq::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7Zaq::I64;
           I64[Sp] = _s7Zap::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ZJC; else goto c7ZI3;
       u7ZJC: // global
           call _c7ZI2(R1) args: 0, res: 0, upd: 0;
       c7ZI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZI2() //  [R1]
         { info_tbl: [(c7ZI2,
                       label: block_c7ZI2_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZI2: // global
           I64[Sp - 16] = block_c7ZI7_info;
           _s7Zar::P64 = R1;
           _s7Zat::P64 = P64[R1 + 7];
           _s7Zas::I64 = I64[R1 + 15];
           R1 = P64[Sp + 40];
           P64[Sp - 8] = _s7Zat::P64;
           I64[Sp] = _s7Zas::I64;
           P64[Sp + 40] = _s7Zar::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ZJD; else goto c7ZId;
       u7ZJD: // global
           call _c7ZI7(R1) args: 0, res: 0, upd: 0;
       c7ZId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZI7() //  [R1]
         { info_tbl: [(c7ZI7,
                       label: block_c7ZI7_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZI7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZIj; else goto c7ZIi;
       c7ZIj: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZIi: // global
           _s7Zav::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s7Zav::I64, 0)) goto c7ZIU; else goto c7ZIT;
       c7ZIT: // global
           _s7Zap::I64 = I64[Sp + 32];
           if (%MO_S_Ge_W64(_s7Zav::I64,
                            _s7Zap::I64)) goto c7ZIU; else goto c7ZIQ;
       c7ZIU: // global
           Hp = Hp - 32;
           R1 = GHC.Event.Array.removeAt1_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c7ZIQ: // global
           _s7Zaj::P64 = P64[Sp + 40];
           _s7Zaq::I64 = I64[Sp + 24];
           _s7Zar::P64 = P64[Sp + 56];
           _s7Zay::I64 = _s7Zap::I64 - 1;
           if (%MO_S_Le_W64(_s7Zay::I64, 0)) goto c7ZIw; else goto c7ZIO;
       c7ZIw: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7Zar::P64;
           I64[Hp - 8] = _s7Zay::I64;
           I64[Hp] = _s7Zaq::I64;
           call MO_WriteBarrier();
           P64[_s7Zaj::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7Zaj::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZIO: // global
           if (%MO_S_Ge_W64(_s7Zav::I64,
                            _s7Zay::I64)) goto c7ZIC; else goto c7ZIG;
       c7ZIC: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7Zar::P64;
           I64[Hp - 8] = _s7Zay::I64;
           I64[Hp] = _s7Zaq::I64;
           call MO_WriteBarrier();
           P64[_s7Zaj::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7Zaj::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZIG: // global
           Hp = Hp - 32;
           I64[Sp] = block_c7ZIF_info;
           R1 = P64[Sp + 48];
           I64[Sp + 32] = _s7Zay::I64;
           I64[Sp + 48] = _s7Zav::I64;
           if (R1 & 7 != 0) goto u7ZJE; else goto c7ZIH;
       u7ZJE: // global
           call _c7ZIF(R1) args: 0, res: 0, upd: 0;
       c7ZIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZIF() //  [R1]
         { info_tbl: [(c7ZIF,
                       label: block_c7ZIF_info
                       rep:StackRep [False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZIF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZIN; else goto c7ZIM;
       c7ZIN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZIM: // global
           _s7Zaj::P64 = P64[Sp + 40];
           _s7Zaq::I64 = I64[Sp + 24];
           _s7Zar::P64 = P64[Sp + 56];
           _s7Zas::I64 = I64[Sp + 16];
           _s7Zat::P64 = P64[Sp + 8];
           _s7Zav::I64 = I64[Sp + 48];
           _s7Zay::I64 = I64[Sp + 32];
           _s7ZaG::I64 = I64[R1 + 7];
           (_s7ZaS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7Zas::I64 + _s7ZaG::I64 * _s7Zav::I64, _s7Zas::I64 + _s7ZaG::I64 * (_s7Zav::I64 + 1), _s7ZaG::I64 * (_s7Zay::I64 - _s7Zav::I64));
           call MO_Touch(_s7Zat::P64);
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7Zar::P64;
           I64[Hp - 8] = _s7Zay::I64;
           I64[Hp] = _s7Zaq::I64;
           call MO_WriteBarrier();
           P64[_s7Zaj::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7Zaj::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.removeAt_entry() //  [R2]
         { info_tbl: [(c7ZJF,
                       label: GHC.Event.Array.removeAt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZJF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7ZJJ; else goto c7ZJI;
       c7ZJJ: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Event.Array.removeAt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ZJI: // global
           I64[Hp - 32] = size_s7Zae_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7ZaY_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.565692503 UTC

[section ""data" . lvl25_r7WMD_closure" {
     lvl25_r7WMD_closure:
         const GHC.Types.I#_con_info;
         const 211;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.567361377 UTC

[section ""data" . lvl26_r7WME_closure" {
     lvl26_r7WME_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.569025151 UTC

[section ""data" . lvl27_r7WMF_closure" {
     lvl27_r7WMF_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.570713945 UTC

[section ""data" . lvl28_r7WMG_closure" {
     lvl28_r7WMG_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl25_r7WMD_closure+1;
         const lvl26_r7WME_closure+1;
         const lvl25_r7WMD_closure+1;
         const lvl27_r7WMF_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.572451942 UTC

[section ""data" . lvl29_r7WMH_closure" {
     lvl29_r7WMH_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl28_r7WMG_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.574692802 UTC

[section ""data" . GHC.Event.Array.findIndex1_closure" {
     GHC.Event.Array.findIndex1_closure:
         const GHC.Event.Array.findIndex1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.findIndex1_entry() //  [R1]
         { info_tbl: [(c7ZL4,
                       label: GHC.Event.Array.findIndex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZL4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZL5; else goto c7ZL6;
       c7ZL5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZL6: // global
           (_c7ZL1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZL1::I64 == 0) goto c7ZL3; else goto c7ZL2;
       c7ZL3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZL2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZL1::I64;
           R2 = lvl29_r7WMH_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.580328288 UTC

[section ""data" . GHC.Event.Array.findIndex_closure" {
     GHC.Event.Array.findIndex_closure:
         const GHC.Event.Array.findIndex_info;
         const 0;
 },
 size_s7Zb0_entry() //  [R1]
         { info_tbl: [(c7ZLn,
                       label: size_s7Zb0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZLn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ZLo; else goto c7ZLp;
       c7ZLo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZLp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.findIndex1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7ZbH_entry() //  [R1, R2, R3]
         { info_tbl: [(c7ZLy,
                       label: sat_s7ZbH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZLy: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c7ZLM; else goto c7ZLN;
       c7ZLM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZLN: // global
           I64[Sp - 32] = block_c7ZLv_info;
           _s7ZaZ::P64 = P64[R1 + 5];
           _s7Zb0::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s7ZaZ::P64;
           P64[Sp - 16] = _s7Zb0::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7ZMX; else goto c7ZLw;
       u7ZMX: // global
           call _c7ZLv(R1) args: 0, res: 0, upd: 0;
       c7ZLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZLv() //  [R1]
         { info_tbl: [(c7ZLv,
                       label: block_c7ZLv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZLv: // global
           _s7Zb8::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c7ZLB_info;
           R1 = _s7Zb8::P64;
           if (R1 & 7 != 0) goto u7ZMW; else goto c7ZLC;
       u7ZMW: // global
           call _c7ZLB(R1) args: 0, res: 0, upd: 0;
       c7ZLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZLB() //  [R1]
         { info_tbl: [(c7ZLB,
                       label: block_c7ZLB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZLB: // global
           I64[Sp - 8] = block_c7ZLG_info;
           _s7Zbb::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Zbb::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZMY; else goto c7ZLH;
       u7ZMY: // global
           call _c7ZLG(R1) args: 0, res: 0, upd: 0;
       c7ZLH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZLG() //  [R1]
         { info_tbl: [(c7ZLG,
                       label: block_c7ZLG_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZLG: // global
           I64[Sp - 8] = block_c7ZLL_info;
           _s7Zbf::P64 = P64[R1 + 7];
           _s7Zbe::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s7Zbf::P64;
           I64[Sp + 24] = _s7Zbe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7ZMZ; else goto c7ZLR;
       u7ZMZ: // global
           call _c7ZLL(R1) args: 0, res: 0, upd: 0;
       c7ZLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZLL() //  [R1]
         { info_tbl: [(c7ZLL,
                       label: block_c7ZLL_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZLL: // global
           I64[Sp - 16] = 0;
           I64[Sp - 8] = 0;
           _s7Zbh::I64 = I64[R1 + 7];
           I64[Sp] = I64[Sp + 16] * _s7Zbh::I64;
           I64[Sp + 16] = _s7Zbh::I64;
           Sp = Sp - 24;
           call _c7ZMj() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZMj() //  []
         { info_tbl: [(c7ZMj,
                       label: block_c7ZMj_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZMj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ZMo; else goto c7ZMn;
       c7ZMo: // global
           HpAlloc = 16;
           I64[Sp] = block_c7ZMj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7ZMn: // global
           _s7Zbv::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_s7Zbv::I64,
                            I64[Sp + 24])) goto c7ZMA; else goto c7ZMM;
       c7ZMA: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 56] + _s7Zbv::I64;
           I64[Sp] = block_c7ZMw_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
       c7ZMM: // global
           Hp = Hp - 16;
           call MO_Touch(P64[Sp + 32]);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZMw() //  [R1]
         { info_tbl: [(c7ZMw,
                       label: block_c7ZMw_info
                       rep:StackRep [True, True, True, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZMw: // global
           I64[Sp - 8] = block_c7ZMy_info;
           R2 = R1;
           _s7ZbD::P64 = R1;
           R1 = P64[Sp + 64];
           P64[Sp] = _s7ZbD::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZMy() //  [R1]
         { info_tbl: [(c7ZMy,
                       label: block_c7ZMy_info
                       rep:StackRep [False, True, True, True, False, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZMy: // global
           _s7Zbw::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7ZMH; else goto c7ZML;
       c7ZMH: // global
           I64[Sp + 16] = I64[Sp + 16] + I64[Sp + 48];
           I64[Sp + 24] = _s7Zbw::I64 + 1;
           Sp = Sp + 8;
           call _c7ZMj() args: 0, res: 0, upd: 0;
       c7ZML: // global
           P64[Sp + 64] = P64[Sp + 8];
           I64[Sp + 72] = _s7Zbw::I64;
           Sp = Sp + 32;
           call _c7ZM1() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZM1() //  []
         { info_tbl: [(c7ZM1,
                       label: block_c7ZM1_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZM1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7ZMa; else goto c7ZM9;
       c7ZMa: // global
           HpAlloc = 56;
           I64[Sp] = block_c7ZM1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c7ZM9: // global
           _s7Zbk::I64 = I64[Sp + 40];
           _s7Zbm::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7Zbk::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s7Zbm::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.findIndex_entry() //  [R2]
         { info_tbl: [(c7ZN3,
                       label: GHC.Event.Array.findIndex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZN3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7ZN7; else goto c7ZN6;
       c7ZN7: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Event.Array.findIndex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ZN6: // global
           I64[Hp - 40] = size_s7Zb0_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7ZbH_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.603644497 UTC

[section ""data" . lvl30_r7WMI_closure" {
     lvl30_r7WMI_closure:
         const GHC.Types.I#_con_info;
         const 74;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.605313986 UTC

[section ""data" . lvl31_r7WMJ_closure" {
     lvl31_r7WMJ_closure:
         const GHC.Types.I#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.607004616 UTC

[section ""data" . lvl32_r7WMK_closure" {
     lvl32_r7WMK_closure:
         const GHC.Types.I#_con_info;
         const 55;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.608596098 UTC

[section ""data" . lvl33_r7WML_closure" {
     lvl33_r7WML_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl30_r7WMI_closure+1;
         const lvl31_r7WMJ_closure+1;
         const lvl30_r7WMI_closure+1;
         const lvl32_r7WMK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.6104352 UTC

[section ""data" . lvl34_r7WMM_closure" {
     lvl34_r7WMM_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl33_r7WML_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.612429803 UTC

[section ""data" . GHC.Event.Array.ensureCapacity2_closure" {
     GHC.Event.Array.ensureCapacity2_closure:
         const GHC.Event.Array.ensureCapacity2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.ensureCapacity2_entry() //  [R1]
         { info_tbl: [(c7ZOy,
                       label: GHC.Event.Array.ensureCapacity2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZOy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZOz; else goto c7ZOA;
       c7ZOz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZOA: // global
           (_c7ZOv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZOv::I64 == 0) goto c7ZOx; else goto c7ZOw;
       c7ZOx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZOw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZOv::I64;
           R2 = lvl34_r7WMM_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.618194706 UTC

[section ""data" . GHC.Event.Array.$wensureCapacity_closure" {
     GHC.Event.Array.$wensureCapacity_closure:
         const GHC.Event.Array.$wensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.$wensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZOQ,
                       label: GHC.Event.Array.$wensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZOQ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c7ZOU; else goto c7ZOV;
       c7ZOU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wensureCapacity_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZOV: // global
           I64[Sp - 32] = block_c7ZON_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7ZRf; else goto c7ZOO;
       u7ZRf: // global
           call _c7ZON(R1) args: 0, res: 0, upd: 0;
       c7ZOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZON() //  [R1]
         { info_tbl: [(c7ZON,
                       label: block_c7ZON_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZON: // global
           I64[Sp - 16] = block_c7ZOT_info;
           _s7ZbR::I64 = I64[R1 + 15];
           _s7ZbS::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7ZbS::I64;
           I64[Sp] = _s7ZbR::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ZRe; else goto c7ZOX;
       u7ZRe: // global
           call _c7ZOT(R1) args: 0, res: 0, upd: 0;
       c7ZOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZOT() //  [R1]
         { info_tbl: [(c7ZOT,
                       label: block_c7ZOT_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZOT: // global
           if (%MO_S_Le_W64(I64[Sp + 40],
                            I64[Sp + 8])) goto c7ZP5; else goto c7ZP9;
       c7ZP5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZP9: // global
           I64[Sp - 8] = block_c7ZP8_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp] = P64[R1 + 7];
           I64[Sp + 24] = I64[R1 + 15];
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7ZP8() //  [R1]
         { info_tbl: [(c7ZP8,
                       label: block_c7ZP8_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZP8: // global
           _s7ZbY::I64 = I64[R1 + 7];
           _s7ZbZ::I64 = I64[Sp + 48] - 1;
           _s7Zc0::I64 = _s7ZbZ::I64 | %MO_S_Shr_W64(_s7ZbZ::I64, 1);
           _s7Zc2::I64 = _s7Zc0::I64 | %MO_S_Shr_W64(_s7Zc0::I64, 2);
           _s7Zc4::I64 = _s7Zc2::I64 | %MO_S_Shr_W64(_s7Zc2::I64, 4);
           _s7Zc6::I64 = _s7Zc4::I64 | %MO_S_Shr_W64(_s7Zc4::I64, 8);
           _s7Zc8::I64 = _s7Zc6::I64 | %MO_S_Shr_W64(_s7Zc6::I64, 16);
           _s7Zca::I64 = _s7Zc8::I64 | %MO_S_Shr_W64(_s7Zc8::I64, 32) + 1;
           _s7Zcd::I64 = _s7Zca::I64 * _s7ZbY::I64;
           if (%MO_S_Ge_W64(_s7Zcd::I64, 0)) goto c7ZQ2; else goto c7ZQS;
       c7ZQ2: // global
           I64[Sp - 8] = block_c7ZQ0_info;
           R1 = _s7Zcd::I64;
           I64[Sp] = _s7Zca::I64;
           I64[Sp + 48] = _s7ZbY::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7ZQS: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZQ0() //  [R1]
         { info_tbl: [(c7ZQ0,
                       label: block_c7ZQ0_info
                       rep:StackRep [True, False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZQ0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7ZQ6; else goto c7ZQ5;
       c7ZQ6: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZQ5: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           _s7ZbJ::P64 = P64[Sp + 48];
           _s7ZbR::I64 = I64[Sp + 32];
           _s7ZbS::I64 = I64[Sp + 24];
           _s7ZbU::I64 = I64[Sp + 40];
           _s7ZbV::P64 = P64[Sp + 16];
           _s7Zca::I64 = I64[Sp + 8];
           _s7Zci::I64 = R1 + 16;
           _c7ZQa::P64 = Hp - 61;
           if (_s7ZbU::I64 == 0) goto c7ZQR; else goto c7ZQJ;
       c7ZQR: // global
           call MO_Touch(_s7ZbV::P64);
           if (_s7Zca::I64 == _s7ZbS::I64) goto c7ZQP; else goto c7ZQQ;
       c7ZQQ: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7ZQa::P64;
           I64[Hp - 32] = _s7Zci::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7ZbR::I64;
           I64[Hp] = _s7Zca::I64;
           call MO_WriteBarrier();
           P64[_s7ZbJ::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZbJ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZQJ: // global
           if (%MO_S_Le_W64(_s7ZbS::I64, 0)) goto c7ZQo; else goto c7ZQH;
       c7ZQo: // global
           call MO_Touch(_s7ZbV::P64);
           if (_s7Zca::I64 == _s7ZbS::I64) goto c7ZQP; else goto c7ZQm;
       c7ZQm: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7ZQa::P64;
           I64[Hp - 32] = _s7Zci::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7ZbR::I64;
           I64[Hp] = _s7Zca::I64;
           call MO_WriteBarrier();
           P64[_s7ZbJ::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZbJ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZQH: // global
           (_s7Zcw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Zci::I64, _s7ZbU::I64, _s7ZbS::I64 * I64[Sp + 56]);
           call MO_Touch(_c7ZQa::P64);
           call MO_Touch(_s7ZbV::P64);
           if (_s7Zca::I64 == _s7ZbS::I64) goto c7ZQP; else goto c7ZQG;
       c7ZQP: // global
           Hp = Hp - 56;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ZQG: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c7ZQa::P64;
           I64[Hp - 32] = _s7Zci::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7ZbR::I64;
           I64[Hp] = _s7Zca::I64;
           call MO_WriteBarrier();
           P64[_s7ZbJ::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZbJ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.634612358 UTC

[section ""data" . GHC.Event.Array.ensureCapacity1_closure" {
     GHC.Event.Array.ensureCapacity1_closure:
         const GHC.Event.Array.ensureCapacity1_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZSx,
                       label: GHC.Event.Array.ensureCapacity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZSx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7ZSB; else goto c7ZSC;
       c7ZSB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.ensureCapacity1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZSC: // global
           I64[Sp - 24] = block_c7ZSu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7ZSK; else goto c7ZSv;
       u7ZSK: // global
           call _c7ZSu(R1) args: 0, res: 0, upd: 0;
       c7ZSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZSu() //  [R1]
         { info_tbl: [(c7ZSu,
                       label: block_c7ZSu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZSu: // global
           I64[Sp] = block_c7ZSA_info;
           _s7ZcO::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7ZcO::P64;
           if (R1 & 7 != 0) goto u7ZSJ; else goto c7ZSE;
       u7ZSJ: // global
           call _c7ZSA(R1) args: 0, res: 0, upd: 0;
       c7ZSE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZSA() //  [R1]
         { info_tbl: [(c7ZSA,
                       label: block_c7ZSA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZSA: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wensureCapacity_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.642508208 UTC

[section ""data" . GHC.Event.Array.ensureCapacity_closure" {
     GHC.Event.Array.ensureCapacity_closure:
         const GHC.Event.Array.ensureCapacity_info;
         const 0;
 },
 GHC.Event.Array.ensureCapacity_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZT4,
                       label: GHC.Event.Array.ensureCapacity_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZT4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.ensureCapacity1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.647758402 UTC

[section ""data" . GHC.Event.Array.$wsnoc_closure" {
     GHC.Event.Array.$wsnoc_closure:
         const GHC.Event.Array.$wsnoc_info;
         const 0;
 },
 GHC.Event.Array.$wsnoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZTi,
                       label: GHC.Event.Array.$wsnoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZTi: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c7ZTm; else goto c7ZTn;
       c7ZTm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wsnoc_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZTn: // global
           I64[Sp - 32] = block_c7ZTf_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7ZVN; else goto c7ZTg;
       u7ZVN: // global
           call _c7ZTf(R1) args: 0, res: 0, upd: 0;
       c7ZTg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZTf() //  [R1]
         { info_tbl: [(c7ZTf,
                       label: block_c7ZTf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZTf: // global
           I64[Sp - 16] = block_c7ZTl_info;
           _s7Zd0::I64 = I64[R1 + 15];
           _s7Zd1::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7Zd1::I64;
           I64[Sp] = _s7Zd0::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ZVM; else goto c7ZTp;
       u7ZVM: // global
           call _c7ZTl(R1) args: 0, res: 0, upd: 0;
       c7ZTp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZTl() //  [R1]
         { info_tbl: [(c7ZTl,
                       label: block_c7ZTl_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZTl: // global
           _s7ZcR::P64 = P64[Sp + 24];
           _s7Zd0::I64 = I64[Sp + 16];
           _s7Zd1::I64 = I64[Sp + 8];
           _s7Zd4::P64 = P64[R1 + 7];
           _s7Zd3::I64 = I64[R1 + 15];
           _s7Zd5::I64 = _s7Zd0::I64 + 1;
           if (%MO_S_Le_W64(_s7Zd5::I64,
                            _s7Zd1::I64)) goto c7ZTC; else goto c7ZTJ;
       c7ZTC: // global
           I64[Sp] = block_c7ZTA_info;
           R6 = _s7Zd0::I64;
           R5 = _s7Zd1::I64;
           R4 = _s7Zd4::P64;
           R3 = _s7Zd3::I64;
           R2 = _s7ZcR::P64;
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp + 24] = _s7Zd5::I64;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7ZTJ: // global
           I64[Sp - 24] = block_c7ZTI_info;
           R2 = _s7ZcR::P64;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = GHC.Event.Array.ensureCapacity2_closure;
           P64[Sp - 16] = _s7Zd4::P64;
           I64[Sp - 8] = _s7Zd5::I64;
           I64[Sp] = _s7Zd3::I64;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7ZTA() //  [R1]
         { info_tbl: [(c7ZTA,
                       label: block_c7ZTA_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZTA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ZTG; else goto c7ZTF;
       c7ZTG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZTF: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = P64[Sp + 40];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 8];
           _s7ZcS::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s7ZcS::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZcS::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZTI() //  [R1]
         { info_tbl: [(c7ZTI,
                       label: block_c7ZTI_info
                       rep:StackRep [False, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZTI: // global
           _s7Zdd::I64 = I64[R1 + 7];
           _s7Zde::I64 = I64[Sp + 16] - 1;
           _s7Zdf::I64 = _s7Zde::I64 | %MO_S_Shr_W64(_s7Zde::I64, 1);
           _s7Zdh::I64 = _s7Zdf::I64 | %MO_S_Shr_W64(_s7Zdf::I64, 2);
           _s7Zdj::I64 = _s7Zdh::I64 | %MO_S_Shr_W64(_s7Zdh::I64, 4);
           _s7Zdl::I64 = _s7Zdj::I64 | %MO_S_Shr_W64(_s7Zdj::I64, 8);
           _s7Zdn::I64 = _s7Zdl::I64 | %MO_S_Shr_W64(_s7Zdl::I64, 16);
           _s7Zdp::I64 = _s7Zdn::I64 | %MO_S_Shr_W64(_s7Zdn::I64, 32) + 1;
           _s7Zds::I64 = _s7Zdp::I64 * _s7Zdd::I64;
           if (%MO_S_Ge_W64(_s7Zds::I64, 0)) goto c7ZUC; else goto c7ZVs;
       c7ZUC: // global
           I64[Sp - 16] = block_c7ZUA_info;
           R1 = _s7Zds::I64;
           I64[Sp - 8] = _s7Zdp::I64;
           I64[Sp] = _s7Zdd::I64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c7ZVs: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 72;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZUA() //  [R1]
         { info_tbl: [(c7ZUA,
                       label: block_c7ZUA_info
                       rep:StackRep [True, True, False, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZUA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ZUG; else goto c7ZUF;
       c7ZUG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZUF: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7ZcR::P64 = P64[Sp + 64];
           _s7ZcT::P64 = P64[Sp + 80];
           _s7Zd0::I64 = I64[Sp + 56];
           _s7Zd3::I64 = I64[Sp + 40];
           _s7Zd4::P64 = P64[Sp + 24];
           _s7Zdp::I64 = I64[Sp + 8];
           _s7Zdx::I64 = R1 + 16;
           _c7ZUK::P64 = Hp - 5;
           if (_s7Zd3::I64 == 0) goto c7ZVn; else goto c7ZVj;
       c7ZVn: // global
           call MO_Touch(_s7Zd4::P64);
           I64[Sp] = block_c7ZVm_info;
           R6 = _s7Zd0::I64;
           R5 = _s7Zdp::I64;
           R4 = _c7ZUK::P64;
           R3 = _s7Zdx::I64;
           R2 = _s7ZcR::P64;
           P64[Sp - 8] = _s7ZcT::P64;
           I64[Sp + 64] = _s7Zdx::I64;
           P64[Sp + 80] = _c7ZUK::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7ZVj: // global
           _s7Zd1::I64 = I64[Sp + 48];
           if (%MO_S_Le_W64(_s7Zd1::I64, 0)) goto c7ZUU; else goto c7ZVd;
       c7ZUU: // global
           call MO_Touch(_s7Zd4::P64);
           I64[Sp] = block_c7ZUS_info;
           R6 = _s7Zd0::I64;
           R5 = _s7Zdp::I64;
           R4 = _c7ZUK::P64;
           R3 = _s7Zdx::I64;
           R2 = _s7ZcR::P64;
           P64[Sp - 8] = _s7ZcT::P64;
           I64[Sp + 64] = _s7Zdx::I64;
           P64[Sp + 80] = _c7ZUK::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
       c7ZVd: // global
           (_s7ZdN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Zdx::I64, _s7Zd3::I64, _s7Zd1::I64 * I64[Sp + 16]);
           call MO_Touch(_c7ZUK::P64);
           call MO_Touch(_s7Zd4::P64);
           I64[Sp] = block_c7ZVc_info;
           R6 = _s7Zd0::I64;
           R5 = _s7Zdp::I64;
           R4 = _c7ZUK::P64;
           R3 = _s7Zdx::I64;
           R2 = _s7ZcR::P64;
           P64[Sp - 8] = _s7ZcT::P64;
           I64[Sp + 64] = _s7Zdx::I64;
           P64[Sp + 80] = _c7ZUK::P64;
           Sp = Sp - 8;
           call GHC.Event.Array.$wunsafeWrite'_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7ZVm() //  [R1]
         { info_tbl: [(c7ZVm,
                       label: block_c7ZVm_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZVm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7ZVr; else goto c7ZVq;
       c7ZVr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZVq: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7ZcS::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7ZcS::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZcS::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZUS() //  [R1]
         { info_tbl: [(c7ZUS,
                       label: block_c7ZUS_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZUS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7ZUY; else goto c7ZUX;
       c7ZUY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZUX: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7ZcS::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7ZcS::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZcS::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ZVc() //  [R1]
         { info_tbl: [(c7ZVc,
                       label: block_c7ZVc_info
                       rep:StackRep [True, True, True, True, True, True, True, True,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZVc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7ZVh; else goto c7ZVg;
       c7ZVh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ZVg: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           I64[Hp - 32] = I64[Sp + 64];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 8];
           _s7ZcS::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_s7ZcS::P64 + 8] = Hp - 23;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZcS::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.672526572 UTC

[section ""data" . GHC.Event.Array.snoc1_closure" {
     GHC.Event.Array.snoc1_closure:
         const GHC.Event.Array.snoc1_info;
         const 0;
 },
 GHC.Event.Array.snoc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZXz,
                       label: GHC.Event.Array.snoc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZXz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7ZXA; else goto c7ZXB;
       c7ZXA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.snoc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ZXB: // global
           I64[Sp - 24] = block_c7ZXw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7ZXF; else goto c7ZXx;
       u7ZXF: // global
           call _c7ZXw(R1) args: 0, res: 0, upd: 0;
       c7ZXx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZXw() //  [R1]
         { info_tbl: [(c7ZXw,
                       label: block_c7ZXw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZXw: // global
           R4 = P64[Sp + 16];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.678790427 UTC

[section ""data" . GHC.Event.Array.snoc_closure" {
     GHC.Event.Array.snoc_closure:
         const GHC.Event.Array.snoc_info;
         const 0;
 },
 GHC.Event.Array.snoc_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ZXU,
                       label: GHC.Event.Array.snoc_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZXU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.snoc1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.682818432 UTC

[section ""data" . lvl35_r7WMN_closure" {
     lvl35_r7WMN_closure:
         const GHC.Types.I#_con_info;
         const 245;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.684477797 UTC

[section ""data" . lvl36_r7WMO_closure" {
     lvl36_r7WMO_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.686513002 UTC

[section ""data" . lvl37_r7WMP_closure" {
     lvl37_r7WMP_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.688204114 UTC

[section ""data" . lvl38_r7WMQ_closure" {
     lvl38_r7WMQ_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl35_r7WMN_closure+1;
         const lvl36_r7WMO_closure+1;
         const lvl35_r7WMN_closure+1;
         const lvl37_r7WMP_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.69005428 UTC

[section ""data" . lvl39_r7WMR_closure" {
     lvl39_r7WMR_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl38_r7WMQ_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.69200001 UTC

[section ""data" . lvl40_r7WMS_closure" {
     lvl40_r7WMS_closure:
         const lvl40_r7WMS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_r7WMS_entry() //  [R1]
         { info_tbl: [(c7ZYc,
                       label: lvl40_r7WMS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZYc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ZYd; else goto c7ZYe;
       c7ZYd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZYe: // global
           (_c7ZY9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZY9::I64 == 0) goto c7ZYb; else goto c7ZYa;
       c7ZYb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZYa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZY9::I64;
           R2 = lvl39_r7WMR_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.696093405 UTC

[section ""cstring" . lvl41_r7WMT_bytes" {
     lvl41_r7WMT_bytes:
         I8[] [99,111,112,121,58,32,98,97,100,32,111,102,102,115,101,116,115,32,111,114,32,108,101,110,103,116,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.698192142 UTC

[section ""data" . lvl42_r7WMU_closure" {
     lvl42_r7WMU_closure:
         const lvl42_r7WMU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_r7WMU_entry() //  [R1]
         { info_tbl: [(c7ZYw,
                       label: lvl42_r7WMU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZYw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7ZYx; else goto c7ZYy;
       c7ZYx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ZYy: // global
           (_c7ZYr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7ZYr::I64 == 0) goto c7ZYt; else goto c7ZYs;
       c7ZYt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7ZYs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7ZYr::I64;
           I64[Sp - 24] = block_c7ZYu_info;
           R2 = lvl41_r7WMT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7ZYu() //  [R1]
         { info_tbl: [(c7ZYu,
                       label: block_c7ZYu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZYu: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.708805057 UTC

[section ""data" . GHC.Event.Array.concat3_closure" {
     GHC.Event.Array.concat3_closure:
         const GHC.Event.Array.concat3_info;
         const 0;
 },
 sat_s7Zf2_entry() //  [R1]
         { info_tbl: [(c800x,
                       label: sat_s7Zf2_info
                       rep:HeapRep 2 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c800x: // global
           _s7Zf2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c800y; else goto c800z;
       c800z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c800B; else goto c800A;
       c800B: // global
           HpAlloc = 32;
           goto c800y;
       c800y: // global
           R1 = _s7Zf2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c800A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Zf2::P64;
           _s7ZeL::I64 = I64[_s7Zf2::P64 + 48];
           if (%MO_S_Gt_W64(I64[_s7Zf2::P64 + 32],
                            _s7ZeL::I64)) goto c800v; else goto c800w;
       c800v: // global
           _s7Zei::P64 = P64[_s7Zf2::P64 + 16];
           Hp = Hp - 32;
           R1 = _s7Zei::P64 & (-8);
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c800w: // global
           _s7Zem::P64 = P64[_s7Zf2::P64 + 24];
           _s7Zel::I64 = I64[_s7Zf2::P64 + 40];
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = _s7Zem::P64;
           I64[Hp - 8] = _s7ZeL::I64;
           I64[Hp] = _s7Zel::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7ZfK_entry() //  [R1]
         { info_tbl: [(c802k,
                       label: sat_s7ZfK_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c802k: // global
           _s7ZfK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c802l; else goto c802m;
       c802m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c802o; else goto c802n;
       c802o: // global
           HpAlloc = 56;
           goto c802l;
       c802l: // global
           R1 = _s7ZfK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c802n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7ZfK::P64;
           _s7Zfp::P64 = P64[_s7ZfK::P64 + 16];
           _s7Zek::I64 = I64[_s7ZfK::P64 + 24];
           _s7ZeL::I64 = I64[_s7ZfK::P64 + 32];
           _s7Zfg::I64 = I64[_s7ZfK::P64 + 40];
           _s7Zfo::I64 = I64[_s7ZfK::P64 + 48];
           if (%MO_S_Gt_W64(_s7Zek::I64,
                            _s7ZeL::I64)) goto c802i; else goto c802j;
       c802i: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7Zfp::P64;
           I64[Hp - 32] = _s7Zfo::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7Zek::I64;
           I64[Hp] = _s7Zfg::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c802j: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7Zfp::P64;
           I64[Hp - 32] = _s7Zfo::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7ZeL::I64;
           I64[Hp] = _s7Zfg::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Zga_entry() //  [R1]
         { info_tbl: [(c803j,
                       label: sat_s7Zga_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c803j: // global
           _s7Zga::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c803k; else goto c803l;
       c803l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c803n; else goto c803m;
       c803n: // global
           HpAlloc = 56;
           goto c803k;
       c803k: // global
           R1 = _s7Zga::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c803m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Zga::P64;
           _s7Zfp::P64 = P64[_s7Zga::P64 + 16];
           _s7Zek::I64 = I64[_s7Zga::P64 + 24];
           _s7ZeL::I64 = I64[_s7Zga::P64 + 32];
           _s7Zfg::I64 = I64[_s7Zga::P64 + 40];
           _s7Zfo::I64 = I64[_s7Zga::P64 + 48];
           if (%MO_S_Gt_W64(_s7Zek::I64,
                            _s7ZeL::I64)) goto c803h; else goto c803i;
       c803h: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7Zfp::P64;
           I64[Hp - 32] = _s7Zfo::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7Zek::I64;
           I64[Hp] = _s7Zfg::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c803i: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7Zfp::P64;
           I64[Hp - 32] = _s7Zfo::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7ZeL::I64;
           I64[Hp] = _s7Zfg::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Zgt_entry() //  [R1]
         { info_tbl: [(c8047,
                       label: sat_s7Zgt_info
                       rep:HeapRep 1 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8047: // global
           _s7Zgt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8048; else goto c8049;
       c8049: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c804b; else goto c804a;
       c804b: // global
           HpAlloc = 56;
           goto c8048;
       c8048: // global
           R1 = _s7Zgt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c804a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Zgt::P64;
           _s7Zfp::P64 = P64[_s7Zgt::P64 + 16];
           _s7Zek::I64 = I64[_s7Zgt::P64 + 24];
           _s7ZeL::I64 = I64[_s7Zgt::P64 + 32];
           _s7Zfg::I64 = I64[_s7Zgt::P64 + 40];
           _s7Zfo::I64 = I64[_s7Zgt::P64 + 48];
           if (%MO_S_Gt_W64(_s7Zek::I64,
                            _s7ZeL::I64)) goto c8045; else goto c8046;
       c8045: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7Zfp::P64;
           I64[Hp - 32] = _s7Zfo::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7Zek::I64;
           I64[Hp] = _s7Zfg::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8046: // global
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _s7Zfp::P64;
           I64[Hp - 32] = _s7Zfo::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7ZeL::I64;
           I64[Hp] = _s7Zfg::I64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Array.concat3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c804i,
                       label: GHC.Event.Array.concat3_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c804i: // global
           if ((Sp + -120) < SpLim) (likely: False) goto c804j; else goto c804k;
       c804j: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c804k: // global
           I64[Sp - 40] = block_c7ZYS_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u805y; else goto c7ZYT;
       u805y: // global
           call _c7ZYS(R1) args: 0, res: 0, upd: 0;
       c7ZYT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZYS() //  [R1]
         { info_tbl: [(c7ZYS,
                       label: block_c7ZYS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZYS: // global
           I64[Sp - 24] = block_c7ZYX_info;
           _s7Zei::P64 = R1;
           _s7Zek::I64 = I64[R1 + 15];
           _s7Zel::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _s7Zek::I64;
           I64[Sp - 8] = _s7Zel::I64;
           P64[Sp] = _s7Zei::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u805n; else goto c7ZYY;
       u805n: // global
           call _c7ZYX(R1) args: 0, res: 0, upd: 0;
       c7ZYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZYX() //  [R1]
         { info_tbl: [(c7ZYX,
                       label: block_c7ZYX_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZYX: // global
           I64[Sp - 16] = block_c7ZZ2_info;
           _s7Zem::P64 = R1;
           _s7Zeo::P64 = P64[R1 + 7];
           _s7Zen::I64 = I64[R1 + 15];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _s7Zeo::P64;
           I64[Sp] = _s7Zen::I64;
           P64[Sp + 48] = _s7Zem::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u805o; else goto c7ZZ3;
       u805o: // global
           call _c7ZZ2(R1) args: 0, res: 0, upd: 0;
       c7ZZ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZZ2() //  [R1]
         { info_tbl: [(c7ZZ2,
                       label: block_c7ZZ2_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZ2: // global
           I64[Sp - 8] = block_c7ZZ7_info;
           _s7Zer::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _s7Zer::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u805p; else goto c7ZZ8;
       u805p: // global
           call _c7ZZ7(R1) args: 0, res: 0, upd: 0;
       c7ZZ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZZ7() //  [R1]
         { info_tbl: [(c7ZZ7,
                       label: block_c7ZZ7_info
                       rep:StackRep [True, False, True, True, True, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZ7: // global
           I64[Sp - 8] = block_c7ZZc_info;
           _s7Zev::P64 = P64[R1 + 7];
           _s7Zeu::I64 = I64[R1 + 15];
           R1 = P64[Sp + 88];
           P64[Sp] = _s7Zev::P64;
           I64[Sp + 88] = _s7Zeu::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u805q; else goto c7ZZd;
       u805q: // global
           call _c7ZZc(R1) args: 0, res: 0, upd: 0;
       c7ZZd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ZZc() //  [R1]
         { info_tbl: [(c7ZZc,
                       label: block_c7ZZc_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZc: // global
           _s7Zex::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7Zex::I64, 0)) goto c804r; else goto u805i;
       c804r: // global
           I64[Sp] = block_c7ZZk_info;
           R1 = P64[Sp + 72];
           I64[Sp + 72] = _s7Zex::I64;
           if (R1 & 7 != 0) goto u805r; else goto c7ZZl;
       u805r: // global
           call _c7ZZk(R1) args: 0, res: 0, upd: 0;
       c7ZZl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u805i: // global
           Sp = Sp + 104;
           call _c805h() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZZk() //  [R1]
         { info_tbl: [(c7ZZk,
                       label: block_c7ZZk_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZk: // global
           _s7ZeA::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7ZeA::I64, 0)) goto c805f; else goto u805j;
       c805f: // global
           if (%MO_S_Le_W64(_s7ZeA::I64,
                            I64[Sp + 40])) goto c804u; else goto u805k;
       c804u: // global
           I64[Sp] = block_c7ZZv_info;
           R1 = P64[Sp + 88];
           I64[Sp + 88] = _s7ZeA::I64;
           if (R1 & 7 != 0) goto u805t; else goto c7ZZw;
       u805t: // global
           call _c7ZZv(R1) args: 0, res: 0, upd: 0;
       c7ZZw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u805k: // global
           Sp = Sp + 104;
           goto u805v;
       u805j: // global
           Sp = Sp + 104;
           goto u805v;
       u805v: // global
           call _c805h() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZZv() //  [R1]
         { info_tbl: [(c7ZZv,
                       label: block_c7ZZv_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZv: // global
           _s7ZeE::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7ZeE::I64, 0)) goto c805b; else goto u805l;
       c805b: // global
           _s7Zer::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s7ZeE::I64,
                            _s7Zer::I64)) goto c8058; else goto u805m;
       c8058: // global
           _s7Zeb::P64 = P64[Sp + 64];
           _s7Zei::P64 = P64[Sp + 56];
           _s7Zel::I64 = I64[Sp + 48];
           _s7Zex::I64 = I64[Sp + 72];
           _s7ZeA::I64 = I64[Sp + 88];
           _s7ZeH::I64 = _s7Zer::I64 - _s7ZeE::I64;
           if (%MO_S_Gt_W64(_s7Zex::I64,
                            _s7ZeH::I64)) goto c8055; else goto c8056;
       c8055: // global
           _s7ZeJ::I64 = _s7ZeH::I64;
           goto s7ZeI;
       c8056: // global
           _s7ZeJ::I64 = _s7Zex::I64;
           goto s7ZeI;
       s7ZeI: // global
           if (_s7ZeJ::I64 == 0) goto c8051; else goto c8050;
       c8051: // global
           R1 = _s7Zei::P64;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8050: // global
           _s7ZeL::I64 = _s7ZeA::I64 + _s7ZeJ::I64;
           if (%MO_S_Le_W64(_s7ZeL::I64,
                            _s7Zel::I64)) goto c804y; else goto c804C;
       c804y: // global
           I64[Sp] = block_c7ZZW_info;
           R2 = _s7Zeb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 16] = _s7ZeL::I64;
           I64[Sp + 64] = _s7ZeJ::I64;
           I64[Sp + 72] = _s7ZeE::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c804C: // global
           I64[Sp] = block_c800G_info;
           R2 = _s7Zeb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Event.Array.ensureCapacity2_closure;
           I64[Sp + 56] = _s7ZeL::I64;
           I64[Sp + 72] = _s7ZeJ::I64;
           I64[Sp + 80] = _s7ZeE::I64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       u805m: // global
           Sp = Sp + 104;
           goto u805x;
       u805l: // global
           Sp = Sp + 104;
           goto u805x;
       u805x: // global
           call _c805h() args: 0, res: 0, upd: 0;
     }
 },
 _c7ZZW() //  [R1]
         { info_tbl: [(c7ZZW,
                       label: block_c7ZZW_info
                       rep:StackRep [False, True, False, True, True, True, False, True,
                                     True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ZZW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c804B; else goto c804A;
       c804B: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c804A: // global
           _s7Zei::P64 = P64[Sp + 56];
           _s7Zek::I64 = I64[Sp + 40];
           _s7Zel::I64 = I64[Sp + 48];
           _s7Zem::P64 = P64[Sp + 80];
           _s7Zeo::P64 = P64[Sp + 24];
           _s7Zev::P64 = P64[Sp + 8];
           _s7ZeL::I64 = I64[Sp + 16];
           _s7ZeO::I64 = I64[R1 + 7];
           (_s7ZeY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 32] + I64[Sp + 88] * _s7ZeO::I64, I64[Sp + 96] + I64[Sp + 72] * _s7ZeO::I64, I64[Sp + 64] * _s7ZeO::I64);
           call MO_Touch(_s7Zev::P64);
           call MO_Touch(_s7Zeo::P64);
           I64[Hp - 48] = sat_s7Zf2_info;
           P64[Hp - 32] = _s7Zei::P64;
           P64[Hp - 24] = _s7Zem::P64;
           I64[Hp - 16] = _s7Zek::I64;
           I64[Hp - 8] = _s7Zel::I64;
           I64[Hp] = _s7ZeL::I64;
           R1 = Hp - 48;
           Sp = Sp + 104;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c800G() //  [R1]
         { info_tbl: [(c800G,
                       label: block_c800G_info
                       rep:StackRep [False, True, False, True, True, True, True, False,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c800G: // global
           _s7Zf4::I64 = I64[R1 + 7];
           _s7Zf5::I64 = I64[Sp + 56] - 1;
           _s7Zf6::I64 = _s7Zf5::I64 | %MO_S_Shr_W64(_s7Zf5::I64, 1);
           _s7Zf8::I64 = _s7Zf6::I64 | %MO_S_Shr_W64(_s7Zf6::I64, 2);
           _s7Zfa::I64 = _s7Zf8::I64 | %MO_S_Shr_W64(_s7Zf8::I64, 4);
           _s7Zfc::I64 = _s7Zfa::I64 | %MO_S_Shr_W64(_s7Zfa::I64, 8);
           _s7Zfe::I64 = _s7Zfc::I64 | %MO_S_Shr_W64(_s7Zfc::I64, 16);
           _s7Zfg::I64 = _s7Zfe::I64 | %MO_S_Shr_W64(_s7Zfe::I64, 32) + 1;
           _s7Zfj::I64 = _s7Zfg::I64 * _s7Zf4::I64;
           if (%MO_S_Ge_W64(_s7Zfj::I64, 0)) goto c804F; else goto c804Y;
       c804F: // global
           I64[Sp - 8] = block_c801w_info;
           R1 = _s7Zfj::I64;
           I64[Sp] = _s7Zfg::I64;
           I64[Sp + 16] = _s7Zf4::I64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c804Y: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 104;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c801w() //  [R1]
         { info_tbl: [(c801w,
                       label: block_c801w_info
                       rep:StackRep [True, False, True, False, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c801w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c804I; else goto c804H;
       c804I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c804H: // global
           I64[Hp - 8] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp] = R1;
           _s7Zeb::P64 = P64[Sp + 72];
           _s7Zen::I64 = I64[Sp + 40];
           _s7Zeo::P64 = P64[Sp + 32];
           _s7Zfo::I64 = R1 + 16;
           _c801B::P64 = Hp - 5;
           if (_s7Zen::I64 == 0) goto c804U; else goto c804T;
       c804U: // global
           call MO_Touch(_s7Zeo::P64);
           I64[Sp] = block_c803w_info;
           R2 = _s7Zeb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7Zfo::I64;
           P64[Sp + 72] = _c801B::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c804T: // global
           _s7Zel::I64 = I64[Sp + 56];
           if (%MO_S_Le_W64(_s7Zel::I64, 0)) goto c804K; else goto c804O;
       c804K: // global
           call MO_Touch(_s7Zeo::P64);
           I64[Sp] = block_c801J_info;
           R2 = _s7Zeb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7Zfo::I64;
           P64[Sp + 72] = _c801B::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
       c804O: // global
           (_s7ZfQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Zfo::I64, _s7Zen::I64, _s7Zel::I64 * I64[Sp + 24]);
           call MO_Touch(_c801B::P64);
           call MO_Touch(_s7Zeo::P64);
           I64[Sp] = block_c802I_info;
           R2 = _s7Zeb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl40_r7WMS_closure;
           I64[Sp + 56] = _s7Zfo::I64;
           P64[Sp + 72] = _c801B::P64;
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c803w() //  [R1]
         { info_tbl: [(c803w,
                       label: block_c803w_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c803w: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c804X; else goto c804W;
       c804X: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c804W: // global
           _c801B::P64 = P64[Sp + 72];
           _s7Zek::I64 = I64[Sp + 48];
           _s7Zev::P64 = P64[Sp + 16];
           _s7ZeL::I64 = I64[Sp + 64];
           _s7Zfg::I64 = I64[Sp + 8];
           _s7Zfo::I64 = I64[Sp + 56];
           _s7Zgd::I64 = I64[R1 + 7];
           (_s7Zgn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Zfo::I64 + I64[Sp + 96] * _s7Zgd::I64, I64[Sp + 104] + I64[Sp + 88] * _s7Zgd::I64, I64[Sp + 80] * _s7Zgd::I64);
           call MO_Touch(_s7Zev::P64);
           call MO_Touch(_c801B::P64);
           I64[Hp - 48] = sat_s7Zgt_info;
           P64[Hp - 32] = _c801B::P64;
           I64[Hp - 24] = _s7Zek::I64;
           I64[Hp - 16] = _s7ZeL::I64;
           I64[Hp - 8] = _s7Zfg::I64;
           I64[Hp] = _s7Zfo::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c801J() //  [R1]
         { info_tbl: [(c801J,
                       label: block_c801J_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c801J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c804N; else goto c804M;
       c804N: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c804M: // global
           _c801B::P64 = P64[Sp + 72];
           _s7Zek::I64 = I64[Sp + 48];
           _s7Zev::P64 = P64[Sp + 16];
           _s7ZeL::I64 = I64[Sp + 64];
           _s7Zfg::I64 = I64[Sp + 8];
           _s7Zfo::I64 = I64[Sp + 56];
           _s7Zfu::I64 = I64[R1 + 7];
           (_s7ZfE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Zfo::I64 + I64[Sp + 96] * _s7Zfu::I64, I64[Sp + 104] + I64[Sp + 88] * _s7Zfu::I64, I64[Sp + 80] * _s7Zfu::I64);
           call MO_Touch(_s7Zev::P64);
           call MO_Touch(_c801B::P64);
           I64[Hp - 48] = sat_s7ZfK_info;
           P64[Hp - 32] = _c801B::P64;
           I64[Hp - 24] = _s7Zek::I64;
           I64[Hp - 16] = _s7ZeL::I64;
           I64[Hp - 8] = _s7Zfg::I64;
           I64[Hp] = _s7Zfo::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c802I() //  [R1]
         { info_tbl: [(c802I,
                       label: block_c802I_info
                       rep:StackRep [True, False, True, True, True, True, True, True,
                                     False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c802I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c804R; else goto c804Q;
       c804R: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c804Q: // global
           _c801B::P64 = P64[Sp + 72];
           _s7Zek::I64 = I64[Sp + 48];
           _s7Zev::P64 = P64[Sp + 16];
           _s7ZeL::I64 = I64[Sp + 64];
           _s7Zfg::I64 = I64[Sp + 8];
           _s7Zfo::I64 = I64[Sp + 56];
           _s7ZfU::I64 = I64[R1 + 7];
           (_s7Zg4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Zfo::I64 + I64[Sp + 96] * _s7ZfU::I64, I64[Sp + 104] + I64[Sp + 88] * _s7ZfU::I64, I64[Sp + 80] * _s7ZfU::I64);
           call MO_Touch(_s7Zev::P64);
           call MO_Touch(_c801B::P64);
           I64[Hp - 48] = sat_s7Zga_info;
           P64[Hp - 32] = _c801B::P64;
           I64[Hp - 24] = _s7Zek::I64;
           I64[Hp - 16] = _s7ZeL::I64;
           I64[Hp - 8] = _s7Zfg::I64;
           I64[Hp] = _s7Zfo::I64;
           R1 = Hp - 48;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c805h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c805h: // global
           R1 = lvl42_r7WMU_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.758062224 UTC

[section ""data" . GHC.Event.Array.concat2_closure" {
     GHC.Event.Array.concat2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.760432246 UTC

[section ""data" . GHC.Event.Array.$wconcat_closure" {
     GHC.Event.Array.$wconcat_closure:
         const GHC.Event.Array.$wconcat_info;
         const 0;
 },
 GHC.Event.Array.$wconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c808M,
                       label: GHC.Event.Array.$wconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c808M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c808Q; else goto c808R;
       c808Q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c808R: // global
           I64[Sp - 32] = block_c808J_info;
           R1 = P64[R3 + 8];
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8099; else goto c808K;
       u8099: // global
           call _c808J(R1) args: 0, res: 0, upd: 0;
       c808K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c808J() //  [R1]
         { info_tbl: [(c808J,
                       label: block_c808J_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c808J: // global
           _s7ZgO::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_c808P_info;
           _s7ZgI::P64 = R1;
           _s7ZgK::I64 = I64[R1 + 15];
           R1 = _s7ZgO::P64;
           I64[Sp] = _s7ZgK::I64;
           P64[Sp + 24] = _s7ZgI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8098; else goto c808T;
       u8098: // global
           call _c808P(R1) args: 0, res: 0, upd: 0;
       c808T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c808P() //  [R1]
         { info_tbl: [(c808P,
                       label: block_c808P_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c808P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8092; else goto c8091;
       c8092: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8091: // global
           _s7ZgR::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _s7ZgR::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           _s7ZgB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c808Z_info;
           R6 = GHC.Event.Array.concat2_closure+1;
           R5 = R1;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = _s7ZgB::P64;
           P64[Sp + 8] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c808Z() //  [R1]
         { info_tbl: [(c808Z,
                       label: block_c808Z_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c808Z: // global
           _s7ZgC::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7ZgC::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7ZgC::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.771603782 UTC

[section ""data" . GHC.Event.Array.concat1_closure" {
     GHC.Event.Array.concat1_closure:
         const GHC.Event.Array.concat1_info;
         const 0;
 },
 GHC.Event.Array.concat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c809I,
                       label: GHC.Event.Array.concat1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c809I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c809M; else goto c809N;
       c809M: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.concat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c809N: // global
           I64[Sp - 24] = block_c809F_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u809V; else goto c809G;
       u809V: // global
           call _c809F(R1) args: 0, res: 0, upd: 0;
       c809G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c809F() //  [R1]
         { info_tbl: [(c809F,
                       label: block_c809F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c809F: // global
           I64[Sp] = block_c809L_info;
           _s7Zh4::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Zh4::P64;
           if (R1 & 7 != 0) goto u809U; else goto c809P;
       u809U: // global
           call _c809L(R1) args: 0, res: 0, upd: 0;
       c809P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c809L() //  [R1]
         { info_tbl: [(c809L,
                       label: block_c809L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c809L: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Array.$wconcat_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.780145374 UTC

[section ""data" . GHC.Event.Array.concat_closure" {
     GHC.Event.Array.concat_closure:
         const GHC.Event.Array.concat_info;
         const 0;
 },
 GHC.Event.Array.concat_entry() //  [R2, R3, R4]
         { info_tbl: [(c80af,
                       label: GHC.Event.Array.concat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80af: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.concat1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.784077327 UTC

[section ""data" . GHC.Event.Array.copy1_closure" {
     GHC.Event.Array.copy1_closure:
         const GHC.Event.Array.copy1_info;
         const 0;
 },
 GHC.Event.Array.copy1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c80at,
                       label: GHC.Event.Array.copy1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80at: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c80ax; else goto c80ay;
       c80ax: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.copy1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c80ay: // global
           I64[Sp - 40] = block_c80aq_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u80aM; else goto c80ar;
       u80aM: // global
           call _c80aq(R1) args: 0, res: 0, upd: 0;
       c80ar: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80aq() //  [R1]
         { info_tbl: [(c80aq,
                       label: block_c80aq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80aq: // global
           I64[Sp - 8] = block_c80aw_info;
           _s7Zhf::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp] = P64[_s7Zhf::P64 + 8];
           P64[Sp + 24] = _s7Zhf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u80aL; else goto c80aA;
       u80aL: // global
           call _c80aw(R1) args: 0, res: 0, upd: 0;
       c80aA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80aw() //  [R1]
         { info_tbl: [(c80aw,
                       label: block_c80aw_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80aw: // global
           _s7Zh9::P64 = P64[Sp + 24];
           _s7Zhn::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp + 24] = block_c80aE_info;
           R6 = P64[Sp + 40];
           R5 = _s7Zhn::P64;
           R4 = _s7Zh9::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 48];
           Sp = Sp + 16;
           call GHC.Event.Array.concat3_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 16, res: 8, upd: 8;
     }
 },
 _c80aE() //  [R1]
         { info_tbl: [(c80aE,
                       label: block_c80aE_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80aE: // global
           _s7Zhf::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s7Zhf::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s7Zhf::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.79423823 UTC

[section ""data" . GHC.Event.Array.copy_closure" {
     GHC.Event.Array.copy_closure:
         const GHC.Event.Array.copy_info;
         const 0;
 },
 GHC.Event.Array.copy_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c80bg,
                       label: GHC.Event.Array.copy_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80bg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.copy1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.797697985 UTC

[section ""data" . lvl43_r7WMV_closure" {
     lvl43_r7WMV_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.799354704 UTC

[section ""data" . lvl44_r7WMW_closure" {
     lvl44_r7WMW_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.801027292 UTC

[section ""data" . lvl45_r7WMX_closure" {
     lvl45_r7WMX_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.802727855 UTC

[section ""data" . lvl46_r7WMY_closure" {
     lvl46_r7WMY_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl43_r7WMV_closure+1;
         const lvl44_r7WMW_closure+1;
         const lvl43_r7WMV_closure+1;
         const lvl45_r7WMX_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.8049761 UTC

[section ""data" . lvl47_r7WMZ_closure" {
     lvl47_r7WMZ_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl46_r7WMY_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.80709689 UTC

[section ""data" . GHC.Event.Array.duplicate1_closure" {
     GHC.Event.Array.duplicate1_closure:
         const GHC.Event.Array.duplicate1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate1_entry() //  [R1]
         { info_tbl: [(c80by,
                       label: GHC.Event.Array.duplicate1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80by: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c80bz; else goto c80bA;
       c80bz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c80bA: // global
           (_c80bv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c80bv::I64 == 0) goto c80bx; else goto c80bw;
       c80bx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c80bw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c80bv::I64;
           R2 = lvl47_r7WMZ_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.81216866 UTC

[section ""data" . GHC.Event.Array.$wnew_closure" {
     GHC.Event.Array.$wnew_closure:
         const GHC.Event.Array.$wnew_info;
         const 0;
 },
 GHC.Event.Array.$wnew_entry() //  [R2, R3]
         { info_tbl: [(c80bP,
                       label: GHC.Event.Array.$wnew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80bP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c80bQ; else goto c80bR;
       c80bQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.$wnew_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c80bR: // global
           I64[Sp - 16] = block_c80bN_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c80bN() //  [R1]
         { info_tbl: [(c80bN,
                       label: block_c80bN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80bN: // global
           _s7Zhx::I64 = I64[Sp + 8] - 1;
           _s7Zhy::I64 = _s7Zhx::I64 | %MO_S_Shr_W64(_s7Zhx::I64, 1);
           _s7ZhA::I64 = _s7Zhy::I64 | %MO_S_Shr_W64(_s7Zhy::I64, 2);
           _s7ZhC::I64 = _s7ZhA::I64 | %MO_S_Shr_W64(_s7ZhA::I64, 4);
           _s7ZhE::I64 = _s7ZhC::I64 | %MO_S_Shr_W64(_s7ZhC::I64, 8);
           _s7ZhG::I64 = _s7ZhE::I64 | %MO_S_Shr_W64(_s7ZhE::I64, 16);
           _s7ZhI::I64 = _s7ZhG::I64 | %MO_S_Shr_W64(_s7ZhG::I64, 32) + 1;
           _s7ZhL::I64 = _s7ZhI::I64 * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7ZhL::I64, 0)) goto c80cT; else goto c80d0;
       c80cT: // global
           I64[Sp] = block_c80cH_info;
           R1 = _s7ZhL::I64;
           I64[Sp + 8] = _s7ZhI::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c80d0: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c80cH() //  [R1]
         { info_tbl: [(c80cH,
                       label: block_c80cH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80cH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c80cW; else goto c80cV;
       c80cW: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80cV: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 61;
           P64[Hp - 32] = R1 + 16;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 8] = block_c80cP_info;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80cP() //  [R1]
         { info_tbl: [(c80cP,
                       label: block_c80cP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80cP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80cZ; else goto c80cY;
       c80cZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80cY: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.822626987 UTC

[section ""data" . GHC.Event.Array.new1_closure" {
     GHC.Event.Array.new1_closure:
         const GHC.Event.Array.new1_info;
         const 0;
 },
 GHC.Event.Array.new1_entry() //  [R2, R3]
         { info_tbl: [(c80dQ,
                       label: GHC.Event.Array.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80dQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c80dR; else goto c80dS;
       c80dR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c80dS: // global
           I64[Sp - 16] = block_c80dN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u80dW; else goto c80dO;
       u80dW: // global
           call _c80dN(R1) args: 0, res: 0, upd: 0;
       c80dO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80dN() //  [R1]
         { info_tbl: [(c80dN,
                       label: block_c80dN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80dN: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Array.$wnew_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.828016019 UTC

[section ""data" . GHC.Event.Array.new_closure" {
     GHC.Event.Array.new_closure:
         const GHC.Event.Array.new_info;
         const 0;
 },
 GHC.Event.Array.new_entry() //  [R2, R3]
         { info_tbl: [(c80eb,
                       label: GHC.Event.Array.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80eb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Array.new1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.831241782 UTC

[section ""data" . lvl48_r7WN0_closure" {
     lvl48_r7WN0_closure:
         const GHC.Types.I#_con_info;
         const 95;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.832921923 UTC

[section ""data" . lvl49_r7WN1_closure" {
     lvl49_r7WN1_closure:
         const GHC.Types.I#_con_info;
         const 23;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.835182543 UTC

[section ""data" . lvl50_r7WN2_closure" {
     lvl50_r7WN2_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.83679166 UTC

[section ""data" . lvl51_r7WN3_closure" {
     lvl51_r7WN3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl7_r7WMb_closure;
         const lvl8_r7WMc_closure;
         const lvl10_r7WMe_closure;
         const lvl48_r7WN0_closure+1;
         const lvl49_r7WN1_closure+1;
         const lvl48_r7WN0_closure+1;
         const lvl50_r7WN2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.839157647 UTC

[section ""data" . lvl52_r7WN4_closure" {
     lvl52_r7WN4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl6_r7WMa_closure;
         const lvl51_r7WN3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.841430779 UTC

[section ""data" . GHC.Event.Array.duplicate2_closure" {
     GHC.Event.Array.duplicate2_closure:
         const GHC.Event.Array.duplicate2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Array.duplicate2_entry() //  [R1]
         { info_tbl: [(c80et,
                       label: GHC.Event.Array.duplicate2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80et: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c80eu; else goto c80ev;
       c80eu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c80ev: // global
           (_c80eq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c80eq::I64 == 0) goto c80es; else goto c80er;
       c80es: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c80er: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c80eq::I64;
           R2 = lvl52_r7WN4_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.846826364 UTC

[section ""data" . GHC.Event.Array.duplicate_closure" {
     GHC.Event.Array.duplicate_closure:
         const GHC.Event.Array.duplicate_info;
         const 0;
 },
 lvl53_s7Zi5_entry() //  [R1]
         { info_tbl: [(c80eM,
                       label: lvl53_s7Zi5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80eM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c80eN; else goto c80eO;
       c80eN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c80eO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate2_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl54_s7Zi6_entry() //  [R1]
         { info_tbl: [(c80eT,
                       label: lvl54_s7Zi6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80eT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c80eU; else goto c80eV;
       c80eU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c80eV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Event.Array.duplicate1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7ZiL_entry() //  [R1, R2]
         { info_tbl: [(c80f4,
                       label: sat_s7ZiL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80f4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c80fi; else goto c80fj;
       c80fi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c80fj: // global
           I64[Sp - 24] = block_c80f1_info;
           _s7Zi5::P64 = P64[R1 + 6];
           _s7Zi6::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s7Zi5::P64;
           P64[Sp - 8] = _s7Zi6::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u80gb; else goto c80f2;
       u80gb: // global
           call _c80f1(R1) args: 0, res: 0, upd: 0;
       c80f2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80f1() //  [R1]
         { info_tbl: [(c80f1,
                       label: block_c80f1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80f1: // global
           _s7Zid::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_c80f7_info;
           R1 = _s7Zid::P64;
           if (R1 & 7 != 0) goto u80ga; else goto c80f8;
       u80ga: // global
           call _c80f7(R1) args: 0, res: 0, upd: 0;
       c80f8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80f7() //  [R1]
         { info_tbl: [(c80f7,
                       label: block_c80f7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80f7: // global
           I64[Sp - 16] = block_c80fc_info;
           _s7Zig::I64 = I64[R1 + 15];
           _s7Zih::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _s7Zih::I64;
           I64[Sp] = _s7Zig::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u80gc; else goto c80fd;
       u80gc: // global
           call _c80fc(R1) args: 0, res: 0, upd: 0;
       c80fd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80fc() //  [R1]
         { info_tbl: [(c80fc,
                       label: block_c80fc_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80fc: // global
           I64[Sp - 8] = block_c80fh_info;
           _s7Zik::P64 = P64[R1 + 7];
           _s7Zij::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _s7Zik::P64;
           I64[Sp + 32] = _s7Zij::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u80gd; else goto c80fn;
       u80gd: // global
           call _c80fh(R1) args: 0, res: 0, upd: 0;
       c80fn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80fh() //  [R1]
         { info_tbl: [(c80fh,
                       label: block_c80fh_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80fh: // global
           _s7Zin::I64 = I64[Sp + 16] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7Zin::I64, 0)) goto c80g1; else goto c80g9;
       c80g1: // global
           I64[Sp] = block_c80fy_info;
           R1 = _s7Zin::I64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
       c80g9: // global
           R1 = GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c80fy() //  [R1]
         { info_tbl: [(c80fy,
                       label: block_c80fy_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80fy: // global
           I64[Sp] = block_c80fA_info;
           _s7Zir::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Zir::P64;
           if (R1 & 7 != 0) goto u80ge; else goto c80fB;
       u80ge: // global
           call _c80fA(R1) args: 0, res: 0, upd: 0;
       c80fB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80fA() //  [R1]
         { info_tbl: [(c80fA,
                       label: block_c80fA_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80fA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c80g5; else goto c80g4;
       c80g5: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80g4: // global
           _s7Zig::I64 = I64[Sp + 24];
           _s7Zih::I64 = I64[Sp + 16];
           _s7Zik::P64 = P64[Sp + 8];
           _s7Zir::P64 = P64[Sp + 32];
           _s7Ziu::I64 = _s7Zir::P64 + 16;
           (_s7ZiA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_s7Ziu::I64, I64[Sp + 40], _s7Zig::I64 * I64[R1 + 7]);
           call MO_Touch(_s7Zik::P64);
           I64[Hp - 64] = GHC.ForeignPtr.PlainPtr_con_info;
           P64[Hp - 56] = _s7Zir::P64;
           _c80fT::P64 = Hp - 61;
           call MO_Touch(_c80fT::P64);
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = _c80fT::P64;
           I64[Hp - 32] = _s7Ziu::I64;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _s7Zig::I64;
           I64[Hp] = _s7Zih::I64;
           I64[Sp + 40] = block_c80fX_info;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c80fX() //  [R1]
         { info_tbl: [(c80fX,
                       label: block_c80fX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80fX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c80g8; else goto c80g7;
       c80g8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c80g7: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Array.duplicate_entry() //  [R2]
         { info_tbl: [(c80gf,
                       label: GHC.Event.Array.duplicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80gf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c80gj; else goto c80gi;
       c80gj: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.Event.Array.duplicate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c80gi: // global
           I64[Hp - 64] = lvl53_s7Zi5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl54_s7Zi6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s7ZiL_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.870771615 UTC

[section ""data" . GHC.Event.Array.AC_closure" {
     GHC.Event.Array.AC_closure:
         const GHC.Event.Array.AC_info;
 },
 GHC.Event.Array.AC_entry() //  [R2, R3, R4]
         { info_tbl: [(c80hA,
                       label: GHC.Event.Array.AC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80hA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c80hE; else goto c80hD;
       c80hE: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Array.AC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c80hD: // global
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.874711279 UTC

[GHC.Event.Array.AC_con_entry() //  [R1]
         { info_tbl: [(c80hL,
                       label: GHC.Event.Array.AC_con_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,65,114,114,97,121,46,65,67]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c80hL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:07.878384113 UTC

[section ""relreadonly" . S7Znn_srt" {
     S7Znn_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.$wlvl1_closure;
         const GHC.Event.Array.$wunsafeRead_closure;
         const GHC.Event.Array.unsafeRead1_closure;
         const GHC.Event.Array.$wlvl_closure;
         const GHC.Event.Array.$wunsafeWrite'_closure;
         const GHC.Event.Array.unsafeWrite2_closure;
         const GHC.Event.Array.unsafeWrite1_closure;
         const GHC.Err.undefined_closure;
         const lvl15_r7WMj_closure;
         const GHC.Event.Array.forM_1_closure;
         const GHC.Event.Array.forM__closure;
         const lvl20_r7WMo_closure;
         const GHC.Event.Array.loop1_closure;
         const GHC.Event.Array.loop_closure;
         const lvl23_r7WMB_closure;
         const GHC.Event.Array.removeAt2_closure;
         const GHC.Event.Array.removeAt1_closure;
         const GHC.Event.Array.removeAt_closure;
         const lvl29_r7WMH_closure;
         const GHC.Event.Array.findIndex1_closure;
         const GHC.Event.Array.findIndex_closure;
         const lvl34_r7WMM_closure;
         const GHC.ForeignPtr.mallocPlainForeignPtrBytes2_closure;
         const GHC.Event.Array.$wensureCapacity_closure;
         const GHC.Event.Array.ensureCapacity2_closure;
         const GHC.Event.Array.ensureCapacity1_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.snoc1_closure;
         const lvl39_r7WMR_closure;
         const GHC.Event.Array.concat3_closure;
         const lvl40_r7WMS_closure;
         const lvl42_r7WMU_closure;
         const GHC.Event.Array.$wconcat_closure;
         const GHC.Event.Array.concat1_closure;
         const GHC.Event.Array.copy1_closure;
         const lvl47_r7WMZ_closure;
         const GHC.Event.Array.duplicate1_closure;
         const GHC.Event.Array.$wnew_closure;
         const GHC.Event.Array.new1_closure;
         const lvl52_r7WN4_closure;
         const GHC.Err.undefined_closure;
         const GHC.Event.Array.duplicate2_closure;
         const GHC.Event.Array.duplicate_closure;
 }]

