
==================== Output Cmm ====================
2018-03-16 16:05:43.307944903 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:43.308587118 UTC

[section ""data" . lvl1_raLJo_closure" {
     lvl1_raLJo_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.30958548 UTC

[section ""data" . lvl2_raLJp_closure" {
     lvl2_raLJp_closure:
         const lvl2_raLJp_info;
 },
 lvl2_raLJp_entry() //  []
         { info_tbl: [(caMdL,
                       label: lvl2_raLJp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMdL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMdM; else goto caMdN;
       caMdM: // global
           R1 = lvl2_raLJp_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMdN: // global
           I64[Sp - 8] = block_caMdG_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caMdG() //  []
         { info_tbl: [(caMdG,
                       label: block_caMdG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMdG: // global
           I64[Sp] = block_caMdI_info;
           R1 = lvl1_raLJo_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMdI() //  [R1]
         { info_tbl: [(caMdI,
                       label: block_caMdI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMdI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMdR; else goto caMdQ;
       caMdR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMdQ: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.310930744 UTC

[section ""data" . GHC.Event.Thread.numEnabledEventManagers_closure" {
     GHC.Event.Thread.numEnabledEventManagers_closure:
         const GHC.Event.Thread.numEnabledEventManagers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.numEnabledEventManagers_entry() //  [R1]
         { info_tbl: [(caMe0,
                       label: GHC.Event.Thread.numEnabledEventManagers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMe0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMe1; else goto caMe2;
       caMe1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMe2: // global
           (_caMdV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMdV::I64 == 0) goto caMdX; else goto caMdW;
       caMdX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMdW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMdV::I64;
           I64[Sp - 24] = block_caMdY_info;
           Sp = Sp - 24;
           call lvl2_raLJp_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caMdY() //  [R1]
         { info_tbl: [(caMdY,
                       label: block_caMdY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMdY: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.311925514 UTC

[section ""cstring" . GHC.Event.Thread.$trModule4_bytes" {
     GHC.Event.Thread.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.312502086 UTC

[section ""data" . GHC.Event.Thread.$trModule3_closure" {
     GHC.Event.Thread.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.313024018 UTC

[section ""cstring" . GHC.Event.Thread.$trModule2_bytes" {
     GHC.Event.Thread.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,104,114,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.313640219 UTC

[section ""data" . GHC.Event.Thread.$trModule1_closure" {
     GHC.Event.Thread.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.314182844 UTC

[section ""data" . GHC.Event.Thread.$trModule_closure" {
     GHC.Event.Thread.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Thread.$trModule3_closure+1;
         const GHC.Event.Thread.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.314755819 UTC

[section ""cstring" . GHC.Event.Thread.blockedOnBadFD3_bytes" {
     GHC.Event.Thread.blockedOnBadFD3_bytes:
         I8[] [97,119,97,105,116,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.315500073 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD2_closure" {
     GHC.Event.Thread.blockedOnBadFD2_closure:
         const GHC.Event.Thread.blockedOnBadFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD2_entry() //  [R1]
         { info_tbl: [(caMea,
                       label: GHC.Event.Thread.blockedOnBadFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMea: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMeb; else goto caMec;
       caMeb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMec: // global
           (_caMe7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMe7::I64 == 0) goto caMe9; else goto caMe8;
       caMe9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMe8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMe7::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.316554001 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD1_closure" {
     GHC.Event.Thread.blockedOnBadFD1_closure:
         const GHC.Event.Thread.blockedOnBadFD1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD1_entry() //  [R1]
         { info_tbl: [(caMej,
                       label: GHC.Event.Thread.blockedOnBadFD1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMej: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMek; else goto caMel;
       caMek: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMel: // global
           (_caMeg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMeg::I64 == 0) goto caMei; else goto caMeh;
       caMei: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMeh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMeg::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = GHC.Event.Thread.blockedOnBadFD2_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.317717985 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD_closure" {
     GHC.Event.Thread.blockedOnBadFD_closure:
         const GHC.Event.Thread.blockedOnBadFD_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD_entry() //  [R1]
         { info_tbl: [(caMet,
                       label: GHC.Event.Thread.blockedOnBadFD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMet: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMeu; else goto caMev;
       caMeu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMev: // global
           (_caMeq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMeq::I64 == 0) goto caMes; else goto caMer;
       caMes: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMer: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMeq::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.318631468 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning7_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning7_bytes:
         I8[] [73,79,77,97,110,97,103,101,114,32,111,110,32,99,97,112,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.321438667 UTC

[section ""data" . restartPollLoop_raLJq_closure" {
     restartPollLoop_raLJq_closure:
         const restartPollLoop_raLJq_info;
         const 0;
 },
 sat_saLKx_entry() //  [R1]
         { info_tbl: [(caMf1,
                       label: sat_saLKx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMf1: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKy_entry() //  [R1]
         { info_tbl: [(caMf4,
                       label: sat_saLKy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMf4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMf8; else goto caMf7;
       caMf8: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMf7: // global
           _saLKb::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_saLKx_info;
           P64[Hp] = _saLKb::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKM_entry() //  [R1, R2]
         { info_tbl: [(caMfj,
                       label: sat_saLKM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMfn; else goto caMfo;
       caMfn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMfo: // global
           I64[Sp - 16] = block_caMfg_info;
           _saLKB::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLKB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMfs; else goto caMfh;
       uaMfs: // global
           call _caMfg(R1) args: 0, res: 0, upd: 0;
       caMfh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMfg() //  [R1]
         { info_tbl: [(caMfg,
                       label: block_caMfg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfg: // global
           _saLKB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caMfm_info;
           R2 = I64[R1 + 7];
           R1 = _saLKB::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMfm() //  []
         { info_tbl: [(caMfm,
                       label: block_caMfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKF_entry() //  [R1]
         { info_tbl: [(caMfE,
                       label: sat_saLKF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMfF; else goto caMfG;
       caMfF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMfG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caMfB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caMfB() //  [R1, R2]
         { info_tbl: [(caMfB,
                       label: block_caMfB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMfJ; else goto caMfI;
       caMfJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caMfI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLKG_entry() //  [R1]
         { info_tbl: [(caMfK,
                       label: sat_saLKG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfK: // global
           _saLKG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caMfL; else goto caMfM;
       caMfM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMfO; else goto caMfN;
       caMfO: // global
           HpAlloc = 24;
           goto caMfL;
       caMfL: // global
           R1 = _saLKG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMfN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saLKG::P64;
           _saLKv::I64 = I64[_saLKG::P64 + 16];
           I64[Hp - 16] = sat_saLKF_info;
           I64[Hp] = _saLKv::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 restartPollLoop_raLJq_entry() //  [R2, R3]
         { info_tbl: [(caMfP,
                       label: restartPollLoop_raLJq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caMfQ; else goto caMfR;
       caMfQ: // global
           R3 = R3;
           R2 = R2;
           R1 = restartPollLoop_raLJq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMfR: // global
           I64[Sp - 16] = block_caMeA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMhk; else goto caMeB;
       uaMhk: // global
           call _caMeA(R1) args: 0, res: 0, upd: 0;
       caMeB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMeA() //  [R1]
         { info_tbl: [(caMeA,
                       label: block_caMeA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMeA: // global
           I64[Sp - 24] = block_caMeF_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saLKb::P64 = R1;
           _saLKn::P64 = P64[R1 + 63];
           _saLKl::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           I64[Sp - 16] = _saLKl::I64;
           P64[Sp - 8] = _saLKn::P64;
           P64[Sp] = _saLKb::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMeF() //  [R1]
         { info_tbl: [(caMeF,
                       label: block_caMeF_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMeF: // global
           I64[Sp] = block_caMfS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMhj; else goto caMg8;
       uaMhj: // global
           call _caMfS(R1) args: 0, res: 0, upd: 0;
       caMg8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMfS() //  [R1]
         { info_tbl: [(caMfS,
                       label: block_caMfS_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfS: // global
           if (R1 & 7 == 2) goto caMhb; else goto uaMhe;
       caMhb: // global
           _saLKn::P64 = P64[Sp + 16];
           (_saLKW::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saLKW::I64) == 0 :: W32) goto uaMhf; else goto caMgx;
       uaMhf: // global
           Sp = Sp + 24;
           goto uaMhn;
       caMgx: // global
           (_saLL1::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caMgv_info;
           R1 = P64[_saLKn::P64 + 8];
           I64[Sp + 16] = _saLL1::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaMhl; else goto caMgz;
       uaMhl: // global
           call _caMgv(R1) args: 0, res: 0, upd: 0;
       caMgz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaMhe: // global
           Sp = Sp + 24;
           goto uaMhn;
       uaMhn: // global
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _caMgv() //  [R1]
         { info_tbl: [(caMgv,
                       label: block_caMgv_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMgv: // global
           if (R1 & 7 == 1) goto caMgG; else goto caMh4;
       caMgG: // global
           I64[Sp + 8] = block_caMgD_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caMh4: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaMhg; else goto caMgU;
       uaMhg: // global
           Sp = Sp + 16;
           call _saLKs() args: 0, res: 0, upd: 0;
       caMgU: // global
           I64[Sp + 8] = block_caMgS_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMgD() //  []
         { info_tbl: [(caMgD,
                       label: block_caMgD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMgD: // global
           Sp = Sp + 8;
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _caMgS() //  []
         { info_tbl: [(caMgS,
                       label: block_caMgS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMgS: // global
           Sp = Sp + 8;
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _saLKs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLKs: // global
           I64[Sp - 8] = block_caMeM_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMhr; else goto caMeN;
       uaMhr: // global
           call _caMeM(R1) args: 0, res: 0, upd: 0;
       caMeN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMeM() //  [R1]
         { info_tbl: [(caMeM,
                       label: block_caMeM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMeM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMg1; else goto caMg0;
       caMg1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMg0: // global
           _saLKv::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_saLKy_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caMf9_info;
           R2 = Hp - 7;
           R1 = _saLKv::I64;
           I64[Sp + 16] = _saLKv::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMf9() //  [R1]
         { info_tbl: [(caMf9,
                       label: block_caMf9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMf9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMg4; else goto caMg3;
       caMg4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMg3: // global
           I64[Hp - 32] = sat_saLKM_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saLKG_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_caMfV_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 8] = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMfV() //  [R1]
         { info_tbl: [(caMfV,
                       label: block_caMfV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMfV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMg7; else goto caMg6;
       caMg7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMg6: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.326315402 UTC

[section ""cstring" . lvl3_raLJr_bytes" {
     lvl3_raLJr_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.327008716 UTC

[section ""data" . lvl4_raLJs_closure" {
     lvl4_raLJs_closure:
         const lvl4_raLJs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raLJs_entry() //  [R1]
         { info_tbl: [(caMhy,
                       label: lvl4_raLJs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMhy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMhz; else goto caMhA;
       caMhz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMhA: // global
           (_caMhv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMhv::I64 == 0) goto caMhx; else goto caMhw;
       caMhx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMhw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMhv::I64;
           R2 = lvl3_raLJr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.328088121 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning8_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning8_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning8_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning8_entry() //  [R2, R3, R4]
         { info_tbl: [(caMhI,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMhI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caMhM; else goto caMhL;
       caMhM: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caMhL: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R3;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 39;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.33163329 UTC

[section ""data" . GHC.Event.Thread.$wstartIOManagerThread_closure" {
     GHC.Event.Thread.$wstartIOManagerThread_closure:
         const GHC.Event.Thread.$wstartIOManagerThread_info;
         const 0;
 },
 GHC.Event.Thread.$wstartIOManagerThread_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMhO: // global
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM0_entry() //  [R1]
         { info_tbl: [(caMit,
                       label: sat_saLM0_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMit: // global
           _saLLE::P64 = P64[R1 + 7];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 15])), %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 23])));
           R2 = _saLLE::P64;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM1_entry() //  [R1]
         { info_tbl: [(caMiG,
                       label: sat_saLM1_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMiG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMiK; else goto caMiJ;
       caMiK: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMiJ: // global
           _saLLE::P64 = P64[R1 + 7];
           _saLLm::I64 = I64[R1 + 15];
           _saLLN::I64 = I64[R1 + 23];
           I64[Hp - 24] = sat_saLM0_info;
           P64[Hp - 16] = _saLLE::P64;
           I64[Hp - 8] = _saLLm::I64;
           I64[Hp] = _saLLN::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLMf_entry() //  [R1, R2]
         { info_tbl: [(caMiV,
                       label: sat_saLMf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMiV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMiZ; else goto caMj0;
       caMiZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMj0: // global
           I64[Sp - 16] = block_caMiS_info;
           _saLM4::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLM4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMj4; else goto caMiT;
       uaMj4: // global
           call _caMiS(R1) args: 0, res: 0, upd: 0;
       caMiT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMiS() //  [R1]
         { info_tbl: [(caMiS,
                       label: block_caMiS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMiS: // global
           _saLM4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caMiY_info;
           R2 = I64[R1 + 7];
           R1 = _saLM4::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMiY() //  []
         { info_tbl: [(caMiY,
                       label: block_caMiY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMiY: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM8_entry() //  [R1]
         { info_tbl: [(caMjg,
                       label: sat_saLM8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMjg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMjh; else goto caMji;
       caMjh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMji: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caMjd_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caMjd() //  [R1, R2]
         { info_tbl: [(caMjd,
                       label: block_caMjd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMjd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMjl; else goto caMjk;
       caMjl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caMjk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLM9_entry() //  [R1]
         { info_tbl: [(caMjm,
                       label: sat_saLM9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMjm: // global
           _saLM9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caMjn; else goto caMjo;
       caMjo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMjq; else goto caMjp;
       caMjq: // global
           HpAlloc = 24;
           goto caMjn;
       caMjn: // global
           R1 = _saLM9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMjp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saLM9::P64;
           _saLLm::I64 = I64[_saLM9::P64 + 16];
           I64[Hp - 16] = sat_saLM8_info;
           I64[Hp] = _saLLm::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.$wstartIOManagerThread_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(caMju,
                       label: GHC.Event.Thread.$wstartIOManagerThread_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMju: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caMjv; else goto caMjw;
       caMjv: // global
           R1 = GHC.Event.Thread.$wstartIOManagerThread_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caMjw: // global
           _saLLm::I64 = R5;
           _saLLk::I64 = R3;
           _saLLj::I64 = R2;
           if (%MO_S_Gt_W64(R2, R5)) goto caMjy; else goto caMjt;
       caMjt: // global
           if (%MO_S_Gt_W64(_saLLm::I64,
                            _saLLk::I64)) goto caMjy; else goto caMjO;
       caMjy: // global
           R4 = _saLLm::I64;
           R3 = _saLLj::I64;
           R2 = _saLLk::I64;
           call GHC.Event.Thread.ensureIOManagerIsRunning8_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
       caMjO: // global
           _saLLv::P64 = P64[(R4 + 24) + (_saLLm::I64 - _saLLj::I64 << 3)];
           I64[Sp - 32] = block_caMjz_info;
           R1 = _saLLv::P64;
           I64[Sp - 24] = _saLLj::I64;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = _saLLm::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaMkL; else goto caMjP;
       uaMkL: // global
           call _caMjz(R1) args: 0, res: 0, upd: 0;
       caMjP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMjz() //  [R1]
         { info_tbl: [(caMjz,
                       label: block_caMjz_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMjz: // global
           if (R1 & 7 == 1) goto uaMkH; else goto caMk5;
       uaMkH: // global
           Sp = Sp + 8;
           call _saLLw() args: 0, res: 0, upd: 0;
       caMk5: // global
           I64[Sp] = block_caMjY_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaMkM; else goto caMjZ;
       uaMkM: // global
           call _caMjY(R1) args: 0, res: 0, upd: 0;
       caMjZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMjY() //  [R1]
         { info_tbl: [(caMjY,
                       label: block_caMjY_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMjY: // global
           I64[Sp - 8] = block_caMk3_info;
           _saLMs::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _saLMs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMkO; else goto caMk7;
       uaMkO: // global
           call _caMk3(R1) args: 0, res: 0, upd: 0;
       caMk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMk3() //  [R1]
         { info_tbl: [(caMk3,
                       label: block_caMk3_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMk3: // global
           I64[Sp] = block_caMkb_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMkb() //  [R1]
         { info_tbl: [(caMkb,
                       label: block_caMkb_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMkb: // global
           if (R1 == 16) goto uaMkI; else goto uaMkG;
       uaMkI: // global
           Sp = Sp + 16;
           call _saLLw() args: 0, res: 0, upd: 0;
       uaMkG: // global
           if (R1 == 17) goto caMky; else goto caMkj;
       caMky: // global
           _saLMs::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 32])), (-1));
           I64[Sp + 8] = block_caMkx_info;
           R2 = _saLMs::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 8, upd: 8;
       caMkj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMkx() //  []
         { info_tbl: [(caMkx,
                       label: block_caMkx_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMkx: // global
           Sp = Sp + 8;
           call _saLLw() args: 0, res: 0, upd: 0;
     }
 },
 _saLLw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLLw: // global
           I64[Sp - 8] = block_caMi8_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caMi8() //  [R1]
         { info_tbl: [(caMi8,
                       label: block_caMi8_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMi8: // global
           I64[Sp] = block_caMia_info;
           R2 = R1;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMia() //  [R1]
         { info_tbl: [(caMia,
                       label: block_caMia_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMia: // global
           I64[Sp] = block_caMic_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMkK; else goto caMid;
       uaMkK: // global
           call _caMic(R1) args: 0, res: 0, upd: 0;
       caMid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMic() //  [R1]
         { info_tbl: [(caMic,
                       label: block_caMic_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMic: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMjG; else goto caMjF;
       caMjG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMjF: // global
           _saLLN::I64 = I64[R1 + 95];
           I64[Hp - 24] = sat_saLM1_info;
           P64[Hp - 16] = R1;
           _saLLm::I64 = I64[Sp + 24];
           I64[Hp - 8] = _saLLm::I64;
           I64[Hp] = _saLLN::I64;
           I64[Sp - 8] = block_caMiL_info;
           R2 = Hp - 23;
           _saLLE::P64 = R1;
           R1 = _saLLm::I64;
           P64[Sp] = _saLLE::P64;
           Sp = Sp - 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMiL() //  [R1]
         { info_tbl: [(caMiL,
                       label: block_caMiL_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMiL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMjJ; else goto caMjI;
       caMjJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMjI: // global
           I64[Hp - 32] = sat_saLMf_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saLM9_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp - 8] = block_caMjD_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMjD() //  [R1]
         { info_tbl: [(caMjD,
                       label: block_caMjD_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMjD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caMjN; else goto caMjM;
       caMjN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMjM: // global
           I64[Hp - 48] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLLl::P64 = P64[Sp + 32];
           _saLMj::I64 = I64[Sp + 40] - I64[Sp + 24];
           call MO_WriteBarrier();
           P64[(_saLLl::P64 + 24) + (_saLMj::I64 << 3)] = Hp - 6;
           I64[_saLLl::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLLl::P64 + 24) + ((I64[_saLLl::P64 + 8] << 3) + (_saLMj::I64 >> 7))] = 1 :: W8;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.367643961 UTC

[section ""data" . lvl5_raLJt_closure" {
     lvl5_raLJt_closure:
         const lvl5_raLJt_info;
 },
 sat_saLNh_entry() //  [R1]
         { info_tbl: [(caMll,
                       label: sat_saLNh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMll: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMlm; else goto caMln;
       caMlm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMln: // global
           I64[Sp - 16] = block_caMlc_info;
           _saLMS::P64 = P64[R1 + 7];
           R1 = _saLMS::P64;
           P64[Sp - 8] = _saLMS::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMlc() //  [R1]
         { info_tbl: [(caMlc,
                       label: block_caMlc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMlc: // global
           _saLMS::P64 = P64[Sp + 8];
           (_saLNc::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saLNc::I64) goto caMlk; else goto caMlj;
       caMlk: // global
           R1 = _saLMS::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMlj: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNc::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl5_raLJt_entry() //  []
         { info_tbl: [(caMlv,
                       label: lvl5_raLJt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMlv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMlw; else goto caMlx;
       caMlw: // global
           R1 = lvl5_raLJt_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMlx: // global
           I64[Sp - 8] = block_caMkV_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caMkV() //  []
         { info_tbl: [(caMkV,
                       label: block_caMkV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMkV: // global
           I64[Sp] = block_caMkX_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caMkX() //  [R1]
         { info_tbl: [(caMkX,
                       label: block_caMkX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMkX: // global
           I64[Sp - 8] = block_caMkZ_info;
           R2 = GHC.Base.Nothing_closure+1;
           _saLMN::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLMN::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMkZ() //  []
         { info_tbl: [(caMkZ,
                       label: block_caMkZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMkZ: // global
           I64[Sp] = block_caMl1_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMl1() //  [R1]
         { info_tbl: [(caMl1,
                       label: block_caMl1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMl1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMlD; else goto caMlC;
       caMlD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMlC: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caMl3::P64 = Hp - 23;
           if (R1 == 0) goto caMlu; else goto caMlt;
       caMlu: // global
           I64[Hp - 8] = sat_saLNh_info;
           P64[Hp] = _caMl3::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caMlt: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMlE_info;
           R1 = _caMl3::P64;
           P64[Sp + 8] = _caMl3::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMlE() //  [R1]
         { info_tbl: [(caMlE,
                       label: block_caMlE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMlE: // global
           _caMl3::P64 = P64[Sp + 8];
           (_saLN0::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saLN0::I64) goto caMlN; else goto caMlM;
       caMlN: // global
           R1 = _caMl3::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMlM: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLN0::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.370084267 UTC

[section ""data" . GHC.Event.Thread.timerManagerThreadVar_closure" {
     GHC.Event.Thread.timerManagerThreadVar_closure:
         const GHC.Event.Thread.timerManagerThreadVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManagerThreadVar_entry() //  [R1]
         { info_tbl: [(caMlZ,
                       label: GHC.Event.Thread.timerManagerThreadVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMlZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMm0; else goto caMm1;
       caMm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMm1: // global
           (_caMlU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMlU::I64 == 0) goto caMlW; else goto caMlV;
       caMlW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMlV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMlU::I64;
           I64[Sp - 24] = block_caMlX_info;
           Sp = Sp - 24;
           call lvl5_raLJt_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caMlX() //  [R1]
         { info_tbl: [(caMlX,
                       label: block_caMlX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMlX: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.371798682 UTC

[section ""data" . lvl6_raLJu_closure" {
     lvl6_raLJu_closure:
         const lvl6_raLJu_info;
 },
 sat_saLNS_entry() //  [R1]
         { info_tbl: [(caMmv,
                       label: sat_saLNS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMmv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMmw; else goto caMmx;
       caMmw: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMmx: // global
           I64[Sp - 16] = block_caMmm_info;
           _saLNt::P64 = P64[R1 + 7];
           R1 = _saLNt::P64;
           P64[Sp - 8] = _saLNt::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMmm() //  [R1]
         { info_tbl: [(caMmm,
                       label: block_caMmm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMmm: // global
           _saLNt::P64 = P64[Sp + 8];
           (_saLNN::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saLNN::I64) goto caMmu; else goto caMmt;
       caMmu: // global
           R1 = _saLNt::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMmt: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNN::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl6_raLJu_entry() //  []
         { info_tbl: [(caMmF,
                       label: lvl6_raLJu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMmF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMmG; else goto caMmH;
       caMmG: // global
           R1 = lvl6_raLJu_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMmH: // global
           I64[Sp - 8] = block_caMm7_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caMm7() //  []
         { info_tbl: [(caMm7,
                       label: block_caMm7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMm7: // global
           I64[Sp] = block_caMm9_info;
           R1 = GHC.Base.Nothing_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMm9() //  [R1]
         { info_tbl: [(caMm9,
                       label: block_caMm9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMm9: // global
           I64[Sp - 8] = block_caMmb_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMmb() //  [R1]
         { info_tbl: [(caMmb,
                       label: block_caMmb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMmb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMmM; else goto caMmL;
       caMmM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMmL: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caMmd::P64 = Hp - 23;
           if (R1 == 0) goto caMmE; else goto caMmD;
       caMmE: // global
           I64[Hp - 8] = sat_saLNS_info;
           P64[Hp] = _caMmd::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caMmD: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMmN_info;
           R1 = _caMmd::P64;
           P64[Sp + 8] = _caMmd::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMmN() //  [R1]
         { info_tbl: [(caMmN,
                       label: block_caMmN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMmN: // global
           _caMmd::P64 = P64[Sp + 8];
           (_saLNB::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saLNB::I64) goto caMmW; else goto caMmV;
       caMmW: // global
           R1 = _caMmd::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMmV: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNB::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.374053524 UTC

[section ""data" . GHC.Event.Thread.timerManager_closure" {
     GHC.Event.Thread.timerManager_closure:
         const GHC.Event.Thread.timerManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManager_entry() //  [R1]
         { info_tbl: [(caMn8,
                       label: GHC.Event.Thread.timerManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMn8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMn9; else goto caMna;
       caMn9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMna: // global
           (_caMn3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMn3::I64 == 0) goto caMn5; else goto caMn4;
       caMn5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMn4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMn3::I64;
           I64[Sp - 24] = block_caMn6_info;
           Sp = Sp - 24;
           call lvl6_raLJu_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caMn6() //  [R1]
         { info_tbl: [(caMn6,
                       label: block_caMn6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMn6: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.375065272 UTC

[section ""cstring" . lvl7_raLJv_bytes" {
     lvl7_raLJv_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,50,49,54,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.375776063 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager2_closure" {
     GHC.Event.Thread.getSystemTimerManager2_closure:
         const GHC.Event.Thread.getSystemTimerManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager2_entry() //  []
         { info_tbl: [(caMni,
                       label: GHC.Event.Thread.getSystemTimerManager2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMni: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMnj; else goto caMnk;
       caMnj: // global
           R1 = GHC.Event.Thread.getSystemTimerManager2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMnk: // global
           I64[Sp - 8] = block_caMng_info;
           R2 = lvl7_raLJv_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMng() //  [R1]
         { info_tbl: [(caMng,
                       label: block_caMng_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMng: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.377023022 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager1_closure" {
     GHC.Event.Thread.getSystemTimerManager1_closure:
         const GHC.Event.Thread.getSystemTimerManager1_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager1_entry() //  []
         { info_tbl: [(caMnv,
                       label: GHC.Event.Thread.getSystemTimerManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMnv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMnw; else goto caMnx;
       caMnw: // global
           R1 = GHC.Event.Thread.getSystemTimerManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMnx: // global
           I64[Sp - 8] = block_caMns_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMnP; else goto caMnt;
       uaMnP: // global
           call _caMns(R1) args: 0, res: 0, upd: 0;
       caMnt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMns() //  [R1]
         { info_tbl: [(caMns,
                       label: block_caMns_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMns: // global
           _saLO3::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caMnA_info;
           R1 = _saLO3::P64;
           if (R1 & 7 != 0) goto uaMnO; else goto caMnC;
       uaMnO: // global
           call _caMnA(R1) args: 0, res: 0, upd: 0;
       caMnC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMnA() //  [R1]
         { info_tbl: [(caMnA,
                       label: block_caMnA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMnA: // global
           if (R1 & 7 == 1) goto caMnI; else goto caMnM;
       caMnI: // global
           Sp = Sp + 8;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caMnM: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.378353357 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager_closure" {
     GHC.Event.Thread.getSystemTimerManager_closure:
         const GHC.Event.Thread.getSystemTimerManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager_entry() //  []
         { info_tbl: [(caMnU,
                       label: GHC.Event.Thread.getSystemTimerManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMnU: // global
           call GHC.Event.Thread.getSystemTimerManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.37979658 UTC

[section ""data" . lvl8_raLJw_closure" {
     lvl8_raLJw_closure:
         const lvl8_raLJw_info;
 },
 sat_saLOE_entry() //  [R1]
         { info_tbl: [(caMor,
                       label: sat_saLOE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMor: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMos; else goto caMot;
       caMos: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMot: // global
           I64[Sp - 16] = block_caMoi_info;
           _saLOf::P64 = P64[R1 + 7];
           R1 = _saLOf::P64;
           P64[Sp - 8] = _saLOf::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMoi() //  [R1]
         { info_tbl: [(caMoi,
                       label: block_caMoi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMoi: // global
           _saLOf::P64 = P64[Sp + 8];
           (_saLOz::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saLOz::I64) goto caMoq; else goto caMop;
       caMoq: // global
           R1 = _saLOf::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMop: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLOz::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_raLJw_entry() //  []
         { info_tbl: [(caMoB,
                       label: lvl8_raLJw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMoB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMoC; else goto caMoD;
       caMoC: // global
           R1 = lvl8_raLJw_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMoD: // global
           I64[Sp - 8] = block_caMo1_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caMo1() //  []
         { info_tbl: [(caMo1,
                       label: block_caMo1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMo1: // global
           I64[Sp] = block_caMo3_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caMo3() //  [R1]
         { info_tbl: [(caMo3,
                       label: block_caMo3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMo3: // global
           I64[Sp - 8] = block_caMo5_info;
           R2 = GHC.Tuple.()_closure+1;
           _saLOa::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLOa::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMo5() //  []
         { info_tbl: [(caMo5,
                       label: block_caMo5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMo5: // global
           I64[Sp] = block_caMo7_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMo7() //  [R1]
         { info_tbl: [(caMo7,
                       label: block_caMo7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMo7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMoJ; else goto caMoI;
       caMoJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMoI: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caMo9::P64 = Hp - 23;
           if (R1 == 0) goto caMoA; else goto caMoz;
       caMoA: // global
           I64[Hp - 8] = sat_saLOE_info;
           P64[Hp] = _caMo9::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caMoz: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMoK_info;
           R1 = _caMo9::P64;
           P64[Sp + 8] = _caMo9::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMoK() //  [R1]
         { info_tbl: [(caMoK,
                       label: block_caMoK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMoK: // global
           _caMo9::P64 = P64[Sp + 8];
           (_saLOn::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saLOn::I64) goto caMoT; else goto caMoS;
       caMoT: // global
           R1 = _caMo9::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMoS: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLOn::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.382313947 UTC

[section ""data" . GHC.Event.Thread.ioManagerLock_closure" {
     GHC.Event.Thread.ioManagerLock_closure:
         const GHC.Event.Thread.ioManagerLock_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ioManagerLock_entry() //  [R1]
         { info_tbl: [(caMp5,
                       label: GHC.Event.Thread.ioManagerLock_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMp5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMp6; else goto caMp7;
       caMp6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMp7: // global
           (_caMp0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMp0::I64 == 0) goto caMp2; else goto caMp1;
       caMp2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMp1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMp0::I64;
           I64[Sp - 24] = block_caMp3_info;
           Sp = Sp - 24;
           call lvl8_raLJw_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caMp3() //  [R1]
         { info_tbl: [(caMp3,
                       label: block_caMp3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMp3: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.384389341 UTC

[section ""data" . lvl9_raLJx_closure" {
     lvl9_raLJx_closure:
         const lvl9_raLJx_info;
         const 0;
 },
 sat_saLPr_entry() //  [R1]
         { info_tbl: [(caMpQ,
                       label: sat_saLPr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMpR; else goto caMpS;
       caMpR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMpS: // global
           I64[Sp - 16] = block_caMpH_info;
           _saLP2::P64 = P64[R1 + 7];
           R1 = _saLP2::P64;
           P64[Sp - 8] = _saLP2::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMpH() //  [R1]
         { info_tbl: [(caMpH,
                       label: block_caMpH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpH: // global
           _saLP2::P64 = P64[Sp + 8];
           (_saLPm::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saLPm::I64) goto caMpP; else goto caMpO;
       caMpP: // global
           R1 = _saLP2::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMpO: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLPm::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_raLJx_entry() //  []
         { info_tbl: [(caMpX,
                       label: lvl9_raLJx_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMpY; else goto caMpZ;
       caMpY: // global
           R1 = lvl9_raLJx_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMpZ: // global
           I64[Sp - 8] = block_caMpd_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caMpd() //  []
         { info_tbl: [(caMpd,
                       label: block_caMpd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpd: // global
           _saLON::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]) - 1;
           if (%MO_S_Gt_W64(0, _saLON::I64)) goto caMqs; else goto caMqt;
       caMqs: // global
           _saLOP::I64 = 0;
           goto saLOO;
       caMqt: // global
           _saLOP::I64 = _saLON::I64 + 1;
           goto saLOO;
       saLOO: // global
           if (%MO_S_Ge_W64(_saLOP::I64, 0)) goto caMq3; else goto caMqo;
       caMq3: // global
           I64[Sp - 16] = block_caMpq_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saLOP::I64;
           I64[Sp - 8] = _saLOP::I64;
           I64[Sp] = _saLON::I64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caMqo: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMpq() //  [R1]
         { info_tbl: [(caMpq,
                       label: block_caMpq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caMq6; else goto caMq5;
       caMq6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMq5: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = Hp - 47;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 16] = block_caMpu_info;
           R1 = Hp - 31;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMpu() //  [R1]
         { info_tbl: [(caMpu,
                       label: block_caMpu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpu: // global
           I64[Sp - 8] = block_caMpw_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMpw() //  [R1]
         { info_tbl: [(caMpw,
                       label: block_caMpw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMpw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMqa; else goto caMq9;
       caMqa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMq9: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caMpy::P64 = Hp - 23;
           if (R1 == 0) goto caMqn; else goto caMqd;
       caMqn: // global
           I64[Hp - 8] = sat_saLPr_info;
           P64[Hp] = _caMpy::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caMqd: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMqb_info;
           R1 = _caMpy::P64;
           P64[Sp + 8] = _caMpy::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMqb() //  [R1]
         { info_tbl: [(caMqb,
                       label: block_caMqb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMqb: // global
           _caMpy::P64 = P64[Sp + 8];
           (_saLPa::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saLPa::I64) goto caMqm; else goto caMql;
       caMqm: // global
           R1 = _caMpy::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMql: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLPa::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.387195607 UTC

[section ""data" . GHC.Event.Thread.eventManager_closure" {
     GHC.Event.Thread.eventManager_closure:
         const GHC.Event.Thread.eventManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.eventManager_entry() //  [R1]
         { info_tbl: [(caMqI,
                       label: GHC.Event.Thread.eventManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMqI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMqJ; else goto caMqK;
       caMqJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMqK: // global
           (_caMqD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMqD::I64 == 0) goto caMqF; else goto caMqE;
       caMqF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMqE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMqD::I64;
           I64[Sp - 24] = block_caMqG_info;
           Sp = Sp - 24;
           call lvl9_raLJx_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caMqG() //  [R1]
         { info_tbl: [(caMqG,
                       label: block_caMqG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMqG: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.388228388 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning5_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning5_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.388968234 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning4_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning4_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning4_entry() //  [R1]
         { info_tbl: [(caMqS,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMqS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMqT; else goto caMqU;
       caMqT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMqU: // global
           (_caMqP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMqP::I64 == 0) goto caMqR; else goto caMqQ;
       caMqR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMqQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMqP::I64;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.391420281 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning3_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning3_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning3_info;
         const 0;
 },
 sat_saLPZ_entry() //  [R1]
         { info_tbl: [(caMrw,
                       label: sat_saLPZ_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caMrx; else goto caMry;
       caMrx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMry: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 63];
           I64[Sp - 24] = I64[R1 + 71];
           P64[Sp - 16] = P64[R1 + 39];
           P64[Sp - 8] = P64[R1 + 47];
           Sp = Sp - 32;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_saLQ0_entry() //  [R1]
         { info_tbl: [(caMrz,
                       label: sat_saLQ0_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrz: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caMrD; else goto caMrC;
       caMrD: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMrC: // global
           _saLPG::P64 = P64[R1 + 7];
           _saLPH::P64 = P64[R1 + 15];
           _saLPI::P64 = P64[R1 + 23];
           _saLPJ::P64 = P64[R1 + 31];
           _saLPN::P64 = P64[R1 + 39];
           _saLPO::P64 = P64[R1 + 47];
           _saLPK::I64 = I64[R1 + 55];
           _saLPL::I64 = I64[R1 + 63];
           _saLPM::I64 = I64[R1 + 71];
           I64[Hp - 72] = sat_saLPZ_info;
           P64[Hp - 64] = _saLPG::P64;
           P64[Hp - 56] = _saLPH::P64;
           P64[Hp - 48] = _saLPI::P64;
           P64[Hp - 40] = _saLPJ::P64;
           P64[Hp - 32] = _saLPN::P64;
           P64[Hp - 24] = _saLPO::P64;
           I64[Hp - 16] = _saLPK::I64;
           I64[Hp - 8] = _saLPL::I64;
           I64[Hp] = _saLPM::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 71;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLQ9_entry() //  [R1, R2]
         { info_tbl: [(caMrO,
                       label: sat_saLQ9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMrS; else goto caMrT;
       caMrS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMrT: // global
           I64[Sp - 16] = block_caMrL_info;
           _saLQ3::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLQ3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMrX; else goto caMrM;
       uaMrX: // global
           call _caMrL(R1) args: 0, res: 0, upd: 0;
       caMrM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMrL() //  [R1]
         { info_tbl: [(caMrL,
                       label: block_caMrL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrL: // global
           _saLQ3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caMrR_info;
           R2 = I64[R1 + 7];
           R1 = _saLQ3::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMrR() //  []
         { info_tbl: [(caMrR,
                       label: block_caMrR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.ensureIOManagerIsRunning3_entry() //  []
         { info_tbl: [(caMrY,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrY: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caMs3; else goto caMs4;
       caMs3: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMs4: // global
           I64[Sp - 8] = block_caMqZ_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caMqZ() //  [R1]
         { info_tbl: [(caMqZ,
                       label: block_caMqZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMqZ: // global
           I64[Sp] = block_caMr1_info;
           R2 = R1;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMr1() //  [R1]
         { info_tbl: [(caMr1,
                       label: block_caMr1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMr1: // global
           I64[Sp] = block_caMr3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMsh; else goto caMr4;
       uaMsh: // global
           call _caMr3(R1) args: 0, res: 0, upd: 0;
       caMr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMr3() //  [R1]
         { info_tbl: [(caMr3,
                       label: block_caMr3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMr3: // global
           _saLPG::P64 = P64[R1 + 7];
           _saLPH::P64 = P64[R1 + 15];
           _saLPI::P64 = P64[R1 + 23];
           _saLPJ::P64 = P64[R1 + 31];
           _saLPN::P64 = P64[R1 + 39];
           _saLPO::P64 = P64[R1 + 47];
           _saLPK::I64 = I64[R1 + 55];
           _saLPL::I64 = I64[R1 + 63];
           _saLPM::I64 = I64[R1 + 71];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLPL::I64)));
           I64[Sp - 80] = block_caMrd_info;
           _saLPF::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp - 72] = _saLPG::P64;
           P64[Sp - 64] = _saLPH::P64;
           P64[Sp - 56] = _saLPI::P64;
           P64[Sp - 48] = _saLPJ::P64;
           I64[Sp - 40] = _saLPK::I64;
           I64[Sp - 32] = _saLPL::I64;
           I64[Sp - 24] = _saLPM::I64;
           P64[Sp - 16] = _saLPN::P64;
           P64[Sp - 8] = _saLPO::P64;
           P64[Sp] = _saLPF::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uaMsi; else goto caMre;
       uaMsi: // global
           call _caMrd(R1) args: 0, res: 0, upd: 0;
       caMre: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMrd() //  [R1]
         { info_tbl: [(caMrd,
                       label: block_caMrd_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrd: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caMsa; else goto caMs9;
       caMsa: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMs9: // global
           _saLPU::P64 = P64[R1 + 7];
           I64[Hp - 88] = GHC.Base.Just_con_info;
           P64[Hp - 80] = P64[Sp + 80];
           _saLPG::P64 = P64[Sp + 8];
           _saLPH::P64 = P64[Sp + 16];
           _saLPI::P64 = P64[Sp + 24];
           _saLPJ::P64 = P64[Sp + 32];
           _saLPK::I64 = I64[Sp + 40];
           _saLPL::I64 = I64[Sp + 48];
           _saLPM::I64 = I64[Sp + 56];
           _saLPN::P64 = P64[Sp + 64];
           _saLPO::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_saLPU::P64 + 8] = Hp - 86;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLPU::P64);
           I64[Hp - 72] = sat_saLQ0_info;
           P64[Hp - 64] = _saLPG::P64;
           P64[Hp - 56] = _saLPH::P64;
           P64[Hp - 48] = _saLPI::P64;
           P64[Hp - 40] = _saLPJ::P64;
           P64[Hp - 32] = _saLPN::P64;
           P64[Hp - 24] = _saLPO::P64;
           I64[Hp - 16] = _saLPK::I64;
           I64[Hp - 8] = _saLPL::I64;
           I64[Hp] = _saLPM::I64;
           I64[Sp + 80] = block_caMrE_info;
           R1 = Hp - 71;
           Sp = Sp + 80;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMrE() //  [R1]
         { info_tbl: [(caMrE,
                       label: block_caMrE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMsd; else goto caMsc;
       caMsd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMsc: // global
           I64[Hp - 8] = sat_saLQ9_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_caMrZ_info;
           R4 = Hp - 6;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMrZ() //  [R1]
         { info_tbl: [(caMrZ,
                       label: block_caMrZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMrZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMsg; else goto caMsf;
       caMsg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMsf: // global
           I64[Hp - 24] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.396782804 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning2_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning2_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning2_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning2_entry() //  [R2]
         { info_tbl: [(caMsu,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMsu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caMsv; else goto caMsw;
       caMsv: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMsw: // global
           I64[Sp - 8] = block_caMsn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMuh; else goto caMso;
       uaMuh: // global
           call _caMsn(R1) args: 0, res: 0, upd: 0;
       caMso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMsn() //  [R1]
         { info_tbl: [(caMsn,
                       label: block_caMsn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMsn: // global
           if (R1 & 7 == 1) goto uaMuc; else goto caMss;
       uaMuc: // global
           Sp = Sp + 8;
           call _caMt9() args: 0, res: 0, upd: 0;
       caMss: // global
           I64[Sp - 8] = block_caMsC_info;
           _saLQh::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saLQh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMuf; else goto caMsE;
       uaMuf: // global
           call _caMsC(R1) args: 0, res: 0, upd: 0;
       caMsE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMsC() //  [R1]
         { info_tbl: [(caMsC,
                       label: block_caMsC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMsC: // global
           I64[Sp] = block_caMsI_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMsI() //  [R1]
         { info_tbl: [(caMsI,
                       label: block_caMsI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMsI: // global
           if (R1 == 16) goto uaMud; else goto uaMub;
       uaMud: // global
           Sp = Sp + 16;
           call _caMt9() args: 0, res: 0, upd: 0;
       uaMub: // global
           if (R1 == 17) goto caMsW; else goto caMsQ;
       caMsW: // global
           I64[Sp + 8] = block_caMsV_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaMui; else goto caMsX;
       uaMui: // global
           call _caMsV(R1) args: 0, res: 0, upd: 0;
       caMsX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMsQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMsV() //  [R1]
         { info_tbl: [(caMsV,
                       label: block_caMsV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMsV: // global
           _saLQv::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caMt1_info;
           R1 = _saLQv::P64;
           if (R1 & 7 != 0) goto uaMuk; else goto caMt3;
       uaMuk: // global
           call _caMt1(R1) args: 0, res: 0, upd: 0;
       caMt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMt1() //  [R1]
         { info_tbl: [(caMt1,
                       label: block_caMt1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMt1: // global
           if (R1 & 7 == 1) goto uaMue; else goto caMtl;
       uaMue: // global
           Sp = Sp + 8;
           call _caMt9() args: 0, res: 0, upd: 0;
       caMtl: // global
           _saLQx::P64 = P64[R1 + 6];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd((-1));
           I64[Sp] = block_caMte_info;
           R1 = _saLQx::P64;
           if (R1 & 7 != 0) goto uaMul; else goto caMtf;
       uaMul: // global
           call _caMte(R1) args: 0, res: 0, upd: 0;
       caMtf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMt9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMt9: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _caMte() //  [R1]
         { info_tbl: [(caMte,
                       label: block_caMte_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMte: // global
           I64[Sp - 48] = block_caMtj_info;
           _saLQE::P64 = P64[R1 + 23];
           _saLQJ::P64 = P64[R1 + 39];
           _saLQK::P64 = P64[R1 + 47];
           _saLQG::I64 = I64[R1 + 55];
           _saLQH::I64 = I64[R1 + 63];
           _saLQI::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _saLQG::I64;
           I64[Sp - 32] = _saLQH::I64;
           I64[Sp - 24] = _saLQI::I64;
           P64[Sp - 16] = _saLQJ::P64;
           P64[Sp - 8] = _saLQK::P64;
           P64[Sp] = _saLQE::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaMun; else goto caMtn;
       uaMun: // global
           call _caMtj(R1) args: 0, res: 0, upd: 0;
       caMtn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMtj() //  [R1]
         { info_tbl: [(caMtj,
                       label: block_caMtj_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMtj: // global
           _saLQE::P64 = P64[Sp + 48];
           _saLQM::P64 = P64[R1 + 7];
           _saLQQ::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saLQE::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLQE::P64);
           I64[Sp] = block_caMtu_info;
           R2 = _saLQM::P64;
           R1 = _saLQQ::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMtu() //  []
         { info_tbl: [(caMtu,
                       label: block_caMtu_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMtu: // global
           I64[Sp] = block_caMtw_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMtw() //  []
         { info_tbl: [(caMtw,
                       label: block_caMtw_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMtw: // global
           _saLQH::I64 = I64[Sp + 16];
           _saLQJ::P64 = P64[Sp + 32];
           (_saLR2::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saLR7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQH::I64)));
           I64[Sp + 16] = block_caMtL_info;
           R1 = _saLQJ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaMuo; else goto caMtM;
       uaMuo: // global
           call _caMtL(R1) args: 0, res: 0, upd: 0;
       caMtM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMtL() //  [R1]
         { info_tbl: [(caMtL,
                       label: block_caMtL_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMtL: // global
           _saLQI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caMtS; else goto caMtW;
       caMtS: // global
           (_saLRd::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQI::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
       caMtW: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saLRl::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQI::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.401088976 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning6_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning6_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning6_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning6_entry() //  [R2]
         { info_tbl: [(caMuw,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMuw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caMuK; else goto caMuL;
       caMuK: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMuL: // global
           I64[Sp - 8] = block_caMut_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMvU; else goto caMuu;
       uaMvU: // global
           call _caMut(R1) args: 0, res: 0, upd: 0;
       caMuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMut() //  [R1]
         { info_tbl: [(caMut,
                       label: block_caMut_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMut: // global
           _saLRs::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caMuz_info;
           R1 = _saLRs::P64;
           if (R1 & 7 != 0) goto uaMvT; else goto caMuA;
       uaMvT: // global
           call _caMuz(R1) args: 0, res: 0, upd: 0;
       caMuA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMuz() //  [R1]
         { info_tbl: [(caMuz,
                       label: block_caMuz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMuz: // global
           I64[Sp - 16] = block_caMuE_info;
           _saLRu::P64 = P64[R1 + 7];
           _saLRx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saLRx::P64;
           P64[Sp] = _saLRu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMvV; else goto caMuF;
       uaMvV: // global
           call _caMuE(R1) args: 0, res: 0, upd: 0;
       caMuF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMuE() //  [R1]
         { info_tbl: [(caMuE,
                       label: block_caMuE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMuE: // global
           I64[Sp] = block_caMuJ_info;
           _saLRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saLRz::I64;
           if (R1 & 7 != 0) goto uaMvW; else goto caMuP;
       uaMvW: // global
           call _caMuJ(R1) args: 0, res: 0, upd: 0;
       caMuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMuJ() //  [R1]
         { info_tbl: [(caMuJ,
                       label: block_caMuJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMuJ: // global
           if (%MO_S_Le_W64(0, I64[Sp + 16])) goto caMvq; else goto caMvt;
       caMvq: // global
           I64[Sp - 8] = 0;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 8;
           call _caMve() args: 0, res: 0, upd: 0;
       caMvt: // global
           I64[Sp + 8] = block_caMvs_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaMvX; else goto caMvu;
       uaMvX: // global
           call _caMvs(R1) args: 0, res: 0, upd: 0;
       caMvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMve() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMve: // global
           I64[Sp - 8] = block_caMvg_info;
           R5 = I64[Sp];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 24];
           R2 = I64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMvg() //  []
         { info_tbl: [(caMvg,
                       label: block_caMvg_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMvg: // global
           _saLRL::I64 = I64[Sp + 8];
           if (_saLRL::I64 == I64[Sp + 32]) goto caMvo; else goto caMvn;
       caMvo: // global
           I64[Sp + 24] = block_caMv2_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaMvZ; else goto caMv4;
       uaMvZ: // global
           call _caMv2(R1) args: 0, res: 0, upd: 0;
       caMv4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMvn: // global
           I64[Sp + 8] = _saLRL::I64 + 1;
           Sp = Sp + 8;
           call _caMve() args: 0, res: 0, upd: 0;
     }
 },
 _caMv2() //  [R1]
         { info_tbl: [(caMv2,
                       label: block_caMv2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMv2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMva; else goto caMv9;
       caMva: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMv9: // global
           _saLRG::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saLRG::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLRG::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMvs() //  [R1]
         { info_tbl: [(caMvs,
                       label: block_caMvs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMvs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMvA; else goto caMvz;
       caMvA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMvz: // global
           _saLRT::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saLRT::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLRT::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.404174658 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning1_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning1_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning1_entry() //  []
         { info_tbl: [(caMwa,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMwb; else goto caMwc;
       caMwb: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMwc: // global
           (_saLS1::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saLS1::I64 == 0) goto caMw9; else goto caMw8;
       caMw9: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMw8: // global
           I64[Sp - 8] = block_caMwe_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMwt; else goto caMwf;
       uaMwt: // global
           call _caMwe(R1) args: 0, res: 0, upd: 0;
       caMwf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMwe() //  [R1]
         { info_tbl: [(caMwe,
                       label: block_caMwe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwe: // global
           I64[Sp] = block_caMwj_info;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure+2;
           R2 = P64[R1 + 7];
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMwj() //  []
         { info_tbl: [(caMwj,
                       label: block_caMwj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwj: // global
           I64[Sp] = block_caMwl_info;
           R1 = GHC.Event.Thread.timerManagerThreadVar_closure;
           if (R1 & 7 != 0) goto uaMwu; else goto caMwo;
       uaMwu: // global
           call _caMwl(R1) args: 0, res: 0, upd: 0;
       caMwo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMwl() //  [R1]
         { info_tbl: [(caMwl,
                       label: block_caMwl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwl: // global
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.405837318 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caMwz,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwz: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.406566529 UTC

[section ""cstring" . lvl10_raLJy_bytes" {
     lvl10_raLJy_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,53,51,58,49,53,45,50,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.407294508 UTC

[section ""data" . lvl11_raLJz_closure" {
     lvl11_raLJz_closure:
         const lvl11_raLJz_info;
         const 0;
 },
 lvl11_raLJz_entry() //  []
         { info_tbl: [(caMwI,
                       label: lvl11_raLJz_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMwJ; else goto caMwK;
       caMwJ: // global
           R1 = lvl11_raLJz_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMwK: // global
           I64[Sp - 8] = block_caMwG_info;
           R2 = lvl10_raLJy_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMwG() //  [R1]
         { info_tbl: [(caMwG,
                       label: block_caMwG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.408176272 UTC

[section ""cstring" . lvl12_raLJA_bytes" {
     lvl12_raLJA_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,51,57,58,49,55,45,51,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.408849174 UTC

[section ""data" . lvl13_raLJB_closure" {
     lvl13_raLJB_closure:
         const lvl13_raLJB_info;
         const 0;
 },
 lvl13_raLJB_entry() //  []
         { info_tbl: [(caMwU,
                       label: lvl13_raLJB_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMwV; else goto caMwW;
       caMwV: // global
           R1 = lvl13_raLJB_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMwW: // global
           I64[Sp - 8] = block_caMwS_info;
           R2 = lvl12_raLJA_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMwS() //  [R1]
         { info_tbl: [(caMwS,
                       label: block_caMwS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMwS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.409932362 UTC

[section ""data" . lvl14_raLJC_closure" {
     lvl14_raLJC_closure:
         const lvl14_raLJC_info;
         const 0;
 },
 lvl14_raLJC_entry() //  [R2, R3, R4]
         { info_tbl: [(caMx4,
                       label: lvl14_raLJC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMx4: // global
           R6 = lvl4_raLJs_closure;
           R5 = R4;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.410861617 UTC

[section ""data" . lvl15_raLJD_closure" {
     lvl15_raLJD_closure:
         const lvl15_raLJD_info;
         const 0;
 },
 lvl15_raLJD_entry() //  [R2, R3]
         { info_tbl: [(caMxb,
                       label: lvl15_raLJD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxb: // global
           R6 = lvl4_raLJs_closure;
           R5 = R3;
           R4 = R2;
           R3 = lvl1_raLJo_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.416786089 UTC

[section ""data" . GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caMz0,
                       label: GHC.Event.Thread.$wioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMz0: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caMz1; else goto caMz2;
       caMz1: // global
           R1 = GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMz2: // global
           _saLSm::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Sp - 16] = block_caMxi_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           I64[Sp - 8] = _saLSm::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMDO; else goto caMxj;
       uaMDO: // global
           call _caMxi(R1) args: 0, res: 0, upd: 0;
       caMxj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMxi() //  [R1]
         { info_tbl: [(caMxi,
                       label: block_caMxi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMz5; else goto caMz4;
       caMz5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMz4: // global
           _saLSo::P64 = P64[R1 + 7];
           _saLSr::P64 = P64[_saLSo::P64 + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saLSo::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSo::P64);
           I64[Sp - 8] = block_caMxr_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp] = _saLSr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMDA; else goto caMxs;
       uaMDA: // global
           call _caMxr(R1) args: 0, res: 0, upd: 0;
       caMxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMxr() //  [R1]
         { info_tbl: [(caMxr,
                       label: block_caMxr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxr: // global
           I64[Sp - 8] = block_caMxw_info;
           _saLSv::P64 = P64[R1 + 7];
           R1 = P64[_saLSv::P64 + 8];
           P64[Sp] = _saLSv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMDB; else goto caMxx;
       uaMDB: // global
           call _caMxw(R1) args: 0, res: 0, upd: 0;
       caMxx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMxw() //  [R1]
         { info_tbl: [(caMxw,
                       label: block_caMxw_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxw: // global
           I64[Sp - 16] = block_caMxB_info;
           _saLSA::P64 = P64[R1 + 7];
           _saLSD::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saLSD::P64;
           P64[Sp] = _saLSA::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMDC; else goto caMxC;
       uaMDC: // global
           call _caMxB(R1) args: 0, res: 0, upd: 0;
       caMxC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMxB() //  [R1]
         { info_tbl: [(caMxB,
                       label: block_caMxB_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxB: // global
           I64[Sp - 8] = block_caMxG_info;
           _saLSE::P64 = R1;
           _saLSF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLSF::I64;
           P64[Sp + 16] = _saLSE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMDD; else goto caMxH;
       uaMDD: // global
           call _caMxG(R1) args: 0, res: 0, upd: 0;
       caMxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMxG() //  [R1]
         { info_tbl: [(caMxG,
                       label: block_caMxG_info
                       rep:StackRep [True, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxG: // global
           _saLSm::I64 = I64[Sp + 48];
           _saLSH::I64 = I64[R1 + 7];
           _saLSI::I64 = I64[Sp + 8] + 1;
           if (%MO_S_Le_W64(_saLSm::I64,
                            _saLSI::I64)) goto caMzb; else goto caMCX;
       caMzb: // global
           I64[Sp] = block_caMxR_info;
           _saLSG::P64 = R1;
           R1 = P64[Sp + 40];
           I64[Sp + 32] = _saLSH::I64;
           P64[Sp + 40] = _saLSG::P64;
           if (R1 & 7 != 0) goto uaMDE; else goto caMxS;
       uaMDE: // global
           call _caMxR(R1) args: 0, res: 0, upd: 0;
       caMxS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMCX: // global
           _saLTn::I64 = _saLSm::I64 - 1;
           if (%MO_S_Gt_W64(0, _saLTn::I64)) goto caMCV; else goto caMCW;
       caMCV: // global
           _saLSG::P64 = R1;
           _saLTp::I64 = 0;
           goto saLTo;
       caMCW: // global
           _saLSG::P64 = R1;
           _saLTp::I64 = _saLTn::I64 + 1;
           goto saLTo;
       saLTo: // global
           if (%MO_S_Ge_W64(_saLTp::I64, 0)) goto caMAg; else goto caMCR;
       caMAg: // global
           I64[Sp - 32] = block_caMyA_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saLTp::I64;
           I64[Sp - 24] = _saLSI::I64;
           I64[Sp - 16] = _saLTn::I64;
           I64[Sp - 8] = _saLTp::I64;
           I64[Sp] = _saLSH::I64;
           P64[Sp + 48] = _saLSG::P64;
           Sp = Sp - 32;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caMCR: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMxR() //  [R1]
         { info_tbl: [(caMxR,
                       label: block_caMxR_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMxR: // global
           _saLSm::I64 = I64[Sp + 48];
           _saLSL::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saLSm::I64,
                            _saLSL::I64)) goto uaMDk; else goto caMAd;
       uaMDk: // global
           Sp = Sp + 56;
           goto uaMDG;
       caMAd: // global
           _saLSN::I64 = _saLSm::I64 - 1;
           if (%MO_S_Le_W64(_saLSL::I64,
                            _saLSN::I64)) goto caMAb; else goto uaMDl;
       caMAb: // global
           I64[Sp] = _saLSL::I64;
           I64[Sp + 48] = _saLSN::I64;
           call _caMyd() args: 0, res: 0, upd: 0;
       uaMDl: // global
           Sp = Sp + 56;
           goto uaMDG;
       uaMDG: // global
           call _caMAc() args: 0, res: 0, upd: 0;
     }
 },
 _caMyd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMyd: // global
           Hp = Hp + 16;
           _saLSY::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caMzp; else goto caMzo;
       caMzp: // global
           HpAlloc = 16;
           I64[Sp] = block_caMyc_info;
           R1 = _saLSY::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMzo: // global
           _saLSE::P64 = P64[Sp + 24];
           _saLSG::P64 = P64[Sp + 40];
           _saLSH::I64 = I64[Sp + 32];
           if (%MO_S_Gt_W64(_saLSH::I64,
                            _saLSY::I64)) goto caMzr; else goto caMA9;
       caMzr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLSY::I64;
           R4 = Hp - 7;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caMA9: // global
           if (%MO_S_Gt_W64(_saLSY::I64,
                            I64[Sp + 8])) goto caMzt; else goto caMzz;
       caMzt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLSY::I64;
           R4 = Hp - 7;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caMzz: // global
           Hp = Hp - 16;
           _saLT7::P64 = P64[P64[Sp + 16] + ((_saLSY::I64 - _saLSH::I64 << 3) + 24)];
           I64[Sp - 8] = block_caMzy_info;
           R1 = _saLT7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMDJ; else goto caMzA;
       uaMDJ: // global
           call _caMzy(R1) args: 0, res: 0, upd: 0;
       caMzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMyc() //  [R1]
         { info_tbl: [(caMyc,
                       label: block_caMyc_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMyc: // global
           I64[Sp] = R1;
           call _caMyd() args: 0, res: 0, upd: 0;
     }
 },
 _caMzy() //  [R1]
         { info_tbl: [(caMzy,
                       label: block_caMzy_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMzy: // global
           if (R1 & 7 == 1) goto caMzG; else goto caMzL;
       caMzG: // global
           Sp = Sp + 64;
           call lvl11_raLJz_entry() args: 8, res: 0, upd: 8;
       caMzL: // global
           I64[Sp] = block_caMzJ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaMDP; else goto caMzM;
       uaMDP: // global
           call _caMzJ(R1) args: 0, res: 0, upd: 0;
       caMzM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMzJ() //  [R1]
         { info_tbl: [(caMzJ,
                       label: block_caMzJ_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMzJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMzU; else goto caMzT;
       caMzU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMzT: // global
           _saLTc::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_caMzR_info;
           R3 = Hp - 7;
           R2 = _saLTc::P64;
           P64[Sp] = _saLTc::P64;
           Sp = Sp - 8;
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMzR() //  [R1]
         { info_tbl: [(caMzR,
                       label: block_caMzR_info
                       rep:StackRep [False, True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMzR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMzY; else goto caMzX;
       caMzY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMzX: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLSD::P64 = P64[Sp + 32];
           _saLSN::I64 = I64[Sp + 64];
           _saLSY::I64 = I64[Sp + 16];
           _saLTh::I64 = _saLSY::I64 - I64[Sp + 48];
           call MO_WriteBarrier();
           P64[(_saLSD::P64 + 24) + (_saLTh::I64 << 3)] = Hp - 6;
           I64[_saLSD::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLSD::P64 + 24) + ((I64[_saLSD::P64 + 8] << 3) + (_saLTh::I64 >> 7))] = 1 :: W8;
           if (_saLSY::I64 == _saLSN::I64) goto uaMDo; else goto caMA7;
       uaMDo: // global
           Sp = Sp + 72;
           call _caMAc() args: 0, res: 0, upd: 0;
       caMA7: // global
           I64[Sp + 16] = _saLSY::I64 + 1;
           Sp = Sp + 16;
           call _caMyd() args: 0, res: 0, upd: 0;
     }
 },
 _caMAc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMAc: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMyA() //  [R1]
         { info_tbl: [(caMyA,
                       label: block_caMyA_info
                       rep:StackRep [True, True, True, True, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMyA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMAj; else goto caMAi;
       caMAj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMAi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           _caMyC::P64 = Hp - 7;
           if (%MO_S_Le_W64(0, I64[Sp + 40])) goto caMCP; else goto uaMDq;
       caMCP: // global
           P64[Sp - 16] = R1;
           I64[Sp - 8] = 0;
           P64[Sp] = _caMyC::P64;
           Sp = Sp - 16;
           call _caMyX() args: 0, res: 0, upd: 0;
       uaMDq: // global
           P64[Sp + 72] = R1;
           P64[Sp + 80] = _caMyC::P64;
           call _caMAl() args: 0, res: 0, upd: 0;
     }
 },
 _caMyX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMyX: // global
           Hp = Hp + 16;
           _saLU8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caMBi; else goto caMBh;
       caMBi: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caMyW_info;
           R1 = _saLU8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMBh: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLU8::I64;
           _saLSE::P64 = P64[Sp + 72];
           _saLSG::P64 = P64[Sp + 96];
           _saLSH::I64 = I64[Sp + 48];
           _caMyZ::P64 = Hp - 7;
           if (%MO_S_Gt_W64(_saLSH::I64,
                            _saLU8::I64)) goto caMBm; else goto caMCN;
       caMBm: // global
           R4 = _caMyZ::P64;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caMCN: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 56])) goto caMBs; else goto caMBz;
       caMBs: // global
           R4 = _caMyZ::P64;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caMBz: // global
           _saLUg::P64 = P64[P64[Sp + 64] + ((_saLU8::I64 - _saLSH::I64 << 3) + 24)];
           I64[Sp - 16] = block_caMBy_info;
           R1 = _saLUg::P64;
           P64[Sp - 8] = _caMyZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMDN; else goto caMBA;
       uaMDN: // global
           call _caMBy(R1) args: 0, res: 0, upd: 0;
       caMBA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMyW() //  [R1]
         { info_tbl: [(caMyW,
                       label: block_caMyW_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMyW: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caMyX() args: 0, res: 0, upd: 0;
     }
 },
 _caMBy() //  [R1]
         { info_tbl: [(caMBy,
                       label: block_caMBy_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMBy: // global
           if (R1 & 7 == 1) goto caMBG; else goto caMBQ;
       caMBG: // global
           Sp = Sp + 120;
           call lvl13_raLJB_entry() args: 8, res: 0, upd: 8;
       caMBQ: // global
           I64[Sp - 8] = block_caMBJ_info;
           _saLUh::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saLUh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMDV; else goto caMBK;
       uaMDV: // global
           call _caMBJ(R1) args: 0, res: 0, upd: 0;
       caMBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMBJ() //  [R1]
         { info_tbl: [(caMBJ,
                       label: block_caMBJ_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMBJ: // global
           I64[Sp - 8] = block_caMBO_info;
           _saLUl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 112];
           P64[Sp] = _saLUl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMDW; else goto caMBS;
       uaMDW: // global
           call _caMBO(R1) args: 0, res: 0, upd: 0;
       caMBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMBO() //  [R1]
         { info_tbl: [(caMBO,
                       label: block_caMBO_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMBO: // global
           _caMyZ::P64 = P64[Sp + 24];
           _saLU8::I64 = I64[Sp + 40];
           if (%MO_S_Ge_W64(_saLU8::I64,
                            I64[R1 + 7])) goto caMC2; else goto caMCM;
       caMC2: // global
           I64[Sp] = block_caMC0_info;
           R3 = _caMyZ::P64;
           R2 = P64[Sp + 8];
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
       caMCM: // global
           _caMyC::P64 = P64[Sp + 48];
           if (%MO_S_Gt_W64(0, _saLU8::I64)) goto caMCw; else goto caMCL;
       caMCw: // global
           R3 = _caMyZ::P64;
           R2 = _caMyC::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caMCL: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 64])) goto caMCC; else goto caMCK;
       caMCC: // global
           R3 = _caMyZ::P64;
           R2 = _caMyC::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caMCK: // global
           _saLSF::I64 = I64[Sp + 88];
           _saLTt::P64 = P64[Sp + 32];
           _saLUh::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[(_saLTt::P64 + 24) + (_saLU8::I64 << 3)] = _saLUh::P64;
           I64[_saLTt::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLTt::P64 + 24) + ((I64[_saLTt::P64 + 8] << 3) + (_saLU8::I64 >> 7))] = 1 :: W8;
           if (_saLU8::I64 == _saLSF::I64) goto uaMDv; else goto caMCI;
       uaMDv: // global
           P64[Sp + 128] = _caMyC::P64;
           P64[Sp + 120] = _saLTt::P64;
           Sp = Sp + 48;
           call _caMAl() args: 0, res: 0, upd: 0;
       caMCI: // global
           I64[Sp + 40] = _saLU8::I64 + 1;
           Sp = Sp + 32;
           call _caMyX() args: 0, res: 0, upd: 0;
     }
 },
 _caMC0() //  [R1]
         { info_tbl: [(caMC0,
                       label: block_caMC0_info
                       rep:StackRep [False, True, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMC0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMC6; else goto caMC5;
       caMC6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMC5: // global
           _caMyC::P64 = P64[Sp + 48];
           _caMyZ::P64 = P64[Sp + 24];
           _saLU8::I64 = I64[Sp + 40];
           if (%MO_S_Gt_W64(0, _saLU8::I64)) goto caMCa; else goto caMCr;
       caMCa: // global
           Hp = Hp - 40;
           R3 = _caMyZ::P64;
           R2 = _caMyC::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caMCr: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 64])) goto caMCg; else goto caMCq;
       caMCg: // global
           Hp = Hp - 40;
           R3 = _caMyZ::P64;
           R2 = _caMyC::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caMCq: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLSF::I64 = I64[Sp + 88];
           _saLTt::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[(_saLTt::P64 + 24) + (_saLU8::I64 << 3)] = Hp - 6;
           I64[_saLTt::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLTt::P64 + 24) + ((I64[_saLTt::P64 + 8] << 3) + (_saLU8::I64 >> 7))] = 1 :: W8;
           if (_saLU8::I64 == _saLSF::I64) goto uaMDt; else goto caMCo;
       uaMDt: // global
           P64[Sp + 128] = _caMyC::P64;
           P64[Sp + 120] = _saLTt::P64;
           Sp = Sp + 48;
           call _caMAl() args: 0, res: 0, upd: 0;
       caMCo: // global
           I64[Sp + 40] = _saLU8::I64 + 1;
           Sp = Sp + 32;
           call _caMyX() args: 0, res: 0, upd: 0;
     }
 },
 _caMAl() //  []
         { info_tbl: [(caMAl,
                       label: block_caMAl_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMAl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMAp; else goto caMAo;
       caMAp: // global
           HpAlloc = 40;
           I64[Sp] = block_caMAl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caMAo: // global
           _saLSI::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saLSI::I64,
                            I64[Sp + 16])) goto caMAQ; else goto caMAR;
       caMAQ: // global
           Hp = Hp - 40;
           I64[Sp + 56] = _saLSI::I64;
           Sp = Sp + 16;
           call _caMAE() args: 0, res: 0, upd: 0;
       caMAR: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 80];
           P64[Hp - 8] = P64[Sp + 72];
           I64[Hp] = I64[Sp + 24];
           _saLSv::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_saLSv::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSv::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMAE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMAE: // global
           I64[Sp - 8] = block_caMAG_info;
           R5 = I64[Sp + 40];
           R4 = P64[Sp + 56];
           R3 = I64[Sp];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMAG() //  []
         { info_tbl: [(caMAG,
                       label: block_caMAG_info
                       rep:StackRep [True, True, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMAG: // global
           _saLTD::I64 = I64[Sp + 48];
           if (_saLTD::I64 == I64[Sp + 8]) goto uaMDy; else goto caMAN;
       uaMDy: // global
           Sp = Sp + 8;
           call _caMAw() args: 0, res: 0, upd: 0;
       caMAN: // global
           I64[Sp + 48] = _saLTD::I64 + 1;
           Sp = Sp + 8;
           call _caMAE() args: 0, res: 0, upd: 0;
     }
 },
 _caMAw() //  []
         { info_tbl: [(caMAw,
                       label: block_caMAw_info
                       rep:StackRep [True, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMAw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMAA; else goto caMAz;
       caMAA: // global
           HpAlloc = 40;
           I64[Sp] = block_caMAw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caMAz: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 56];
           I64[Hp] = I64[Sp + 8];
           _saLSv::P64 = P64[Sp + 48];
           call MO_WriteBarrier();
           P64[_saLSv::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSv::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.426290104 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged2_entry() //  []
         { info_tbl: [(caME5,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caME5: // global
           call GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.427321489 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() //  []
         { info_tbl: [(caMEf,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMEg; else goto caMEh;
       caMEg: // global
           R1 = GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMEh: // global
           I64[Sp - 8] = block_caMEc_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMEl; else goto caMEd;
       uaMEl: // global
           call _caMEc(R1) args: 0, res: 0, upd: 0;
       caMEd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMEc() //  [R1]
         { info_tbl: [(caMEc,
                       label: block_caMEc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEc: // global
           R3 = GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.428562352 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caMEq,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEq: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.429734314 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager2_closure" {
     GHC.Event.Thread.getSystemEventManager2_closure:
         const GHC.Event.Thread.getSystemEventManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager2_entry() //  [R2, R3, R4]
         { info_tbl: [(caMEy,
                       label: GHC.Event.Thread.getSystemEventManager2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMEC; else goto caMEB;
       caMEC: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.getSystemEventManager2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caMEB: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.431940371 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager1_closure" {
     GHC.Event.Thread.getSystemEventManager1_closure:
         const GHC.Event.Thread.getSystemEventManager1_info;
         const 0;
 },
 sat_saLVn_entry() //  [R1]
         { info_tbl: [(caMFu,
                       label: sat_saLVn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMFu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMFv; else goto caMFw;
       caMFv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMFw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLVo_entry() //  [R1]
         { info_tbl: [(caMFB,
                       label: sat_saLVo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMFB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMFC; else goto caMFD;
       caMFC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMFD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caMFk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaMFK; else goto caMFl;
       uaMFK: // global
           call _caMFk(R1) args: 0, res: 0, upd: 0;
       caMFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caMFk() //  [R1]
         { info_tbl: [(caMFk,
                       label: block_caMFk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMFk: // global
           if (R1 & 7 == 1) goto caMFy; else goto caMFz;
       caMFy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caMFz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caMFJ; else goto caMFI;
       caMFJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caMFI: // global
           _saLVm::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_saLVn_info;
           P64[Hp - 16] = _saLVm::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.getSystemEventManager1_entry() //  []
         { info_tbl: [(caMFL,
                       label: GHC.Event.Thread.getSystemEventManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMFL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caMFM; else goto caMFN;
       caMFM: // global
           R1 = GHC.Event.Thread.getSystemEventManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMFN: // global
           I64[Sp - 8] = block_caMEH_info;
           R1 = CurrentTSO;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMEH() //  [R2]
         { info_tbl: [(caMEH,
                       label: block_caMEH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEH: // global
           I64[Sp - 8] = block_caMEL_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           I64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMG1; else goto caMEM;
       uaMG1: // global
           call _caMEL(R1) args: 0, res: 0, upd: 0;
       caMEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMEL() //  [R1]
         { info_tbl: [(caMEL,
                       label: block_caMEL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEL: // global
           _saLV3::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caMEQ_info;
           R1 = _saLV3::P64;
           if (R1 & 7 != 0) goto uaMG2; else goto caMER;
       uaMG2: // global
           call _caMEQ(R1) args: 0, res: 0, upd: 0;
       caMER: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMEQ() //  [R1]
         { info_tbl: [(caMEQ,
                       label: block_caMEQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEQ: // global
           I64[Sp - 16] = block_caMEV_info;
           _saLV6::P64 = P64[R1 + 15];
           _saLV8::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saLV8::P64;
           P64[Sp] = _saLV6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMG3; else goto caMEW;
       uaMG3: // global
           call _caMEV(R1) args: 0, res: 0, upd: 0;
       caMEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMEV() //  [R1]
         { info_tbl: [(caMEV,
                       label: block_caMEV_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMEV: // global
           I64[Sp - 8] = block_caMF0_info;
           _saLV9::P64 = R1;
           _saLVa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVa::I64;
           P64[Sp + 16] = _saLV9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMG4; else goto caMF1;
       uaMG4: // global
           call _caMF0(R1) args: 0, res: 0, upd: 0;
       caMF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMF0() //  [R1]
         { info_tbl: [(caMF0,
                       label: block_caMF0_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMF0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMFU; else goto caMFT;
       caMFU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMFT: // global
           _saLUX::I64 = I64[Sp + 32];
           _saLV9::P64 = P64[Sp + 24];
           _saLVa::I64 = I64[Sp + 8];
           _saLVb::P64 = R1;
           if (%MO_S_Gt_W64(_saLVa::I64,
                            _saLUX::I64)) goto caMFY; else goto caMG0;
       caMG0: // global
           if (%MO_S_Gt_W64(_saLUX::I64,
                            I64[R1 + 7])) goto caMFY; else goto caMFZ;
       caMFY: // global
           Hp = Hp - 24;
           R4 = _saLUX::I64;
           R3 = _saLV9::P64;
           R2 = _saLVb::P64;
           Sp = Sp + 40;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caMFZ: // global
           I64[Hp - 16] = sat_saLVo_info;
           P64[Hp] = P64[P64[Sp + 16] + ((_saLUX::I64 - _saLVa::I64 << 3) + 24)];
           R1 = Hp - 16;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.437169196 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager_closure" {
     GHC.Event.Thread.getSystemEventManager_closure:
         const GHC.Event.Thread.getSystemEventManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager_entry() //  []
         { info_tbl: [(caMG9,
                       label: GHC.Event.Thread.getSystemEventManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMG9: // global
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.437945964 UTC

[section ""cstring" . lvl16_raLJE_bytes" {
     lvl16_raLJE_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.438691132 UTC

[section ""data" . lvl17_raLJF_closure" {
     lvl17_raLJF_closure:
         const lvl17_raLJF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_raLJF_entry() //  [R1]
         { info_tbl: [(caMGi,
                       label: lvl17_raLJF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMGi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMGj; else goto caMGk;
       caMGj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMGk: // global
           (_caMGf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMGf::I64 == 0) goto caMGh; else goto caMGg;
       caMGh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMGg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMGf::I64;
           R2 = lvl16_raLJE_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.439741126 UTC

[section ""data" . lvl18_raLJG_closure" {
     lvl18_raLJG_closure:
         const lvl18_raLJG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_raLJG_entry() //  [R1]
         { info_tbl: [(caMGr,
                       label: lvl18_raLJG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMGr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMGs; else goto caMGt;
       caMGs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMGt: // global
           (_caMGo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMGo::I64 == 0) goto caMGq; else goto caMGp;
       caMGq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMGp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMGo::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl17_raLJF_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.440864129 UTC

[section ""data" . lvl19_raLJH_closure" {
     lvl19_raLJH_closure:
         const lvl19_raLJH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_raLJH_entry() //  [R1]
         { info_tbl: [(caMGA,
                       label: lvl19_raLJH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMGA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMGB; else goto caMGC;
       caMGB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMGC: // global
           (_caMGx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMGx::I64 == 0) goto caMGz; else goto caMGy;
       caMGz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMGy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMGx::I64;
           R2 = lvl18_raLJG_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.441747634 UTC

[section ""data" . lvl20_raLJI_closure" {
     lvl20_raLJI_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.442324617 UTC

[section ""data" . lvl21_raLJJ_closure" {
     lvl21_raLJJ_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.442927803 UTC

[section ""data" . lvl22_raLJK_closure" {
     lvl22_raLJK_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.443513924 UTC

[section ""cstring" . lvl23_raLJL_bytes" {
     lvl23_raLJL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,56,51,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.444264241 UTC

[section ""data" . lvl24_raLJM_closure" {
     lvl24_raLJM_closure:
         const lvl24_raLJM_info;
         const 0;
 },
 lvl24_raLJM_entry() //  []
         { info_tbl: [(caMGJ,
                       label: lvl24_raLJM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMGJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMGK; else goto caMGL;
       caMGK: // global
           R1 = lvl24_raLJM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMGL: // global
           I64[Sp - 8] = block_caMGH_info;
           R2 = lvl23_raLJL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMGH() //  [R1]
         { info_tbl: [(caMGH,
                       label: block_caMGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMGH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.457267345 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM1_closure" {
     GHC.Event.Thread.threadWaitReadSTM1_closure:
         const GHC.Event.Thread.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saLWA_entry() //  [R1]
         { info_tbl: [(caMIA,
                       label: sat_saLWA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIA: // global
           _saLWA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caMIB; else goto caMIC;
       caMIC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMIE; else goto caMID;
       caMIE: // global
           HpAlloc = 16;
           goto caMIB;
       caMIB: // global
           R1 = _saLWA::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMID: // global
           _saLVB::P64 = P64[_saLWA::P64 + 7];
           _saLWv::P64 = P64[_saLWA::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWv::P64;
           I64[Sp - 8] = block_caMIy_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMIy() //  []
         { info_tbl: [(caMIy,
                       label: block_caMIy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIy: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl31_saLWt_entry() //  [R1, R2, R3]
         { info_tbl: [(caMIG,
                       label: lvl31_saLWt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMIK; else goto caMIJ;
       caMIK: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMIJ: // global
           _saLVB::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_saLWA_info;
           P64[Hp - 8] = _saLVB::P64;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saLXa_entry() //  [R1, R2]
         { info_tbl: [(caMJQ,
                       label: $wgo_saLXa_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMJR; else goto caMJS;
       caMJR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMJS: // global
           I64[Sp - 24] = block_caMJJ_info;
           _saLXa::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saLWa::I64;
           P64[Sp - 8] = _saLXa::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaMKf; else goto caMJK;
       uaMKf: // global
           call _caMJJ(R1) args: 0, res: 0, upd: 0;
       caMJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMJJ() //  [R1]
         { info_tbl: [(caMJJ,
                       label: block_caMJJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJJ: // global
           if (R1 & 7 == 1) goto caMJN; else goto caMJO;
       caMJN: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMJO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMK0; else goto caMJZ;
       caMK0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMJZ: // global
           _saLXe::P64 = P64[R1 + 6];
           _saLXf::P64 = P64[R1 + 14];
           _saLXd::I64 = I64[R1 + 22];
           if (_saLXd::I64 == I64[Sp + 8]) goto caMKe; else goto caMK8;
       caMKe: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLXe::P64;
           R3 = _saLXf::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMK8: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMK4_info;
           R2 = _saLXf::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saLXe::P64;
           I64[Sp + 16] = _saLXd::I64;
           call $wgo_saLXa_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMK4() //  [R1, R2, R3]
         { info_tbl: [(caMK4,
                       label: block_caMK4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMK4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMKb; else goto caMKa;
       caMKb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caMKa: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saLXZ_entry() //  [R1, R2]
         { info_tbl: [(caML0,
                       label: $wgo_saLXZ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caML0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caML1; else goto caML2;
       caML1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caML2: // global
           I64[Sp - 24] = block_caMKT_info;
           _saLXZ::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saLWa::I64;
           P64[Sp - 8] = _saLXZ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaMLp; else goto caMKU;
       uaMLp: // global
           call _caMKT(R1) args: 0, res: 0, upd: 0;
       caMKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMKT() //  [R1]
         { info_tbl: [(caMKT,
                       label: block_caMKT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKT: // global
           if (R1 & 7 == 1) goto caMKX; else goto caMKY;
       caMKX: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMKY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMLa; else goto caML9;
       caMLa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caML9: // global
           _saLY3::P64 = P64[R1 + 6];
           _saLY4::P64 = P64[R1 + 14];
           _saLY2::I64 = I64[R1 + 22];
           if (_saLY2::I64 == I64[Sp + 8]) goto caMLo; else goto caMLi;
       caMLo: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLY3::P64;
           R3 = _saLY4::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMLi: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMLe_info;
           R2 = _saLY4::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saLY3::P64;
           I64[Sp + 16] = _saLY2::I64;
           call $wgo_saLXZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMLe() //  [R1, R2, R3]
         { info_tbl: [(caMLe,
                       label: block_caMLe_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMLe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMLl; else goto caMLk;
       caMLl: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caMLk: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saLWq_entry() //  [R1, R2]
         { info_tbl: [(caMLu,
                       label: $wio_saLWq_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMLu: // global
           _saLWr::P64 = R2;
           _saLWq::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caMLv; else goto caMLw;
       caMLw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caMLy; else goto caMLx;
       caMLy: // global
           HpAlloc = 80;
           goto caMLv;
       caMLv: // global
           R2 = _saLWr::P64;
           R1 = _saLWq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMLx: // global
           _saLVB::P64 = P64[_saLWq::P64 + 6];
           _saLW1::P64 = P64[_saLWq::P64 + 14];
           _saLW3::P64 = P64[_saLWq::P64 + 22];
           _saLW4::P64 = P64[_saLWq::P64 + 30];
           _saLW9::P64 = P64[_saLWq::P64 + 38];
           _saLW8::I64 = I64[_saLWq::P64 + 46];
           _saLWa::I64 = I64[_saLWq::P64 + 54];
           _saLWc::I64 = I64[_saLWq::P64 + 62];
           I64[Hp - 72] = lvl31_saLWt_info;
           P64[Hp - 64] = _saLVB::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saLWa::I64;
           I64[Hp - 32] = _saLW8::I64;
           I64[Hp - 24] = _saLWc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caMIa_info;
           R5 = _saLWr::P64;
           R4 = Hp - 14;
           R3 = _saLWa::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saLW1::P64;
           P64[Sp - 48] = _saLW3::P64;
           P64[Sp - 40] = _saLW4::P64;
           P64[Sp - 32] = _saLW9::P64;
           I64[Sp - 24] = _saLWa::I64;
           I64[Sp - 16] = _saLWc::I64;
           P64[Sp - 8] = _saLWr::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMIa() //  [R1]
         { info_tbl: [(caMIa,
                       label: block_caMIa_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIa: // global
           I64[Sp - 8] = block_caMIe_info;
           _saLWF::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMNS; else goto caMIf;
       uaMNS: // global
           call _caMIe(R1) args: 0, res: 0, upd: 0;
       caMIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMIe() //  [R1]
         { info_tbl: [(caMIe,
                       label: block_caMIe_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIe: // global
           if (R1 & 7 == 1) goto caMLr; else goto caMLs;
       caMLr: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saLWG() args: 0, res: 0, upd: 0;
       caMLs: // global
           I64[Sp] = block_caMIk_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMIk() //  [R1]
         { info_tbl: [(caMIk,
                       label: block_caMIk_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMNr; else goto caMNq;
       caMNr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMNq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saLWG() args: 0, res: 0, upd: 0;
     }
 },
 _saLWG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLWG: // global
           _saLWI::P64 = P64[Sp];
           I64[Sp] = block_caMIO_info;
           R1 = _saLWI::P64;
           if (R1 & 7 != 0) goto uaMOd; else goto caMIP;
       uaMOd: // global
           call _caMIO(R1) args: 0, res: 0, upd: 0;
       caMIP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMIO() //  [R1]
         { info_tbl: [(caMIO,
                       label: block_caMIO_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIO: // global
           _saLWL::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saLWM::I64 = _saLWL::I64 & 8;
           if (_saLWM::I64 != 0) goto uaMNL; else goto uaMNK;
       uaMNL: // global
           I64[Sp] = _saLWM::I64;
           I64[Sp + 40] = _saLWL::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caMJ0() args: 0, res: 0, upd: 0;
       uaMNK: // global
           I64[Sp + 32] = _saLWM::I64;
           I64[Sp + 64] = _saLWL::I64;
           Sp = Sp + 16;
           call _caMKi() args: 0, res: 0, upd: 0;
     }
 },
 _caMJ0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJ0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMLG; else goto caMLF;
       caMLG: // global
           HpAlloc = 32;
           _saLWM::I64 = I64[Sp];
           I64[Sp] = block_caMIZ_info;
           R1 = _saLWM::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMLF: // global
           _saLWL::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saLWL::I64) goto caMLI; else goto caMLJ;
       caMLI: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMLJ: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saLWL::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caMJe_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caMIZ() //  [R1]
         { info_tbl: [(caMIZ,
                       label: block_caMIZ_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMIZ: // global
           I64[Sp] = R1;
           call _caMJ0() args: 0, res: 0, upd: 0;
     }
 },
 _caMJe() //  [R1]
         { info_tbl: [(caMJe,
                       label: block_caMJe_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJe: // global
           I64[Sp] = block_caMJg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMNY; else goto caMJh;
       uaMNY: // global
           call _caMJg(R1) args: 0, res: 0, upd: 0;
       caMJh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMJg() //  [R1]
         { info_tbl: [(caMJg,
                       label: block_caMJg_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJg: // global
           if (R1 & 7 == 1) goto caMLN; else goto caMMv;
       caMLN: // global
           I64[Sp + 40] = block_caMJl_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaMNZ; else goto caMJm;
       uaMNZ: // global
           call _caMJl(R1) args: 0, res: 0, upd: 0;
       caMJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMMv: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMJl() //  [R1]
         { info_tbl: [(caMJl,
                       label: block_caMJl_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJl: // global
           _saLWr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caMLQ; else goto caMMp;
       caMLQ: // global
           I64[Sp] = block_caMJq_info;
           R1 = P64[_saLWr::P64 + 8];
           if (R1 & 7 != 0) goto uaMO0; else goto caMJr;
       uaMO0: // global
           call _caMJq(R1) args: 0, res: 0, upd: 0;
       caMJr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMMp: // global
           I64[Sp + 24] = block_caMMn_info;
           R5 = _saLWr::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMJq() //  [R1]
         { info_tbl: [(caMJq,
                       label: block_caMJq_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMJq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMLT; else goto caMLS;
       caMLT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMLS: // global
           _saLWa::I64 = I64[Sp + 8];
           _saLX1::P64 = P64[R1 + 7];
           _saLX3::P64 = P64[R1 + 15];
           _saLX2::I64 = I64[R1 + 23];
           _saLX4::I64 = _saLWa::I64 & (I64[_saLX1::P64 + 8] - 1);
           _saLX9::P64 = P64[(_saLX1::P64 + 24) + (_saLX4::I64 << 3)];
           I64[Hp - 8] = $wgo_saLXa_info;
           I64[Hp] = _saLWa::I64;
           I64[Sp - 8] = block_caMLU_info;
           R2 = _saLX9::P64;
           R1 = Hp - 7;
           I64[Sp] = _saLX4::I64;
           P64[Sp + 8] = _saLX3::P64;
           I64[Sp + 16] = _saLX2::I64;
           P64[Sp + 24] = _saLX1::P64;
           Sp = Sp - 8;
           call $wgo_saLXa_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMLU() //  [R1, R2, R3]
         { info_tbl: [(caMLU,
                       label: block_caMLU_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMLU: // global
           I64[Sp - 16] = block_caMLW_info;
           _saLXo::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saLXo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMO5; else goto caMLY;
       uaMO5: // global
           call _caMLW(R1) args: 0, res: 0, upd: 0;
       caMLY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMLW() //  [R1]
         { info_tbl: [(caMLW,
                       label: block_caMLW_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMLW: // global
           if (R1 & 7 == 1) goto uaMNN; else goto caMM9;
       uaMNN: // global
           Sp = Sp + 56;
           call _caMN6() args: 0, res: 0, upd: 0;
       caMM9: // global
           _saLX1::P64 = P64[Sp + 48];
           _saLX4::I64 = I64[Sp + 24];
           _saLXo::P64 = P64[Sp + 16];
           _saLXq::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saLX1::P64 + 24) + (_saLX4::I64 << 3)] = _saLXq::P64;
           I64[_saLX1::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLX1::P64 + 24) + ((I64[_saLX1::P64 + 8] << 3) + (_saLX4::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caMM7_info;
           R1 = _saLXo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaMO6; else goto caMMa;
       uaMO6: // global
           call _caMM7(R1) args: 0, res: 0, upd: 0;
       caMMa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMM7() //  [R1]
         { info_tbl: [(caMM7,
                       label: block_caMM7_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMM7: // global
           if (R1 & 7 == 1) goto uaMNO; else goto caMMk;
       uaMNO: // global
           Sp = Sp + 32;
           call _caMN6() args: 0, res: 0, upd: 0;
       caMMk: // global
           _saLX2::I64 = I64[Sp + 16];
           _saLX3::P64 = P64[Sp + 8];
           I64[_saLX2::I64] = I64[_saLX2::I64] - 1;
           call MO_Touch(_saLX3::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMMn() //  []
         { info_tbl: [(caMMn,
                       label: block_caMMn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMMn: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMKi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMMz; else goto caMMy;
       caMMz: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caMKh_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMMy: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caMKo_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMKh() //  [R1]
         { info_tbl: [(caMKh,
                       label: block_caMKh_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKh: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caMKi() args: 0, res: 0, upd: 0;
     }
 },
 _caMKo() //  [R1]
         { info_tbl: [(caMKo,
                       label: block_caMKo_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKo: // global
           I64[Sp] = block_caMKq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMO2; else goto caMKr;
       uaMO2: // global
           call _caMKq(R1) args: 0, res: 0, upd: 0;
       caMKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMKq() //  [R1]
         { info_tbl: [(caMKq,
                       label: block_caMKq_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKq: // global
           if (R1 & 7 == 1) goto caMMD; else goto caMNl;
       caMMD: // global
           I64[Sp + 40] = block_caMKv_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaMO3; else goto caMKw;
       uaMO3: // global
           call _caMKv(R1) args: 0, res: 0, upd: 0;
       caMKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMNl: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMKv() //  [R1]
         { info_tbl: [(caMKv,
                       label: block_caMKv_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKv: // global
           _saLWr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caMMG; else goto caMNf;
       caMMG: // global
           I64[Sp] = block_caMKA_info;
           R1 = P64[_saLWr::P64 + 8];
           if (R1 & 7 != 0) goto uaMO4; else goto caMKB;
       uaMO4: // global
           call _caMKA(R1) args: 0, res: 0, upd: 0;
       caMKB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caMNf: // global
           I64[Sp + 24] = block_caMNd_info;
           R5 = _saLWr::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMKA() //  [R1]
         { info_tbl: [(caMKA,
                       label: block_caMKA_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMKA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMMJ; else goto caMMI;
       caMMJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMMI: // global
           _saLWa::I64 = I64[Sp + 8];
           _saLXQ::P64 = P64[R1 + 7];
           _saLXS::P64 = P64[R1 + 15];
           _saLXR::I64 = I64[R1 + 23];
           _saLXT::I64 = _saLWa::I64 & (I64[_saLXQ::P64 + 8] - 1);
           _saLXY::P64 = P64[(_saLXQ::P64 + 24) + (_saLXT::I64 << 3)];
           I64[Hp - 8] = $wgo_saLXZ_info;
           I64[Hp] = _saLWa::I64;
           I64[Sp - 8] = block_caMMK_info;
           R2 = _saLXY::P64;
           R1 = Hp - 7;
           I64[Sp] = _saLXT::I64;
           P64[Sp + 8] = _saLXS::P64;
           I64[Sp + 16] = _saLXR::I64;
           P64[Sp + 24] = _saLXQ::P64;
           Sp = Sp - 8;
           call $wgo_saLXZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMMK() //  [R1, R2, R3]
         { info_tbl: [(caMMK,
                       label: block_caMMK_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMMK: // global
           I64[Sp - 16] = block_caMMM_info;
           _saLYd::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saLYd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMO9; else goto caMMO;
       uaMO9: // global
           call _caMMM(R1) args: 0, res: 0, upd: 0;
       caMMO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMMM() //  [R1]
         { info_tbl: [(caMMM,
                       label: block_caMMM_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMMM: // global
           if (R1 & 7 == 1) goto uaMNQ; else goto caMMZ;
       uaMNQ: // global
           Sp = Sp + 56;
           call _caMN6() args: 0, res: 0, upd: 0;
       caMMZ: // global
           _saLXQ::P64 = P64[Sp + 48];
           _saLXT::I64 = I64[Sp + 24];
           _saLYd::P64 = P64[Sp + 16];
           _saLYf::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saLXQ::P64 + 24) + (_saLXT::I64 << 3)] = _saLYf::P64;
           I64[_saLXQ::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLXQ::P64 + 24) + ((I64[_saLXQ::P64 + 8] << 3) + (_saLXT::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caMMX_info;
           R1 = _saLYd::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaMOa; else goto caMN0;
       uaMOa: // global
           call _caMMX(R1) args: 0, res: 0, upd: 0;
       caMN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMMX() //  [R1]
         { info_tbl: [(caMMX,
                       label: block_caMMX_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMMX: // global
           if (R1 & 7 == 1) goto uaMNR; else goto caMNa;
       uaMNR: // global
           Sp = Sp + 32;
           call _caMN6() args: 0, res: 0, upd: 0;
       caMNa: // global
           _saLXR::I64 = I64[Sp + 16];
           _saLXS::P64 = P64[Sp + 8];
           I64[_saLXR::I64] = I64[_saLXR::I64] - 1;
           call MO_Touch(_saLXS::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMN6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMN6: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMNd() //  []
         { info_tbl: [(caMNd,
                       label: block_caMNd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMNd: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saLYy_entry() //  [R1, R2]
         { info_tbl: [(caMOm,
                       label: io1_saLYy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMOn; else goto caMOo;
       caMOn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMOo: // global
           I64[Sp - 16] = block_caMOj_info;
           _saLWq::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLWq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMOs; else goto caMOk;
       uaMOs: // global
           call _caMOj(R1) args: 0, res: 0, upd: 0;
       caMOk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMOj() //  [R1]
         { info_tbl: [(caMOj,
                       label: block_caMOj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOj: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saLWq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLYU_entry() //  [R1]
         { info_tbl: [(caMOF,
                       label: sat_saLYU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMOG; else goto caMOH;
       caMOG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMOH: // global
           I64[Sp - 8] = block_caMOD_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMOD() //  []
         { info_tbl: [(caMOD,
                       label: block_caMOD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOD: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLYP_entry() //  [R1]
         { info_tbl: [(caMOX,
                       label: sat_saLYP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMOY; else goto caMOZ;
       caMOY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMOZ: // global
           I64[Sp - 8] = block_caMOO_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMOO() //  [R1]
         { info_tbl: [(caMOO,
                       label: block_caMOO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOO: // global
           I64[Sp] = block_caMOQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMPs; else goto caMOR;
       uaMPs: // global
           call _caMOQ(R1) args: 0, res: 0, upd: 0;
       caMOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMOQ() //  [R1]
         { info_tbl: [(caMOQ,
                       label: block_caMOQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOQ: // global
           if (R1 & 7 == 1) goto caMOU; else goto caMOV;
       caMOU: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caMOV: // global
           I64[Sp] = block_caMP6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaMPt; else goto caMP8;
       uaMPt: // global
           call _caMP6(R1) args: 0, res: 0, upd: 0;
       caMP8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMP6() //  [R1]
         { info_tbl: [(caMP6,
                       label: block_caMP6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMP6: // global
           if (I64[R1 + 7] & 4 == 0) goto caMPo; else goto caMPi;
       caMPo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caMPi: // global
           R1 = lvl19_raLJH_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ5_entry() //  [R1, R2]
         { info_tbl: [(caMPF,
                       label: sat_saLZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMPF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMPG; else goto caMPH;
       caMPG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMPH: // global
           I64[Sp - 16] = block_caMPD_info;
           _saLZ2::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saLZ2::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMPD() //  []
         { info_tbl: [(caMPD,
                       label: block_caMPD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMPD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ0_entry() //  [R1]
         { info_tbl: [(caMPO,
                       label: sat_saLZ0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMPO: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ1_entry() //  [R1]
         { info_tbl: [(caMPW,
                       label: sat_saLZ1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMPW: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZh_entry() //  [R1]
         { info_tbl: [(caMQl,
                       label: sat_saLZh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQl: // global
           _saLZh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caMQm; else goto caMQn;
       caMQn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMQp; else goto caMQo;
       caMQp: // global
           HpAlloc = 16;
           goto caMQm;
       caMQm: // global
           R1 = _saLZh::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMQo: // global
           _saLVB::P64 = P64[_saLZh::P64 + 7];
           _saLWb::P64 = P64[_saLZh::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caMQj_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMQj() //  []
         { info_tbl: [(caMQj,
                       label: block_caMQj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZy_entry() //  [R1, R2]
         { info_tbl: [(caMQG,
                       label: sat_saLZy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMQH; else goto caMQI;
       caMQH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMQI: // global
           I64[Sp - 16] = block_caMQE_info;
           _saLZv::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saLZv::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMQE() //  []
         { info_tbl: [(caMQE,
                       label: block_caMQE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZt_entry() //  [R1]
         { info_tbl: [(caMQP,
                       label: sat_saLZt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQP: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZu_entry() //  [R1]
         { info_tbl: [(caMQX,
                       label: sat_saLZu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQX: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZD_entry() //  [R1]
         { info_tbl: [(caMR4,
                       label: sat_saLZD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMR4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMR5; else goto caMR6;
       caMR5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMR6: // global
           I64[Sp - 24] = block_caMQx_info;
           _saLWp::P64 = P64[R1 + 7];
           _saLYy::P64 = P64[R1 + 15];
           R1 = _saLWp::P64;
           P64[Sp - 16] = _saLWp::P64;
           P64[Sp - 8] = _saLYy::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMQx() //  [R1]
         { info_tbl: [(caMQx,
                       label: block_caMQx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caMR9; else goto caMR8;
       caMR9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMR8: // global
           I64[Hp - 56] = sat_saLZy_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZt_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saLZu_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caMR0_info;
           R2 = Hp - 54;
           _saLZs::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saLZs::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMR0() //  [R1]
         { info_tbl: [(caMR0,
                       label: block_caMR0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMR0: // global
           _saLWp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caMR2_info;
           R2 = P64[Sp + 16];
           _saLZB::P64 = R1;
           R1 = _saLWp::P64;
           P64[Sp + 16] = _saLZB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMR2() //  []
         { info_tbl: [(caMR2,
                       label: block_caMR2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMR2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZO_entry() //  [R1]
         { info_tbl: [(caMRw,
                       label: sat_saLZO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRw: // global
           _saLZO::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caMRx; else goto caMRy;
       caMRy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMRA; else goto caMRz;
       caMRA: // global
           HpAlloc = 16;
           goto caMRx;
       caMRx: // global
           R1 = _saLZO::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMRz: // global
           _saLVB::P64 = P64[_saLZO::P64 + 7];
           _saLWb::P64 = P64[_saLZO::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caMRu_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMRu() //  []
         { info_tbl: [(caMRu,
                       label: block_caMRu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRu: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM04_entry() //  [R1, R2]
         { info_tbl: [(caMRM,
                       label: sat_saM04_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMRN; else goto caMRO;
       caMRN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMRO: // global
           I64[Sp - 16] = block_caMRK_info;
           _saM01::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM01::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMRK() //  []
         { info_tbl: [(caMRK,
                       label: block_caMRK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZZ_entry() //  [R1]
         { info_tbl: [(caMRV,
                       label: sat_saLZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRV: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM00_entry() //  [R1]
         { info_tbl: [(caMS3,
                       label: sat_saM00_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMS3: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM0g_entry() //  [R1]
         { info_tbl: [(caMSs,
                       label: sat_saM0g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMSs: // global
           _saM0g::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caMSt; else goto caMSu;
       caMSu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMSw; else goto caMSv;
       caMSw: // global
           HpAlloc = 16;
           goto caMSt;
       caMSt: // global
           R1 = _saM0g::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMSv: // global
           _saLVB::P64 = P64[_saM0g::P64 + 7];
           _saLWb::P64 = P64[_saM0g::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caMSq_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMSq() //  []
         { info_tbl: [(caMSq,
                       label: block_caMSq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMSq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saLVx_entry() //  [R1]
         { info_tbl: [(caMSC,
                       label: io_saLVx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMSC: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caMSD; else goto caMSE;
       caMSD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caMSE: // global
           I64[Sp - 24] = block_caMH0_info;
           _saLVr::P64 = P64[R1 + 7];
           _saLVs::P64 = P64[R1 + 15];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _saLVr::P64;
           P64[Sp - 8] = _saLVs::P64;
           Sp = Sp - 24;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMH0() //  [R1]
         { info_tbl: [(caMH0,
                       label: block_caMH0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMH0: // global
           I64[Sp - 8] = block_caMH2_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caMH2() //  [R1]
         { info_tbl: [(caMH2,
                       label: block_caMH2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMH2: // global
           I64[Sp] = block_caMH4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMUZ; else goto caMH5;
       uaMUZ: // global
           call _caMH4(R1) args: 0, res: 0, upd: 0;
       caMH5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMH4() //  [R1]
         { info_tbl: [(caMH4,
                       label: block_caMH4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMH4: // global
           if (R1 & 7 == 1) goto caMSz; else goto caMSA;
       caMSz: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caMSA: // global
           I64[Sp] = block_caMHa_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaMV0; else goto caMHb;
       uaMV0: // global
           call _caMHa(R1) args: 0, res: 0, upd: 0;
       caMHb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHa() //  [R1]
         { info_tbl: [(caMHa,
                       label: block_caMHa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHa: // global
           I64[Sp - 40] = block_caMHf_info;
           _saLVI::P64 = R1;
           _saLVJ::P64 = P64[R1 + 7];
           _saLVL::P64 = P64[R1 + 23];
           _saLVN::P64 = P64[R1 + 31];
           _saLVP::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saLVJ::P64;
           P64[Sp - 24] = _saLVL::P64;
           P64[Sp - 16] = _saLVN::P64;
           P64[Sp - 8] = _saLVP::P64;
           P64[Sp] = _saLVI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaMV1; else goto caMHg;
       uaMV1: // global
           call _caMHf(R1) args: 0, res: 0, upd: 0;
       caMHg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHf() //  [R1]
         { info_tbl: [(caMHf,
                       label: block_caMHf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHf: // global
           I64[Sp - 8] = block_caMHk_info;
           _saLVW::P64 = R1;
           _saLVX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVX::I64;
           P64[Sp + 16] = _saLVW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMV2; else goto caMHl;
       uaMV2: // global
           call _caMHk(R1) args: 0, res: 0, upd: 0;
       caMHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHk() //  [R1]
         { info_tbl: [(caMHk,
                       label: block_caMHk_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHk: // global
           I64[Sp - 8] = block_caMHp_info;
           _saLVY::P64 = R1;
           _saLVZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVZ::I64;
           P64[Sp + 16] = _saLVY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMV3; else goto caMHq;
       uaMV3: // global
           call _caMHp(R1) args: 0, res: 0, upd: 0;
       caMHq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHp() //  [R1]
         { info_tbl: [(caMHp,
                       label: block_caMHp_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHp: // global
           _saLVs::P64 = P64[Sp + 80];
           _saLW1::P64 = P64[R1 + 7];
           _saLW3::P64 = P64[R1 + 23];
           _saLW4::P64 = P64[R1 + 31];
           (_saLW8::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caMHw_info;
           R1 = _saLVs::P64;
           I64[Sp - 8] = _saLW8::I64;
           P64[Sp] = _saLW4::P64;
           P64[Sp + 48] = _saLW3::P64;
           P64[Sp + 80] = _saLW1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaMV4; else goto caMHx;
       uaMV4: // global
           call _caMHw(R1) args: 0, res: 0, upd: 0;
       caMHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHw() //  [R1]
         { info_tbl: [(caMHw,
                       label: block_caMHw_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHw: // global
           I64[Sp - 8] = block_caMHB_info;
           _saLW9::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saLWa::I64;
           P64[Sp + 88] = _saLW9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMV5; else goto caMHC;
       uaMV5: // global
           call _caMHB(R1) args: 0, res: 0, upd: 0;
       caMHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHB() //  [R1]
         { info_tbl: [(caMHB,
                       label: block_caMHB_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHB: // global
           I64[Sp - 16] = block_caMHG_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMHG() //  [R1]
         { info_tbl: [(caMHG,
                       label: block_caMHG_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHG: // global
           _saLVW::P64 = P64[Sp + 72];
           _saLVX::I64 = I64[Sp + 56];
           _saLVY::P64 = P64[Sp + 64];
           _saLWg::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saLVX::I64,
                            _saLWg::I64)) goto caMSU; else goto caMUH;
       caMUH: // global
           if (%MO_S_Gt_W64(_saLWg::I64,
                            I64[Sp + 48])) goto caMSU; else goto caMSV;
       caMSU: // global
           R4 = _saLWg::I64;
           R3 = _saLVW::P64;
           R2 = _saLVY::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caMSV: // global
           _saLWn::P64 = P64[P64[Sp + 80] + ((_saLWg::I64 - _saLVX::I64 << 3) + 24)];
           I64[Sp] = block_caMHW_info;
           _saLWf::I64 = R1;
           R1 = _saLWn::P64;
           I64[Sp + 80] = _saLWf::I64;
           if (R1 & 7 != 0) goto uaMV6; else goto caMHX;
       uaMV6: // global
           call _caMHW(R1) args: 0, res: 0, upd: 0;
       caMHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMHW() //  [R1]
         { info_tbl: [(caMHW,
                       label: block_caMHW_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMHW: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caMSY; else goto caMSX;
       caMSY: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMSX: // global
           _saLWp::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saLWq_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saLYy_info;
           P64[Hp - 24] = Hp - 102;
           _caMOe::P64 = Hp - 30;
           _saLYW::I64 = I64[Sp + 80];
           if (_saLYW::I64 != 0) goto uaMUR; else goto caMTD;
       uaMUR: // global
           if (_saLYW::I64 != 1) goto caMT4; else goto caMU8;
       caMT4: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caMPw_info;
           R1 = _saLWp::P64;
           P64[Sp + 112] = _saLWp::P64;
           P64[Sp + 120] = _caMOe::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caMU8: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caMRD_info;
           R1 = _saLWp::P64;
           P64[Sp + 112] = _saLWp::P64;
           P64[Sp + 120] = _caMOe::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caMTD: // global
           I64[Hp - 16] = sat_saLZD_info;
           P64[Hp - 8] = _saLWp::P64;
           P64[Hp] = _caMOe::P64;
           I64[Sp + 8] = block_caMRc_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMPw() //  [R1]
         { info_tbl: [(caMPw,
                       label: block_caMPw_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMPw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caMT7; else goto caMT6;
       caMT7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMT6: // global
           I64[Hp - 56] = sat_saLZ5_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZ0_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saLZ1_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caMPZ_info;
           R2 = Hp - 54;
           _saLYZ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saLYZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMPZ() //  [R1]
         { info_tbl: [(caMPZ,
                       label: block_caMPZ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMPZ: // global
           I64[Sp] = block_caMQ1_info;
           R2 = P64[Sp + 112];
           _saLZ8::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saLZ8::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMQ1() //  []
         { info_tbl: [(caMQ1,
                       label: block_caMQ1_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQ1: // global
           I64[Sp] = block_caMQ3_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaMV8; else goto caMQ4;
       uaMV8: // global
           call _caMQ3(R1) args: 0, res: 0, upd: 0;
       caMQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMQ3() //  [R1]
         { info_tbl: [(caMQ3,
                       label: block_caMQ3_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQ3: // global
           I64[Sp] = block_caMQ8_info;
           _saLZb::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saLZb::P64;
           if (R1 & 7 != 0) goto uaMV9; else goto caMQ9;
       uaMV9: // global
           call _caMQ8(R1) args: 0, res: 0, upd: 0;
       caMQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMQ8() //  [R1]
         { info_tbl: [(caMQ8,
                       label: block_caMQ8_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQ8: // global
           if (R1 & 7 == 1) goto caMTf; else goto caMTv;
       caMTf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMTi; else goto caMTh;
       caMTi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMTh: // global
           I64[Hp - 16] = sat_saLZh_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caMTb_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caMTv: // global
           I64[Sp + 8] = block_caMTt_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaMVa; else goto caMTw;
       uaMVa: // global
           call _caMTt(R1) args: 0, res: 0, upd: 0;
       caMTw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMTb() //  []
         { info_tbl: [(caMTb,
                       label: block_caMTb_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMTb: // global
           I64[Sp] = block_caMTd_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaMVh; else goto caMTk;
       uaMVh: // global
           call _caMTd(R1) args: 0, res: 0, upd: 0;
       caMTk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMTd() //  [R1]
         { info_tbl: [(caMTd,
                       label: block_caMTd_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMTd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMTq; else goto caMTp;
       caMTq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMTp: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 _caMTt() //  [R1]
         { info_tbl: [(caMTt,
                       label: block_caMTt_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMTt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMTC; else goto caMTB;
       caMTC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMTB: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 _caMRD() //  [R1]
         { info_tbl: [(caMRD,
                       label: block_caMRD_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caMUb; else goto caMUa;
       caMUb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMUa: // global
           I64[Hp - 56] = sat_saM04_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZZ_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM00_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caMS6_info;
           R2 = Hp - 54;
           _saLZY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saLZY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMS6() //  [R1]
         { info_tbl: [(caMS6,
                       label: block_caMS6_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMS6: // global
           I64[Sp] = block_caMS8_info;
           R2 = P64[Sp + 112];
           _saM07::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM07::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMS8() //  []
         { info_tbl: [(caMS8,
                       label: block_caMS8_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMS8: // global
           I64[Sp] = block_caMSa_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaMVe; else goto caMSb;
       uaMVe: // global
           call _caMSa(R1) args: 0, res: 0, upd: 0;
       caMSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMSa() //  [R1]
         { info_tbl: [(caMSa,
                       label: block_caMSa_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMSa: // global
           I64[Sp] = block_caMSf_info;
           _saM0a::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM0a::P64;
           if (R1 & 7 != 0) goto uaMVf; else goto caMSg;
       uaMVf: // global
           call _caMSf(R1) args: 0, res: 0, upd: 0;
       caMSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMSf() //  [R1]
         { info_tbl: [(caMSf,
                       label: block_caMSf_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMSf: // global
           if (R1 & 7 == 1) goto caMUj; else goto caMUz;
       caMUj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMUm; else goto caMUl;
       caMUm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMUl: // global
           I64[Hp - 16] = sat_saM0g_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caMUf_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caMUz: // global
           I64[Sp + 8] = block_caMUx_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaMVg; else goto caMUA;
       uaMVg: // global
           call _caMUx(R1) args: 0, res: 0, upd: 0;
       caMUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMUf() //  []
         { info_tbl: [(caMUf,
                       label: block_caMUf_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMUf: // global
           I64[Sp] = block_caMUh_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaMVn; else goto caMUo;
       uaMVn: // global
           call _caMUh(R1) args: 0, res: 0, upd: 0;
       caMUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMUh() //  [R1]
         { info_tbl: [(caMUh,
                       label: block_caMUh_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMUh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMUu; else goto caMUt;
       caMUu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMUt: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 _caMUx() //  [R1]
         { info_tbl: [(caMUx,
                       label: block_caMUx_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMUx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMUG; else goto caMUF;
       caMUG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMUF: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 _caMRc() //  [R1]
         { info_tbl: [(caMRc,
                       label: block_caMRc_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRc: // global
           I64[Sp] = block_caMRe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaMVb; else goto caMRf;
       uaMVb: // global
           call _caMRe(R1) args: 0, res: 0, upd: 0;
       caMRf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMRe() //  [R1]
         { info_tbl: [(caMRe,
                       label: block_caMRe_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRe: // global
           I64[Sp] = block_caMRj_info;
           _saLZI::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saLZI::P64;
           if (R1 & 7 != 0) goto uaMVc; else goto caMRk;
       uaMVc: // global
           call _caMRj(R1) args: 0, res: 0, upd: 0;
       caMRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMRj() //  [R1]
         { info_tbl: [(caMRj,
                       label: block_caMRj_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMRj: // global
           if (R1 & 7 == 1) goto caMTK; else goto caMU0;
       caMTK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMTN; else goto caMTM;
       caMTN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMTM: // global
           I64[Hp - 16] = sat_saLZO_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caMTG_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caMU0: // global
           I64[Sp + 8] = block_caMTY_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaMVd; else goto caMU1;
       uaMVd: // global
           call _caMTY(R1) args: 0, res: 0, upd: 0;
       caMU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMTG() //  []
         { info_tbl: [(caMTG,
                       label: block_caMTG_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMTG: // global
           I64[Sp] = block_caMTI_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaMVk; else goto caMTP;
       uaMVk: // global
           call _caMTI(R1) args: 0, res: 0, upd: 0;
       caMTP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMTI() //  [R1]
         { info_tbl: [(caMTI,
                       label: block_caMTI_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMTI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMTV; else goto caMTU;
       caMTV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMTU: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 _caMTY() //  [R1]
         { info_tbl: [(caMTY,
                       label: block_caMTY_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMTY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMU7; else goto caMU6;
       caMU7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMU6: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 _caMOw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOw: // global
           Hp = Hp + 64;
           _saLYF::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caMT2; else goto caMT1;
       caMT2: // global
           HpAlloc = 64;
           I64[Sp - 8] = block_caMOv_info;
           R1 = _saLYF::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMT1: // global
           I64[Hp - 56] = sat_saLYU_info;
           P64[Hp - 48] = P64[Sp];
           P64[Hp - 40] = _saLYF::P64;
           I64[Hp - 32] = sat_saLYP_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMOv() //  [R1]
         { info_tbl: [(caMOv,
                       label: block_caMOv_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMOv: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caMOw() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.threadWaitReadSTM1_entry() //  [R2, R3]
         { info_tbl: [(caMVu,
                       label: GHC.Event.Thread.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMVu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMVv; else goto caMVw;
       caMVv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMVw: // global
           I64[Sp - 24] = block_caMGT_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMGT() //  [R1]
         { info_tbl: [(caMGT,
                       label: block_caMGT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMGT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caMVz; else goto caMVy;
       caMVz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caMVy: // global
           I64[Hp - 16] = io_saLVx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caMGV::P64 = Hp - 15;
           if (R1 == 0) goto caMVt; else goto caMVs;
       caMVt: // global
           R1 = _caMGV::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caMVs: // global
           R1 = _caMGV::P64;
           Sp = Sp + 24;
           call io_saLVx_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.483854296 UTC

[section ""data" . threadWaitReadSTM2_raLJN_closure" {
     threadWaitReadSTM2_raLJN_closure:
         const threadWaitReadSTM2_raLJN_info;
         const 0;
 },
 threadWaitReadSTM2_raLJN_entry() //  [R2]
         { info_tbl: [(caMVE,
                       label: threadWaitReadSTM2_raLJN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMVE: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.484756765 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM_closure" {
     GHC.Event.Thread.threadWaitReadSTM_closure:
         const GHC.Event.Thread.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caMVL,
                       label: GHC.Event.Thread.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMVL: // global
           R2 = R2;
           call threadWaitReadSTM2_raLJN_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.485614543 UTC

[section ""data" . threadWaitWriteSTM1_raLJO_closure" {
     threadWaitWriteSTM1_raLJO_closure:
         const threadWaitWriteSTM1_raLJO_info;
         const 0;
 },
 threadWaitWriteSTM1_raLJO_entry() //  [R2]
         { info_tbl: [(caMVS,
                       label: threadWaitWriteSTM1_raLJO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMVS: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.486474143 UTC

[section ""data" . GHC.Event.Thread.threadWaitWriteSTM_closure" {
     GHC.Event.Thread.threadWaitWriteSTM_closure:
         const GHC.Event.Thread.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caMVZ,
                       label: GHC.Event.Thread.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMVZ: // global
           R2 = R2;
           call threadWaitWriteSTM1_raLJO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.48716169 UTC

[section ""cstring" . lvl25_raLJP_bytes" {
     lvl25_raLJP_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.487936903 UTC

[section ""data" . lvl26_raLJQ_closure" {
     lvl26_raLJQ_closure:
         const lvl26_raLJQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_raLJQ_entry() //  [R1]
         { info_tbl: [(caMW8,
                       label: lvl26_raLJQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMW8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMW9; else goto caMWa;
       caMW9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMWa: // global
           (_caMW5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMW5::I64 == 0) goto caMW7; else goto caMW6;
       caMW7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMW6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMW5::I64;
           R2 = lvl25_raLJP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.489048542 UTC

[section ""data" . lvl27_raLJR_closure" {
     lvl27_raLJR_closure:
         const lvl27_raLJR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_raLJR_entry() //  [R1]
         { info_tbl: [(caMWh,
                       label: lvl27_raLJR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMWi; else goto caMWj;
       caMWi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMWj: // global
           (_caMWe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMWe::I64 == 0) goto caMWg; else goto caMWf;
       caMWg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMWf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMWe::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl26_raLJQ_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.490185449 UTC

[section ""data" . lvl28_raLJS_closure" {
     lvl28_raLJS_closure:
         const lvl28_raLJS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_raLJS_entry() //  [R1]
         { info_tbl: [(caMWq,
                       label: lvl28_raLJS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caMWr; else goto caMWs;
       caMWr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMWs: // global
           (_caMWn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caMWn::I64 == 0) goto caMWp; else goto caMWo;
       caMWp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caMWo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMWn::I64;
           R2 = lvl27_raLJR_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.502801476 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead1_closure" {
     GHC.Event.Thread.threadWaitRead1_closure:
         const GHC.Event.Thread.threadWaitRead1_info;
         const 0;
 },
 lvl31_saM1r_entry() //  [R1, R2, R3]
         { info_tbl: [(caMY8,
                       label: lvl31_saM1r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMY8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMY9; else goto caMYa;
       caMY9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMYa: // global
           I64[Sp - 8] = block_caMY6_info;
           R2 = R3;
           R1 = P64[R1 + 5];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMY6() //  []
         { info_tbl: [(caMY6,
                       label: block_caMY6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMY6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saM25_entry() //  [R1, R2]
         { info_tbl: [(caMZh,
                       label: $wgo_saM25_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caMZi; else goto caMZj;
       caMZi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMZj: // global
           I64[Sp - 24] = block_caMZa_info;
           _saM25::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saM18::I64;
           P64[Sp - 8] = _saM25::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaMZG; else goto caMZb;
       uaMZG: // global
           call _caMZa(R1) args: 0, res: 0, upd: 0;
       caMZb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMZa() //  [R1]
         { info_tbl: [(caMZa,
                       label: block_caMZa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZa: // global
           if (R1 & 7 == 1) goto caMZe; else goto caMZf;
       caMZe: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMZf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caMZr; else goto caMZq;
       caMZr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caMZq: // global
           _saM29::P64 = P64[R1 + 6];
           _saM2a::P64 = P64[R1 + 14];
           _saM28::I64 = I64[R1 + 22];
           if (_saM28::I64 == I64[Sp + 8]) goto caMZF; else goto caMZz;
       caMZF: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saM29::P64;
           R3 = _saM2a::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caMZz: // global
           Hp = Hp - 16;
           I64[Sp] = block_caMZv_info;
           R2 = _saM2a::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saM29::P64;
           I64[Sp + 16] = _saM28::I64;
           call $wgo_saM25_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMZv() //  [R1, R2, R3]
         { info_tbl: [(caMZv,
                       label: block_caMZv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caMZC; else goto caMZB;
       caMZC: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caMZB: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saM2U_entry() //  [R1, R2]
         { info_tbl: [(caN0r,
                       label: $wgo_saM2U_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN0r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caN0s; else goto caN0t;
       caN0s: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN0t: // global
           I64[Sp - 24] = block_caN0k_info;
           _saM2U::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saM18::I64;
           P64[Sp - 8] = _saM2U::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaN0Q; else goto caN0l;
       uaN0Q: // global
           call _caN0k(R1) args: 0, res: 0, upd: 0;
       caN0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN0k() //  [R1]
         { info_tbl: [(caN0k,
                       label: block_caN0k_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN0k: // global
           if (R1 & 7 == 1) goto caN0o; else goto caN0p;
       caN0o: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caN0p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caN0B; else goto caN0A;
       caN0B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN0A: // global
           _saM2Y::P64 = P64[R1 + 6];
           _saM2Z::P64 = P64[R1 + 14];
           _saM2X::I64 = I64[R1 + 22];
           if (_saM2X::I64 == I64[Sp + 8]) goto caN0P; else goto caN0J;
       caN0P: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saM2Y::P64;
           R3 = _saM2Z::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caN0J: // global
           Hp = Hp - 16;
           I64[Sp] = block_caN0F_info;
           R2 = _saM2Z::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saM2Y::P64;
           I64[Sp + 16] = _saM2X::I64;
           call $wgo_saM2U_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN0F() //  [R1, R2, R3]
         { info_tbl: [(caN0F,
                       label: block_caN0F_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN0F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caN0M; else goto caN0L;
       caN0M: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caN0L: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saM1o_entry() //  [R1, R2]
         { info_tbl: [(caN0V,
                       label: $wio_saM1o_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN0V: // global
           _saM1p::P64 = R2;
           _saM1o::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caN0W; else goto caN0X;
       caN0X: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caN0Z; else goto caN0Y;
       caN0Z: // global
           HpAlloc = 80;
           goto caN0W;
       caN0W: // global
           R2 = _saM1p::P64;
           R1 = _saM1o::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN0Y: // global
           _saM0z::P64 = P64[_saM1o::P64 + 6];
           _saM0Z::P64 = P64[_saM1o::P64 + 14];
           _saM11::P64 = P64[_saM1o::P64 + 22];
           _saM12::P64 = P64[_saM1o::P64 + 30];
           _saM17::P64 = P64[_saM1o::P64 + 38];
           _saM16::I64 = I64[_saM1o::P64 + 46];
           _saM18::I64 = I64[_saM1o::P64 + 54];
           _saM1a::I64 = I64[_saM1o::P64 + 62];
           I64[Hp - 72] = lvl31_saM1r_info;
           P64[Hp - 64] = _saM0z::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saM18::I64;
           I64[Hp - 32] = _saM16::I64;
           I64[Hp - 24] = _saM1a::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caMXO_info;
           R5 = _saM1p::P64;
           R4 = Hp - 14;
           R3 = _saM18::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saM0Z::P64;
           P64[Sp - 48] = _saM11::P64;
           P64[Sp - 40] = _saM12::P64;
           P64[Sp - 32] = _saM17::P64;
           I64[Sp - 24] = _saM18::I64;
           I64[Sp - 16] = _saM1a::I64;
           P64[Sp - 8] = _saM1p::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMXO() //  [R1]
         { info_tbl: [(caMXO,
                       label: block_caMXO_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXO: // global
           I64[Sp - 8] = block_caMXS_info;
           _saM1A::P64 = R1;
           R1 = R1;
           P64[Sp] = _saM1A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaN3j; else goto caMXT;
       uaN3j: // global
           call _caMXS(R1) args: 0, res: 0, upd: 0;
       caMXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMXS() //  [R1]
         { info_tbl: [(caMXS,
                       label: block_caMXS_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXS: // global
           if (R1 & 7 == 1) goto caN0S; else goto caN0T;
       caN0S: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saM1B() args: 0, res: 0, upd: 0;
       caN0T: // global
           I64[Sp] = block_caMXY_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMXY() //  [R1]
         { info_tbl: [(caMXY,
                       label: block_caMXY_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caN2S; else goto caN2R;
       caN2S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caN2R: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saM1B() args: 0, res: 0, upd: 0;
     }
 },
 _saM1B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saM1B: // global
           _saM1D::P64 = P64[Sp];
           I64[Sp] = block_caMYf_info;
           R1 = _saM1D::P64;
           if (R1 & 7 != 0) goto uaN3E; else goto caMYg;
       uaN3E: // global
           call _caMYf(R1) args: 0, res: 0, upd: 0;
       caMYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMYf() //  [R1]
         { info_tbl: [(caMYf,
                       label: block_caMYf_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYf: // global
           _saM1G::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saM1H::I64 = _saM1G::I64 & 8;
           if (_saM1H::I64 != 0) goto uaN3c; else goto uaN3b;
       uaN3c: // global
           I64[Sp] = _saM1H::I64;
           I64[Sp + 40] = _saM1G::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caMYr() args: 0, res: 0, upd: 0;
       uaN3b: // global
           I64[Sp + 32] = _saM1H::I64;
           I64[Sp + 64] = _saM1G::I64;
           Sp = Sp + 16;
           call _caMZJ() args: 0, res: 0, upd: 0;
     }
 },
 _caMYr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caN17; else goto caN16;
       caN17: // global
           HpAlloc = 32;
           _saM1H::I64 = I64[Sp];
           I64[Sp] = block_caMYq_info;
           R1 = _saM1H::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caN16: // global
           _saM1G::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saM1G::I64) goto caN19; else goto caN1a;
       caN19: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caN1a: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saM1G::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caMYF_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caMYq() //  [R1]
         { info_tbl: [(caMYq,
                       label: block_caMYq_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYq: // global
           I64[Sp] = R1;
           call _caMYr() args: 0, res: 0, upd: 0;
     }
 },
 _caMYF() //  [R1]
         { info_tbl: [(caMYF,
                       label: block_caMYF_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYF: // global
           I64[Sp] = block_caMYH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaN3p; else goto caMYI;
       uaN3p: // global
           call _caMYH(R1) args: 0, res: 0, upd: 0;
       caMYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMYH() //  [R1]
         { info_tbl: [(caMYH,
                       label: block_caMYH_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYH: // global
           if (R1 & 7 == 1) goto caN1e; else goto caN1W;
       caN1e: // global
           I64[Sp + 40] = block_caMYM_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaN3q; else goto caMYN;
       uaN3q: // global
           call _caMYM(R1) args: 0, res: 0, upd: 0;
       caMYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caN1W: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMYM() //  [R1]
         { info_tbl: [(caMYM,
                       label: block_caMYM_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYM: // global
           _saM1p::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caN1h; else goto caN1Q;
       caN1h: // global
           I64[Sp] = block_caMYR_info;
           R1 = P64[_saM1p::P64 + 8];
           if (R1 & 7 != 0) goto uaN3r; else goto caMYS;
       uaN3r: // global
           call _caMYR(R1) args: 0, res: 0, upd: 0;
       caMYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caN1Q: // global
           I64[Sp + 24] = block_caN1O_info;
           R5 = _saM1p::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caMYR() //  [R1]
         { info_tbl: [(caMYR,
                       label: block_caMYR_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMYR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caN1k; else goto caN1j;
       caN1k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN1j: // global
           _saM18::I64 = I64[Sp + 8];
           _saM1W::P64 = P64[R1 + 7];
           _saM1Y::P64 = P64[R1 + 15];
           _saM1X::I64 = I64[R1 + 23];
           _saM1Z::I64 = _saM18::I64 & (I64[_saM1W::P64 + 8] - 1);
           _saM24::P64 = P64[(_saM1W::P64 + 24) + (_saM1Z::I64 << 3)];
           I64[Hp - 8] = $wgo_saM25_info;
           I64[Hp] = _saM18::I64;
           I64[Sp - 8] = block_caN1l_info;
           R2 = _saM24::P64;
           R1 = Hp - 7;
           I64[Sp] = _saM1Z::I64;
           P64[Sp + 8] = _saM1Y::P64;
           I64[Sp + 16] = _saM1X::I64;
           P64[Sp + 24] = _saM1W::P64;
           Sp = Sp - 8;
           call $wgo_saM25_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN1l() //  [R1, R2, R3]
         { info_tbl: [(caN1l,
                       label: block_caN1l_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN1l: // global
           I64[Sp - 16] = block_caN1n_info;
           _saM2j::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saM2j::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaN3w; else goto caN1p;
       uaN3w: // global
           call _caN1n(R1) args: 0, res: 0, upd: 0;
       caN1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN1n() //  [R1]
         { info_tbl: [(caN1n,
                       label: block_caN1n_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN1n: // global
           if (R1 & 7 == 1) goto uaN3e; else goto caN1A;
       uaN3e: // global
           Sp = Sp + 56;
           call _caN2x() args: 0, res: 0, upd: 0;
       caN1A: // global
           _saM1W::P64 = P64[Sp + 48];
           _saM1Z::I64 = I64[Sp + 24];
           _saM2j::P64 = P64[Sp + 16];
           _saM2l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saM1W::P64 + 24) + (_saM1Z::I64 << 3)] = _saM2l::P64;
           I64[_saM1W::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saM1W::P64 + 24) + ((I64[_saM1W::P64 + 8] << 3) + (_saM1Z::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caN1y_info;
           R1 = _saM2j::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaN3x; else goto caN1B;
       uaN3x: // global
           call _caN1y(R1) args: 0, res: 0, upd: 0;
       caN1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN1y() //  [R1]
         { info_tbl: [(caN1y,
                       label: block_caN1y_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN1y: // global
           if (R1 & 7 == 1) goto uaN3f; else goto caN1L;
       uaN3f: // global
           Sp = Sp + 32;
           call _caN2x() args: 0, res: 0, upd: 0;
       caN1L: // global
           _saM1X::I64 = I64[Sp + 16];
           _saM1Y::P64 = P64[Sp + 8];
           I64[_saM1X::I64] = I64[_saM1X::I64] - 1;
           call MO_Touch(_saM1Y::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caN1O() //  []
         { info_tbl: [(caN1O,
                       label: block_caN1O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN1O: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMZJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caN20; else goto caN1Z;
       caN20: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caMZI_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caN1Z: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caMZP_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMZI() //  [R1]
         { info_tbl: [(caMZI,
                       label: block_caMZI_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZI: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caMZJ() args: 0, res: 0, upd: 0;
     }
 },
 _caMZP() //  [R1]
         { info_tbl: [(caMZP,
                       label: block_caMZP_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZP: // global
           I64[Sp] = block_caMZR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaN3t; else goto caMZS;
       uaN3t: // global
           call _caMZR(R1) args: 0, res: 0, upd: 0;
       caMZS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMZR() //  [R1]
         { info_tbl: [(caMZR,
                       label: block_caMZR_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZR: // global
           if (R1 & 7 == 1) goto caN24; else goto caN2M;
       caN24: // global
           I64[Sp + 40] = block_caMZW_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaN3u; else goto caMZX;
       uaN3u: // global
           call _caMZW(R1) args: 0, res: 0, upd: 0;
       caMZX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caN2M: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caMZW() //  [R1]
         { info_tbl: [(caMZW,
                       label: block_caMZW_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMZW: // global
           _saM1p::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caN27; else goto caN2G;
       caN27: // global
           I64[Sp] = block_caN01_info;
           R1 = P64[_saM1p::P64 + 8];
           if (R1 & 7 != 0) goto uaN3v; else goto caN02;
       uaN3v: // global
           call _caN01(R1) args: 0, res: 0, upd: 0;
       caN02: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caN2G: // global
           I64[Sp + 24] = block_caN2E_info;
           R5 = _saM1p::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caN01() //  [R1]
         { info_tbl: [(caN01,
                       label: block_caN01_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN01: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caN2a; else goto caN29;
       caN2a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN29: // global
           _saM18::I64 = I64[Sp + 8];
           _saM2L::P64 = P64[R1 + 7];
           _saM2N::P64 = P64[R1 + 15];
           _saM2M::I64 = I64[R1 + 23];
           _saM2O::I64 = _saM18::I64 & (I64[_saM2L::P64 + 8] - 1);
           _saM2T::P64 = P64[(_saM2L::P64 + 24) + (_saM2O::I64 << 3)];
           I64[Hp - 8] = $wgo_saM2U_info;
           I64[Hp] = _saM18::I64;
           I64[Sp - 8] = block_caN2b_info;
           R2 = _saM2T::P64;
           R1 = Hp - 7;
           I64[Sp] = _saM2O::I64;
           P64[Sp + 8] = _saM2N::P64;
           I64[Sp + 16] = _saM2M::I64;
           P64[Sp + 24] = _saM2L::P64;
           Sp = Sp - 8;
           call $wgo_saM2U_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN2b() //  [R1, R2, R3]
         { info_tbl: [(caN2b,
                       label: block_caN2b_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN2b: // global
           I64[Sp - 16] = block_caN2d_info;
           _saM38::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saM38::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaN3A; else goto caN2f;
       uaN3A: // global
           call _caN2d(R1) args: 0, res: 0, upd: 0;
       caN2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN2d() //  [R1]
         { info_tbl: [(caN2d,
                       label: block_caN2d_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN2d: // global
           if (R1 & 7 == 1) goto uaN3h; else goto caN2q;
       uaN3h: // global
           Sp = Sp + 56;
           call _caN2x() args: 0, res: 0, upd: 0;
       caN2q: // global
           _saM2L::P64 = P64[Sp + 48];
           _saM2O::I64 = I64[Sp + 24];
           _saM38::P64 = P64[Sp + 16];
           _saM3a::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saM2L::P64 + 24) + (_saM2O::I64 << 3)] = _saM3a::P64;
           I64[_saM2L::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saM2L::P64 + 24) + ((I64[_saM2L::P64 + 8] << 3) + (_saM2O::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caN2o_info;
           R1 = _saM38::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaN3B; else goto caN2r;
       uaN3B: // global
           call _caN2o(R1) args: 0, res: 0, upd: 0;
       caN2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN2o() //  [R1]
         { info_tbl: [(caN2o,
                       label: block_caN2o_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN2o: // global
           if (R1 & 7 == 1) goto uaN3i; else goto caN2B;
       uaN3i: // global
           Sp = Sp + 32;
           call _caN2x() args: 0, res: 0, upd: 0;
       caN2B: // global
           _saM2M::I64 = I64[Sp + 16];
           _saM2N::P64 = P64[Sp + 8];
           I64[_saM2M::I64] = I64[_saM2M::I64] - 1;
           call MO_Touch(_saM2N::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caN2x() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN2x: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caN2E() //  []
         { info_tbl: [(caN2E,
                       label: block_caN2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN2E: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saM3t_entry() //  [R1, R2]
         { info_tbl: [(caN3N,
                       label: io1_saM3t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN3N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caN3O; else goto caN3P;
       caN3O: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN3P: // global
           I64[Sp - 16] = block_caN3K_info;
           _saM1o::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saM1o::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaN3T; else goto caN3L;
       uaN3T: // global
           call _caN3K(R1) args: 0, res: 0, upd: 0;
       caN3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN3K() //  [R1]
         { info_tbl: [(caN3K,
                       label: block_caN3K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN3K: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saM1o_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3I_entry() //  [R1, R2]
         { info_tbl: [(caN46,
                       label: sat_saM3I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN46: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caN47; else goto caN48;
       caN47: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN48: // global
           I64[Sp - 16] = block_caN44_info;
           R3 = P64[R1 + 14];
           _saM3D::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM3D::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caN44() //  []
         { info_tbl: [(caN44,
                       label: block_caN44_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN44: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3C_entry() //  [R1]
         { info_tbl: [(caN4f,
                       label: sat_saM3C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4f: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3Y_entry() //  [R1, R2]
         { info_tbl: [(caN4t,
                       label: sat_saM3Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caN4u; else goto caN4v;
       caN4u: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN4v: // global
           I64[Sp - 16] = block_caN4r_info;
           _saM3V::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM3V::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN4r() //  []
         { info_tbl: [(caN4r,
                       label: block_caN4r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4r: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3T_entry() //  [R1]
         { info_tbl: [(caN4C,
                       label: sat_saM3T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4C: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3U_entry() //  [R1]
         { info_tbl: [(caN4K,
                       label: sat_saM3U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4K: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4l_entry() //  [R1, R2]
         { info_tbl: [(caN52,
                       label: sat_saM4l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN52: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caN53; else goto caN54;
       caN53: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN54: // global
           I64[Sp - 16] = block_caN50_info;
           _saM4i::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM4i::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN50() //  []
         { info_tbl: [(caN50,
                       label: block_caN50_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN50: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4g_entry() //  [R1]
         { info_tbl: [(caN5b,
                       label: sat_saM4g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5b: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4h_entry() //  [R1]
         { info_tbl: [(caN5j,
                       label: sat_saM4h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5j: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4q_entry() //  [R1]
         { info_tbl: [(caN5q,
                       label: sat_saM4q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caN5r; else goto caN5s;
       caN5r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caN5s: // global
           I64[Sp - 24] = block_caN4T_info;
           _saM1n::P64 = P64[R1 + 7];
           _saM3t::P64 = P64[R1 + 15];
           R1 = _saM1n::P64;
           P64[Sp - 16] = _saM1n::P64;
           P64[Sp - 8] = _saM3t::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN4T() //  [R1]
         { info_tbl: [(caN4T,
                       label: block_caN4T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4T: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caN5v; else goto caN5u;
       caN5v: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN5u: // global
           I64[Hp - 56] = sat_saM4l_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM4g_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM4h_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caN5m_info;
           R2 = Hp - 54;
           _saM4f::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saM4f::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN5m() //  [R1]
         { info_tbl: [(caN5m,
                       label: block_caN5m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5m: // global
           _saM1n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caN5o_info;
           R2 = P64[Sp + 16];
           _saM4o::P64 = R1;
           R1 = _saM1n::P64;
           P64[Sp + 16] = _saM4o::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN5o() //  []
         { info_tbl: [(caN5o,
                       label: block_caN5o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5o: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4L_entry() //  [R1, R2]
         { info_tbl: [(caN5I,
                       label: sat_saM4L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caN5J; else goto caN5K;
       caN5J: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN5K: // global
           I64[Sp - 16] = block_caN5G_info;
           _saM4I::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM4I::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN5G() //  []
         { info_tbl: [(caN5G,
                       label: block_caN5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5G: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4G_entry() //  [R1]
         { info_tbl: [(caN5R,
                       label: sat_saM4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5R: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4H_entry() //  [R1]
         { info_tbl: [(caN5Z,
                       label: sat_saM4H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5Z: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saM0v_entry() //  [R1]
         { info_tbl: [(caN66,
                       label: io_saM0v_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN66: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caN67; else goto caN68;
       caN67: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caN68: // global
           I64[Sp - 24] = block_caMWE_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caMWE() //  [R1]
         { info_tbl: [(caMWE,
                       label: block_caMWE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWE: // global
           I64[Sp - 8] = block_caMWG_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caMWG() //  [R1]
         { info_tbl: [(caMWG,
                       label: block_caMWG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWG: // global
           I64[Sp] = block_caMWI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaN9o; else goto caMWJ;
       uaN9o: // global
           call _caMWI(R1) args: 0, res: 0, upd: 0;
       caMWJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMWI() //  [R1]
         { info_tbl: [(caMWI,
                       label: block_caMWI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWI: // global
           if (R1 & 7 == 1) goto caN63; else goto caN64;
       caN63: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caN64: // global
           I64[Sp] = block_caMWO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaN9p; else goto caMWP;
       uaN9p: // global
           call _caMWO(R1) args: 0, res: 0, upd: 0;
       caMWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMWO() //  [R1]
         { info_tbl: [(caMWO,
                       label: block_caMWO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWO: // global
           I64[Sp - 40] = block_caMWT_info;
           _saM0G::P64 = R1;
           _saM0H::P64 = P64[R1 + 7];
           _saM0J::P64 = P64[R1 + 23];
           _saM0L::P64 = P64[R1 + 31];
           _saM0N::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saM0H::P64;
           P64[Sp - 24] = _saM0J::P64;
           P64[Sp - 16] = _saM0L::P64;
           P64[Sp - 8] = _saM0N::P64;
           P64[Sp] = _saM0G::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaN9q; else goto caMWU;
       uaN9q: // global
           call _caMWT(R1) args: 0, res: 0, upd: 0;
       caMWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMWT() //  [R1]
         { info_tbl: [(caMWT,
                       label: block_caMWT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWT: // global
           I64[Sp - 8] = block_caMWY_info;
           _saM0U::P64 = R1;
           _saM0V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM0V::I64;
           P64[Sp + 16] = _saM0U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaN9r; else goto caMWZ;
       uaN9r: // global
           call _caMWY(R1) args: 0, res: 0, upd: 0;
       caMWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMWY() //  [R1]
         { info_tbl: [(caMWY,
                       label: block_caMWY_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWY: // global
           I64[Sp - 8] = block_caMX3_info;
           _saM0W::P64 = R1;
           _saM0X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM0X::I64;
           P64[Sp + 16] = _saM0W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaN9s; else goto caMX4;
       uaN9s: // global
           call _caMX3(R1) args: 0, res: 0, upd: 0;
       caMX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMX3() //  [R1]
         { info_tbl: [(caMX3,
                       label: block_caMX3_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMX3: // global
           _saM0q::P64 = P64[Sp + 80];
           _saM0Z::P64 = P64[R1 + 7];
           _saM11::P64 = P64[R1 + 23];
           _saM12::P64 = P64[R1 + 31];
           (_saM16::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caMXa_info;
           R1 = _saM0q::P64;
           I64[Sp - 8] = _saM16::I64;
           P64[Sp] = _saM12::P64;
           P64[Sp + 48] = _saM11::P64;
           P64[Sp + 80] = _saM0Z::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaN9t; else goto caMXb;
       uaN9t: // global
           call _caMXa(R1) args: 0, res: 0, upd: 0;
       caMXb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMXa() //  [R1]
         { info_tbl: [(caMXa,
                       label: block_caMXa_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXa: // global
           I64[Sp - 8] = block_caMXf_info;
           _saM17::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saM18::I64;
           P64[Sp + 88] = _saM17::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaN9u; else goto caMXg;
       uaN9u: // global
           call _caMXf(R1) args: 0, res: 0, upd: 0;
       caMXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMXf() //  [R1]
         { info_tbl: [(caMXf,
                       label: block_caMXf_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXf: // global
           I64[Sp - 16] = block_caMXk_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMXk() //  [R1]
         { info_tbl: [(caMXk,
                       label: block_caMXk_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXk: // global
           _saM0U::P64 = P64[Sp + 72];
           _saM0V::I64 = I64[Sp + 56];
           _saM0W::P64 = P64[Sp + 64];
           _saM1e::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saM0V::I64,
                            _saM1e::I64)) goto caN6o; else goto caN96;
       caN96: // global
           if (%MO_S_Gt_W64(_saM1e::I64,
                            I64[Sp + 48])) goto caN6o; else goto caN6p;
       caN6o: // global
           R4 = _saM1e::I64;
           R3 = _saM0U::P64;
           R2 = _saM0W::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caN6p: // global
           _saM1l::P64 = P64[P64[Sp + 80] + ((_saM1e::I64 - _saM0V::I64 << 3) + 24)];
           I64[Sp] = block_caMXA_info;
           _saM1d::I64 = R1;
           R1 = _saM1l::P64;
           I64[Sp + 80] = _saM1d::I64;
           if (R1 & 7 != 0) goto uaN9v; else goto caMXB;
       uaN9v: // global
           call _caMXA(R1) args: 0, res: 0, upd: 0;
       caMXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMXA() //  [R1]
         { info_tbl: [(caMXA,
                       label: block_caMXA_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMXA: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caN6s; else goto caN6r;
       caN6s: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN6r: // global
           _saM1n::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saM1o_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saM3t_info;
           P64[Hp - 24] = Hp - 102;
           _caN3F::P64 = Hp - 30;
           _saM3P::I64 = I64[Sp + 80];
           if (_saM3P::I64 != 0) goto uaN9g; else goto caN7J;
       uaN9g: // global
           if (_saM3P::I64 != 1) goto caN70; else goto caN8q;
       caN70: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caN4k_info;
           R1 = _saM1n::P64;
           P64[Sp + 112] = _saM1n::P64;
           P64[Sp + 120] = _caN3F::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caN8q: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caN5z_info;
           R1 = _saM1n::P64;
           P64[Sp + 112] = _saM1n::P64;
           P64[Sp + 120] = _caN3F::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caN7J: // global
           I64[Hp - 16] = sat_saM4q_info;
           P64[Hp - 8] = _saM1n::P64;
           P64[Hp] = _caN3F::P64;
           I64[Sp + 8] = block_caN7G_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN4k() //  [R1]
         { info_tbl: [(caN4k,
                       label: block_caN4k_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4k: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caN73; else goto caN72;
       caN73: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN72: // global
           I64[Hp - 56] = sat_saM3Y_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM3T_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM3U_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caN6U_info;
           R2 = Hp - 54;
           _saM3S::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saM3S::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN6U() //  [R1]
         { info_tbl: [(caN6U,
                       label: block_caN6U_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN6U: // global
           I64[Sp] = block_caN6W_info;
           R2 = P64[Sp + 112];
           _saM41::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM41::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN6W() //  []
         { info_tbl: [(caN6W,
                       label: block_caN6W_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN6W: // global
           I64[Sp] = block_caN6Y_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaN9y; else goto caN76;
       uaN9y: // global
           call _caN6Y(R1) args: 0, res: 0, upd: 0;
       caN76: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN6Y() //  [R1]
         { info_tbl: [(caN6Y,
                       label: block_caN6Y_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN6Y: // global
           I64[Sp] = block_caN7a_info;
           _saM44::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM44::P64;
           if (R1 & 7 != 0) goto uaN9z; else goto caN7c;
       uaN9z: // global
           call _caN7a(R1) args: 0, res: 0, upd: 0;
       caN7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7a() //  [R1]
         { info_tbl: [(caN7a,
                       label: block_caN7a_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7a: // global
           if (R1 & 7 == 1) goto caN7l; else goto caN7y;
       caN7l: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caN7g_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caN7y: // global
           I64[Sp + 8] = block_caN7w_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaN9A; else goto caN7z;
       uaN9A: // global
           call _caN7w(R1) args: 0, res: 0, upd: 0;
       caN7z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7g() //  []
         { info_tbl: [(caN7g,
                       label: block_caN7g_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7g: // global
           I64[Sp] = block_caN7i_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaN9B; else goto caN7n;
       uaN9B: // global
           call _caN7i(R1) args: 0, res: 0, upd: 0;
       caN7n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7i() //  [R1]
         { info_tbl: [(caN7i,
                       label: block_caN7i_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7i: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN7t; else goto caN7s;
       caN7t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN7s: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN7w() //  [R1]
         { info_tbl: [(caN7w,
                       label: block_caN7w_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN7F; else goto caN7E;
       caN7F: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN7E: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN5z() //  [R1]
         { info_tbl: [(caN5z,
                       label: block_caN5z_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN5z: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caN8t; else goto caN8s;
       caN8t: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN8s: // global
           I64[Hp - 56] = sat_saM4L_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM4G_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM4H_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caN8l_info;
           R2 = Hp - 54;
           _saM4F::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saM4F::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN8l() //  [R1]
         { info_tbl: [(caN8l,
                       label: block_caN8l_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8l: // global
           I64[Sp] = block_caN8n_info;
           R2 = P64[Sp + 112];
           _saM4O::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM4O::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN8n() //  []
         { info_tbl: [(caN8n,
                       label: block_caN8n_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8n: // global
           I64[Sp] = block_caN8p_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaN9K; else goto caN8w;
       uaN9K: // global
           call _caN8p(R1) args: 0, res: 0, upd: 0;
       caN8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN8p() //  [R1]
         { info_tbl: [(caN8p,
                       label: block_caN8p_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8p: // global
           I64[Sp] = block_caN8A_info;
           _saM4R::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM4R::P64;
           if (R1 & 7 != 0) goto uaN9L; else goto caN8C;
       uaN9L: // global
           call _caN8A(R1) args: 0, res: 0, upd: 0;
       caN8C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN8A() //  [R1]
         { info_tbl: [(caN8A,
                       label: block_caN8A_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8A: // global
           if (R1 & 7 == 1) goto caN8L; else goto caN8Y;
       caN8L: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caN8G_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caN8Y: // global
           I64[Sp + 8] = block_caN8W_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaN9M; else goto caN8Z;
       uaN9M: // global
           call _caN8W(R1) args: 0, res: 0, upd: 0;
       caN8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN8G() //  []
         { info_tbl: [(caN8G,
                       label: block_caN8G_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8G: // global
           I64[Sp] = block_caN8I_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaN9N; else goto caN8N;
       uaN9N: // global
           call _caN8I(R1) args: 0, res: 0, upd: 0;
       caN8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN8I() //  [R1]
         { info_tbl: [(caN8I,
                       label: block_caN8I_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN8T; else goto caN8S;
       caN8T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN8S: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN8W() //  [R1]
         { info_tbl: [(caN8W,
                       label: block_caN8W_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN95; else goto caN94;
       caN95: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN94: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN7G() //  [R1]
         { info_tbl: [(caN7G,
                       label: block_caN7G_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7G: // global
           I64[Sp] = block_caN7I_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaN9E; else goto caN7L;
       uaN9E: // global
           call _caN7I(R1) args: 0, res: 0, upd: 0;
       caN7L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7I() //  [R1]
         { info_tbl: [(caN7I,
                       label: block_caN7I_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7I: // global
           I64[Sp] = block_caN7P_info;
           _saM4v::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM4v::P64;
           if (R1 & 7 != 0) goto uaN9F; else goto caN7R;
       uaN9F: // global
           call _caN7P(R1) args: 0, res: 0, upd: 0;
       caN7R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7P() //  [R1]
         { info_tbl: [(caN7P,
                       label: block_caN7P_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7P: // global
           if (R1 & 7 == 1) goto caN80; else goto caN8d;
       caN80: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caN7V_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caN8d: // global
           I64[Sp + 8] = block_caN8b_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaN9G; else goto caN8e;
       uaN9G: // global
           call _caN8b(R1) args: 0, res: 0, upd: 0;
       caN8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7V() //  []
         { info_tbl: [(caN7V,
                       label: block_caN7V_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7V: // global
           I64[Sp] = block_caN7X_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaN9H; else goto caN82;
       uaN9H: // global
           call _caN7X(R1) args: 0, res: 0, upd: 0;
       caN82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN7X() //  [R1]
         { info_tbl: [(caN7X,
                       label: block_caN7X_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN7X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN88; else goto caN87;
       caN88: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN87: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN8b() //  [R1]
         { info_tbl: [(caN8b,
                       label: block_caN8b_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN8b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN8k; else goto caN8j;
       caN8k: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN8j: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN3X() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN3X: // global
           Hp = Hp + 40;
           _saM3A::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caN6y; else goto caN6x;
       caN6y: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caN3W_info;
           R1 = _saM3A::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caN6x: // global
           I64[Hp - 32] = sat_saM3I_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = _saM3A::P64;
           I64[Hp - 8] = sat_saM3C_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_caN6t_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN3W() //  [R1]
         { info_tbl: [(caN3W,
                       label: block_caN3W_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN3W: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caN3X() args: 0, res: 0, upd: 0;
     }
 },
 _caN6t() //  [R1]
         { info_tbl: [(caN6t,
                       label: block_caN6t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN6t: // global
           I64[Sp] = block_caN6v_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaN9x; else goto caN6A;
       uaN9x: // global
           call _caN6v(R1) args: 0, res: 0, upd: 0;
       caN6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN6v() //  [R1]
         { info_tbl: [(caN6v,
                       label: block_caN6v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN6v: // global
           if (I64[R1 + 7] & 4 == 0) goto caN6Q; else goto caN6K;
       caN6Q: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caN6K: // global
           R1 = lvl28_raLJS_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.threadWaitRead1_entry() //  [R2, R3]
         { info_tbl: [(caN9U,
                       label: GHC.Event.Thread.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN9U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caN9V; else goto caN9W;
       caN9V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitRead1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caN9W: // global
           I64[Sp - 24] = block_caMWx_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caMWx() //  [R1]
         { info_tbl: [(caMWx,
                       label: block_caMWx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMWx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caN9Z; else goto caN9Y;
       caN9Z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caN9Y: // global
           I64[Hp - 16] = io_saM0v_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caMWz::P64 = Hp - 15;
           if (R1 == 0) goto caN9T; else goto caN9S;
       caN9T: // global
           R1 = _caMWz::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caN9S: // global
           R1 = _caMWz::P64;
           Sp = Sp + 24;
           call io_saM0v_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.530425026 UTC

[section ""data" . threadWaitWrite1_raLJT_closure" {
     threadWaitWrite1_raLJT_closure:
         const threadWaitWrite1_raLJT_info;
         const 0;
 },
 threadWaitWrite1_raLJT_entry() //  [R2]
         { info_tbl: [(caNa4,
                       label: threadWaitWrite1_raLJT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNa4: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.531362059 UTC

[section ""data" . GHC.Event.Thread.threadWaitWrite_closure" {
     GHC.Event.Thread.threadWaitWrite_closure:
         const GHC.Event.Thread.threadWaitWrite_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caNab,
                       label: GHC.Event.Thread.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNab: // global
           R2 = R2;
           call threadWaitWrite1_raLJT_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.532222145 UTC

[section ""data" . threadWaitRead2_raLJU_closure" {
     threadWaitRead2_raLJU_closure:
         const threadWaitRead2_raLJU_info;
         const 0;
 },
 threadWaitRead2_raLJU_entry() //  [R2]
         { info_tbl: [(caNai,
                       label: threadWaitRead2_raLJU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNai: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.533042618 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead_closure" {
     GHC.Event.Thread.threadWaitRead_closure:
         const GHC.Event.Thread.threadWaitRead_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caNap,
                       label: GHC.Event.Thread.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNap: // global
           R2 = R2;
           call threadWaitRead2_raLJU_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.533768988 UTC

[section ""cstring" . lvl29_raLJV_bytes" {
     lvl29_raLJV_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,48,52,58,53,45,49,55]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.534496921 UTC

[section ""data" . lvl30_raLJW_closure" {
     lvl30_raLJW_closure:
         const lvl30_raLJW_info;
         const 0;
 },
 lvl30_raLJW_entry() //  []
         { info_tbl: [(caNay,
                       label: lvl30_raLJW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNay: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNaz; else goto caNaA;
       caNaz: // global
           R1 = lvl30_raLJW_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNaA: // global
           I64[Sp - 8] = block_caNaw_info;
           R2 = lvl29_raLJV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNaw() //  [R1]
         { info_tbl: [(caNaw,
                       label: block_caNaw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNaw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.535824267 UTC

[section ""data" . go_raLJX_closure" {
     go_raLJX_closure:
         const go_raLJX_info;
 },
 go_raLJX_entry() //  [R2]
         { info_tbl: [(caNaP,
                       label: go_raLJX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNaP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNaQ; else goto uaNb1;
       caNaQ: // global
           R2 = R2;
           R1 = go_raLJX_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaNb1: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caNaF() args: 0, res: 0, upd: 0;
     }
 },
 _caNaF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNaF: // global
           _saM52::P64 = P64[Sp];
           I64[Sp] = block_caNaI_info;
           R1 = _saM52::P64;
           if (R1 & 7 != 0) goto uaNb3; else goto caNaJ;
       uaNb3: // global
           call _caNaI(R1) args: 0, res: 0, upd: 0;
       caNaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNaI() //  [R1]
         { info_tbl: [(caNaI,
                       label: block_caNaI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNaI: // global
           if (R1 & 7 == 1) goto caNaM; else goto caNaN;
       caNaM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNaN: // global
           I64[Sp - 8] = block_caNaX_info;
           _saM56::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM56::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNaX() //  []
         { info_tbl: [(caNaX,
                       label: block_caNaX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNaX: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caNaF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.543222683 UTC

[section ""data" . GHC.Event.Thread.closeFdWith1_closure" {
     GHC.Event.Thread.closeFdWith1_closure:
         const GHC.Event.Thread.closeFdWith1_info;
         const 0;
 },
 go1_saM5z_entry() //  [R1, R2]
         { info_tbl: [(caNbS,
                       label: go1_saM5z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNbS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caNbT; else goto caNbU;
       caNbT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNbU: // global
           I64[Sp - 24] = block_caNbL_info;
           _saM5z::P64 = R1;
           _saM5b::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _saM5b::P64;
           P64[Sp - 8] = _saM5z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaNcZ; else goto caNbM;
       uaNcZ: // global
           call _caNbL(R1) args: 0, res: 0, upd: 0;
       caNbM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNbL() //  [R1]
         { info_tbl: [(caNbL,
                       label: block_caNbL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNbL: // global
           if (R1 & 7 == 1) goto caNbP; else goto caNbQ;
       caNbP: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNbQ: // global
           I64[Sp - 8] = block_caNc0_info;
           _saM5E::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM5E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNcY; else goto caNc1;
       uaNcY: // global
           call _caNc0(R1) args: 0, res: 0, upd: 0;
       caNc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNc0() //  [R1]
         { info_tbl: [(caNc0,
                       label: block_caNc0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNc0: // global
           I64[Sp - 16] = block_caNc5_info;
           _saM5I::P64 = P64[R1 + 23];
           _saM5K::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saM5K::P64;
           P64[Sp] = _saM5I::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNd0; else goto caNc6;
       uaNd0: // global
           call _caNc5(R1) args: 0, res: 0, upd: 0;
       caNc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNc5() //  [R1]
         { info_tbl: [(caNc5,
                       label: block_caNc5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNc5: // global
           I64[Sp - 8] = block_caNca_info;
           _saM5T::P64 = R1;
           _saM5U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM5U::I64;
           P64[Sp + 16] = _saM5T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNd1; else goto caNcb;
       uaNd1: // global
           call _caNca(R1) args: 0, res: 0, upd: 0;
       caNcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNca() //  [R1]
         { info_tbl: [(caNca,
                       label: block_caNca_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNca: // global
           I64[Sp - 8] = block_caNcf_info;
           _saM5V::P64 = R1;
           _saM5W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saM5W::I64;
           P64[Sp + 40] = _saM5V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNd2; else goto caNck;
       uaNd2: // global
           call _caNcf(R1) args: 0, res: 0, upd: 0;
       caNck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNcf() //  [R1]
         { info_tbl: [(caNcf,
                       label: block_caNcf_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNcf: // global
           _saM5T::P64 = P64[Sp + 32];
           _saM5U::I64 = I64[Sp + 16];
           _saM5V::P64 = P64[Sp + 48];
           _saM5Z::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saM5U::I64,
                            _saM5Z::I64)) goto caNcB; else goto caNcX;
       caNcX: // global
           if (%MO_S_Gt_W64(_saM5Z::I64,
                            I64[Sp + 8])) goto caNcB; else goto caNcR;
       caNcB: // global
           R4 = _saM5Z::I64;
           R3 = _saM5T::P64;
           R2 = _saM5V::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caNcR: // global
           _saM66::P64 = P64[P64[Sp + 24] + ((_saM5Z::I64 - _saM5U::I64 << 3) + 24)];
           I64[Sp + 32] = block_caNcH_info;
           R1 = _saM66::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uaNd3; else goto caNcI;
       uaNd3: // global
           call _caNcH(R1) args: 0, res: 0, upd: 0;
       caNcI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNcH() //  [R1]
         { info_tbl: [(caNcH,
                       label: block_caNcH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNcH: // global
           I64[Sp] = block_caNcM_info;
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNcM() //  [R1]
         { info_tbl: [(caNcM,
                       label: block_caNcM_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNcM: // global
           I64[Sp + 16] = block_caNcO_info;
           R2 = P64[Sp + 8];
           _saM6b::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saM6b::P64;
           Sp = Sp + 16;
           call go1_saM5z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNcO() //  [R1]
         { info_tbl: [(caNcO,
                       label: block_caNcO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNcO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNcW; else goto caNcV;
       caNcW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNcV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_saM6j_entry() //  [R1, R2, R3]
         { info_tbl: [(caNdi,
                       label: go2_saM6j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdi: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caNdj; else goto caNdk;
       caNdj: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caNdk: // global
           I64[Sp - 32] = block_caNdb_info;
           _saM6j::P64 = R1;
           _saM5b::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _saM5b::P64;
           P64[Sp - 16] = _saM6j::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNe3; else goto caNdc;
       uaNe3: // global
           call _caNdb(R1) args: 0, res: 0, upd: 0;
       caNdc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNdb() //  [R1]
         { info_tbl: [(caNdb,
                       label: block_caNdb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdb: // global
           if (R1 & 7 == 1) goto uaNdZ; else goto caNdg;
       uaNdZ: // global
           Sp = Sp + 32;
           call _caNdy() args: 0, res: 0, upd: 0;
       caNdg: // global
           I64[Sp - 8] = block_caNdq_info;
           _saM6o::P64 = P64[R1 + 6];
           _saM6p::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _saM6p::P64;
           P64[Sp + 24] = _saM6o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNe1; else goto caNds;
       uaNe1: // global
           call _caNdq(R1) args: 0, res: 0, upd: 0;
       caNds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNdq() //  [R1]
         { info_tbl: [(caNdq,
                       label: block_caNdq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdq: // global
           if (R1 & 7 == 1) goto uaNe0; else goto caNdR;
       uaNe0: // global
           Sp = Sp + 40;
           call _caNdy() args: 0, res: 0, upd: 0;
       caNdR: // global
           I64[Sp - 8] = block_caNdB_info;
           _saM6s::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNe4; else goto caNdC;
       uaNe4: // global
           call _caNdB(R1) args: 0, res: 0, upd: 0;
       caNdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNdy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdy: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNdB() //  [R1]
         { info_tbl: [(caNdB,
                       label: block_caNdB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdB: // global
           I64[Sp] = block_caNdG_info;
           _saM6u::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saM6u::P64;
           if (R1 & 7 != 0) goto uaNe6; else goto caNdH;
       uaNe6: // global
           call _caNdG(R1) args: 0, res: 0, upd: 0;
       caNdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNdG() //  [R1]
         { info_tbl: [(caNdG,
                       label: block_caNdG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdG: // global
           I64[Sp] = block_caNdL_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNdL() //  [R1]
         { info_tbl: [(caNdL,
                       label: block_caNdL_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdL: // global
           _saM6j::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caNdN_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           _saM6z::P64 = R1;
           R1 = _saM6j::P64;
           P64[Sp + 40] = _saM6z::P64;
           Sp = Sp + 32;
           call go2_saM6j_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNdN() //  [R1]
         { info_tbl: [(caNdN,
                       label: block_caNdN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNdN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNdX; else goto caNdW;
       caNdX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNdW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7k_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(caNej,
                       label: sat_saM7k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNej: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caNex; else goto caNey;
       caNex: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caNey: // global
           I64[Sp - 32] = block_caNeg_info;
           _saM5b::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _saM5b::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNfb; else goto caNeh;
       uaNfb: // global
           call _caNeg(R1) args: 0, res: 0, upd: 0;
       caNeh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNeg() //  [R1]
         { info_tbl: [(caNeg,
                       label: block_caNeg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNeg: // global
           I64[Sp - 16] = block_caNem_info;
           _saM6S::P64 = P64[R1 + 23];
           _saM6U::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saM6U::P64;
           P64[Sp] = _saM6S::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNfa; else goto caNen;
       uaNfa: // global
           call _caNem(R1) args: 0, res: 0, upd: 0;
       caNen: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNem() //  [R1]
         { info_tbl: [(caNem,
                       label: block_caNem_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNem: // global
           I64[Sp - 8] = block_caNer_info;
           _saM73::P64 = R1;
           _saM74::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM74::I64;
           P64[Sp + 16] = _saM73::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNfc; else goto caNes;
       uaNfc: // global
           call _caNer(R1) args: 0, res: 0, upd: 0;
       caNes: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNer() //  [R1]
         { info_tbl: [(caNer,
                       label: block_caNer_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNer: // global
           I64[Sp - 8] = block_caNew_info;
           _saM75::P64 = R1;
           _saM76::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saM76::I64;
           P64[Sp + 32] = _saM75::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNfd; else goto caNeC;
       uaNfd: // global
           call _caNew(R1) args: 0, res: 0, upd: 0;
       caNeC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNew() //  [R1]
         { info_tbl: [(caNew,
                       label: block_caNew_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNew: // global
           _saM73::P64 = P64[Sp + 32];
           _saM74::I64 = I64[Sp + 16];
           _saM75::P64 = P64[Sp + 40];
           _saM79::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saM74::I64,
                            _saM79::I64)) goto caNeT; else goto caNf9;
       caNf9: // global
           if (%MO_S_Gt_W64(_saM79::I64,
                            I64[Sp + 8])) goto caNeT; else goto caNf5;
       caNeT: // global
           R4 = _saM79::I64;
           R3 = _saM73::P64;
           R2 = _saM75::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caNf5: // global
           _saM7g::P64 = P64[P64[Sp + 24] + ((_saM79::I64 - _saM74::I64 << 3) + 24)];
           I64[Sp + 40] = block_caNeZ_info;
           R1 = _saM7g::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaNfe; else goto caNf0;
       uaNfe: // global
           call _caNeZ(R1) args: 0, res: 0, upd: 0;
       caNf0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNeZ() //  [R1]
         { info_tbl: [(caNeZ,
                       label: block_caNeZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNeZ: // global
           _saM6M::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caNf4_info;
           R2 = _saM6M::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNf4() //  []
         { info_tbl: [(caNf4,
                       label: block_caNf4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNf4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7t_entry() //  [R1, R2]
         { info_tbl: [(caNfs,
                       label: sat_saM7t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNfs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNft; else goto caNfu;
       caNft: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNfu: // global
           I64[Sp - 16] = block_caNfq_info;
           _saM7o::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7o::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNfq() //  []
         { info_tbl: [(caNfq,
                       label: block_caNfq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNfq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7n_entry() //  [R1]
         { info_tbl: [(caNfC,
                       label: sat_saM7n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNfC: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7I_entry() //  [R1, R2]
         { info_tbl: [(caNfS,
                       label: sat_saM7I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNfS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNfT; else goto caNfU;
       caNfT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNfU: // global
           I64[Sp - 16] = block_caNfQ_info;
           _saM7D::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7D::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNfQ() //  []
         { info_tbl: [(caNfQ,
                       label: block_caNfQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNfQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7C_entry() //  [R1]
         { info_tbl: [(caNg2,
                       label: sat_saM7C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNg2: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7P_entry() //  [R1]
         { info_tbl: [(caNg9,
                       label: sat_saM7P_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNg9: // global
           _saM7P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caNga; else goto caNgb;
       caNgb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caNgd; else goto caNgc;
       caNgd: // global
           HpAlloc = 64;
           goto caNga;
       caNga: // global
           R1 = _saM7P::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNgc: // global
           _saM5a::P64 = P64[_saM7P::P64 + 7];
           _saM5b::P64 = P64[_saM7P::P64 + 15];
           _saM6K::P64 = P64[_saM7P::P64 + 23];
           I64[Hp - 56] = sat_saM7I_info;
           P64[Hp - 48] = _saM6K::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7C_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_caNg5_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           P64[Sp - 8] = _saM6K::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNg5() //  [R1]
         { info_tbl: [(caNg5,
                       label: block_caNg5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNg5: // global
           I64[Sp] = block_caNg7_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNg7() //  []
         { info_tbl: [(caNg7,
                       label: block_caNg7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNg7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7X_entry() //  [R1, R2]
         { info_tbl: [(caNgo,
                       label: sat_saM7X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNgp; else goto caNgq;
       caNgp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNgq: // global
           I64[Sp - 16] = block_caNgm_info;
           _saM7S::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7S::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNgm() //  []
         { info_tbl: [(caNgm,
                       label: block_caNgm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7R_entry() //  [R1]
         { info_tbl: [(caNgy,
                       label: sat_saM7R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgy: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saM5x_entry() //  [R1]
         { info_tbl: [(caNgB,
                       label: io_saM5x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgB: // global
           _saM5x::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto caNgC; else goto caNgD;
       caNgD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNgF; else goto caNgE;
       caNgF: // global
           HpAlloc = 16;
           goto caNgC;
       caNgC: // global
           R1 = _saM5x::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNgE: // global
           _saM5a::P64 = P64[_saM5x::P64 + 7];
           _saM5b::P64 = P64[_saM5x::P64 + 15];
           _saM5t::P64 = P64[_saM5x::P64 + 23];
           I64[Hp - 8] = go1_saM5z_info;
           P64[Hp] = _saM5b::P64;
           I64[Sp - 32] = block_caNd4_info;
           R2 = _saM5t::P64;
           R1 = Hp - 6;
           P64[Sp - 24] = _saM5a::P64;
           P64[Sp - 16] = _saM5b::P64;
           P64[Sp - 8] = _saM5t::P64;
           Sp = Sp - 32;
           call go1_saM5z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNd4() //  [R1]
         { info_tbl: [(caNd4,
                       label: block_caNd4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNd4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNgI; else goto caNgH;
       caNgI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNgH: // global
           I64[Hp - 8] = go2_saM6j_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_caNe7_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           _saM6i::P64 = R1;
           R1 = Hp - 5;
           P64[Sp] = _saM6i::P64;
           Sp = Sp - 8;
           call go2_saM6j_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNe7() //  [R1]
         { info_tbl: [(caNe7,
                       label: block_caNe7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNe7: // global
           I64[Sp - 8] = block_caNe9_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNe9() //  [R1]
         { info_tbl: [(caNe9,
                       label: block_caNe9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNe9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNgM; else goto caNgL;
       caNgM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNgL: // global
           I64[Hp - 8] = sat_saM7k_info;
           P64[Hp] = P64[Sp + 32];
           _saM6i::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caNff_info;
           R5 = P64[Sp + 8];
           R4 = _saM6i::P64;
           R3 = P64[Sp + 40];
           R2 = Hp - 4;
           I64[Sp + 40] = R1;
           Sp = Sp + 16;
           call GHC.List.zipWith3_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNff() //  [R1]
         { info_tbl: [(caNff,
                       label: block_caNff_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNff: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caNgP; else goto caNgO;
       caNgP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNgO: // global
           _saM5a::P64 = P64[Sp + 8];
           _saM5b::P64 = P64[Sp + 16];
           _saM7l::I64 = I64[Sp + 24];
           if (_saM7l::I64 == 0) goto caNgY; else goto uaNh6;
       caNgY: // global
           I64[Hp - 56] = sat_saM7P_info;
           P64[Hp - 48] = _saM5a::P64;
           P64[Hp - 40] = _saM5b::P64;
           P64[Hp - 32] = R1;
           _caNfG::P64 = Hp - 55;
           Hp = Hp - 32;
           R1 = _caNfG::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uaNh6: // global
           if (_saM7l::I64 == 1) goto caNh2; else goto caNgU;
       caNh2: // global
           I64[Hp - 56] = sat_saM7X_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7R_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caNgZ_info;
           R2 = Hp - 54;
           _saM6K::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saM6K::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caNgU: // global
           I64[Hp - 56] = sat_saM7t_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7n_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caNgQ_info;
           R2 = Hp - 54;
           _saM6K::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saM6K::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNgZ() //  [R1]
         { info_tbl: [(caNgZ,
                       label: block_caNgZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgZ: // global
           I64[Sp] = block_caNh1_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNh1() //  []
         { info_tbl: [(caNh1,
                       label: block_caNh1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNh1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNgQ() //  [R1]
         { info_tbl: [(caNgQ,
                       label: block_caNgQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgQ: // global
           I64[Sp] = block_caNgS_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNgS() //  []
         { info_tbl: [(caNgS,
                       label: block_caNgS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNgS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_saM86_entry() //  [R1, R2]
         { info_tbl: [(caNhk,
                       label: go1_saM86_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNhk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caNhl; else goto caNhm;
       caNhl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNhm: // global
           _saM87::I64 = R2;
           _saM5n::P64 = P64[R1 + 14];
           _saM5p::P64 = P64[R1 + 22];
           _saM5o::I64 = I64[R1 + 30];
           if (%MO_S_Gt_W64(_saM5o::I64, R2)) goto caNhs; else goto caNhj;
       caNhj: // global
           _saM5q::I64 = I64[R1 + 38];
           if (%MO_S_Gt_W64(_saM87::I64,
                            _saM5q::I64)) goto caNhs; else goto caNhz;
       caNhs: // global
           R4 = _saM87::I64;
           R3 = _saM5n::P64;
           R2 = _saM5p::P64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caNhz: // global
           _saM8g::P64 = P64[P64[R1 + 6] + ((_saM87::I64 - _saM5o::I64 << 3) + 24)];
           I64[Sp - 32] = block_caNhy_info;
           _saM86::P64 = R1;
           R1 = _saM8g::P64;
           I64[Sp - 24] = _saM5q::I64;
           P64[Sp - 16] = _saM86::P64;
           I64[Sp - 8] = _saM87::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNih; else goto caNhA;
       uaNih: // global
           call _caNhy(R1) args: 0, res: 0, upd: 0;
       caNhA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNhy() //  [R1]
         { info_tbl: [(caNhy,
                       label: block_caNhy_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNhy: // global
           if (R1 & 7 == 1) goto caNhG; else goto caNhQ;
       caNhG: // global
           Sp = Sp + 32;
           call lvl30_raLJW_entry() args: 8, res: 0, upd: 8;
       caNhQ: // global
           I64[Sp] = block_caNhJ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaNii; else goto caNhK;
       uaNii: // global
           call _caNhJ(R1) args: 0, res: 0, upd: 0;
       caNhK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNhJ() //  [R1]
         { info_tbl: [(caNhJ,
                       label: block_caNhJ_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNhJ: // global
           I64[Sp] = block_caNhO_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaNij; else goto caNhS;
       uaNij: // global
           call _caNhO(R1) args: 0, res: 0, upd: 0;
       caNhS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNhO() //  [R1]
         { info_tbl: [(caNhO,
                       label: block_caNhO_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNhO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNhY; else goto caNhX;
       caNhY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNhX: // global
           _saM87::I64 = I64[Sp + 24];
           if (_saM87::I64 == I64[Sp + 8]) goto caNif; else goto caNi9;
       caNif: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNi9: // global
           Hp = Hp - 24;
           _saM86::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caNi5_info;
           R2 = _saM87::I64 + 1;
           _saM8n::P64 = R1;
           R1 = _saM86::P64;
           P64[Sp + 24] = _saM8n::P64;
           Sp = Sp + 16;
           call go1_saM86_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNi5() //  [R1]
         { info_tbl: [(caNi5,
                       label: block_caNi5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNi5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNic; else goto caNib;
       caNic: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNib: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaNiP_srtd" {
     uaNiP_srtd:
         const SaMem_srt+224;
         const 38;
         const 223338307585;
 },
 GHC.Event.Thread.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caNik,
                       label: GHC.Event.Thread.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNik: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caNil; else goto caNim;
       caNil: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.closeFdWith1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caNim: // global
           I64[Sp - 24] = block_caNba_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaNiN; else goto caNbb;
       uaNiN: // global
           call _caNba(R1) args: 0, res: 0, upd: 0;
       caNbb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNba() //  [R1]
         { info_tbl: [(caNba,
                       label: block_caNba_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNba: // global
           _saM5h::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNbf_info;
           R1 = _saM5h::P64;
           if (R1 & 7 != 0) goto uaNiJ; else goto caNbg;
       uaNiJ: // global
           call _caNbf(R1) args: 0, res: 0, upd: 0;
       caNbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNbf() //  [R1]
         { info_tbl: [(caNbf,
                       label: block_caNbf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNbf: // global
           I64[Sp - 16] = block_caNbk_info;
           _saM5k::P64 = P64[R1 + 15];
           _saM5m::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saM5m::P64;
           P64[Sp] = _saM5k::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNiK; else goto caNbl;
       uaNiK: // global
           call _caNbk(R1) args: 0, res: 0, upd: 0;
       caNbl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNbk() //  [R1]
         { info_tbl: [(caNbk,
                       label: block_caNbk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNbk: // global
           I64[Sp - 8] = block_caNbp_info;
           _saM5n::P64 = R1;
           _saM5o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM5o::I64;
           P64[Sp + 16] = _saM5n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNiL; else goto caNbq;
       uaNiL: // global
           call _caNbp(R1) args: 0, res: 0, upd: 0;
       caNbq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNbp() //  [R1]
         { info_tbl: [(caNbp,
                       label: block_caNbp_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNbp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caNis; else goto caNir;
       caNis: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNir: // global
           _saM5o::I64 = I64[Sp + 8];
           _saM5q::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saM5o::I64,
                            _saM5q::I64)) goto caNiD; else goto caNiG;
       caNiD: // global
           I64[Hp - 40] = go1_saM86_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = _saM5o::I64;
           I64[Hp] = _saM5q::I64;
           I64[Sp + 24] = block_caNiB_info;
           R2 = _saM5o::I64;
           R1 = Hp - 38;
           Sp = Sp + 24;
           call go1_saM86_entry(R2, R1) args: 8, res: 8, upd: 8;
       caNiG: // global
           Hp = Hp - 48;
           P64[Sp + 24] = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call _saM5r() args: 0, res: 0, upd: 0;
     }
 },
 _caNiB() //  [R1]
         { info_tbl: [(caNiB,
                       label: block_caNiB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNiB: // global
           P64[Sp] = R1;
           call _saM5r() args: 0, res: 0, upd: 0;
     }
 },
 _saM5r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saM5r: // global
           I64[Sp - 8] = block_caNbz_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNbz() //  [R1]
         { info_tbl: [(caNbz,
                       label: block_caNbz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNbz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNiw; else goto caNiv;
       caNiw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNiv: // global
           I64[Hp - 24] = io_saM5x_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _caNbB::P64 = Hp - 23;
           if (R1 == 0) goto caNiA; else goto caNiz;
       caNiA: // global
           R1 = _caNbB::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caNiz: // global
           R1 = _caNbB::P64;
           Sp = Sp + 32;
           call io_saM5x_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.557561134 UTC

[section ""data" . GHC.Event.Thread.closeFdWith_closure" {
     GHC.Event.Thread.closeFdWith_closure:
         const GHC.Event.Thread.closeFdWith_info;
         const 0;
 },
 GHC.Event.Thread.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caNiU,
                       label: GHC.Event.Thread.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNiU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.558611311 UTC

[section ""data" . GHC.Event.Thread.registerDelay2_closure" {
     GHC.Event.Thread.registerDelay2_closure:
         const GHC.Event.Thread.registerDelay2_info;
 },
 GHC.Event.Thread.registerDelay2_entry() //  []
         { info_tbl: [(caNj4,
                       label: GHC.Event.Thread.registerDelay2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNj4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNj5; else goto caNj6;
       caNj5: // global
           R1 = GHC.Event.Thread.registerDelay2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNj6: // global
           I64[Sp - 8] = block_caNj1_info;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNj1() //  [R1]
         { info_tbl: [(caNj1,
                       label: block_caNj1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNj1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNj9; else goto caNj8;
       caNj9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNj8: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.56253365 UTC

[section ""data" . GHC.Event.Thread.$wregisterDelay_closure" {
     GHC.Event.Thread.$wregisterDelay_closure:
         const GHC.Event.Thread.$wregisterDelay_info;
         const 0;
 },
 w1_saM9g_entry() //  [R1]
         { info_tbl: [(caNjG,
                       label: w1_saM9g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNjK; else goto caNjL;
       caNjK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNjL: // global
           I64[Sp - 8] = block_caNjD_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNjP; else goto caNjE;
       uaNjP: // global
           call _caNjD(R1) args: 0, res: 0, upd: 0;
       caNjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNjD() //  [R1]
         { info_tbl: [(caNjD,
                       label: block_caNjD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjD: // global
           I64[Sp] = block_caNjJ_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNjJ() //  []
         { info_tbl: [(caNjJ,
                       label: block_caNjJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saM9q_entry() //  [R1]
         { info_tbl: [(caNjZ,
                       label: w2_saM9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjZ: // global
           R1 = P64[R1 + 7];
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMa6_entry() //  [R1]
         { info_tbl: [(caNkB,
                       label: sat_saMa6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caNkC; else goto caNkD;
       caNkC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNkD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caNkt_info;
           _saM9x::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saM9x::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNly; else goto caNku;
       uaNly: // global
           call _caNkt(R1) args: 0, res: 0, upd: 0;
       caNku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caNkt() //  [R1]
         { info_tbl: [(caNkt,
                       label: block_caNkt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkt: // global
           _caNkA::P64 = R1 & 7;
           if (_caNkA::P64 < 3) goto uaNlp; else goto uaNls;
       uaNlp: // global
           _saM9x::P64 = P64[Sp + 8];
           if (_caNkA::P64 < 2) goto caNkx; else goto caNky;
       caNkx: // global
           I64[Sp] = block_caNkG_info;
           _saM9A::I64 = I64[R1 + 39];
           R1 = _saM9x::P64;
           I64[Sp + 8] = _saM9A::I64;
           if (R1 & 7 != 0) goto uaNlv; else goto caNkI;
       uaNlv: // global
           call _caNkG(R1) args: 0, res: 0, upd: 0;
       caNkI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caNky: // global
           I64[Sp] = block_caNkZ_info;
           _saM9S::I64 = I64[R1 + 22];
           R1 = _saM9x::P64;
           I64[Sp + 8] = _saM9S::I64;
           if (R1 & 7 != 0) goto uaNlw; else goto caNl1;
       uaNlw: // global
           call _caNkZ(R1) args: 0, res: 0, upd: 0;
       caNl1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaNls: // global
           Sp = Sp + 16;
           call _caNkz() args: 0, res: 0, upd: 0;
     }
 },
 _caNkG() //  [R1]
         { info_tbl: [(caNkG,
                       label: block_caNkG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkG: // global
           _caNlm::P64 = R1 & 7;
           if (_caNlm::P64 < 3) goto uaNlq; else goto uaNlt;
       uaNlq: // global
           _saM9A::I64 = I64[Sp + 8];
           if (_caNlm::P64 < 2) goto caNkO; else goto caNkS;
       caNkO: // global
           R1 = I64[((_saM9A::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNkS: // global
           R1 = I64[((_saM9A::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaNlt: // global
           Sp = Sp + 16;
           call _caNkz() args: 0, res: 0, upd: 0;
     }
 },
 _caNkZ() //  [R1]
         { info_tbl: [(caNkZ,
                       label: block_caNkZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkZ: // global
           _caNlj::P64 = R1 & 7;
           if (_caNlj::P64 < 3) goto uaNlr; else goto uaNlu;
       uaNlr: // global
           _saM9S::I64 = I64[Sp + 8];
           if (_caNlj::P64 < 2) goto caNl7; else goto caNlb;
       caNl7: // global
           R1 = I64[((_saM9S::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNlb: // global
           R1 = I64[((_saM9S::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaNlu: // global
           Sp = Sp + 16;
           call _caNkz() args: 0, res: 0, upd: 0;
     }
 },
 _caNkz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkz: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMa7_entry() //  [R1, R2]
         { info_tbl: [(caNlB,
                       label: sat_saMa7_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNlB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caNlD; else goto caNlE;
       caNlD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNlE: // global
           I64[Sp - 40] = block_caNkh_info;
           R3 = R2;
           _saM9v::P64 = R2;
           R2 = P64[R1 + 15];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saM9v::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNkh() //  [R1]
         { info_tbl: [(caNkh,
                       label: block_caNkh_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkh: // global
           _saM9s::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caNkl_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saM9s::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNkl() //  [R1]
         { info_tbl: [(caNkl,
                       label: block_caNkl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNkl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caNlI; else goto caNlH;
       caNlI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNlH: // global
           I64[Hp - 48] = sat_saMa6_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.$wregisterDelay_entry() //  [R2]
         { info_tbl: [(caNlJ,
                       label: GHC.Event.Thread.$wregisterDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNlJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caNlK; else goto caNlL;
       caNlK: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wregisterDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNlL: // global
           I64[Sp - 16] = block_caNje_info;
           R1 = GHC.Event.Thread.registerDelay2_closure+1;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNje() //  [R1]
         { info_tbl: [(caNje,
                       label: block_caNje_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNje: // global
           I64[Sp - 8] = block_caNjg_info;
           _saM8U::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp] = _saM8U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNni; else goto caNjh;
       uaNni: // global
           call _caNjg(R1) args: 0, res: 0, upd: 0;
       caNjh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNjg() //  [R1]
         { info_tbl: [(caNjg,
                       label: block_caNjg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjg: // global
           _saM8Z::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNjl_info;
           R1 = _saM8Z::P64;
           if (R1 & 7 != 0) goto uaNnj; else goto caNjm;
       uaNnj: // global
           call _caNjl(R1) args: 0, res: 0, upd: 0;
       caNjm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNjl() //  [R1]
         { info_tbl: [(caNjl,
                       label: block_caNjl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjl: // global
           if (R1 & 7 == 1) goto caNlR; else goto caNlT;
       caNlR: // global
           Sp = Sp + 24;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caNlT: // global
           I64[Sp] = block_caNjr_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaNnk; else goto caNjs;
       uaNnk: // global
           call _caNjr(R1) args: 0, res: 0, upd: 0;
       caNjs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNjr() //  [R1]
         { info_tbl: [(caNjr,
                       label: block_caNjr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNjr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caNlW; else goto caNlV;
       caNlW: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNlV: // global
           _saM8Q::I64 = I64[Sp + 16];
           _saM8U::P64 = P64[Sp + 8];
           _saM95::P64 = P64[R1 + 15];
           _saM9c::P64 = P64[R1 + 47];
           _saM9a::I64 = I64[R1 + 71];
           (_saM9f::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 80] = w1_saM9g_info;
           P64[Hp - 72] = _saM8U::P64;
           _caNjy::P64 = Hp - 79;
           if (%MO_S_Gt_W64(_saM8Q::I64, 0)) goto caNm1; else goto caNn9;
       caNm1: // global
           (_saM9p::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 64] = w2_saM9q_info;
           P64[Hp - 56] = _caNjy::P64;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _saM9f::I64;
           I64[Hp - 32] = sat_saMa7_info;
           P64[Hp - 24] = Hp - 63;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saM9f::I64;
           I64[Hp] = _saM8Q::I64 * 1000 + _saM9p::I64;
           I64[Sp - 8] = block_caNlX_info;
           R2 = Hp - 31;
           R1 = _saM95::P64;
           P64[Sp] = _saM9c::P64;
           I64[Sp + 16] = _saM9a::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caNn9: // global
           Hp = Hp - 72;
           I64[Sp] = block_caNn8_info;
           R1 = _caNjy::P64;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNlX() //  [R1]
         { info_tbl: [(caNlX,
                       label: block_caNlX_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNlX: // global
           I64[Sp] = block_caNlZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaNnl; else goto caNm3;
       uaNnl: // global
           call _caNlZ(R1) args: 0, res: 0, upd: 0;
       caNm3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNlZ() //  [R1]
         { info_tbl: [(caNlZ,
                       label: block_caNlZ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNlZ: // global
           if (R1 & 7 == 1) goto uaNnf; else goto caNn6;
       uaNnf: // global
           Sp = Sp + 16;
           goto uaNno;
       caNn6: // global
           _saM9c::P64 = P64[Sp + 8];
           (_saMag::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 24])), 1);
           if (%MO_SS_Conv_W64_W32(_saMag::I64) == 0 :: W32) goto uaNng; else goto caNms;
       uaNng: // global
           Sp = Sp + 16;
           goto uaNno;
       uaNno: // global
           call _caNn2() args: 0, res: 0, upd: 0;
       caNms: // global
           (_saMal::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caNmq_info;
           R1 = P64[_saM9c::P64 + 8];
           I64[Sp + 24] = _saMal::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaNnm; else goto caNmu;
       uaNnm: // global
           call _caNmq(R1) args: 0, res: 0, upd: 0;
       caNmu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNmq() //  [R1]
         { info_tbl: [(caNmq,
                       label: block_caNmq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNmq: // global
           if (R1 & 7 == 1) goto caNmB; else goto caNmZ;
       caNmB: // global
           I64[Sp] = block_caNmy_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caNmZ: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 16]) == 9 :: W32) goto uaNnh; else goto caNmP;
       uaNnh: // global
           Sp = Sp + 8;
           call _caNn2() args: 0, res: 0, upd: 0;
       caNmP: // global
           I64[Sp] = block_caNmN_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNmy() //  []
         { info_tbl: [(caNmy,
                       label: block_caNmy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNmy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNn2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNn2: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNmN() //  []
         { info_tbl: [(caNmN,
                       label: block_caNmN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNmN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNn8() //  []
         { info_tbl: [(caNn8,
                       label: block_caNn8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNn8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.568893277 UTC

[section ""data" . GHC.Event.Thread.registerDelay1_closure" {
     GHC.Event.Thread.registerDelay1_closure:
         const GHC.Event.Thread.registerDelay1_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay1_entry() //  [R2]
         { info_tbl: [(caNnx,
                       label: GHC.Event.Thread.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNnx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNny; else goto caNnz;
       caNny: // global
           R2 = R2;
           R1 = GHC.Event.Thread.registerDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNnz: // global
           I64[Sp - 8] = block_caNnu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNnD; else goto caNnv;
       uaNnD: // global
           call _caNnu(R1) args: 0, res: 0, upd: 0;
       caNnv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNnu() //  [R1]
         { info_tbl: [(caNnu,
                       label: block_caNnu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNnu: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wregisterDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.570046934 UTC

[section ""data" . GHC.Event.Thread.registerDelay_closure" {
     GHC.Event.Thread.registerDelay_closure:
         const GHC.Event.Thread.registerDelay_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay_entry() //  [R2]
         { info_tbl: [(caNnI,
                       label: GHC.Event.Thread.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNnI: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.575796405 UTC

[section ""data" . GHC.Event.Thread.$wthreadDelay_closure" {
     GHC.Event.Thread.$wthreadDelay_closure:
         const GHC.Event.Thread.$wthreadDelay_info;
         const 0;
 },
 sat_saMbR_entry() //  [R1]
         { info_tbl: [(caNoM,
                       label: sat_saMbR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNoM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caNoN; else goto caNoO;
       caNoN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNoO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caNoE_info;
           _saMbi::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saMbi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNpJ; else goto caNoF;
       uaNpJ: // global
           call _caNoE(R1) args: 0, res: 0, upd: 0;
       caNoF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caNoE() //  [R1]
         { info_tbl: [(caNoE,
                       label: block_caNoE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNoE: // global
           _caNoL::P64 = R1 & 7;
           if (_caNoL::P64 < 3) goto uaNpA; else goto uaNpD;
       uaNpA: // global
           _saMbi::P64 = P64[Sp + 8];
           if (_caNoL::P64 < 2) goto caNoI; else goto caNoJ;
       caNoI: // global
           I64[Sp] = block_caNoR_info;
           _saMbl::I64 = I64[R1 + 39];
           R1 = _saMbi::P64;
           I64[Sp + 8] = _saMbl::I64;
           if (R1 & 7 != 0) goto uaNpG; else goto caNoT;
       uaNpG: // global
           call _caNoR(R1) args: 0, res: 0, upd: 0;
       caNoT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caNoJ: // global
           I64[Sp] = block_caNpa_info;
           _saMbD::I64 = I64[R1 + 22];
           R1 = _saMbi::P64;
           I64[Sp + 8] = _saMbD::I64;
           if (R1 & 7 != 0) goto uaNpH; else goto caNpc;
       uaNpH: // global
           call _caNpa(R1) args: 0, res: 0, upd: 0;
       caNpc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaNpD: // global
           Sp = Sp + 16;
           call _caNoK() args: 0, res: 0, upd: 0;
     }
 },
 _caNoR() //  [R1]
         { info_tbl: [(caNoR,
                       label: block_caNoR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNoR: // global
           _caNpx::P64 = R1 & 7;
           if (_caNpx::P64 < 3) goto uaNpB; else goto uaNpE;
       uaNpB: // global
           _saMbl::I64 = I64[Sp + 8];
           if (_caNpx::P64 < 2) goto caNoZ; else goto caNp3;
       caNoZ: // global
           R1 = I64[((_saMbl::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNp3: // global
           R1 = I64[((_saMbl::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaNpE: // global
           Sp = Sp + 16;
           call _caNoK() args: 0, res: 0, upd: 0;
     }
 },
 _caNpa() //  [R1]
         { info_tbl: [(caNpa,
                       label: block_caNpa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNpa: // global
           _caNpu::P64 = R1 & 7;
           if (_caNpu::P64 < 3) goto uaNpC; else goto uaNpF;
       uaNpC: // global
           _saMbD::I64 = I64[Sp + 8];
           if (_caNpu::P64 < 2) goto caNpi; else goto caNpm;
       caNpi: // global
           R1 = I64[((_saMbD::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNpm: // global
           R1 = I64[((_saMbD::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaNpF: // global
           Sp = Sp + 16;
           call _caNoK() args: 0, res: 0, upd: 0;
     }
 },
 _caNoK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNoK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMbS_entry() //  [R1, R2]
         { info_tbl: [(caNpM,
                       label: sat_saMbS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNpM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNpO; else goto caNpP;
       caNpO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNpP: // global
           I64[Sp - 16] = block_caNow_info;
           R3 = R2;
           _saMbh::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _saMbh::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNow() //  [R1]
         { info_tbl: [(caNow,
                       label: block_caNow_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNow: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caNpS; else goto caNpR;
       caNpS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNpR: // global
           I64[Hp - 48] = sat_saMbR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMci_entry() //  [R1, R2]
         { info_tbl: [(caNq2,
                       label: sat_saMci_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNq2: // global
           _saMbf::P64 = R2;
           _saMci::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto caNq3; else goto caNq4;
       caNq4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNq6; else goto caNq5;
       caNq6: // global
           HpAlloc = 16;
           goto caNq3;
       caNq3: // global
           R2 = _saMbf::P64;
           R1 = _saMci::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNq5: // global
           _saMaY::P64 = P64[_saMci::P64 + 6];
           _saMb5::P64 = P64[_saMci::P64 + 14];
           _saMbc::P64 = P64[_saMci::P64 + 22];
           _saMb3::I64 = I64[_saMci::P64 + 30];
           I64[Hp - 8] = sat_saMbS_info;
           P64[Hp] = _saMbc::P64;
           I64[Sp - 32] = block_caNpT_info;
           R2 = Hp - 7;
           R1 = _saMaY::P64;
           I64[Sp - 24] = _saMb3::I64;
           P64[Sp - 16] = _saMb5::P64;
           P64[Sp - 8] = _saMbf::P64;
           Sp = Sp - 32;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNpT() //  [R1]
         { info_tbl: [(caNpT,
                       label: block_caNpT_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNpT: // global
           I64[Sp] = block_caNpV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaNrb; else goto caNpW;
       uaNrb: // global
           call _caNpV(R1) args: 0, res: 0, upd: 0;
       caNpW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNpV() //  [R1]
         { info_tbl: [(caNpV,
                       label: block_caNpV_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNpV: // global
           if (R1 & 7 == 1) goto uaNr8; else goto caNq0;
       uaNr8: // global
           Sp = Sp + 24;
           goto uaNre;
       caNq0: // global
           _saMb5::P64 = P64[Sp + 16];
           (_saMc1::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saMc1::I64) == 0 :: W32) goto uaNr9; else goto caNqt;
       uaNr9: // global
           Sp = Sp + 24;
           goto uaNre;
       uaNre: // global
           call _caNr3() args: 0, res: 0, upd: 0;
       caNqt: // global
           (_saMc6::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caNqr_info;
           R1 = P64[_saMb5::P64 + 8];
           I64[Sp + 16] = _saMc6::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaNrc; else goto caNqv;
       uaNrc: // global
           call _caNqr(R1) args: 0, res: 0, upd: 0;
       caNqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNqr() //  [R1]
         { info_tbl: [(caNqr,
                       label: block_caNqr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNqr: // global
           if (R1 & 7 == 1) goto caNqC; else goto caNr0;
       caNqC: // global
           I64[Sp + 8] = block_caNqz_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caNr0: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaNra; else goto caNqQ;
       uaNra: // global
           Sp = Sp + 16;
           call _caNr3() args: 0, res: 0, upd: 0;
       caNqQ: // global
           I64[Sp + 8] = block_caNqO_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNqz() //  []
         { info_tbl: [(caNqz,
                       label: block_caNqz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNqz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNr3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNr3: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNqO() //  []
         { info_tbl: [(caNqO,
                       label: block_caNqO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNqO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMbe_entry() //  [R1]
         { info_tbl: [(caNrl,
                       label: sat_saMbe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNrl: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 w1_saMco_entry() //  [R1]
         { info_tbl: [(caNrz,
                       label: w1_saMco_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNrz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNrA; else goto caNrB;
       caNrA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNrB: // global
           I64[Sp - 8] = block_caNrx_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNrx() //  []
         { info_tbl: [(caNrx,
                       label: block_caNrx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNrx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMd5_entry() //  [R1]
         { info_tbl: [(caNsb,
                       label: sat_saMd5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNsb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caNsc; else goto caNsd;
       caNsc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNsd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caNs3_info;
           _saMcw::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saMcw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNt8; else goto caNs4;
       uaNt8: // global
           call _caNs3(R1) args: 0, res: 0, upd: 0;
       caNs4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caNs3() //  [R1]
         { info_tbl: [(caNs3,
                       label: block_caNs3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNs3: // global
           _caNsa::P64 = R1 & 7;
           if (_caNsa::P64 < 3) goto uaNsZ; else goto uaNt2;
       uaNsZ: // global
           _saMcw::P64 = P64[Sp + 8];
           if (_caNsa::P64 < 2) goto caNs7; else goto caNs8;
       caNs7: // global
           I64[Sp] = block_caNsg_info;
           _saMcz::I64 = I64[R1 + 39];
           R1 = _saMcw::P64;
           I64[Sp + 8] = _saMcz::I64;
           if (R1 & 7 != 0) goto uaNt5; else goto caNsi;
       uaNt5: // global
           call _caNsg(R1) args: 0, res: 0, upd: 0;
       caNsi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caNs8: // global
           I64[Sp] = block_caNsz_info;
           _saMcR::I64 = I64[R1 + 22];
           R1 = _saMcw::P64;
           I64[Sp + 8] = _saMcR::I64;
           if (R1 & 7 != 0) goto uaNt6; else goto caNsB;
       uaNt6: // global
           call _caNsz(R1) args: 0, res: 0, upd: 0;
       caNsB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaNt2: // global
           Sp = Sp + 16;
           call _caNs9() args: 0, res: 0, upd: 0;
     }
 },
 _caNsg() //  [R1]
         { info_tbl: [(caNsg,
                       label: block_caNsg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNsg: // global
           _caNsW::P64 = R1 & 7;
           if (_caNsW::P64 < 3) goto uaNt0; else goto uaNt3;
       uaNt0: // global
           _saMcz::I64 = I64[Sp + 8];
           if (_caNsW::P64 < 2) goto caNso; else goto caNss;
       caNso: // global
           R1 = I64[((_saMcz::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNss: // global
           R1 = I64[((_saMcz::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaNt3: // global
           Sp = Sp + 16;
           call _caNs9() args: 0, res: 0, upd: 0;
     }
 },
 _caNsz() //  [R1]
         { info_tbl: [(caNsz,
                       label: block_caNsz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNsz: // global
           _caNsT::P64 = R1 & 7;
           if (_caNsT::P64 < 3) goto uaNt1; else goto uaNt4;
       uaNt1: // global
           _saMcR::I64 = I64[Sp + 8];
           if (_caNsT::P64 < 2) goto caNsH; else goto caNsL;
       caNsH: // global
           R1 = I64[((_saMcR::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNsL: // global
           R1 = I64[((_saMcR::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaNt4: // global
           Sp = Sp + 16;
           call _caNs9() args: 0, res: 0, upd: 0;
     }
 },
 _caNs9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNs9: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMd6_entry() //  [R1, R2]
         { info_tbl: [(caNtb,
                       label: sat_saMd6_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNtb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caNtd; else goto caNte;
       caNtd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNte: // global
           I64[Sp - 40] = block_caNrR_info;
           R3 = R2;
           _saMcu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 15];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saMcu::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNrR() //  [R1]
         { info_tbl: [(caNrR,
                       label: block_caNrR_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNrR: // global
           _saMcr::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caNrV_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saMcr::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNrV() //  [R1]
         { info_tbl: [(caNrV,
                       label: block_caNrV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNrV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caNti; else goto caNth;
       caNti: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNth: // global
           I64[Hp - 48] = sat_saMd5_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saMaJ_entry() //  [R1]
         { info_tbl: [(caNtj,
                       label: io_saMaJ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNtj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caNtk; else goto caNtl;
       caNtk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNtl: // global
           I64[Sp - 16] = block_caNnW_info;
           _saMaE::I64 = I64[R1 + 7];
           R1 = GHC.Event.Thread.timerManager_closure;
           I64[Sp - 8] = _saMaE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNv0; else goto caNnX;
       uaNv0: // global
           call _caNnW(R1) args: 0, res: 0, upd: 0;
       caNnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNnW() //  [R1]
         { info_tbl: [(caNnW,
                       label: block_caNnW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNnW: // global
           _saMaP::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNo1_info;
           R1 = _saMaP::P64;
           if (R1 & 7 != 0) goto uaNuX; else goto caNo2;
       uaNuX: // global
           call _caNo1(R1) args: 0, res: 0, upd: 0;
       caNo2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNo1() //  [R1]
         { info_tbl: [(caNo1,
                       label: block_caNo1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNo1: // global
           if (R1 & 7 == 1) goto caNtq; else goto caNts;
       caNtq: // global
           Sp = Sp + 16;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caNts: // global
           I64[Sp - 8] = block_caNo7_info;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caNo7() //  [R1]
         { info_tbl: [(caNo7,
                       label: block_caNo7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNo7: // global
           I64[Sp] = block_caNo9_info;
           _saMaV::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saMaV::P64;
           if (R1 & 7 != 0) goto uaNuY; else goto caNoa;
       uaNuY: // global
           call _caNo9(R1) args: 0, res: 0, upd: 0;
       caNoa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNo9() //  [R1]
         { info_tbl: [(caNo9,
                       label: block_caNo9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNo9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caNtw; else goto caNtv;
       caNtw: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNtv: // global
           _saMaE::I64 = I64[Sp + 16];
           _saMaV::P64 = P64[Sp + 8];
           _saMaY::P64 = P64[R1 + 15];
           _saMb5::P64 = P64[R1 + 47];
           _saMb3::I64 = I64[R1 + 71];
           (_saMb8::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _saMb8::I64;
           _caNog::P64 = Hp - 63;
           if (%MO_S_Gt_W64(_saMaE::I64, 0)) goto caNtE; else goto caNuM;
       caNtE: // global
           (_saMcn::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 48] = w1_saMco_info;
           P64[Hp - 40] = _saMaV::P64;
           I64[Hp - 32] = sat_saMd6_info;
           P64[Hp - 24] = _caNog::P64;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saMb8::I64;
           I64[Hp] = _saMaE::I64 * 1000 + _saMcn::I64;
           I64[Sp - 24] = block_caNtA_info;
           R2 = Hp - 31;
           R1 = _saMaY::P64;
           I64[Sp - 16] = _saMb3::I64;
           P64[Sp - 8] = _saMb5::P64;
           P64[Sp] = _saMaY::P64;
           P64[Sp + 16] = _caNog::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caNuM: // global
           Hp = Hp - 56;
           I64[Sp - 24] = block_caNuL_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saMaV::P64;
           P64[Sp + 16] = _caNog::P64;
           P64[Sp] = _saMaY::P64;
           I64[Sp - 16] = _saMb3::I64;
           P64[Sp - 8] = _saMb5::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNtA() //  [R1]
         { info_tbl: [(caNtA,
                       label: block_caNtA_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNtA: // global
           I64[Sp] = block_caNtC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaNv1; else goto caNtG;
       uaNv1: // global
           call _caNtC(R1) args: 0, res: 0, upd: 0;
       caNtG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNtC() //  [R1]
         { info_tbl: [(caNtC,
                       label: block_caNtC_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNtC: // global
           if (R1 & 7 == 1) goto uaNv4; else goto caNuJ;
       caNuJ: // global
           _saMb5::P64 = P64[Sp + 16];
           (_saMdf::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saMdf::I64) == 0 :: W32) goto uaNv4; else goto caNu5;
       uaNv4: // global
           call _caNuL() args: 0, res: 0, upd: 0;
       caNu5: // global
           (_saMdk::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_caNu3_info;
           R1 = P64[_saMb5::P64 + 8];
           I64[Sp] = _saMdk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNv3; else goto caNu7;
       uaNv3: // global
           call _caNu3(R1) args: 0, res: 0, upd: 0;
       caNu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNu3() //  [R1]
         { info_tbl: [(caNu3,
                       label: block_caNu3_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNu3: // global
           if (R1 & 7 == 1) goto caNue; else goto caNuC;
       caNue: // global
           I64[Sp + 8] = block_caNub_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caNuC: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaNuS; else goto caNus;
       uaNuS: // global
           Sp = Sp + 8;
           call _caNuL() args: 0, res: 0, upd: 0;
       caNus: // global
           I64[Sp + 8] = block_caNuq_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNub() //  []
         { info_tbl: [(caNub,
                       label: block_caNub_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNub: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caNok() args: 0, res: 0, upd: 0;
     }
 },
 _caNuq() //  []
         { info_tbl: [(caNuq,
                       label: block_caNuq_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNuq: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caNok() args: 0, res: 0, upd: 0;
     }
 },
 _caNuL() //  []
         { info_tbl: [(caNuL,
                       label: block_caNuL_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNuL: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caNok() args: 0, res: 0, upd: 0;
     }
 },
 _caNok() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNok: // global
           Hp = Hp + 56;
           _saMbc::P64 = P64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caNtz; else goto caNty;
       caNtz: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_caNoj_info;
           R1 = _saMbc::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNty: // global
           I64[Hp - 48] = sat_saMci_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _saMbc::P64;
           I64[Hp - 16] = I64[Sp];
           I64[Hp - 8] = sat_saMbe_info;
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 46;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNoj() //  [R1]
         { info_tbl: [(caNoj,
                       label: block_caNoj_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNoj: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caNok() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.$wthreadDelay_entry() //  [R2]
         { info_tbl: [(caNvd,
                       label: GHC.Event.Thread.$wthreadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNve; else goto caNvf;
       caNve: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wthreadDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNvf: // global
           I64[Sp - 16] = block_caNnP_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNnP() //  [R1]
         { info_tbl: [(caNnP,
                       label: block_caNnP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNnP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNvi; else goto caNvh;
       caNvi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNvh: // global
           I64[Hp - 8] = io_saMaJ_info;
           I64[Hp] = I64[Sp + 8];
           _caNnR::P64 = Hp - 7;
           if (R1 == 0) goto caNvc; else goto caNvb;
       caNvc: // global
           R1 = _caNnR::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caNvb: // global
           R1 = _caNnR::P64;
           Sp = Sp + 16;
           call io_saMaJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.589922985 UTC

[section ""data" . GHC.Event.Thread.threadDelay1_closure" {
     GHC.Event.Thread.threadDelay1_closure:
         const GHC.Event.Thread.threadDelay1_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay1_entry() //  [R2]
         { info_tbl: [(caNvq,
                       label: GHC.Event.Thread.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNvr; else goto caNvs;
       caNvr: // global
           R2 = R2;
           R1 = GHC.Event.Thread.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNvs: // global
           I64[Sp - 8] = block_caNvn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNvw; else goto caNvo;
       uaNvw: // global
           call _caNvn(R1) args: 0, res: 0, upd: 0;
       caNvo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNvn() //  [R1]
         { info_tbl: [(caNvn,
                       label: block_caNvn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvn: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wthreadDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.591039467 UTC

[section ""data" . GHC.Event.Thread.threadDelay_closure" {
     GHC.Event.Thread.threadDelay_closure:
         const GHC.Event.Thread.threadDelay_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay_entry() //  [R2]
         { info_tbl: [(caNvB,
                       label: GHC.Event.Thread.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvB: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.591760771 UTC

[section ""relreadonly" . SaMem_srt" {
     SaMem_srt:
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.Event.Thread.blockedOnBadFD2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Event.Thread.blockedOnBadFD1_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const restartPollLoop_raLJq_closure;
         const GHC.Arr.$windexError_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
         const lvl4_raLJs_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Thread.$wstartIOManagerThread_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager1_closure;
         const GHC.Arr.negRange_closure;
         const lvl9_raLJx_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
         const GHC.Event.Thread.eventManager_closure;
         const GHC.Event.Thread.numEnabledEventManagers_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
         const GHC.Event.Thread.ioManagerLock_closure;
         const GHC.Event.Thread.timerManagerThreadVar_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const lvl11_raLJz_closure;
         const lvl13_raLJB_closure;
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
         const lvl14_raLJC_closure;
         const lvl15_raLJD_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure;
         const GHC.Event.Thread.getSystemEventManager2_closure;
         const GHC.Event.Thread.getSystemEventManager1_closure;
         const lvl17_raLJF_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const lvl18_raLJG_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl24_raLJM_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const lvl19_raLJH_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const threadWaitReadSTM2_raLJN_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const threadWaitWriteSTM1_raLJO_closure;
         const lvl26_raLJQ_closure;
         const lvl27_raLJR_closure;
         const lvl28_raLJS_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const threadWaitWrite1_raLJT_closure;
         const threadWaitRead2_raLJU_closure;
         const lvl30_raLJW_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Event.Thread.$wregisterDelay_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Event.Thread.$wthreadDelay_closure;
         const GHC.Event.Thread.threadDelay1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.59273433 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:43.593282135 UTC

[section ""data" . lvl1_raLJo_closure" {
     lvl1_raLJo_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.594074354 UTC

[section ""data" . lvl2_raLJp_closure" {
     lvl2_raLJp_closure:
         const lvl2_raLJp_info;
 },
 lvl2_raLJp_entry() //  []
         { info_tbl: [(caNvN,
                       label: lvl2_raLJp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNvO; else goto caNvP;
       caNvO: // global
           R1 = lvl2_raLJp_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNvP: // global
           I64[Sp - 8] = block_caNvI_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caNvI() //  []
         { info_tbl: [(caNvI,
                       label: block_caNvI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvI: // global
           I64[Sp] = block_caNvK_info;
           R1 = lvl1_raLJo_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNvK() //  [R1]
         { info_tbl: [(caNvK,
                       label: block_caNvK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNvK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNvT; else goto caNvS;
       caNvT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNvS: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.595360996 UTC

[section ""data" . GHC.Event.Thread.numEnabledEventManagers_closure" {
     GHC.Event.Thread.numEnabledEventManagers_closure:
         const GHC.Event.Thread.numEnabledEventManagers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.numEnabledEventManagers_entry() //  [R1]
         { info_tbl: [(caNw2,
                       label: GHC.Event.Thread.numEnabledEventManagers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNw2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNw3; else goto caNw4;
       caNw3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNw4: // global
           (_caNvX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNvX::I64 == 0) goto caNvZ; else goto caNvY;
       caNvZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNvY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNvX::I64;
           I64[Sp - 24] = block_caNw0_info;
           Sp = Sp - 24;
           call lvl2_raLJp_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caNw0() //  [R1]
         { info_tbl: [(caNw0,
                       label: block_caNw0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNw0: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.596361411 UTC

[section ""cstring" . GHC.Event.Thread.$trModule4_bytes" {
     GHC.Event.Thread.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.596946132 UTC

[section ""data" . GHC.Event.Thread.$trModule3_closure" {
     GHC.Event.Thread.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.597556033 UTC

[section ""cstring" . GHC.Event.Thread.$trModule2_bytes" {
     GHC.Event.Thread.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,104,114,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.59810636 UTC

[section ""data" . GHC.Event.Thread.$trModule1_closure" {
     GHC.Event.Thread.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.598666568 UTC

[section ""data" . GHC.Event.Thread.$trModule_closure" {
     GHC.Event.Thread.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Thread.$trModule3_closure+1;
         const GHC.Event.Thread.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.599228588 UTC

[section ""cstring" . GHC.Event.Thread.blockedOnBadFD3_bytes" {
     GHC.Event.Thread.blockedOnBadFD3_bytes:
         I8[] [97,119,97,105,116,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.599955098 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD2_closure" {
     GHC.Event.Thread.blockedOnBadFD2_closure:
         const GHC.Event.Thread.blockedOnBadFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD2_entry() //  [R1]
         { info_tbl: [(caNwc,
                       label: GHC.Event.Thread.blockedOnBadFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNwc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNwd; else goto caNwe;
       caNwd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNwe: // global
           (_caNw9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNw9::I64 == 0) goto caNwb; else goto caNwa;
       caNwb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNwa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNw9::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.600970992 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD1_closure" {
     GHC.Event.Thread.blockedOnBadFD1_closure:
         const GHC.Event.Thread.blockedOnBadFD1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD1_entry() //  [R1]
         { info_tbl: [(caNwl,
                       label: GHC.Event.Thread.blockedOnBadFD1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNwl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNwm; else goto caNwn;
       caNwm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNwn: // global
           (_caNwi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNwi::I64 == 0) goto caNwk; else goto caNwj;
       caNwk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNwj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNwi::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = GHC.Event.Thread.blockedOnBadFD2_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.6021103 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD_closure" {
     GHC.Event.Thread.blockedOnBadFD_closure:
         const GHC.Event.Thread.blockedOnBadFD_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD_entry() //  [R1]
         { info_tbl: [(caNwu,
                       label: GHC.Event.Thread.blockedOnBadFD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNwu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNwv; else goto caNww;
       caNwv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNww: // global
           (_caNwr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNwr::I64 == 0) goto caNwt; else goto caNws;
       caNwt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNws: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNwr::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.602992694 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning7_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning7_bytes:
         I8[] [73,79,77,97,110,97,103,101,114,32,111,110,32,99,97,112,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.605723876 UTC

[section ""data" . restartPollLoop_raLJq_closure" {
     restartPollLoop_raLJq_closure:
         const restartPollLoop_raLJq_info;
         const 0;
 },
 sat_saLKx_entry() //  [R1]
         { info_tbl: [(caNx2,
                       label: sat_saLKx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNx2: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKy_entry() //  [R1]
         { info_tbl: [(caNx5,
                       label: sat_saLKy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNx5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNx9; else goto caNx8;
       caNx9: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNx8: // global
           _saLKb::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_saLKx_info;
           P64[Hp] = _saLKb::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKM_entry() //  [R1, R2]
         { info_tbl: [(caNxk,
                       label: sat_saLKM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNxo; else goto caNxp;
       caNxo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNxp: // global
           I64[Sp - 16] = block_caNxh_info;
           _saLKB::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLKB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNxt; else goto caNxi;
       uaNxt: // global
           call _caNxh(R1) args: 0, res: 0, upd: 0;
       caNxi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNxh() //  [R1]
         { info_tbl: [(caNxh,
                       label: block_caNxh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxh: // global
           _saLKB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caNxn_info;
           R2 = I64[R1 + 7];
           R1 = _saLKB::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNxn() //  []
         { info_tbl: [(caNxn,
                       label: block_caNxn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxn: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKF_entry() //  [R1]
         { info_tbl: [(caNxF,
                       label: sat_saLKF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNxG; else goto caNxH;
       caNxG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNxH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caNxC_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caNxC() //  [R1, R2]
         { info_tbl: [(caNxC,
                       label: block_caNxC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNxK; else goto caNxJ;
       caNxK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caNxJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLKG_entry() //  [R1]
         { info_tbl: [(caNxL,
                       label: sat_saLKG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxL: // global
           _saLKG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caNxM; else goto caNxN;
       caNxN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNxP; else goto caNxO;
       caNxP: // global
           HpAlloc = 24;
           goto caNxM;
       caNxM: // global
           R1 = _saLKG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNxO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saLKG::P64;
           _saLKv::I64 = I64[_saLKG::P64 + 16];
           I64[Hp - 16] = sat_saLKF_info;
           I64[Hp] = _saLKv::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 restartPollLoop_raLJq_entry() //  [R2, R3]
         { info_tbl: [(caNxQ,
                       label: restartPollLoop_raLJq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caNxR; else goto caNxS;
       caNxR: // global
           R3 = R3;
           R2 = R2;
           R1 = restartPollLoop_raLJq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caNxS: // global
           I64[Sp - 16] = block_caNwB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNzl; else goto caNwC;
       uaNzl: // global
           call _caNwB(R1) args: 0, res: 0, upd: 0;
       caNwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNwB() //  [R1]
         { info_tbl: [(caNwB,
                       label: block_caNwB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNwB: // global
           I64[Sp - 24] = block_caNwG_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saLKb::P64 = R1;
           _saLKn::P64 = P64[R1 + 63];
           _saLKl::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           I64[Sp - 16] = _saLKl::I64;
           P64[Sp - 8] = _saLKn::P64;
           P64[Sp] = _saLKb::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNwG() //  [R1]
         { info_tbl: [(caNwG,
                       label: block_caNwG_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNwG: // global
           I64[Sp] = block_caNxT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaNzk; else goto caNy9;
       uaNzk: // global
           call _caNxT(R1) args: 0, res: 0, upd: 0;
       caNy9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNxT() //  [R1]
         { info_tbl: [(caNxT,
                       label: block_caNxT_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxT: // global
           if (R1 & 7 == 2) goto caNzc; else goto uaNzf;
       caNzc: // global
           _saLKn::P64 = P64[Sp + 16];
           (_saLKW::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saLKW::I64) == 0 :: W32) goto uaNzg; else goto caNyy;
       uaNzg: // global
           Sp = Sp + 24;
           goto uaNzo;
       caNyy: // global
           (_saLL1::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caNyw_info;
           R1 = P64[_saLKn::P64 + 8];
           I64[Sp + 16] = _saLL1::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaNzm; else goto caNyA;
       uaNzm: // global
           call _caNyw(R1) args: 0, res: 0, upd: 0;
       caNyA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaNzf: // global
           Sp = Sp + 24;
           goto uaNzo;
       uaNzo: // global
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _caNyw() //  [R1]
         { info_tbl: [(caNyw,
                       label: block_caNyw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNyw: // global
           if (R1 & 7 == 1) goto caNyH; else goto caNz5;
       caNyH: // global
           I64[Sp + 8] = block_caNyE_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caNz5: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaNzh; else goto caNyV;
       uaNzh: // global
           Sp = Sp + 16;
           call _saLKs() args: 0, res: 0, upd: 0;
       caNyV: // global
           I64[Sp + 8] = block_caNyT_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNyE() //  []
         { info_tbl: [(caNyE,
                       label: block_caNyE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNyE: // global
           Sp = Sp + 8;
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _caNyT() //  []
         { info_tbl: [(caNyT,
                       label: block_caNyT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNyT: // global
           Sp = Sp + 8;
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _saLKs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLKs: // global
           I64[Sp - 8] = block_caNwN_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNzs; else goto caNwO;
       uaNzs: // global
           call _caNwN(R1) args: 0, res: 0, upd: 0;
       caNwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNwN() //  [R1]
         { info_tbl: [(caNwN,
                       label: block_caNwN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNwN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNy2; else goto caNy1;
       caNy2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNy1: // global
           _saLKv::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_saLKy_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caNxa_info;
           R2 = Hp - 7;
           R1 = _saLKv::I64;
           I64[Sp + 16] = _saLKv::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNxa() //  [R1]
         { info_tbl: [(caNxa,
                       label: block_caNxa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNy5; else goto caNy4;
       caNy5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNy4: // global
           I64[Hp - 32] = sat_saLKM_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saLKG_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_caNxW_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 8] = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNxW() //  [R1]
         { info_tbl: [(caNxW,
                       label: block_caNxW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNxW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNy8; else goto caNy7;
       caNy8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNy7: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.610511623 UTC

[section ""cstring" . lvl3_raLJr_bytes" {
     lvl3_raLJr_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.611260155 UTC

[section ""data" . lvl4_raLJs_closure" {
     lvl4_raLJs_closure:
         const lvl4_raLJs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raLJs_entry() //  [R1]
         { info_tbl: [(caNzz,
                       label: lvl4_raLJs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNzz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNzA; else goto caNzB;
       caNzA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNzB: // global
           (_caNzw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNzw::I64 == 0) goto caNzy; else goto caNzx;
       caNzy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNzx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNzw::I64;
           R2 = lvl3_raLJr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.612375726 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning8_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning8_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning8_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning8_entry() //  [R2, R3, R4]
         { info_tbl: [(caNzJ,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNzJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caNzN; else goto caNzM;
       caNzN: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caNzM: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R3;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 39;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.615949005 UTC

[section ""data" . GHC.Event.Thread.$wstartIOManagerThread_closure" {
     GHC.Event.Thread.$wstartIOManagerThread_closure:
         const GHC.Event.Thread.$wstartIOManagerThread_info;
         const 0;
 },
 GHC.Event.Thread.$wstartIOManagerThread_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNzP: // global
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM0_entry() //  [R1]
         { info_tbl: [(caNAu,
                       label: sat_saLM0_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAu: // global
           _saLLE::P64 = P64[R1 + 7];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 15])), %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 23])));
           R2 = _saLLE::P64;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM1_entry() //  [R1]
         { info_tbl: [(caNAH,
                       label: sat_saLM1_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNAL; else goto caNAK;
       caNAL: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNAK: // global
           _saLLE::P64 = P64[R1 + 7];
           _saLLm::I64 = I64[R1 + 15];
           _saLLN::I64 = I64[R1 + 23];
           I64[Hp - 24] = sat_saLM0_info;
           P64[Hp - 16] = _saLLE::P64;
           I64[Hp - 8] = _saLLm::I64;
           I64[Hp] = _saLLN::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLMf_entry() //  [R1, R2]
         { info_tbl: [(caNAW,
                       label: sat_saLMf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNB0; else goto caNB1;
       caNB0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNB1: // global
           I64[Sp - 16] = block_caNAT_info;
           _saLM4::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLM4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNB5; else goto caNAU;
       uaNB5: // global
           call _caNAT(R1) args: 0, res: 0, upd: 0;
       caNAU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNAT() //  [R1]
         { info_tbl: [(caNAT,
                       label: block_caNAT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAT: // global
           _saLM4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caNAZ_info;
           R2 = I64[R1 + 7];
           R1 = _saLM4::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNAZ() //  []
         { info_tbl: [(caNAZ,
                       label: block_caNAZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAZ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM8_entry() //  [R1]
         { info_tbl: [(caNBh,
                       label: sat_saLM8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNBi; else goto caNBj;
       caNBi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNBj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caNBe_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caNBe() //  [R1, R2]
         { info_tbl: [(caNBe,
                       label: block_caNBe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNBm; else goto caNBl;
       caNBm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caNBl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLM9_entry() //  [R1]
         { info_tbl: [(caNBn,
                       label: sat_saLM9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBn: // global
           _saLM9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caNBo; else goto caNBp;
       caNBp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNBr; else goto caNBq;
       caNBr: // global
           HpAlloc = 24;
           goto caNBo;
       caNBo: // global
           R1 = _saLM9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNBq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saLM9::P64;
           _saLLm::I64 = I64[_saLM9::P64 + 16];
           I64[Hp - 16] = sat_saLM8_info;
           I64[Hp] = _saLLm::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.$wstartIOManagerThread_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(caNBv,
                       label: GHC.Event.Thread.$wstartIOManagerThread_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBv: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caNBw; else goto caNBx;
       caNBw: // global
           R1 = GHC.Event.Thread.$wstartIOManagerThread_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caNBx: // global
           _saLLm::I64 = R5;
           _saLLk::I64 = R3;
           _saLLj::I64 = R2;
           if (%MO_S_Gt_W64(R2, R5)) goto caNBz; else goto caNBu;
       caNBu: // global
           if (%MO_S_Gt_W64(_saLLm::I64,
                            _saLLk::I64)) goto caNBz; else goto caNBP;
       caNBz: // global
           R4 = _saLLm::I64;
           R3 = _saLLj::I64;
           R2 = _saLLk::I64;
           call GHC.Event.Thread.ensureIOManagerIsRunning8_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
       caNBP: // global
           _saLLv::P64 = P64[(R4 + 24) + (_saLLm::I64 - _saLLj::I64 << 3)];
           I64[Sp - 32] = block_caNBA_info;
           R1 = _saLLv::P64;
           I64[Sp - 24] = _saLLj::I64;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = _saLLm::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaNCM; else goto caNBQ;
       uaNCM: // global
           call _caNBA(R1) args: 0, res: 0, upd: 0;
       caNBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNBA() //  [R1]
         { info_tbl: [(caNBA,
                       label: block_caNBA_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBA: // global
           if (R1 & 7 == 1) goto uaNCI; else goto caNC6;
       uaNCI: // global
           Sp = Sp + 8;
           call _saLLw() args: 0, res: 0, upd: 0;
       caNC6: // global
           I64[Sp] = block_caNBZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaNCN; else goto caNC0;
       uaNCN: // global
           call _caNBZ(R1) args: 0, res: 0, upd: 0;
       caNC0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNBZ() //  [R1]
         { info_tbl: [(caNBZ,
                       label: block_caNBZ_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBZ: // global
           I64[Sp - 8] = block_caNC4_info;
           _saLMs::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _saLMs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNCP; else goto caNC8;
       uaNCP: // global
           call _caNC4(R1) args: 0, res: 0, upd: 0;
       caNC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNC4() //  [R1]
         { info_tbl: [(caNC4,
                       label: block_caNC4_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNC4: // global
           I64[Sp] = block_caNCc_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNCc() //  [R1]
         { info_tbl: [(caNCc,
                       label: block_caNCc_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNCc: // global
           if (R1 == 16) goto uaNCJ; else goto uaNCH;
       uaNCJ: // global
           Sp = Sp + 16;
           call _saLLw() args: 0, res: 0, upd: 0;
       uaNCH: // global
           if (R1 == 17) goto caNCz; else goto caNCk;
       caNCz: // global
           _saLMs::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 32])), (-1));
           I64[Sp + 8] = block_caNCy_info;
           R2 = _saLMs::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 8, upd: 8;
       caNCk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNCy() //  []
         { info_tbl: [(caNCy,
                       label: block_caNCy_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNCy: // global
           Sp = Sp + 8;
           call _saLLw() args: 0, res: 0, upd: 0;
     }
 },
 _saLLw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLLw: // global
           I64[Sp - 8] = block_caNA9_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caNA9() //  [R1]
         { info_tbl: [(caNA9,
                       label: block_caNA9_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNA9: // global
           I64[Sp] = block_caNAb_info;
           R2 = R1;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNAb() //  [R1]
         { info_tbl: [(caNAb,
                       label: block_caNAb_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAb: // global
           I64[Sp] = block_caNAd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaNCL; else goto caNAe;
       uaNCL: // global
           call _caNAd(R1) args: 0, res: 0, upd: 0;
       caNAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNAd() //  [R1]
         { info_tbl: [(caNAd,
                       label: block_caNAd_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNBH; else goto caNBG;
       caNBH: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNBG: // global
           _saLLN::I64 = I64[R1 + 95];
           I64[Hp - 24] = sat_saLM1_info;
           P64[Hp - 16] = R1;
           _saLLm::I64 = I64[Sp + 24];
           I64[Hp - 8] = _saLLm::I64;
           I64[Hp] = _saLLN::I64;
           I64[Sp - 8] = block_caNAM_info;
           R2 = Hp - 23;
           _saLLE::P64 = R1;
           R1 = _saLLm::I64;
           P64[Sp] = _saLLE::P64;
           Sp = Sp - 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNAM() //  [R1]
         { info_tbl: [(caNAM,
                       label: block_caNAM_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNAM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNBK; else goto caNBJ;
       caNBK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNBJ: // global
           I64[Hp - 32] = sat_saLMf_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saLM9_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp - 8] = block_caNBE_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNBE() //  [R1]
         { info_tbl: [(caNBE,
                       label: block_caNBE_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNBE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caNBO; else goto caNBN;
       caNBO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNBN: // global
           I64[Hp - 48] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLLl::P64 = P64[Sp + 32];
           _saLMj::I64 = I64[Sp + 40] - I64[Sp + 24];
           call MO_WriteBarrier();
           P64[(_saLLl::P64 + 24) + (_saLMj::I64 << 3)] = Hp - 6;
           I64[_saLLl::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLLl::P64 + 24) + ((I64[_saLLl::P64 + 8] << 3) + (_saLMj::I64 >> 7))] = 1 :: W8;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.62286556 UTC

[section ""data" . lvl5_raLJt_closure" {
     lvl5_raLJt_closure:
         const lvl5_raLJt_info;
 },
 sat_saLNh_entry() //  [R1]
         { info_tbl: [(caNDm,
                       label: sat_saLNh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNDm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNDn; else goto caNDo;
       caNDn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNDo: // global
           I64[Sp - 16] = block_caNDd_info;
           _saLMS::P64 = P64[R1 + 7];
           R1 = _saLMS::P64;
           P64[Sp - 8] = _saLMS::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNDd() //  [R1]
         { info_tbl: [(caNDd,
                       label: block_caNDd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNDd: // global
           _saLMS::P64 = P64[Sp + 8];
           (_saLNc::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saLNc::I64) goto caNDl; else goto caNDk;
       caNDl: // global
           R1 = _saLMS::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNDk: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNc::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl5_raLJt_entry() //  []
         { info_tbl: [(caNDw,
                       label: lvl5_raLJt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNDx; else goto caNDy;
       caNDx: // global
           R1 = lvl5_raLJt_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNDy: // global
           I64[Sp - 8] = block_caNCW_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caNCW() //  []
         { info_tbl: [(caNCW,
                       label: block_caNCW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNCW: // global
           I64[Sp] = block_caNCY_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caNCY() //  [R1]
         { info_tbl: [(caNCY,
                       label: block_caNCY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNCY: // global
           I64[Sp - 8] = block_caND0_info;
           R2 = GHC.Base.Nothing_closure+1;
           _saLMN::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLMN::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caND0() //  []
         { info_tbl: [(caND0,
                       label: block_caND0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caND0: // global
           I64[Sp] = block_caND2_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caND2() //  [R1]
         { info_tbl: [(caND2,
                       label: block_caND2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caND2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNDE; else goto caNDD;
       caNDE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNDD: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caND4::P64 = Hp - 23;
           if (R1 == 0) goto caNDv; else goto caNDu;
       caNDv: // global
           I64[Hp - 8] = sat_saLNh_info;
           P64[Hp] = _caND4::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caNDu: // global
           Hp = Hp - 16;
           I64[Sp] = block_caNDF_info;
           R1 = _caND4::P64;
           P64[Sp + 8] = _caND4::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNDF() //  [R1]
         { info_tbl: [(caNDF,
                       label: block_caNDF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNDF: // global
           _caND4::P64 = P64[Sp + 8];
           (_saLN0::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saLN0::I64) goto caNDO; else goto caNDN;
       caNDO: // global
           R1 = _caND4::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNDN: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLN0::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.625222872 UTC

[section ""data" . GHC.Event.Thread.timerManagerThreadVar_closure" {
     GHC.Event.Thread.timerManagerThreadVar_closure:
         const GHC.Event.Thread.timerManagerThreadVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManagerThreadVar_entry() //  [R1]
         { info_tbl: [(caNE0,
                       label: GHC.Event.Thread.timerManagerThreadVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNE0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNE1; else goto caNE2;
       caNE1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNE2: // global
           (_caNDV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNDV::I64 == 0) goto caNDX; else goto caNDW;
       caNDX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNDW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNDV::I64;
           I64[Sp - 24] = block_caNDY_info;
           Sp = Sp - 24;
           call lvl5_raLJt_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caNDY() //  [R1]
         { info_tbl: [(caNDY,
                       label: block_caNDY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNDY: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.626977989 UTC

[section ""data" . lvl6_raLJu_closure" {
     lvl6_raLJu_closure:
         const lvl6_raLJu_info;
 },
 sat_saLNS_entry() //  [R1]
         { info_tbl: [(caNEw,
                       label: sat_saLNS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNEw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNEx; else goto caNEy;
       caNEx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNEy: // global
           I64[Sp - 16] = block_caNEn_info;
           _saLNt::P64 = P64[R1 + 7];
           R1 = _saLNt::P64;
           P64[Sp - 8] = _saLNt::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNEn() //  [R1]
         { info_tbl: [(caNEn,
                       label: block_caNEn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNEn: // global
           _saLNt::P64 = P64[Sp + 8];
           (_saLNN::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saLNN::I64) goto caNEv; else goto caNEu;
       caNEv: // global
           R1 = _saLNt::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNEu: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNN::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl6_raLJu_entry() //  []
         { info_tbl: [(caNEG,
                       label: lvl6_raLJu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNEG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNEH; else goto caNEI;
       caNEH: // global
           R1 = lvl6_raLJu_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNEI: // global
           I64[Sp - 8] = block_caNE8_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caNE8() //  []
         { info_tbl: [(caNE8,
                       label: block_caNE8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNE8: // global
           I64[Sp] = block_caNEa_info;
           R1 = GHC.Base.Nothing_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNEa() //  [R1]
         { info_tbl: [(caNEa,
                       label: block_caNEa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNEa: // global
           I64[Sp - 8] = block_caNEc_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNEc() //  [R1]
         { info_tbl: [(caNEc,
                       label: block_caNEc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNEc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNEN; else goto caNEM;
       caNEN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNEM: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caNEe::P64 = Hp - 23;
           if (R1 == 0) goto caNEF; else goto caNEE;
       caNEF: // global
           I64[Hp - 8] = sat_saLNS_info;
           P64[Hp] = _caNEe::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caNEE: // global
           Hp = Hp - 16;
           I64[Sp] = block_caNEO_info;
           R1 = _caNEe::P64;
           P64[Sp + 8] = _caNEe::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNEO() //  [R1]
         { info_tbl: [(caNEO,
                       label: block_caNEO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNEO: // global
           _caNEe::P64 = P64[Sp + 8];
           (_saLNB::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saLNB::I64) goto caNEX; else goto caNEW;
       caNEX: // global
           R1 = _caNEe::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNEW: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNB::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.629217844 UTC

[section ""data" . GHC.Event.Thread.timerManager_closure" {
     GHC.Event.Thread.timerManager_closure:
         const GHC.Event.Thread.timerManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManager_entry() //  [R1]
         { info_tbl: [(caNF9,
                       label: GHC.Event.Thread.timerManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNF9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNFa; else goto caNFb;
       caNFa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNFb: // global
           (_caNF4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNF4::I64 == 0) goto caNF6; else goto caNF5;
       caNF6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNF5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNF4::I64;
           I64[Sp - 24] = block_caNF7_info;
           Sp = Sp - 24;
           call lvl6_raLJu_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caNF7() //  [R1]
         { info_tbl: [(caNF7,
                       label: block_caNF7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNF7: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.630279739 UTC

[section ""cstring" . lvl7_raLJv_bytes" {
     lvl7_raLJv_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,50,49,54,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.631043741 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager2_closure" {
     GHC.Event.Thread.getSystemTimerManager2_closure:
         const GHC.Event.Thread.getSystemTimerManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager2_entry() //  []
         { info_tbl: [(caNFj,
                       label: GHC.Event.Thread.getSystemTimerManager2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNFj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNFk; else goto caNFl;
       caNFk: // global
           R1 = GHC.Event.Thread.getSystemTimerManager2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNFl: // global
           I64[Sp - 8] = block_caNFh_info;
           R2 = lvl7_raLJv_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNFh() //  [R1]
         { info_tbl: [(caNFh,
                       label: block_caNFh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNFh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.632296993 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager1_closure" {
     GHC.Event.Thread.getSystemTimerManager1_closure:
         const GHC.Event.Thread.getSystemTimerManager1_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager1_entry() //  []
         { info_tbl: [(caNFw,
                       label: GHC.Event.Thread.getSystemTimerManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNFw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNFx; else goto caNFy;
       caNFx: // global
           R1 = GHC.Event.Thread.getSystemTimerManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNFy: // global
           I64[Sp - 8] = block_caNFt_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNFQ; else goto caNFu;
       uaNFQ: // global
           call _caNFt(R1) args: 0, res: 0, upd: 0;
       caNFu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNFt() //  [R1]
         { info_tbl: [(caNFt,
                       label: block_caNFt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNFt: // global
           _saLO3::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNFB_info;
           R1 = _saLO3::P64;
           if (R1 & 7 != 0) goto uaNFP; else goto caNFD;
       uaNFP: // global
           call _caNFB(R1) args: 0, res: 0, upd: 0;
       caNFD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNFB() //  [R1]
         { info_tbl: [(caNFB,
                       label: block_caNFB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNFB: // global
           if (R1 & 7 == 1) goto caNFJ; else goto caNFN;
       caNFJ: // global
           Sp = Sp + 8;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caNFN: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.63366976 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager_closure" {
     GHC.Event.Thread.getSystemTimerManager_closure:
         const GHC.Event.Thread.getSystemTimerManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager_entry() //  []
         { info_tbl: [(caNFV,
                       label: GHC.Event.Thread.getSystemTimerManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNFV: // global
           call GHC.Event.Thread.getSystemTimerManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.635133289 UTC

[section ""data" . lvl8_raLJw_closure" {
     lvl8_raLJw_closure:
         const lvl8_raLJw_info;
 },
 sat_saLOE_entry() //  [R1]
         { info_tbl: [(caNGs,
                       label: sat_saLOE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNGs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNGt; else goto caNGu;
       caNGt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNGu: // global
           I64[Sp - 16] = block_caNGj_info;
           _saLOf::P64 = P64[R1 + 7];
           R1 = _saLOf::P64;
           P64[Sp - 8] = _saLOf::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNGj() //  [R1]
         { info_tbl: [(caNGj,
                       label: block_caNGj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNGj: // global
           _saLOf::P64 = P64[Sp + 8];
           (_saLOz::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saLOz::I64) goto caNGr; else goto caNGq;
       caNGr: // global
           R1 = _saLOf::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNGq: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLOz::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_raLJw_entry() //  []
         { info_tbl: [(caNGC,
                       label: lvl8_raLJw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNGC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNGD; else goto caNGE;
       caNGD: // global
           R1 = lvl8_raLJw_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNGE: // global
           I64[Sp - 8] = block_caNG2_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caNG2() //  []
         { info_tbl: [(caNG2,
                       label: block_caNG2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNG2: // global
           I64[Sp] = block_caNG4_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caNG4() //  [R1]
         { info_tbl: [(caNG4,
                       label: block_caNG4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNG4: // global
           I64[Sp - 8] = block_caNG6_info;
           R2 = GHC.Tuple.()_closure+1;
           _saLOa::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLOa::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNG6() //  []
         { info_tbl: [(caNG6,
                       label: block_caNG6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNG6: // global
           I64[Sp] = block_caNG8_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNG8() //  [R1]
         { info_tbl: [(caNG8,
                       label: block_caNG8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNG8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNGK; else goto caNGJ;
       caNGK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNGJ: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caNGa::P64 = Hp - 23;
           if (R1 == 0) goto caNGB; else goto caNGA;
       caNGB: // global
           I64[Hp - 8] = sat_saLOE_info;
           P64[Hp] = _caNGa::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caNGA: // global
           Hp = Hp - 16;
           I64[Sp] = block_caNGL_info;
           R1 = _caNGa::P64;
           P64[Sp + 8] = _caNGa::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNGL() //  [R1]
         { info_tbl: [(caNGL,
                       label: block_caNGL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNGL: // global
           _caNGa::P64 = P64[Sp + 8];
           (_saLOn::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saLOn::I64) goto caNGU; else goto caNGT;
       caNGU: // global
           R1 = _caNGa::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNGT: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLOn::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.637552276 UTC

[section ""data" . GHC.Event.Thread.ioManagerLock_closure" {
     GHC.Event.Thread.ioManagerLock_closure:
         const GHC.Event.Thread.ioManagerLock_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ioManagerLock_entry() //  [R1]
         { info_tbl: [(caNH6,
                       label: GHC.Event.Thread.ioManagerLock_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNH6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNH7; else goto caNH8;
       caNH7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNH8: // global
           (_caNH1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNH1::I64 == 0) goto caNH3; else goto caNH2;
       caNH3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNH2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNH1::I64;
           I64[Sp - 24] = block_caNH4_info;
           Sp = Sp - 24;
           call lvl8_raLJw_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caNH4() //  [R1]
         { info_tbl: [(caNH4,
                       label: block_caNH4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNH4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.63962164 UTC

[section ""data" . lvl9_raLJx_closure" {
     lvl9_raLJx_closure:
         const lvl9_raLJx_info;
         const 0;
 },
 sat_saLPr_entry() //  [R1]
         { info_tbl: [(caNHR,
                       label: sat_saLPr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNHS; else goto caNHT;
       caNHS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNHT: // global
           I64[Sp - 16] = block_caNHI_info;
           _saLP2::P64 = P64[R1 + 7];
           R1 = _saLP2::P64;
           P64[Sp - 8] = _saLP2::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNHI() //  [R1]
         { info_tbl: [(caNHI,
                       label: block_caNHI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHI: // global
           _saLP2::P64 = P64[Sp + 8];
           (_saLPm::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saLPm::I64) goto caNHQ; else goto caNHP;
       caNHQ: // global
           R1 = _saLP2::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNHP: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLPm::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_raLJx_entry() //  []
         { info_tbl: [(caNHY,
                       label: lvl9_raLJx_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNHZ; else goto caNI0;
       caNHZ: // global
           R1 = lvl9_raLJx_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNI0: // global
           I64[Sp - 8] = block_caNHe_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caNHe() //  []
         { info_tbl: [(caNHe,
                       label: block_caNHe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHe: // global
           _saLON::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]) - 1;
           if (%MO_S_Gt_W64(0, _saLON::I64)) goto caNIt; else goto caNIu;
       caNIt: // global
           _saLOP::I64 = 0;
           goto saLOO;
       caNIu: // global
           _saLOP::I64 = _saLON::I64 + 1;
           goto saLOO;
       saLOO: // global
           if (%MO_S_Ge_W64(_saLOP::I64, 0)) goto caNI4; else goto caNIp;
       caNI4: // global
           I64[Sp - 16] = block_caNHr_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saLOP::I64;
           I64[Sp - 8] = _saLOP::I64;
           I64[Sp] = _saLON::I64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caNIp: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNHr() //  [R1]
         { info_tbl: [(caNHr,
                       label: block_caNHr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caNI7; else goto caNI6;
       caNI7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNI6: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = Hp - 47;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 16] = block_caNHv_info;
           R1 = Hp - 31;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNHv() //  [R1]
         { info_tbl: [(caNHv,
                       label: block_caNHv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHv: // global
           I64[Sp - 8] = block_caNHx_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNHx() //  [R1]
         { info_tbl: [(caNHx,
                       label: block_caNHx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNHx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNIb; else goto caNIa;
       caNIb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNIa: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caNHz::P64 = Hp - 23;
           if (R1 == 0) goto caNIo; else goto caNIe;
       caNIo: // global
           I64[Hp - 8] = sat_saLPr_info;
           P64[Hp] = _caNHz::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caNIe: // global
           Hp = Hp - 16;
           I64[Sp] = block_caNIc_info;
           R1 = _caNHz::P64;
           P64[Sp + 8] = _caNHz::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNIc() //  [R1]
         { info_tbl: [(caNIc,
                       label: block_caNIc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNIc: // global
           _caNHz::P64 = P64[Sp + 8];
           (_saLPa::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saLPa::I64) goto caNIn; else goto caNIm;
       caNIn: // global
           R1 = _caNHz::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNIm: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLPa::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.642471485 UTC

[section ""data" . GHC.Event.Thread.eventManager_closure" {
     GHC.Event.Thread.eventManager_closure:
         const GHC.Event.Thread.eventManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.eventManager_entry() //  [R1]
         { info_tbl: [(caNIJ,
                       label: GHC.Event.Thread.eventManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNIJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNIK; else goto caNIL;
       caNIK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNIL: // global
           (_caNIE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNIE::I64 == 0) goto caNIG; else goto caNIF;
       caNIG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNIF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNIE::I64;
           I64[Sp - 24] = block_caNIH_info;
           Sp = Sp - 24;
           call lvl9_raLJx_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caNIH() //  [R1]
         { info_tbl: [(caNIH,
                       label: block_caNIH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNIH: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.643516912 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning5_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning5_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.644241728 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning4_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning4_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning4_entry() //  [R1]
         { info_tbl: [(caNIT,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNIT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNIU; else goto caNIV;
       caNIU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNIV: // global
           (_caNIQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNIQ::I64 == 0) goto caNIS; else goto caNIR;
       caNIS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNIR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNIQ::I64;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.646708836 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning3_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning3_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning3_info;
         const 0;
 },
 sat_saLPZ_entry() //  [R1]
         { info_tbl: [(caNJx,
                       label: sat_saLPZ_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caNJy; else goto caNJz;
       caNJy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNJz: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 63];
           I64[Sp - 24] = I64[R1 + 71];
           P64[Sp - 16] = P64[R1 + 39];
           P64[Sp - 8] = P64[R1 + 47];
           Sp = Sp - 32;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_saLQ0_entry() //  [R1]
         { info_tbl: [(caNJA,
                       label: sat_saLQ0_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caNJE; else goto caNJD;
       caNJE: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNJD: // global
           _saLPG::P64 = P64[R1 + 7];
           _saLPH::P64 = P64[R1 + 15];
           _saLPI::P64 = P64[R1 + 23];
           _saLPJ::P64 = P64[R1 + 31];
           _saLPN::P64 = P64[R1 + 39];
           _saLPO::P64 = P64[R1 + 47];
           _saLPK::I64 = I64[R1 + 55];
           _saLPL::I64 = I64[R1 + 63];
           _saLPM::I64 = I64[R1 + 71];
           I64[Hp - 72] = sat_saLPZ_info;
           P64[Hp - 64] = _saLPG::P64;
           P64[Hp - 56] = _saLPH::P64;
           P64[Hp - 48] = _saLPI::P64;
           P64[Hp - 40] = _saLPJ::P64;
           P64[Hp - 32] = _saLPN::P64;
           P64[Hp - 24] = _saLPO::P64;
           I64[Hp - 16] = _saLPK::I64;
           I64[Hp - 8] = _saLPL::I64;
           I64[Hp] = _saLPM::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 71;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLQ9_entry() //  [R1, R2]
         { info_tbl: [(caNJP,
                       label: sat_saLQ9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNJT; else goto caNJU;
       caNJT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNJU: // global
           I64[Sp - 16] = block_caNJM_info;
           _saLQ3::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLQ3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNJY; else goto caNJN;
       uaNJY: // global
           call _caNJM(R1) args: 0, res: 0, upd: 0;
       caNJN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNJM() //  [R1]
         { info_tbl: [(caNJM,
                       label: block_caNJM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJM: // global
           _saLQ3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caNJS_info;
           R2 = I64[R1 + 7];
           R1 = _saLQ3::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNJS() //  []
         { info_tbl: [(caNJS,
                       label: block_caNJS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.ensureIOManagerIsRunning3_entry() //  []
         { info_tbl: [(caNJZ,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJZ: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caNK4; else goto caNK5;
       caNK4: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNK5: // global
           I64[Sp - 8] = block_caNJ0_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caNJ0() //  [R1]
         { info_tbl: [(caNJ0,
                       label: block_caNJ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJ0: // global
           I64[Sp] = block_caNJ2_info;
           R2 = R1;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNJ2() //  [R1]
         { info_tbl: [(caNJ2,
                       label: block_caNJ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJ2: // global
           I64[Sp] = block_caNJ4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaNKi; else goto caNJ5;
       uaNKi: // global
           call _caNJ4(R1) args: 0, res: 0, upd: 0;
       caNJ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNJ4() //  [R1]
         { info_tbl: [(caNJ4,
                       label: block_caNJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJ4: // global
           _saLPG::P64 = P64[R1 + 7];
           _saLPH::P64 = P64[R1 + 15];
           _saLPI::P64 = P64[R1 + 23];
           _saLPJ::P64 = P64[R1 + 31];
           _saLPN::P64 = P64[R1 + 39];
           _saLPO::P64 = P64[R1 + 47];
           _saLPK::I64 = I64[R1 + 55];
           _saLPL::I64 = I64[R1 + 63];
           _saLPM::I64 = I64[R1 + 71];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLPL::I64)));
           I64[Sp - 80] = block_caNJe_info;
           _saLPF::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp - 72] = _saLPG::P64;
           P64[Sp - 64] = _saLPH::P64;
           P64[Sp - 56] = _saLPI::P64;
           P64[Sp - 48] = _saLPJ::P64;
           I64[Sp - 40] = _saLPK::I64;
           I64[Sp - 32] = _saLPL::I64;
           I64[Sp - 24] = _saLPM::I64;
           P64[Sp - 16] = _saLPN::P64;
           P64[Sp - 8] = _saLPO::P64;
           P64[Sp] = _saLPF::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uaNKj; else goto caNJf;
       uaNKj: // global
           call _caNJe(R1) args: 0, res: 0, upd: 0;
       caNJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNJe() //  [R1]
         { info_tbl: [(caNJe,
                       label: block_caNJe_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJe: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caNKb; else goto caNKa;
       caNKb: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNKa: // global
           _saLPU::P64 = P64[R1 + 7];
           I64[Hp - 88] = GHC.Base.Just_con_info;
           P64[Hp - 80] = P64[Sp + 80];
           _saLPG::P64 = P64[Sp + 8];
           _saLPH::P64 = P64[Sp + 16];
           _saLPI::P64 = P64[Sp + 24];
           _saLPJ::P64 = P64[Sp + 32];
           _saLPK::I64 = I64[Sp + 40];
           _saLPL::I64 = I64[Sp + 48];
           _saLPM::I64 = I64[Sp + 56];
           _saLPN::P64 = P64[Sp + 64];
           _saLPO::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_saLPU::P64 + 8] = Hp - 86;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLPU::P64);
           I64[Hp - 72] = sat_saLQ0_info;
           P64[Hp - 64] = _saLPG::P64;
           P64[Hp - 56] = _saLPH::P64;
           P64[Hp - 48] = _saLPI::P64;
           P64[Hp - 40] = _saLPJ::P64;
           P64[Hp - 32] = _saLPN::P64;
           P64[Hp - 24] = _saLPO::P64;
           I64[Hp - 16] = _saLPK::I64;
           I64[Hp - 8] = _saLPL::I64;
           I64[Hp] = _saLPM::I64;
           I64[Sp + 80] = block_caNJF_info;
           R1 = Hp - 71;
           Sp = Sp + 80;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNJF() //  [R1]
         { info_tbl: [(caNJF,
                       label: block_caNJF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNJF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNKe; else goto caNKd;
       caNKe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNKd: // global
           I64[Hp - 8] = sat_saLQ9_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_caNK0_info;
           R4 = Hp - 6;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNK0() //  [R1]
         { info_tbl: [(caNK0,
                       label: block_caNK0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNK0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caNKh; else goto caNKg;
       caNKh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNKg: // global
           I64[Hp - 24] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.652154984 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning2_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning2_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning2_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning2_entry() //  [R2]
         { info_tbl: [(caNKv,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNKv: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caNKw; else goto caNKx;
       caNKw: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNKx: // global
           I64[Sp - 8] = block_caNKo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNMi; else goto caNKp;
       uaNMi: // global
           call _caNKo(R1) args: 0, res: 0, upd: 0;
       caNKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNKo() //  [R1]
         { info_tbl: [(caNKo,
                       label: block_caNKo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNKo: // global
           if (R1 & 7 == 1) goto uaNMd; else goto caNKt;
       uaNMd: // global
           Sp = Sp + 8;
           call _caNLa() args: 0, res: 0, upd: 0;
       caNKt: // global
           I64[Sp - 8] = block_caNKD_info;
           _saLQh::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saLQh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNMg; else goto caNKF;
       uaNMg: // global
           call _caNKD(R1) args: 0, res: 0, upd: 0;
       caNKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNKD() //  [R1]
         { info_tbl: [(caNKD,
                       label: block_caNKD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNKD: // global
           I64[Sp] = block_caNKJ_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNKJ() //  [R1]
         { info_tbl: [(caNKJ,
                       label: block_caNKJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNKJ: // global
           if (R1 == 16) goto uaNMe; else goto uaNMc;
       uaNMe: // global
           Sp = Sp + 16;
           call _caNLa() args: 0, res: 0, upd: 0;
       uaNMc: // global
           if (R1 == 17) goto caNKX; else goto caNKR;
       caNKX: // global
           I64[Sp + 8] = block_caNKW_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaNMj; else goto caNKY;
       uaNMj: // global
           call _caNKW(R1) args: 0, res: 0, upd: 0;
       caNKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caNKR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNKW() //  [R1]
         { info_tbl: [(caNKW,
                       label: block_caNKW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNKW: // global
           _saLQv::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNL2_info;
           R1 = _saLQv::P64;
           if (R1 & 7 != 0) goto uaNMl; else goto caNL4;
       uaNMl: // global
           call _caNL2(R1) args: 0, res: 0, upd: 0;
       caNL4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNL2() //  [R1]
         { info_tbl: [(caNL2,
                       label: block_caNL2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNL2: // global
           if (R1 & 7 == 1) goto uaNMf; else goto caNLm;
       uaNMf: // global
           Sp = Sp + 8;
           call _caNLa() args: 0, res: 0, upd: 0;
       caNLm: // global
           _saLQx::P64 = P64[R1 + 6];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd((-1));
           I64[Sp] = block_caNLf_info;
           R1 = _saLQx::P64;
           if (R1 & 7 != 0) goto uaNMm; else goto caNLg;
       uaNMm: // global
           call _caNLf(R1) args: 0, res: 0, upd: 0;
       caNLg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNLa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNLa: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _caNLf() //  [R1]
         { info_tbl: [(caNLf,
                       label: block_caNLf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNLf: // global
           I64[Sp - 48] = block_caNLk_info;
           _saLQE::P64 = P64[R1 + 23];
           _saLQJ::P64 = P64[R1 + 39];
           _saLQK::P64 = P64[R1 + 47];
           _saLQG::I64 = I64[R1 + 55];
           _saLQH::I64 = I64[R1 + 63];
           _saLQI::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _saLQG::I64;
           I64[Sp - 32] = _saLQH::I64;
           I64[Sp - 24] = _saLQI::I64;
           P64[Sp - 16] = _saLQJ::P64;
           P64[Sp - 8] = _saLQK::P64;
           P64[Sp] = _saLQE::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaNMo; else goto caNLo;
       uaNMo: // global
           call _caNLk(R1) args: 0, res: 0, upd: 0;
       caNLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNLk() //  [R1]
         { info_tbl: [(caNLk,
                       label: block_caNLk_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNLk: // global
           _saLQE::P64 = P64[Sp + 48];
           _saLQM::P64 = P64[R1 + 7];
           _saLQQ::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saLQE::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLQE::P64);
           I64[Sp] = block_caNLv_info;
           R2 = _saLQM::P64;
           R1 = _saLQQ::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNLv() //  []
         { info_tbl: [(caNLv,
                       label: block_caNLv_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNLv: // global
           I64[Sp] = block_caNLx_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNLx() //  []
         { info_tbl: [(caNLx,
                       label: block_caNLx_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNLx: // global
           _saLQH::I64 = I64[Sp + 16];
           _saLQJ::P64 = P64[Sp + 32];
           (_saLR2::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saLR7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQH::I64)));
           I64[Sp + 16] = block_caNLM_info;
           R1 = _saLQJ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaNMp; else goto caNLN;
       uaNMp: // global
           call _caNLM(R1) args: 0, res: 0, upd: 0;
       caNLN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNLM() //  [R1]
         { info_tbl: [(caNLM,
                       label: block_caNLM_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNLM: // global
           _saLQI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caNLT; else goto caNLX;
       caNLT: // global
           (_saLRd::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQI::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
       caNLX: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saLRl::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQI::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.659815093 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning6_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning6_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning6_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning6_entry() //  [R2]
         { info_tbl: [(caNMx,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNMx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caNML; else goto caNMM;
       caNML: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNMM: // global
           I64[Sp - 8] = block_caNMu_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNNV; else goto caNMv;
       uaNNV: // global
           call _caNMu(R1) args: 0, res: 0, upd: 0;
       caNMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNMu() //  [R1]
         { info_tbl: [(caNMu,
                       label: block_caNMu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNMu: // global
           _saLRs::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNMA_info;
           R1 = _saLRs::P64;
           if (R1 & 7 != 0) goto uaNNU; else goto caNMB;
       uaNNU: // global
           call _caNMA(R1) args: 0, res: 0, upd: 0;
       caNMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNMA() //  [R1]
         { info_tbl: [(caNMA,
                       label: block_caNMA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNMA: // global
           I64[Sp - 16] = block_caNMF_info;
           _saLRu::P64 = P64[R1 + 7];
           _saLRx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saLRx::P64;
           P64[Sp] = _saLRu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNNW; else goto caNMG;
       uaNNW: // global
           call _caNMF(R1) args: 0, res: 0, upd: 0;
       caNMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNMF() //  [R1]
         { info_tbl: [(caNMF,
                       label: block_caNMF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNMF: // global
           I64[Sp] = block_caNMK_info;
           _saLRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saLRz::I64;
           if (R1 & 7 != 0) goto uaNNX; else goto caNMQ;
       uaNNX: // global
           call _caNMK(R1) args: 0, res: 0, upd: 0;
       caNMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNMK() //  [R1]
         { info_tbl: [(caNMK,
                       label: block_caNMK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNMK: // global
           if (%MO_S_Le_W64(0, I64[Sp + 16])) goto caNNr; else goto caNNu;
       caNNr: // global
           I64[Sp - 8] = 0;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 8;
           call _caNNf() args: 0, res: 0, upd: 0;
       caNNu: // global
           I64[Sp + 8] = block_caNNt_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaNNY; else goto caNNv;
       uaNNY: // global
           call _caNNt(R1) args: 0, res: 0, upd: 0;
       caNNv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNNf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNNf: // global
           I64[Sp - 8] = block_caNNh_info;
           R5 = I64[Sp];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 24];
           R2 = I64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNNh() //  []
         { info_tbl: [(caNNh,
                       label: block_caNNh_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNNh: // global
           _saLRL::I64 = I64[Sp + 8];
           if (_saLRL::I64 == I64[Sp + 32]) goto caNNp; else goto caNNo;
       caNNp: // global
           I64[Sp + 24] = block_caNN3_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaNO0; else goto caNN5;
       uaNO0: // global
           call _caNN3(R1) args: 0, res: 0, upd: 0;
       caNN5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caNNo: // global
           I64[Sp + 8] = _saLRL::I64 + 1;
           Sp = Sp + 8;
           call _caNNf() args: 0, res: 0, upd: 0;
     }
 },
 _caNN3() //  [R1]
         { info_tbl: [(caNN3,
                       label: block_caNN3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNN3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNNb; else goto caNNa;
       caNNb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNNa: // global
           _saLRG::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saLRG::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLRG::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNNt() //  [R1]
         { info_tbl: [(caNNt,
                       label: block_caNNt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNNt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNNB; else goto caNNA;
       caNNB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNNA: // global
           _saLRT::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saLRT::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLRT::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.662930271 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning1_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning1_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning1_entry() //  []
         { info_tbl: [(caNOb,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNOc; else goto caNOd;
       caNOc: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNOd: // global
           (_saLS1::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saLS1::I64 == 0) goto caNOa; else goto caNO9;
       caNOa: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caNO9: // global
           I64[Sp - 8] = block_caNOf_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNOu; else goto caNOg;
       uaNOu: // global
           call _caNOf(R1) args: 0, res: 0, upd: 0;
       caNOg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNOf() //  [R1]
         { info_tbl: [(caNOf,
                       label: block_caNOf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOf: // global
           I64[Sp] = block_caNOk_info;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure+2;
           R2 = P64[R1 + 7];
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNOk() //  []
         { info_tbl: [(caNOk,
                       label: block_caNOk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOk: // global
           I64[Sp] = block_caNOm_info;
           R1 = GHC.Event.Thread.timerManagerThreadVar_closure;
           if (R1 & 7 != 0) goto uaNOv; else goto caNOp;
       uaNOv: // global
           call _caNOm(R1) args: 0, res: 0, upd: 0;
       caNOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNOm() //  [R1]
         { info_tbl: [(caNOm,
                       label: block_caNOm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOm: // global
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.664406758 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caNOA,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOA: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.66504484 UTC

[section ""cstring" . lvl10_raLJy_bytes" {
     lvl10_raLJy_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,53,51,58,49,53,45,50,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.665786853 UTC

[section ""data" . lvl11_raLJz_closure" {
     lvl11_raLJz_closure:
         const lvl11_raLJz_info;
         const 0;
 },
 lvl11_raLJz_entry() //  []
         { info_tbl: [(caNOJ,
                       label: lvl11_raLJz_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNOK; else goto caNOL;
       caNOK: // global
           R1 = lvl11_raLJz_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNOL: // global
           I64[Sp - 8] = block_caNOH_info;
           R2 = lvl10_raLJy_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNOH() //  [R1]
         { info_tbl: [(caNOH,
                       label: block_caNOH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.66667868 UTC

[section ""cstring" . lvl12_raLJA_bytes" {
     lvl12_raLJA_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,51,57,58,49,55,45,51,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.667356521 UTC

[section ""data" . lvl13_raLJB_closure" {
     lvl13_raLJB_closure:
         const lvl13_raLJB_info;
         const 0;
 },
 lvl13_raLJB_entry() //  []
         { info_tbl: [(caNOV,
                       label: lvl13_raLJB_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNOW; else goto caNOX;
       caNOW: // global
           R1 = lvl13_raLJB_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNOX: // global
           I64[Sp - 8] = block_caNOT_info;
           R2 = lvl12_raLJA_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNOT() //  [R1]
         { info_tbl: [(caNOT,
                       label: block_caNOT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNOT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.668410747 UTC

[section ""data" . lvl14_raLJC_closure" {
     lvl14_raLJC_closure:
         const lvl14_raLJC_info;
         const 0;
 },
 lvl14_raLJC_entry() //  [R2, R3, R4]
         { info_tbl: [(caNP5,
                       label: lvl14_raLJC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNP5: // global
           R6 = lvl4_raLJs_closure;
           R5 = R4;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.669302627 UTC

[section ""data" . lvl15_raLJD_closure" {
     lvl15_raLJD_closure:
         const lvl15_raLJD_info;
         const 0;
 },
 lvl15_raLJD_entry() //  [R2, R3]
         { info_tbl: [(caNPc,
                       label: lvl15_raLJD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPc: // global
           R6 = lvl4_raLJs_closure;
           R5 = R3;
           R4 = R2;
           R3 = lvl1_raLJo_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.675253853 UTC

[section ""data" . GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caNR1,
                       label: GHC.Event.Thread.$wioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNR1: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caNR2; else goto caNR3;
       caNR2: // global
           R1 = GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNR3: // global
           _saLSm::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Sp - 16] = block_caNPj_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           I64[Sp - 8] = _saLSm::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNVP; else goto caNPk;
       uaNVP: // global
           call _caNPj(R1) args: 0, res: 0, upd: 0;
       caNPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNPj() //  [R1]
         { info_tbl: [(caNPj,
                       label: block_caNPj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNR6; else goto caNR5;
       caNR6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNR5: // global
           _saLSo::P64 = P64[R1 + 7];
           _saLSr::P64 = P64[_saLSo::P64 + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saLSo::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSo::P64);
           I64[Sp - 8] = block_caNPs_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp] = _saLSr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNVB; else goto caNPt;
       uaNVB: // global
           call _caNPs(R1) args: 0, res: 0, upd: 0;
       caNPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNPs() //  [R1]
         { info_tbl: [(caNPs,
                       label: block_caNPs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPs: // global
           I64[Sp - 8] = block_caNPx_info;
           _saLSv::P64 = P64[R1 + 7];
           R1 = P64[_saLSv::P64 + 8];
           P64[Sp] = _saLSv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNVC; else goto caNPy;
       uaNVC: // global
           call _caNPx(R1) args: 0, res: 0, upd: 0;
       caNPy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNPx() //  [R1]
         { info_tbl: [(caNPx,
                       label: block_caNPx_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPx: // global
           I64[Sp - 16] = block_caNPC_info;
           _saLSA::P64 = P64[R1 + 7];
           _saLSD::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saLSD::P64;
           P64[Sp] = _saLSA::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNVD; else goto caNPD;
       uaNVD: // global
           call _caNPC(R1) args: 0, res: 0, upd: 0;
       caNPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNPC() //  [R1]
         { info_tbl: [(caNPC,
                       label: block_caNPC_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPC: // global
           I64[Sp - 8] = block_caNPH_info;
           _saLSE::P64 = R1;
           _saLSF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLSF::I64;
           P64[Sp + 16] = _saLSE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNVE; else goto caNPI;
       uaNVE: // global
           call _caNPH(R1) args: 0, res: 0, upd: 0;
       caNPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNPH() //  [R1]
         { info_tbl: [(caNPH,
                       label: block_caNPH_info
                       rep:StackRep [True, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPH: // global
           _saLSm::I64 = I64[Sp + 48];
           _saLSH::I64 = I64[R1 + 7];
           _saLSI::I64 = I64[Sp + 8] + 1;
           if (%MO_S_Le_W64(_saLSm::I64,
                            _saLSI::I64)) goto caNRc; else goto caNUY;
       caNRc: // global
           I64[Sp] = block_caNPS_info;
           _saLSG::P64 = R1;
           R1 = P64[Sp + 40];
           I64[Sp + 32] = _saLSH::I64;
           P64[Sp + 40] = _saLSG::P64;
           if (R1 & 7 != 0) goto uaNVF; else goto caNPT;
       uaNVF: // global
           call _caNPS(R1) args: 0, res: 0, upd: 0;
       caNPT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caNUY: // global
           _saLTn::I64 = _saLSm::I64 - 1;
           if (%MO_S_Gt_W64(0, _saLTn::I64)) goto caNUW; else goto caNUX;
       caNUW: // global
           _saLSG::P64 = R1;
           _saLTp::I64 = 0;
           goto saLTo;
       caNUX: // global
           _saLSG::P64 = R1;
           _saLTp::I64 = _saLTn::I64 + 1;
           goto saLTo;
       saLTo: // global
           if (%MO_S_Ge_W64(_saLTp::I64, 0)) goto caNSh; else goto caNUS;
       caNSh: // global
           I64[Sp - 32] = block_caNQB_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saLTp::I64;
           I64[Sp - 24] = _saLSI::I64;
           I64[Sp - 16] = _saLTn::I64;
           I64[Sp - 8] = _saLTp::I64;
           I64[Sp] = _saLSH::I64;
           P64[Sp + 48] = _saLSG::P64;
           Sp = Sp - 32;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caNUS: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNPS() //  [R1]
         { info_tbl: [(caNPS,
                       label: block_caNPS_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNPS: // global
           _saLSm::I64 = I64[Sp + 48];
           _saLSL::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saLSm::I64,
                            _saLSL::I64)) goto uaNVl; else goto caNSe;
       uaNVl: // global
           Sp = Sp + 56;
           goto uaNVH;
       caNSe: // global
           _saLSN::I64 = _saLSm::I64 - 1;
           if (%MO_S_Le_W64(_saLSL::I64,
                            _saLSN::I64)) goto caNSc; else goto uaNVm;
       caNSc: // global
           I64[Sp] = _saLSL::I64;
           I64[Sp + 48] = _saLSN::I64;
           call _caNQe() args: 0, res: 0, upd: 0;
       uaNVm: // global
           Sp = Sp + 56;
           goto uaNVH;
       uaNVH: // global
           call _caNSd() args: 0, res: 0, upd: 0;
     }
 },
 _caNQe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNQe: // global
           Hp = Hp + 16;
           _saLSY::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caNRq; else goto caNRp;
       caNRq: // global
           HpAlloc = 16;
           I64[Sp] = block_caNQd_info;
           R1 = _saLSY::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNRp: // global
           _saLSE::P64 = P64[Sp + 24];
           _saLSG::P64 = P64[Sp + 40];
           _saLSH::I64 = I64[Sp + 32];
           if (%MO_S_Gt_W64(_saLSH::I64,
                            _saLSY::I64)) goto caNRs; else goto caNSa;
       caNRs: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLSY::I64;
           R4 = Hp - 7;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caNSa: // global
           if (%MO_S_Gt_W64(_saLSY::I64,
                            I64[Sp + 8])) goto caNRu; else goto caNRA;
       caNRu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLSY::I64;
           R4 = Hp - 7;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caNRA: // global
           Hp = Hp - 16;
           _saLT7::P64 = P64[P64[Sp + 16] + ((_saLSY::I64 - _saLSH::I64 << 3) + 24)];
           I64[Sp - 8] = block_caNRz_info;
           R1 = _saLT7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNVK; else goto caNRB;
       uaNVK: // global
           call _caNRz(R1) args: 0, res: 0, upd: 0;
       caNRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNQd() //  [R1]
         { info_tbl: [(caNQd,
                       label: block_caNQd_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNQd: // global
           I64[Sp] = R1;
           call _caNQe() args: 0, res: 0, upd: 0;
     }
 },
 _caNRz() //  [R1]
         { info_tbl: [(caNRz,
                       label: block_caNRz_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNRz: // global
           if (R1 & 7 == 1) goto caNRH; else goto caNRM;
       caNRH: // global
           Sp = Sp + 64;
           call lvl11_raLJz_entry() args: 8, res: 0, upd: 8;
       caNRM: // global
           I64[Sp] = block_caNRK_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaNVQ; else goto caNRN;
       uaNVQ: // global
           call _caNRK(R1) args: 0, res: 0, upd: 0;
       caNRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNRK() //  [R1]
         { info_tbl: [(caNRK,
                       label: block_caNRK_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNRK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNRV; else goto caNRU;
       caNRV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNRU: // global
           _saLTc::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_caNRS_info;
           R3 = Hp - 7;
           R2 = _saLTc::P64;
           P64[Sp] = _saLTc::P64;
           Sp = Sp - 8;
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNRS() //  [R1]
         { info_tbl: [(caNRS,
                       label: block_caNRS_info
                       rep:StackRep [False, True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNRS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNRZ; else goto caNRY;
       caNRZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNRY: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLSD::P64 = P64[Sp + 32];
           _saLSN::I64 = I64[Sp + 64];
           _saLSY::I64 = I64[Sp + 16];
           _saLTh::I64 = _saLSY::I64 - I64[Sp + 48];
           call MO_WriteBarrier();
           P64[(_saLSD::P64 + 24) + (_saLTh::I64 << 3)] = Hp - 6;
           I64[_saLSD::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLSD::P64 + 24) + ((I64[_saLSD::P64 + 8] << 3) + (_saLTh::I64 >> 7))] = 1 :: W8;
           if (_saLSY::I64 == _saLSN::I64) goto uaNVp; else goto caNS8;
       uaNVp: // global
           Sp = Sp + 72;
           call _caNSd() args: 0, res: 0, upd: 0;
       caNS8: // global
           I64[Sp + 16] = _saLSY::I64 + 1;
           Sp = Sp + 16;
           call _caNQe() args: 0, res: 0, upd: 0;
     }
 },
 _caNSd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNSd: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNQB() //  [R1]
         { info_tbl: [(caNQB,
                       label: block_caNQB_info
                       rep:StackRep [True, True, True, True, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNQB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNSk; else goto caNSj;
       caNSk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNSj: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           _caNQD::P64 = Hp - 7;
           if (%MO_S_Le_W64(0, I64[Sp + 40])) goto caNUQ; else goto uaNVr;
       caNUQ: // global
           P64[Sp - 16] = R1;
           I64[Sp - 8] = 0;
           P64[Sp] = _caNQD::P64;
           Sp = Sp - 16;
           call _caNQY() args: 0, res: 0, upd: 0;
       uaNVr: // global
           P64[Sp + 72] = R1;
           P64[Sp + 80] = _caNQD::P64;
           call _caNSm() args: 0, res: 0, upd: 0;
     }
 },
 _caNQY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNQY: // global
           Hp = Hp + 16;
           _saLU8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caNTj; else goto caNTi;
       caNTj: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caNQX_info;
           R1 = _saLU8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caNTi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLU8::I64;
           _saLSE::P64 = P64[Sp + 72];
           _saLSG::P64 = P64[Sp + 96];
           _saLSH::I64 = I64[Sp + 48];
           _caNR0::P64 = Hp - 7;
           if (%MO_S_Gt_W64(_saLSH::I64,
                            _saLU8::I64)) goto caNTn; else goto caNUO;
       caNTn: // global
           R4 = _caNR0::P64;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caNUO: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 56])) goto caNTt; else goto caNTA;
       caNTt: // global
           R4 = _caNR0::P64;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caNTA: // global
           _saLUg::P64 = P64[P64[Sp + 64] + ((_saLU8::I64 - _saLSH::I64 << 3) + 24)];
           I64[Sp - 16] = block_caNTz_info;
           R1 = _saLUg::P64;
           P64[Sp - 8] = _caNR0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNVO; else goto caNTB;
       uaNVO: // global
           call _caNTz(R1) args: 0, res: 0, upd: 0;
       caNTB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNQX() //  [R1]
         { info_tbl: [(caNQX,
                       label: block_caNQX_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNQX: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caNQY() args: 0, res: 0, upd: 0;
     }
 },
 _caNTz() //  [R1]
         { info_tbl: [(caNTz,
                       label: block_caNTz_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNTz: // global
           if (R1 & 7 == 1) goto caNTH; else goto caNTR;
       caNTH: // global
           Sp = Sp + 120;
           call lvl13_raLJB_entry() args: 8, res: 0, upd: 8;
       caNTR: // global
           I64[Sp - 8] = block_caNTK_info;
           _saLUh::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saLUh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNVW; else goto caNTL;
       uaNVW: // global
           call _caNTK(R1) args: 0, res: 0, upd: 0;
       caNTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNTK() //  [R1]
         { info_tbl: [(caNTK,
                       label: block_caNTK_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNTK: // global
           I64[Sp - 8] = block_caNTP_info;
           _saLUl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 112];
           P64[Sp] = _saLUl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNVX; else goto caNTT;
       uaNVX: // global
           call _caNTP(R1) args: 0, res: 0, upd: 0;
       caNTT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNTP() //  [R1]
         { info_tbl: [(caNTP,
                       label: block_caNTP_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNTP: // global
           _caNR0::P64 = P64[Sp + 24];
           _saLU8::I64 = I64[Sp + 40];
           if (%MO_S_Ge_W64(_saLU8::I64,
                            I64[R1 + 7])) goto caNU3; else goto caNUN;
       caNU3: // global
           I64[Sp] = block_caNU1_info;
           R3 = _caNR0::P64;
           R2 = P64[Sp + 8];
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
       caNUN: // global
           _caNQD::P64 = P64[Sp + 48];
           if (%MO_S_Gt_W64(0, _saLU8::I64)) goto caNUx; else goto caNUM;
       caNUx: // global
           R3 = _caNR0::P64;
           R2 = _caNQD::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caNUM: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 64])) goto caNUD; else goto caNUL;
       caNUD: // global
           R3 = _caNR0::P64;
           R2 = _caNQD::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caNUL: // global
           _saLSF::I64 = I64[Sp + 88];
           _saLTt::P64 = P64[Sp + 32];
           _saLUh::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[(_saLTt::P64 + 24) + (_saLU8::I64 << 3)] = _saLUh::P64;
           I64[_saLTt::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLTt::P64 + 24) + ((I64[_saLTt::P64 + 8] << 3) + (_saLU8::I64 >> 7))] = 1 :: W8;
           if (_saLU8::I64 == _saLSF::I64) goto uaNVw; else goto caNUJ;
       uaNVw: // global
           P64[Sp + 128] = _caNQD::P64;
           P64[Sp + 120] = _saLTt::P64;
           Sp = Sp + 48;
           call _caNSm() args: 0, res: 0, upd: 0;
       caNUJ: // global
           I64[Sp + 40] = _saLU8::I64 + 1;
           Sp = Sp + 32;
           call _caNQY() args: 0, res: 0, upd: 0;
     }
 },
 _caNU1() //  [R1]
         { info_tbl: [(caNU1,
                       label: block_caNU1_info
                       rep:StackRep [False, True, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNU1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNU7; else goto caNU6;
       caNU7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNU6: // global
           _caNQD::P64 = P64[Sp + 48];
           _caNR0::P64 = P64[Sp + 24];
           _saLU8::I64 = I64[Sp + 40];
           if (%MO_S_Gt_W64(0, _saLU8::I64)) goto caNUb; else goto caNUs;
       caNUb: // global
           Hp = Hp - 40;
           R3 = _caNR0::P64;
           R2 = _caNQD::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caNUs: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 64])) goto caNUh; else goto caNUr;
       caNUh: // global
           Hp = Hp - 40;
           R3 = _caNR0::P64;
           R2 = _caNQD::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caNUr: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLSF::I64 = I64[Sp + 88];
           _saLTt::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[(_saLTt::P64 + 24) + (_saLU8::I64 << 3)] = Hp - 6;
           I64[_saLTt::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLTt::P64 + 24) + ((I64[_saLTt::P64 + 8] << 3) + (_saLU8::I64 >> 7))] = 1 :: W8;
           if (_saLU8::I64 == _saLSF::I64) goto uaNVu; else goto caNUp;
       uaNVu: // global
           P64[Sp + 128] = _caNQD::P64;
           P64[Sp + 120] = _saLTt::P64;
           Sp = Sp + 48;
           call _caNSm() args: 0, res: 0, upd: 0;
       caNUp: // global
           I64[Sp + 40] = _saLU8::I64 + 1;
           Sp = Sp + 32;
           call _caNQY() args: 0, res: 0, upd: 0;
     }
 },
 _caNSm() //  []
         { info_tbl: [(caNSm,
                       label: block_caNSm_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNSm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNSq; else goto caNSp;
       caNSq: // global
           HpAlloc = 40;
           I64[Sp] = block_caNSm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caNSp: // global
           _saLSI::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saLSI::I64,
                            I64[Sp + 16])) goto caNSR; else goto caNSS;
       caNSR: // global
           Hp = Hp - 40;
           I64[Sp + 56] = _saLSI::I64;
           Sp = Sp + 16;
           call _caNSF() args: 0, res: 0, upd: 0;
       caNSS: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 80];
           P64[Hp - 8] = P64[Sp + 72];
           I64[Hp] = I64[Sp + 24];
           _saLSv::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_saLSv::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSv::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caNSF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNSF: // global
           I64[Sp - 8] = block_caNSH_info;
           R5 = I64[Sp + 40];
           R4 = P64[Sp + 56];
           R3 = I64[Sp];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNSH() //  []
         { info_tbl: [(caNSH,
                       label: block_caNSH_info
                       rep:StackRep [True, True, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNSH: // global
           _saLTD::I64 = I64[Sp + 48];
           if (_saLTD::I64 == I64[Sp + 8]) goto uaNVz; else goto caNSO;
       uaNVz: // global
           Sp = Sp + 8;
           call _caNSx() args: 0, res: 0, upd: 0;
       caNSO: // global
           I64[Sp + 48] = _saLTD::I64 + 1;
           Sp = Sp + 8;
           call _caNSF() args: 0, res: 0, upd: 0;
     }
 },
 _caNSx() //  []
         { info_tbl: [(caNSx,
                       label: block_caNSx_info
                       rep:StackRep [True, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNSx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNSB; else goto caNSA;
       caNSB: // global
           HpAlloc = 40;
           I64[Sp] = block_caNSx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caNSA: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 56];
           I64[Hp] = I64[Sp + 8];
           _saLSv::P64 = P64[Sp + 48];
           call MO_WriteBarrier();
           P64[_saLSv::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSv::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.684363107 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged2_entry() //  []
         { info_tbl: [(caNW6,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNW6: // global
           call GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.685295148 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() //  []
         { info_tbl: [(caNWg,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNWh; else goto caNWi;
       caNWh: // global
           R1 = GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNWi: // global
           I64[Sp - 8] = block_caNWd_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNWm; else goto caNWe;
       uaNWm: // global
           call _caNWd(R1) args: 0, res: 0, upd: 0;
       caNWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNWd() //  [R1]
         { info_tbl: [(caNWd,
                       label: block_caNWd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWd: // global
           R3 = GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.686404848 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caNWr,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWr: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.687328143 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager2_closure" {
     GHC.Event.Thread.getSystemEventManager2_closure:
         const GHC.Event.Thread.getSystemEventManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager2_entry() //  [R2, R3, R4]
         { info_tbl: [(caNWz,
                       label: GHC.Event.Thread.getSystemEventManager2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caNWD; else goto caNWC;
       caNWD: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.getSystemEventManager2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caNWC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.68947468 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager1_closure" {
     GHC.Event.Thread.getSystemEventManager1_closure:
         const GHC.Event.Thread.getSystemEventManager1_info;
         const 0;
 },
 sat_saLVn_entry() //  [R1]
         { info_tbl: [(caNXv,
                       label: sat_saLVn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNXv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNXw; else goto caNXx;
       caNXw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNXx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLVo_entry() //  [R1]
         { info_tbl: [(caNXC,
                       label: sat_saLVo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNXC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caNXD; else goto caNXE;
       caNXD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNXE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caNXl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaNXL; else goto caNXm;
       uaNXL: // global
           call _caNXl(R1) args: 0, res: 0, upd: 0;
       caNXm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caNXl() //  [R1]
         { info_tbl: [(caNXl,
                       label: block_caNXl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNXl: // global
           if (R1 & 7 == 1) goto caNXz; else goto caNXA;
       caNXz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caNXA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caNXK; else goto caNXJ;
       caNXK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caNXJ: // global
           _saLVm::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_saLVn_info;
           P64[Hp - 16] = _saLVm::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.getSystemEventManager1_entry() //  []
         { info_tbl: [(caNXM,
                       label: GHC.Event.Thread.getSystemEventManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNXM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caNXN; else goto caNXO;
       caNXN: // global
           R1 = GHC.Event.Thread.getSystemEventManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNXO: // global
           I64[Sp - 8] = block_caNWI_info;
           R1 = CurrentTSO;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNWI() //  [R2]
         { info_tbl: [(caNWI,
                       label: block_caNWI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWI: // global
           I64[Sp - 8] = block_caNWM_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           I64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNY2; else goto caNWN;
       uaNY2: // global
           call _caNWM(R1) args: 0, res: 0, upd: 0;
       caNWN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNWM() //  [R1]
         { info_tbl: [(caNWM,
                       label: block_caNWM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWM: // global
           _saLV3::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caNWR_info;
           R1 = _saLV3::P64;
           if (R1 & 7 != 0) goto uaNY3; else goto caNWS;
       uaNY3: // global
           call _caNWR(R1) args: 0, res: 0, upd: 0;
       caNWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNWR() //  [R1]
         { info_tbl: [(caNWR,
                       label: block_caNWR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWR: // global
           I64[Sp - 16] = block_caNWW_info;
           _saLV6::P64 = P64[R1 + 15];
           _saLV8::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saLV8::P64;
           P64[Sp] = _saLV6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaNY4; else goto caNWX;
       uaNY4: // global
           call _caNWW(R1) args: 0, res: 0, upd: 0;
       caNWX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNWW() //  [R1]
         { info_tbl: [(caNWW,
                       label: block_caNWW_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNWW: // global
           I64[Sp - 8] = block_caNX1_info;
           _saLV9::P64 = R1;
           _saLVa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVa::I64;
           P64[Sp + 16] = _saLV9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNY5; else goto caNX2;
       uaNY5: // global
           call _caNX1(R1) args: 0, res: 0, upd: 0;
       caNX2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNX1() //  [R1]
         { info_tbl: [(caNX1,
                       label: block_caNX1_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNX1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caNXV; else goto caNXU;
       caNXV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caNXU: // global
           _saLUX::I64 = I64[Sp + 32];
           _saLV9::P64 = P64[Sp + 24];
           _saLVa::I64 = I64[Sp + 8];
           _saLVb::P64 = R1;
           if (%MO_S_Gt_W64(_saLVa::I64,
                            _saLUX::I64)) goto caNXZ; else goto caNY1;
       caNY1: // global
           if (%MO_S_Gt_W64(_saLUX::I64,
                            I64[R1 + 7])) goto caNXZ; else goto caNY0;
       caNXZ: // global
           Hp = Hp - 24;
           R4 = _saLUX::I64;
           R3 = _saLV9::P64;
           R2 = _saLVb::P64;
           Sp = Sp + 40;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caNY0: // global
           I64[Hp - 16] = sat_saLVo_info;
           P64[Hp] = P64[P64[Sp + 16] + ((_saLUX::I64 - _saLVa::I64 << 3) + 24)];
           R1 = Hp - 16;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.692363099 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager_closure" {
     GHC.Event.Thread.getSystemEventManager_closure:
         const GHC.Event.Thread.getSystemEventManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager_entry() //  []
         { info_tbl: [(caNYa,
                       label: GHC.Event.Thread.getSystemEventManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYa: // global
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.693006972 UTC

[section ""cstring" . lvl16_raLJE_bytes" {
     lvl16_raLJE_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.694022653 UTC

[section ""data" . lvl17_raLJF_closure" {
     lvl17_raLJF_closure:
         const lvl17_raLJF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_raLJF_entry() //  [R1]
         { info_tbl: [(caNYj,
                       label: lvl17_raLJF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNYk; else goto caNYl;
       caNYk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNYl: // global
           (_caNYg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNYg::I64 == 0) goto caNYi; else goto caNYh;
       caNYi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNYh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNYg::I64;
           R2 = lvl16_raLJE_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.695088943 UTC

[section ""data" . lvl18_raLJG_closure" {
     lvl18_raLJG_closure:
         const lvl18_raLJG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_raLJG_entry() //  [R1]
         { info_tbl: [(caNYs,
                       label: lvl18_raLJG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNYt; else goto caNYu;
       caNYt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNYu: // global
           (_caNYp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNYp::I64 == 0) goto caNYr; else goto caNYq;
       caNYr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNYq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNYp::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl17_raLJF_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.696191535 UTC

[section ""data" . lvl19_raLJH_closure" {
     lvl19_raLJH_closure:
         const lvl19_raLJH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_raLJH_entry() //  [R1]
         { info_tbl: [(caNYB,
                       label: lvl19_raLJH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caNYC; else goto caNYD;
       caNYC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNYD: // global
           (_caNYy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caNYy::I64 == 0) goto caNYA; else goto caNYz;
       caNYA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caNYz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNYy::I64;
           R2 = lvl18_raLJG_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.697103771 UTC

[section ""data" . lvl20_raLJI_closure" {
     lvl20_raLJI_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.697706087 UTC

[section ""data" . lvl21_raLJJ_closure" {
     lvl21_raLJJ_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.698276741 UTC

[section ""data" . lvl22_raLJK_closure" {
     lvl22_raLJK_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.698849411 UTC

[section ""cstring" . lvl23_raLJL_bytes" {
     lvl23_raLJL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,56,51,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.699593044 UTC

[section ""data" . lvl24_raLJM_closure" {
     lvl24_raLJM_closure:
         const lvl24_raLJM_info;
         const 0;
 },
 lvl24_raLJM_entry() //  []
         { info_tbl: [(caNYK,
                       label: lvl24_raLJM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNYL; else goto caNYM;
       caNYL: // global
           R1 = lvl24_raLJM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caNYM: // global
           I64[Sp - 8] = block_caNYI_info;
           R2 = lvl23_raLJL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caNYI() //  [R1]
         { info_tbl: [(caNYI,
                       label: block_caNYI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.712895443 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM1_closure" {
     GHC.Event.Thread.threadWaitReadSTM1_closure:
         const GHC.Event.Thread.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saLWA_entry() //  [R1]
         { info_tbl: [(caO0B,
                       label: sat_saLWA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0B: // global
           _saLWA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caO0C; else goto caO0D;
       caO0D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO0F; else goto caO0E;
       caO0F: // global
           HpAlloc = 16;
           goto caO0C;
       caO0C: // global
           R1 = _saLWA::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caO0E: // global
           _saLVB::P64 = P64[_saLWA::P64 + 7];
           _saLWv::P64 = P64[_saLWA::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWv::P64;
           I64[Sp - 8] = block_caO0z_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO0z() //  []
         { info_tbl: [(caO0z,
                       label: block_caO0z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl31_saLWt_entry() //  [R1, R2, R3]
         { info_tbl: [(caO0H,
                       label: lvl31_saLWt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caO0L; else goto caO0K;
       caO0L: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caO0K: // global
           _saLVB::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_saLWA_info;
           P64[Hp - 8] = _saLVB::P64;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saLXa_entry() //  [R1, R2]
         { info_tbl: [(caO1R,
                       label: $wgo_saLXa_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO1R: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caO1S; else goto caO1T;
       caO1S: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO1T: // global
           I64[Sp - 24] = block_caO1K_info;
           _saLXa::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saLWa::I64;
           P64[Sp - 8] = _saLXa::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaO2g; else goto caO1L;
       uaO2g: // global
           call _caO1K(R1) args: 0, res: 0, upd: 0;
       caO1L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO1K() //  [R1]
         { info_tbl: [(caO1K,
                       label: block_caO1K_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO1K: // global
           if (R1 & 7 == 1) goto caO1O; else goto caO1P;
       caO1O: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caO1P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO21; else goto caO20;
       caO21: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caO20: // global
           _saLXe::P64 = P64[R1 + 6];
           _saLXf::P64 = P64[R1 + 14];
           _saLXd::I64 = I64[R1 + 22];
           if (_saLXd::I64 == I64[Sp + 8]) goto caO2f; else goto caO29;
       caO2f: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLXe::P64;
           R3 = _saLXf::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caO29: // global
           Hp = Hp - 16;
           I64[Sp] = block_caO25_info;
           R2 = _saLXf::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saLXe::P64;
           I64[Sp + 16] = _saLXd::I64;
           call $wgo_saLXa_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO25() //  [R1, R2, R3]
         { info_tbl: [(caO25,
                       label: block_caO25_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO25: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caO2c; else goto caO2b;
       caO2c: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caO2b: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saLXZ_entry() //  [R1, R2]
         { info_tbl: [(caO31,
                       label: $wgo_saLXZ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO31: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caO32; else goto caO33;
       caO32: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO33: // global
           I64[Sp - 24] = block_caO2U_info;
           _saLXZ::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saLWa::I64;
           P64[Sp - 8] = _saLXZ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaO3q; else goto caO2V;
       uaO3q: // global
           call _caO2U(R1) args: 0, res: 0, upd: 0;
       caO2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO2U() //  [R1]
         { info_tbl: [(caO2U,
                       label: block_caO2U_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2U: // global
           if (R1 & 7 == 1) goto caO2Y; else goto caO2Z;
       caO2Y: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caO2Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO3b; else goto caO3a;
       caO3b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caO3a: // global
           _saLY3::P64 = P64[R1 + 6];
           _saLY4::P64 = P64[R1 + 14];
           _saLY2::I64 = I64[R1 + 22];
           if (_saLY2::I64 == I64[Sp + 8]) goto caO3p; else goto caO3j;
       caO3p: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLY3::P64;
           R3 = _saLY4::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caO3j: // global
           Hp = Hp - 16;
           I64[Sp] = block_caO3f_info;
           R2 = _saLY4::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saLY3::P64;
           I64[Sp + 16] = _saLY2::I64;
           call $wgo_saLXZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO3f() //  [R1, R2, R3]
         { info_tbl: [(caO3f,
                       label: block_caO3f_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO3f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caO3m; else goto caO3l;
       caO3m: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caO3l: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saLWq_entry() //  [R1, R2]
         { info_tbl: [(caO3v,
                       label: $wio_saLWq_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO3v: // global
           _saLWr::P64 = R2;
           _saLWq::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caO3w; else goto caO3x;
       caO3x: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caO3z; else goto caO3y;
       caO3z: // global
           HpAlloc = 80;
           goto caO3w;
       caO3w: // global
           R2 = _saLWr::P64;
           R1 = _saLWq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO3y: // global
           _saLVB::P64 = P64[_saLWq::P64 + 6];
           _saLW1::P64 = P64[_saLWq::P64 + 14];
           _saLW3::P64 = P64[_saLWq::P64 + 22];
           _saLW4::P64 = P64[_saLWq::P64 + 30];
           _saLW9::P64 = P64[_saLWq::P64 + 38];
           _saLW8::I64 = I64[_saLWq::P64 + 46];
           _saLWa::I64 = I64[_saLWq::P64 + 54];
           _saLWc::I64 = I64[_saLWq::P64 + 62];
           I64[Hp - 72] = lvl31_saLWt_info;
           P64[Hp - 64] = _saLVB::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saLWa::I64;
           I64[Hp - 32] = _saLW8::I64;
           I64[Hp - 24] = _saLWc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caO0b_info;
           R5 = _saLWr::P64;
           R4 = Hp - 14;
           R3 = _saLWa::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saLW1::P64;
           P64[Sp - 48] = _saLW3::P64;
           P64[Sp - 40] = _saLW4::P64;
           P64[Sp - 32] = _saLW9::P64;
           I64[Sp - 24] = _saLWa::I64;
           I64[Sp - 16] = _saLWc::I64;
           P64[Sp - 8] = _saLWr::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caO0b() //  [R1]
         { info_tbl: [(caO0b,
                       label: block_caO0b_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0b: // global
           I64[Sp - 8] = block_caO0f_info;
           _saLWF::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaO5T; else goto caO0g;
       uaO5T: // global
           call _caO0f(R1) args: 0, res: 0, upd: 0;
       caO0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO0f() //  [R1]
         { info_tbl: [(caO0f,
                       label: block_caO0f_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0f: // global
           if (R1 & 7 == 1) goto caO3s; else goto caO3t;
       caO3s: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saLWG() args: 0, res: 0, upd: 0;
       caO3t: // global
           I64[Sp] = block_caO0l_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caO0l() //  [R1]
         { info_tbl: [(caO0l,
                       label: block_caO0l_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO5s; else goto caO5r;
       caO5s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caO5r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saLWG() args: 0, res: 0, upd: 0;
     }
 },
 _saLWG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLWG: // global
           _saLWI::P64 = P64[Sp];
           I64[Sp] = block_caO0P_info;
           R1 = _saLWI::P64;
           if (R1 & 7 != 0) goto uaO6e; else goto caO0Q;
       uaO6e: // global
           call _caO0P(R1) args: 0, res: 0, upd: 0;
       caO0Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO0P() //  [R1]
         { info_tbl: [(caO0P,
                       label: block_caO0P_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO0P: // global
           _saLWL::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saLWM::I64 = _saLWL::I64 & 8;
           if (_saLWM::I64 != 0) goto uaO5M; else goto uaO5L;
       uaO5M: // global
           I64[Sp] = _saLWM::I64;
           I64[Sp + 40] = _saLWL::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caO11() args: 0, res: 0, upd: 0;
       uaO5L: // global
           I64[Sp + 32] = _saLWM::I64;
           I64[Sp + 64] = _saLWL::I64;
           Sp = Sp + 16;
           call _caO2j() args: 0, res: 0, upd: 0;
     }
 },
 _caO11() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO11: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caO3H; else goto caO3G;
       caO3H: // global
           HpAlloc = 32;
           _saLWM::I64 = I64[Sp];
           I64[Sp] = block_caO10_info;
           R1 = _saLWM::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caO3G: // global
           _saLWL::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saLWL::I64) goto caO3J; else goto caO3K;
       caO3J: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caO3K: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saLWL::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caO1f_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caO10() //  [R1]
         { info_tbl: [(caO10,
                       label: block_caO10_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO10: // global
           I64[Sp] = R1;
           call _caO11() args: 0, res: 0, upd: 0;
     }
 },
 _caO1f() //  [R1]
         { info_tbl: [(caO1f,
                       label: block_caO1f_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO1f: // global
           I64[Sp] = block_caO1h_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaO5Z; else goto caO1i;
       uaO5Z: // global
           call _caO1h(R1) args: 0, res: 0, upd: 0;
       caO1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO1h() //  [R1]
         { info_tbl: [(caO1h,
                       label: block_caO1h_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO1h: // global
           if (R1 & 7 == 1) goto caO3O; else goto caO4w;
       caO3O: // global
           I64[Sp + 40] = block_caO1m_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaO60; else goto caO1n;
       uaO60: // global
           call _caO1m(R1) args: 0, res: 0, upd: 0;
       caO1n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caO4w: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO1m() //  [R1]
         { info_tbl: [(caO1m,
                       label: block_caO1m_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO1m: // global
           _saLWr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caO3R; else goto caO4q;
       caO3R: // global
           I64[Sp] = block_caO1r_info;
           R1 = P64[_saLWr::P64 + 8];
           if (R1 & 7 != 0) goto uaO61; else goto caO1s;
       uaO61: // global
           call _caO1r(R1) args: 0, res: 0, upd: 0;
       caO1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caO4q: // global
           I64[Sp + 24] = block_caO4o_info;
           R5 = _saLWr::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caO1r() //  [R1]
         { info_tbl: [(caO1r,
                       label: block_caO1r_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO1r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO3U; else goto caO3T;
       caO3U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caO3T: // global
           _saLWa::I64 = I64[Sp + 8];
           _saLX1::P64 = P64[R1 + 7];
           _saLX3::P64 = P64[R1 + 15];
           _saLX2::I64 = I64[R1 + 23];
           _saLX4::I64 = _saLWa::I64 & (I64[_saLX1::P64 + 8] - 1);
           _saLX9::P64 = P64[(_saLX1::P64 + 24) + (_saLX4::I64 << 3)];
           I64[Hp - 8] = $wgo_saLXa_info;
           I64[Hp] = _saLWa::I64;
           I64[Sp - 8] = block_caO3V_info;
           R2 = _saLX9::P64;
           R1 = Hp - 7;
           I64[Sp] = _saLX4::I64;
           P64[Sp + 8] = _saLX3::P64;
           I64[Sp + 16] = _saLX2::I64;
           P64[Sp + 24] = _saLX1::P64;
           Sp = Sp - 8;
           call $wgo_saLXa_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO3V() //  [R1, R2, R3]
         { info_tbl: [(caO3V,
                       label: block_caO3V_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO3V: // global
           I64[Sp - 16] = block_caO3X_info;
           _saLXo::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saLXo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaO66; else goto caO3Z;
       uaO66: // global
           call _caO3X(R1) args: 0, res: 0, upd: 0;
       caO3Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO3X() //  [R1]
         { info_tbl: [(caO3X,
                       label: block_caO3X_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO3X: // global
           if (R1 & 7 == 1) goto uaO5O; else goto caO4a;
       uaO5O: // global
           Sp = Sp + 56;
           call _caO57() args: 0, res: 0, upd: 0;
       caO4a: // global
           _saLX1::P64 = P64[Sp + 48];
           _saLX4::I64 = I64[Sp + 24];
           _saLXo::P64 = P64[Sp + 16];
           _saLXq::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saLX1::P64 + 24) + (_saLX4::I64 << 3)] = _saLXq::P64;
           I64[_saLX1::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLX1::P64 + 24) + ((I64[_saLX1::P64 + 8] << 3) + (_saLX4::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caO48_info;
           R1 = _saLXo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaO67; else goto caO4b;
       uaO67: // global
           call _caO48(R1) args: 0, res: 0, upd: 0;
       caO4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO48() //  [R1]
         { info_tbl: [(caO48,
                       label: block_caO48_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO48: // global
           if (R1 & 7 == 1) goto uaO5P; else goto caO4l;
       uaO5P: // global
           Sp = Sp + 32;
           call _caO57() args: 0, res: 0, upd: 0;
       caO4l: // global
           _saLX2::I64 = I64[Sp + 16];
           _saLX3::P64 = P64[Sp + 8];
           I64[_saLX2::I64] = I64[_saLX2::I64] - 1;
           call MO_Touch(_saLX3::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO4o() //  []
         { info_tbl: [(caO4o,
                       label: block_caO4o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO4o: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO2j() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO4A; else goto caO4z;
       caO4A: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caO2i_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caO4z: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caO2p_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO2i() //  [R1]
         { info_tbl: [(caO2i,
                       label: block_caO2i_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2i: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caO2j() args: 0, res: 0, upd: 0;
     }
 },
 _caO2p() //  [R1]
         { info_tbl: [(caO2p,
                       label: block_caO2p_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2p: // global
           I64[Sp] = block_caO2r_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaO63; else goto caO2s;
       uaO63: // global
           call _caO2r(R1) args: 0, res: 0, upd: 0;
       caO2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO2r() //  [R1]
         { info_tbl: [(caO2r,
                       label: block_caO2r_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2r: // global
           if (R1 & 7 == 1) goto caO4E; else goto caO5m;
       caO4E: // global
           I64[Sp + 40] = block_caO2w_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaO64; else goto caO2x;
       uaO64: // global
           call _caO2w(R1) args: 0, res: 0, upd: 0;
       caO2x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caO5m: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO2w() //  [R1]
         { info_tbl: [(caO2w,
                       label: block_caO2w_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2w: // global
           _saLWr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caO4H; else goto caO5g;
       caO4H: // global
           I64[Sp] = block_caO2B_info;
           R1 = P64[_saLWr::P64 + 8];
           if (R1 & 7 != 0) goto uaO65; else goto caO2C;
       uaO65: // global
           call _caO2B(R1) args: 0, res: 0, upd: 0;
       caO2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caO5g: // global
           I64[Sp + 24] = block_caO5e_info;
           R5 = _saLWr::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caO2B() //  [R1]
         { info_tbl: [(caO2B,
                       label: block_caO2B_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO2B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO4K; else goto caO4J;
       caO4K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caO4J: // global
           _saLWa::I64 = I64[Sp + 8];
           _saLXQ::P64 = P64[R1 + 7];
           _saLXS::P64 = P64[R1 + 15];
           _saLXR::I64 = I64[R1 + 23];
           _saLXT::I64 = _saLWa::I64 & (I64[_saLXQ::P64 + 8] - 1);
           _saLXY::P64 = P64[(_saLXQ::P64 + 24) + (_saLXT::I64 << 3)];
           I64[Hp - 8] = $wgo_saLXZ_info;
           I64[Hp] = _saLWa::I64;
           I64[Sp - 8] = block_caO4L_info;
           R2 = _saLXY::P64;
           R1 = Hp - 7;
           I64[Sp] = _saLXT::I64;
           P64[Sp + 8] = _saLXS::P64;
           I64[Sp + 16] = _saLXR::I64;
           P64[Sp + 24] = _saLXQ::P64;
           Sp = Sp - 8;
           call $wgo_saLXZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO4L() //  [R1, R2, R3]
         { info_tbl: [(caO4L,
                       label: block_caO4L_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO4L: // global
           I64[Sp - 16] = block_caO4N_info;
           _saLYd::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saLYd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaO6a; else goto caO4P;
       uaO6a: // global
           call _caO4N(R1) args: 0, res: 0, upd: 0;
       caO4P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO4N() //  [R1]
         { info_tbl: [(caO4N,
                       label: block_caO4N_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO4N: // global
           if (R1 & 7 == 1) goto uaO5R; else goto caO50;
       uaO5R: // global
           Sp = Sp + 56;
           call _caO57() args: 0, res: 0, upd: 0;
       caO50: // global
           _saLXQ::P64 = P64[Sp + 48];
           _saLXT::I64 = I64[Sp + 24];
           _saLYd::P64 = P64[Sp + 16];
           _saLYf::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saLXQ::P64 + 24) + (_saLXT::I64 << 3)] = _saLYf::P64;
           I64[_saLXQ::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLXQ::P64 + 24) + ((I64[_saLXQ::P64 + 8] << 3) + (_saLXT::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caO4Y_info;
           R1 = _saLYd::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaO6b; else goto caO51;
       uaO6b: // global
           call _caO4Y(R1) args: 0, res: 0, upd: 0;
       caO51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO4Y() //  [R1]
         { info_tbl: [(caO4Y,
                       label: block_caO4Y_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO4Y: // global
           if (R1 & 7 == 1) goto uaO5S; else goto caO5b;
       uaO5S: // global
           Sp = Sp + 32;
           call _caO57() args: 0, res: 0, upd: 0;
       caO5b: // global
           _saLXR::I64 = I64[Sp + 16];
           _saLXS::P64 = P64[Sp + 8];
           I64[_saLXR::I64] = I64[_saLXR::I64] - 1;
           call MO_Touch(_saLXS::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO57() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO57: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO5e() //  []
         { info_tbl: [(caO5e,
                       label: block_caO5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO5e: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saLYy_entry() //  [R1, R2]
         { info_tbl: [(caO6n,
                       label: io1_saLYy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caO6o; else goto caO6p;
       caO6o: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO6p: // global
           I64[Sp - 16] = block_caO6k_info;
           _saLWq::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLWq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaO6t; else goto caO6l;
       uaO6t: // global
           call _caO6k(R1) args: 0, res: 0, upd: 0;
       caO6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO6k() //  [R1]
         { info_tbl: [(caO6k,
                       label: block_caO6k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6k: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saLWq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLYU_entry() //  [R1]
         { info_tbl: [(caO6G,
                       label: sat_saLYU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caO6H; else goto caO6I;
       caO6H: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caO6I: // global
           I64[Sp - 8] = block_caO6E_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caO6E() //  []
         { info_tbl: [(caO6E,
                       label: block_caO6E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6E: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLYP_entry() //  [R1]
         { info_tbl: [(caO6Y,
                       label: sat_saLYP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caO6Z; else goto caO70;
       caO6Z: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caO70: // global
           I64[Sp - 8] = block_caO6P_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO6P() //  [R1]
         { info_tbl: [(caO6P,
                       label: block_caO6P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6P: // global
           I64[Sp] = block_caO6R_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaO7t; else goto caO6S;
       uaO7t: // global
           call _caO6R(R1) args: 0, res: 0, upd: 0;
       caO6S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO6R() //  [R1]
         { info_tbl: [(caO6R,
                       label: block_caO6R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6R: // global
           if (R1 & 7 == 1) goto caO6V; else goto caO6W;
       caO6V: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caO6W: // global
           I64[Sp] = block_caO77_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaO7u; else goto caO79;
       uaO7u: // global
           call _caO77(R1) args: 0, res: 0, upd: 0;
       caO79: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO77() //  [R1]
         { info_tbl: [(caO77,
                       label: block_caO77_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO77: // global
           if (I64[R1 + 7] & 4 == 0) goto caO7p; else goto caO7j;
       caO7p: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caO7j: // global
           R1 = lvl19_raLJH_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ5_entry() //  [R1, R2]
         { info_tbl: [(caO7G,
                       label: sat_saLZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO7G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caO7H; else goto caO7I;
       caO7H: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO7I: // global
           I64[Sp - 16] = block_caO7E_info;
           _saLZ2::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saLZ2::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO7E() //  []
         { info_tbl: [(caO7E,
                       label: block_caO7E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO7E: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ0_entry() //  [R1]
         { info_tbl: [(caO7P,
                       label: sat_saLZ0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO7P: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ1_entry() //  [R1]
         { info_tbl: [(caO7X,
                       label: sat_saLZ1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO7X: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZh_entry() //  [R1]
         { info_tbl: [(caO8m,
                       label: sat_saLZh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8m: // global
           _saLZh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caO8n; else goto caO8o;
       caO8o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO8q; else goto caO8p;
       caO8q: // global
           HpAlloc = 16;
           goto caO8n;
       caO8n: // global
           R1 = _saLZh::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caO8p: // global
           _saLVB::P64 = P64[_saLZh::P64 + 7];
           _saLWb::P64 = P64[_saLZh::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caO8k_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO8k() //  []
         { info_tbl: [(caO8k,
                       label: block_caO8k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8k: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZy_entry() //  [R1, R2]
         { info_tbl: [(caO8H,
                       label: sat_saLZy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caO8I; else goto caO8J;
       caO8I: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO8J: // global
           I64[Sp - 16] = block_caO8F_info;
           _saLZv::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saLZv::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO8F() //  []
         { info_tbl: [(caO8F,
                       label: block_caO8F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8F: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZt_entry() //  [R1]
         { info_tbl: [(caO8Q,
                       label: sat_saLZt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8Q: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZu_entry() //  [R1]
         { info_tbl: [(caO8Y,
                       label: sat_saLZu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8Y: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZD_entry() //  [R1]
         { info_tbl: [(caO95,
                       label: sat_saLZD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO95: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caO96; else goto caO97;
       caO96: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caO97: // global
           I64[Sp - 24] = block_caO8y_info;
           _saLWp::P64 = P64[R1 + 7];
           _saLYy::P64 = P64[R1 + 15];
           R1 = _saLWp::P64;
           P64[Sp - 16] = _saLWp::P64;
           P64[Sp - 8] = _saLYy::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO8y() //  [R1]
         { info_tbl: [(caO8y,
                       label: block_caO8y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO8y: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caO9a; else goto caO99;
       caO9a: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caO99: // global
           I64[Hp - 56] = sat_saLZy_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZt_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saLZu_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caO91_info;
           R2 = Hp - 54;
           _saLZs::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saLZs::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO91() //  [R1]
         { info_tbl: [(caO91,
                       label: block_caO91_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO91: // global
           _saLWp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caO93_info;
           R2 = P64[Sp + 16];
           _saLZB::P64 = R1;
           R1 = _saLWp::P64;
           P64[Sp + 16] = _saLZB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO93() //  []
         { info_tbl: [(caO93,
                       label: block_caO93_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO93: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZO_entry() //  [R1]
         { info_tbl: [(caO9x,
                       label: sat_saLZO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9x: // global
           _saLZO::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caO9y; else goto caO9z;
       caO9z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caO9B; else goto caO9A;
       caO9B: // global
           HpAlloc = 16;
           goto caO9y;
       caO9y: // global
           R1 = _saLZO::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caO9A: // global
           _saLVB::P64 = P64[_saLZO::P64 + 7];
           _saLWb::P64 = P64[_saLZO::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caO9v_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO9v() //  []
         { info_tbl: [(caO9v,
                       label: block_caO9v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9v: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM04_entry() //  [R1, R2]
         { info_tbl: [(caO9N,
                       label: sat_saM04_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caO9O; else goto caO9P;
       caO9O: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO9P: // global
           I64[Sp - 16] = block_caO9L_info;
           _saM01::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM01::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO9L() //  []
         { info_tbl: [(caO9L,
                       label: block_caO9L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9L: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZZ_entry() //  [R1]
         { info_tbl: [(caO9W,
                       label: sat_saLZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9W: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM00_entry() //  [R1]
         { info_tbl: [(caOa4,
                       label: sat_saM00_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOa4: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM0g_entry() //  [R1]
         { info_tbl: [(caOat,
                       label: sat_saM0g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOat: // global
           _saM0g::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caOau; else goto caOav;
       caOav: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOax; else goto caOaw;
       caOax: // global
           HpAlloc = 16;
           goto caOau;
       caOau: // global
           R1 = _saM0g::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOaw: // global
           _saLVB::P64 = P64[_saM0g::P64 + 7];
           _saLWb::P64 = P64[_saM0g::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caOar_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOar() //  []
         { info_tbl: [(caOar,
                       label: block_caOar_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOar: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saLVx_entry() //  [R1]
         { info_tbl: [(caOaD,
                       label: io_saLVx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOaD: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caOaE; else goto caOaF;
       caOaE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOaF: // global
           I64[Sp - 24] = block_caNZ1_info;
           _saLVr::P64 = P64[R1 + 7];
           _saLVs::P64 = P64[R1 + 15];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _saLVr::P64;
           P64[Sp - 8] = _saLVs::P64;
           Sp = Sp - 24;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZ1() //  [R1]
         { info_tbl: [(caNZ1,
                       label: block_caNZ1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZ1: // global
           I64[Sp - 8] = block_caNZ3_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caNZ3() //  [R1]
         { info_tbl: [(caNZ3,
                       label: block_caNZ3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZ3: // global
           I64[Sp] = block_caNZ5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOd0; else goto caNZ6;
       uaOd0: // global
           call _caNZ5(R1) args: 0, res: 0, upd: 0;
       caNZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZ5() //  [R1]
         { info_tbl: [(caNZ5,
                       label: block_caNZ5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZ5: // global
           if (R1 & 7 == 1) goto caOaA; else goto caOaB;
       caOaA: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caOaB: // global
           I64[Sp] = block_caNZb_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaOd1; else goto caNZc;
       uaOd1: // global
           call _caNZb(R1) args: 0, res: 0, upd: 0;
       caNZc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZb() //  [R1]
         { info_tbl: [(caNZb,
                       label: block_caNZb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZb: // global
           I64[Sp - 40] = block_caNZg_info;
           _saLVI::P64 = R1;
           _saLVJ::P64 = P64[R1 + 7];
           _saLVL::P64 = P64[R1 + 23];
           _saLVN::P64 = P64[R1 + 31];
           _saLVP::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saLVJ::P64;
           P64[Sp - 24] = _saLVL::P64;
           P64[Sp - 16] = _saLVN::P64;
           P64[Sp - 8] = _saLVP::P64;
           P64[Sp] = _saLVI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaOd2; else goto caNZh;
       uaOd2: // global
           call _caNZg(R1) args: 0, res: 0, upd: 0;
       caNZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZg() //  [R1]
         { info_tbl: [(caNZg,
                       label: block_caNZg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZg: // global
           I64[Sp - 8] = block_caNZl_info;
           _saLVW::P64 = R1;
           _saLVX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVX::I64;
           P64[Sp + 16] = _saLVW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOd3; else goto caNZm;
       uaOd3: // global
           call _caNZl(R1) args: 0, res: 0, upd: 0;
       caNZm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZl() //  [R1]
         { info_tbl: [(caNZl,
                       label: block_caNZl_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZl: // global
           I64[Sp - 8] = block_caNZq_info;
           _saLVY::P64 = R1;
           _saLVZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVZ::I64;
           P64[Sp + 16] = _saLVY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOd4; else goto caNZr;
       uaOd4: // global
           call _caNZq(R1) args: 0, res: 0, upd: 0;
       caNZr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZq() //  [R1]
         { info_tbl: [(caNZq,
                       label: block_caNZq_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZq: // global
           _saLVs::P64 = P64[Sp + 80];
           _saLW1::P64 = P64[R1 + 7];
           _saLW3::P64 = P64[R1 + 23];
           _saLW4::P64 = P64[R1 + 31];
           (_saLW8::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caNZx_info;
           R1 = _saLVs::P64;
           I64[Sp - 8] = _saLW8::I64;
           P64[Sp] = _saLW4::P64;
           P64[Sp + 48] = _saLW3::P64;
           P64[Sp + 80] = _saLW1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOd5; else goto caNZy;
       uaOd5: // global
           call _caNZx(R1) args: 0, res: 0, upd: 0;
       caNZy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZx() //  [R1]
         { info_tbl: [(caNZx,
                       label: block_caNZx_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZx: // global
           I64[Sp - 8] = block_caNZC_info;
           _saLW9::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saLWa::I64;
           P64[Sp + 88] = _saLW9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOd6; else goto caNZD;
       uaOd6: // global
           call _caNZC(R1) args: 0, res: 0, upd: 0;
       caNZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZC() //  [R1]
         { info_tbl: [(caNZC,
                       label: block_caNZC_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZC: // global
           I64[Sp - 16] = block_caNZH_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNZH() //  [R1]
         { info_tbl: [(caNZH,
                       label: block_caNZH_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZH: // global
           _saLVW::P64 = P64[Sp + 72];
           _saLVX::I64 = I64[Sp + 56];
           _saLVY::P64 = P64[Sp + 64];
           _saLWg::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saLVX::I64,
                            _saLWg::I64)) goto caOaV; else goto caOcI;
       caOcI: // global
           if (%MO_S_Gt_W64(_saLWg::I64,
                            I64[Sp + 48])) goto caOaV; else goto caOaW;
       caOaV: // global
           R4 = _saLWg::I64;
           R3 = _saLVW::P64;
           R2 = _saLVY::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caOaW: // global
           _saLWn::P64 = P64[P64[Sp + 80] + ((_saLWg::I64 - _saLVX::I64 << 3) + 24)];
           I64[Sp] = block_caNZX_info;
           _saLWf::I64 = R1;
           R1 = _saLWn::P64;
           I64[Sp + 80] = _saLWf::I64;
           if (R1 & 7 != 0) goto uaOd7; else goto caNZY;
       uaOd7: // global
           call _caNZX(R1) args: 0, res: 0, upd: 0;
       caNZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNZX() //  [R1]
         { info_tbl: [(caNZX,
                       label: block_caNZX_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNZX: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caOaZ; else goto caOaY;
       caOaZ: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOaY: // global
           _saLWp::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saLWq_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saLYy_info;
           P64[Hp - 24] = Hp - 102;
           _caO6f::P64 = Hp - 30;
           _saLYW::I64 = I64[Sp + 80];
           if (_saLYW::I64 != 0) goto uaOcS; else goto caObE;
       uaOcS: // global
           if (_saLYW::I64 != 1) goto caOb5; else goto caOc9;
       caOb5: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caO7x_info;
           R1 = _saLWp::P64;
           P64[Sp + 112] = _saLWp::P64;
           P64[Sp + 120] = _caO6f::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caOc9: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caO9E_info;
           R1 = _saLWp::P64;
           P64[Sp + 112] = _saLWp::P64;
           P64[Sp + 120] = _caO6f::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caObE: // global
           I64[Hp - 16] = sat_saLZD_info;
           P64[Hp - 8] = _saLWp::P64;
           P64[Hp] = _caO6f::P64;
           I64[Sp + 8] = block_caO9d_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO7x() //  [R1]
         { info_tbl: [(caO7x,
                       label: block_caO7x_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO7x: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOb8; else goto caOb7;
       caOb8: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOb7: // global
           I64[Hp - 56] = sat_saLZ5_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZ0_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saLZ1_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caO80_info;
           R2 = Hp - 54;
           _saLYZ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saLYZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO80() //  [R1]
         { info_tbl: [(caO80,
                       label: block_caO80_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO80: // global
           I64[Sp] = block_caO82_info;
           R2 = P64[Sp + 112];
           _saLZ8::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saLZ8::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO82() //  []
         { info_tbl: [(caO82,
                       label: block_caO82_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO82: // global
           I64[Sp] = block_caO84_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaOd9; else goto caO85;
       uaOd9: // global
           call _caO84(R1) args: 0, res: 0, upd: 0;
       caO85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO84() //  [R1]
         { info_tbl: [(caO84,
                       label: block_caO84_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO84: // global
           I64[Sp] = block_caO89_info;
           _saLZb::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saLZb::P64;
           if (R1 & 7 != 0) goto uaOda; else goto caO8a;
       uaOda: // global
           call _caO89(R1) args: 0, res: 0, upd: 0;
       caO8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO89() //  [R1]
         { info_tbl: [(caO89,
                       label: block_caO89_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO89: // global
           if (R1 & 7 == 1) goto caObg; else goto caObw;
       caObg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caObj; else goto caObi;
       caObj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caObi: // global
           I64[Hp - 16] = sat_saLZh_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caObc_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caObw: // global
           I64[Sp + 8] = block_caObu_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOdb; else goto caObx;
       uaOdb: // global
           call _caObu(R1) args: 0, res: 0, upd: 0;
       caObx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caObc() //  []
         { info_tbl: [(caObc,
                       label: block_caObc_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caObc: // global
           I64[Sp] = block_caObe_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaOdi; else goto caObl;
       uaOdi: // global
           call _caObe(R1) args: 0, res: 0, upd: 0;
       caObl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caObe() //  [R1]
         { info_tbl: [(caObe,
                       label: block_caObe_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caObe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caObr; else goto caObq;
       caObr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caObq: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 _caObu() //  [R1]
         { info_tbl: [(caObu,
                       label: block_caObu_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caObu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caObD; else goto caObC;
       caObD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caObC: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 _caO9E() //  [R1]
         { info_tbl: [(caO9E,
                       label: block_caO9E_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9E: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOcc; else goto caOcb;
       caOcc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOcb: // global
           I64[Hp - 56] = sat_saM04_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZZ_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM00_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caOa7_info;
           R2 = Hp - 54;
           _saLZY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saLZY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOa7() //  [R1]
         { info_tbl: [(caOa7,
                       label: block_caOa7_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOa7: // global
           I64[Sp] = block_caOa9_info;
           R2 = P64[Sp + 112];
           _saM07::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM07::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOa9() //  []
         { info_tbl: [(caOa9,
                       label: block_caOa9_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOa9: // global
           I64[Sp] = block_caOab_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaOdf; else goto caOac;
       uaOdf: // global
           call _caOab(R1) args: 0, res: 0, upd: 0;
       caOac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOab() //  [R1]
         { info_tbl: [(caOab,
                       label: block_caOab_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOab: // global
           I64[Sp] = block_caOag_info;
           _saM0a::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM0a::P64;
           if (R1 & 7 != 0) goto uaOdg; else goto caOah;
       uaOdg: // global
           call _caOag(R1) args: 0, res: 0, upd: 0;
       caOah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOag() //  [R1]
         { info_tbl: [(caOag,
                       label: block_caOag_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOag: // global
           if (R1 & 7 == 1) goto caOck; else goto caOcA;
       caOck: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOcn; else goto caOcm;
       caOcn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOcm: // global
           I64[Hp - 16] = sat_saM0g_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caOcg_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caOcA: // global
           I64[Sp + 8] = block_caOcy_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOdh; else goto caOcB;
       uaOdh: // global
           call _caOcy(R1) args: 0, res: 0, upd: 0;
       caOcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOcg() //  []
         { info_tbl: [(caOcg,
                       label: block_caOcg_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOcg: // global
           I64[Sp] = block_caOci_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaOdo; else goto caOcp;
       uaOdo: // global
           call _caOci(R1) args: 0, res: 0, upd: 0;
       caOcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOci() //  [R1]
         { info_tbl: [(caOci,
                       label: block_caOci_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOci: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOcv; else goto caOcu;
       caOcv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOcu: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 _caOcy() //  [R1]
         { info_tbl: [(caOcy,
                       label: block_caOcy_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOcy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOcH; else goto caOcG;
       caOcH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOcG: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 _caO9d() //  [R1]
         { info_tbl: [(caO9d,
                       label: block_caO9d_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9d: // global
           I64[Sp] = block_caO9f_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOdc; else goto caO9g;
       uaOdc: // global
           call _caO9f(R1) args: 0, res: 0, upd: 0;
       caO9g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO9f() //  [R1]
         { info_tbl: [(caO9f,
                       label: block_caO9f_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9f: // global
           I64[Sp] = block_caO9k_info;
           _saLZI::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saLZI::P64;
           if (R1 & 7 != 0) goto uaOdd; else goto caO9l;
       uaOdd: // global
           call _caO9k(R1) args: 0, res: 0, upd: 0;
       caO9l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO9k() //  [R1]
         { info_tbl: [(caO9k,
                       label: block_caO9k_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9k: // global
           if (R1 & 7 == 1) goto caObL; else goto caOc1;
       caObL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caObO; else goto caObN;
       caObO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caObN: // global
           I64[Hp - 16] = sat_saLZO_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caObH_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caOc1: // global
           I64[Sp + 8] = block_caObZ_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOde; else goto caOc2;
       uaOde: // global
           call _caObZ(R1) args: 0, res: 0, upd: 0;
       caOc2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caObH() //  []
         { info_tbl: [(caObH,
                       label: block_caObH_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caObH: // global
           I64[Sp] = block_caObJ_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaOdl; else goto caObQ;
       uaOdl: // global
           call _caObJ(R1) args: 0, res: 0, upd: 0;
       caObQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caObJ() //  [R1]
         { info_tbl: [(caObJ,
                       label: block_caObJ_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caObJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caObW; else goto caObV;
       caObW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caObV: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 _caObZ() //  [R1]
         { info_tbl: [(caObZ,
                       label: block_caObZ_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caObZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOc8; else goto caOc7;
       caOc8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOc7: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 _caO6x() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6x: // global
           Hp = Hp + 64;
           _saLYF::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caOb3; else goto caOb2;
       caOb3: // global
           HpAlloc = 64;
           I64[Sp - 8] = block_caO6w_info;
           R1 = _saLYF::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOb2: // global
           I64[Hp - 56] = sat_saLYU_info;
           P64[Hp - 48] = P64[Sp];
           P64[Hp - 40] = _saLYF::P64;
           I64[Hp - 32] = sat_saLYP_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caO6w() //  [R1]
         { info_tbl: [(caO6w,
                       label: block_caO6w_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO6w: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caO6x() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.threadWaitReadSTM1_entry() //  [R2, R3]
         { info_tbl: [(caOdv,
                       label: GHC.Event.Thread.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOdv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOdw; else goto caOdx;
       caOdw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOdx: // global
           I64[Sp - 24] = block_caNYU_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caNYU() //  [R1]
         { info_tbl: [(caNYU,
                       label: block_caNYU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNYU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOdA; else goto caOdz;
       caOdA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOdz: // global
           I64[Hp - 16] = io_saLVx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caNYW::P64 = Hp - 15;
           if (R1 == 0) goto caOdu; else goto caOdt;
       caOdu: // global
           R1 = _caNYW::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caOdt: // global
           R1 = _caNYW::P64;
           Sp = Sp + 24;
           call io_saLVx_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.743003357 UTC

[section ""data" . threadWaitReadSTM2_raLJN_closure" {
     threadWaitReadSTM2_raLJN_closure:
         const threadWaitReadSTM2_raLJN_info;
         const 0;
 },
 threadWaitReadSTM2_raLJN_entry() //  [R2]
         { info_tbl: [(caOdF,
                       label: threadWaitReadSTM2_raLJN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOdF: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.74390452 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM_closure" {
     GHC.Event.Thread.threadWaitReadSTM_closure:
         const GHC.Event.Thread.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caOdM,
                       label: GHC.Event.Thread.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOdM: // global
           R2 = R2;
           call threadWaitReadSTM2_raLJN_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.744693947 UTC

[section ""data" . threadWaitWriteSTM1_raLJO_closure" {
     threadWaitWriteSTM1_raLJO_closure:
         const threadWaitWriteSTM1_raLJO_info;
         const 0;
 },
 threadWaitWriteSTM1_raLJO_entry() //  [R2]
         { info_tbl: [(caOdT,
                       label: threadWaitWriteSTM1_raLJO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOdT: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.745527237 UTC

[section ""data" . GHC.Event.Thread.threadWaitWriteSTM_closure" {
     GHC.Event.Thread.threadWaitWriteSTM_closure:
         const GHC.Event.Thread.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caOe0,
                       label: GHC.Event.Thread.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOe0: // global
           R2 = R2;
           call threadWaitWriteSTM1_raLJO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.746281317 UTC

[section ""cstring" . lvl25_raLJP_bytes" {
     lvl25_raLJP_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.747066691 UTC

[section ""data" . lvl26_raLJQ_closure" {
     lvl26_raLJQ_closure:
         const lvl26_raLJQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_raLJQ_entry() //  [R1]
         { info_tbl: [(caOe9,
                       label: lvl26_raLJQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOe9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOea; else goto caOeb;
       caOea: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOeb: // global
           (_caOe6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOe6::I64 == 0) goto caOe8; else goto caOe7;
       caOe8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOe7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOe6::I64;
           R2 = lvl25_raLJP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.748143117 UTC

[section ""data" . lvl27_raLJR_closure" {
     lvl27_raLJR_closure:
         const lvl27_raLJR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_raLJR_entry() //  [R1]
         { info_tbl: [(caOei,
                       label: lvl27_raLJR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOei: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOej; else goto caOek;
       caOej: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOek: // global
           (_caOef::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOef::I64 == 0) goto caOeh; else goto caOeg;
       caOeh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOeg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOef::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl26_raLJQ_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.749289361 UTC

[section ""data" . lvl28_raLJS_closure" {
     lvl28_raLJS_closure:
         const lvl28_raLJS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_raLJS_entry() //  [R1]
         { info_tbl: [(caOer,
                       label: lvl28_raLJS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOer: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOes; else goto caOet;
       caOes: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOet: // global
           (_caOeo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOeo::I64 == 0) goto caOeq; else goto caOep;
       caOeq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOep: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOeo::I64;
           R2 = lvl27_raLJR_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.761156601 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead1_closure" {
     GHC.Event.Thread.threadWaitRead1_closure:
         const GHC.Event.Thread.threadWaitRead1_info;
         const 0;
 },
 lvl31_saM1r_entry() //  [R1, R2, R3]
         { info_tbl: [(caOg9,
                       label: lvl31_saM1r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOg9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOga; else goto caOgb;
       caOga: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOgb: // global
           I64[Sp - 8] = block_caOg7_info;
           R2 = R3;
           R1 = P64[R1 + 5];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOg7() //  []
         { info_tbl: [(caOg7,
                       label: block_caOg7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOg7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saM25_entry() //  [R1, R2]
         { info_tbl: [(caOhi,
                       label: $wgo_saM25_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOhj; else goto caOhk;
       caOhj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOhk: // global
           I64[Sp - 24] = block_caOhb_info;
           _saM25::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saM18::I64;
           P64[Sp - 8] = _saM25::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaOhH; else goto caOhc;
       uaOhH: // global
           call _caOhb(R1) args: 0, res: 0, upd: 0;
       caOhc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOhb() //  [R1]
         { info_tbl: [(caOhb,
                       label: block_caOhb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhb: // global
           if (R1 & 7 == 1) goto caOhf; else goto caOhg;
       caOhf: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOhg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOhs; else goto caOhr;
       caOhs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOhr: // global
           _saM29::P64 = P64[R1 + 6];
           _saM2a::P64 = P64[R1 + 14];
           _saM28::I64 = I64[R1 + 22];
           if (_saM28::I64 == I64[Sp + 8]) goto caOhG; else goto caOhA;
       caOhG: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saM29::P64;
           R3 = _saM2a::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOhA: // global
           Hp = Hp - 16;
           I64[Sp] = block_caOhw_info;
           R2 = _saM2a::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saM29::P64;
           I64[Sp + 16] = _saM28::I64;
           call $wgo_saM25_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOhw() //  [R1, R2, R3]
         { info_tbl: [(caOhw,
                       label: block_caOhw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOhD; else goto caOhC;
       caOhD: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caOhC: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saM2U_entry() //  [R1, R2]
         { info_tbl: [(caOis,
                       label: $wgo_saM2U_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOis: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOit; else goto caOiu;
       caOit: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOiu: // global
           I64[Sp - 24] = block_caOil_info;
           _saM2U::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saM18::I64;
           P64[Sp - 8] = _saM2U::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaOiR; else goto caOim;
       uaOiR: // global
           call _caOil(R1) args: 0, res: 0, upd: 0;
       caOim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOil() //  [R1]
         { info_tbl: [(caOil,
                       label: block_caOil_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOil: // global
           if (R1 & 7 == 1) goto caOip; else goto caOiq;
       caOip: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOiq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOiC; else goto caOiB;
       caOiC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOiB: // global
           _saM2Y::P64 = P64[R1 + 6];
           _saM2Z::P64 = P64[R1 + 14];
           _saM2X::I64 = I64[R1 + 22];
           if (_saM2X::I64 == I64[Sp + 8]) goto caOiQ; else goto caOiK;
       caOiQ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saM2Y::P64;
           R3 = _saM2Z::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOiK: // global
           Hp = Hp - 16;
           I64[Sp] = block_caOiG_info;
           R2 = _saM2Z::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saM2Y::P64;
           I64[Sp + 16] = _saM2X::I64;
           call $wgo_saM2U_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOiG() //  [R1, R2, R3]
         { info_tbl: [(caOiG,
                       label: block_caOiG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOiG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOiN; else goto caOiM;
       caOiN: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caOiM: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saM1o_entry() //  [R1, R2]
         { info_tbl: [(caOiW,
                       label: $wio_saM1o_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOiW: // global
           _saM1p::P64 = R2;
           _saM1o::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caOiX; else goto caOiY;
       caOiY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caOj0; else goto caOiZ;
       caOj0: // global
           HpAlloc = 80;
           goto caOiX;
       caOiX: // global
           R2 = _saM1p::P64;
           R1 = _saM1o::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOiZ: // global
           _saM0z::P64 = P64[_saM1o::P64 + 6];
           _saM0Z::P64 = P64[_saM1o::P64 + 14];
           _saM11::P64 = P64[_saM1o::P64 + 22];
           _saM12::P64 = P64[_saM1o::P64 + 30];
           _saM17::P64 = P64[_saM1o::P64 + 38];
           _saM16::I64 = I64[_saM1o::P64 + 46];
           _saM18::I64 = I64[_saM1o::P64 + 54];
           _saM1a::I64 = I64[_saM1o::P64 + 62];
           I64[Hp - 72] = lvl31_saM1r_info;
           P64[Hp - 64] = _saM0z::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saM18::I64;
           I64[Hp - 32] = _saM16::I64;
           I64[Hp - 24] = _saM1a::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caOfP_info;
           R5 = _saM1p::P64;
           R4 = Hp - 14;
           R3 = _saM18::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saM0Z::P64;
           P64[Sp - 48] = _saM11::P64;
           P64[Sp - 40] = _saM12::P64;
           P64[Sp - 32] = _saM17::P64;
           I64[Sp - 24] = _saM18::I64;
           I64[Sp - 16] = _saM1a::I64;
           P64[Sp - 8] = _saM1p::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOfP() //  [R1]
         { info_tbl: [(caOfP,
                       label: block_caOfP_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfP: // global
           I64[Sp - 8] = block_caOfT_info;
           _saM1A::P64 = R1;
           R1 = R1;
           P64[Sp] = _saM1A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOlk; else goto caOfU;
       uaOlk: // global
           call _caOfT(R1) args: 0, res: 0, upd: 0;
       caOfU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOfT() //  [R1]
         { info_tbl: [(caOfT,
                       label: block_caOfT_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfT: // global
           if (R1 & 7 == 1) goto caOiT; else goto caOiU;
       caOiT: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saM1B() args: 0, res: 0, upd: 0;
       caOiU: // global
           I64[Sp] = block_caOfZ_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOfZ() //  [R1]
         { info_tbl: [(caOfZ,
                       label: block_caOfZ_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOkT; else goto caOkS;
       caOkT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOkS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saM1B() args: 0, res: 0, upd: 0;
     }
 },
 _saM1B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saM1B: // global
           _saM1D::P64 = P64[Sp];
           I64[Sp] = block_caOgg_info;
           R1 = _saM1D::P64;
           if (R1 & 7 != 0) goto uaOlF; else goto caOgh;
       uaOlF: // global
           call _caOgg(R1) args: 0, res: 0, upd: 0;
       caOgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOgg() //  [R1]
         { info_tbl: [(caOgg,
                       label: block_caOgg_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgg: // global
           _saM1G::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saM1H::I64 = _saM1G::I64 & 8;
           if (_saM1H::I64 != 0) goto uaOld; else goto uaOlc;
       uaOld: // global
           I64[Sp] = _saM1H::I64;
           I64[Sp + 40] = _saM1G::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caOgs() args: 0, res: 0, upd: 0;
       uaOlc: // global
           I64[Sp + 32] = _saM1H::I64;
           I64[Sp + 64] = _saM1G::I64;
           Sp = Sp + 16;
           call _caOhK() args: 0, res: 0, upd: 0;
     }
 },
 _caOgs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOj8; else goto caOj7;
       caOj8: // global
           HpAlloc = 32;
           _saM1H::I64 = I64[Sp];
           I64[Sp] = block_caOgr_info;
           R1 = _saM1H::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOj7: // global
           _saM1G::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saM1G::I64) goto caOja; else goto caOjb;
       caOja: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOjb: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saM1G::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caOgG_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caOgr() //  [R1]
         { info_tbl: [(caOgr,
                       label: block_caOgr_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgr: // global
           I64[Sp] = R1;
           call _caOgs() args: 0, res: 0, upd: 0;
     }
 },
 _caOgG() //  [R1]
         { info_tbl: [(caOgG,
                       label: block_caOgG_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgG: // global
           I64[Sp] = block_caOgI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOlq; else goto caOgJ;
       uaOlq: // global
           call _caOgI(R1) args: 0, res: 0, upd: 0;
       caOgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOgI() //  [R1]
         { info_tbl: [(caOgI,
                       label: block_caOgI_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgI: // global
           if (R1 & 7 == 1) goto caOjf; else goto caOjX;
       caOjf: // global
           I64[Sp + 40] = block_caOgN_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaOlr; else goto caOgO;
       uaOlr: // global
           call _caOgN(R1) args: 0, res: 0, upd: 0;
       caOgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caOjX: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOgN() //  [R1]
         { info_tbl: [(caOgN,
                       label: block_caOgN_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgN: // global
           _saM1p::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caOji; else goto caOjR;
       caOji: // global
           I64[Sp] = block_caOgS_info;
           R1 = P64[_saM1p::P64 + 8];
           if (R1 & 7 != 0) goto uaOls; else goto caOgT;
       uaOls: // global
           call _caOgS(R1) args: 0, res: 0, upd: 0;
       caOgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caOjR: // global
           I64[Sp + 24] = block_caOjP_info;
           R5 = _saM1p::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOgS() //  [R1]
         { info_tbl: [(caOgS,
                       label: block_caOgS_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOgS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOjl; else goto caOjk;
       caOjl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOjk: // global
           _saM18::I64 = I64[Sp + 8];
           _saM1W::P64 = P64[R1 + 7];
           _saM1Y::P64 = P64[R1 + 15];
           _saM1X::I64 = I64[R1 + 23];
           _saM1Z::I64 = _saM18::I64 & (I64[_saM1W::P64 + 8] - 1);
           _saM24::P64 = P64[(_saM1W::P64 + 24) + (_saM1Z::I64 << 3)];
           I64[Hp - 8] = $wgo_saM25_info;
           I64[Hp] = _saM18::I64;
           I64[Sp - 8] = block_caOjm_info;
           R2 = _saM24::P64;
           R1 = Hp - 7;
           I64[Sp] = _saM1Z::I64;
           P64[Sp + 8] = _saM1Y::P64;
           I64[Sp + 16] = _saM1X::I64;
           P64[Sp + 24] = _saM1W::P64;
           Sp = Sp - 8;
           call $wgo_saM25_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOjm() //  [R1, R2, R3]
         { info_tbl: [(caOjm,
                       label: block_caOjm_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOjm: // global
           I64[Sp - 16] = block_caOjo_info;
           _saM2j::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saM2j::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOlx; else goto caOjq;
       uaOlx: // global
           call _caOjo(R1) args: 0, res: 0, upd: 0;
       caOjq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOjo() //  [R1]
         { info_tbl: [(caOjo,
                       label: block_caOjo_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOjo: // global
           if (R1 & 7 == 1) goto uaOlf; else goto caOjB;
       uaOlf: // global
           Sp = Sp + 56;
           call _caOky() args: 0, res: 0, upd: 0;
       caOjB: // global
           _saM1W::P64 = P64[Sp + 48];
           _saM1Z::I64 = I64[Sp + 24];
           _saM2j::P64 = P64[Sp + 16];
           _saM2l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saM1W::P64 + 24) + (_saM1Z::I64 << 3)] = _saM2l::P64;
           I64[_saM1W::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saM1W::P64 + 24) + ((I64[_saM1W::P64 + 8] << 3) + (_saM1Z::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caOjz_info;
           R1 = _saM2j::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaOly; else goto caOjC;
       uaOly: // global
           call _caOjz(R1) args: 0, res: 0, upd: 0;
       caOjC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOjz() //  [R1]
         { info_tbl: [(caOjz,
                       label: block_caOjz_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOjz: // global
           if (R1 & 7 == 1) goto uaOlg; else goto caOjM;
       uaOlg: // global
           Sp = Sp + 32;
           call _caOky() args: 0, res: 0, upd: 0;
       caOjM: // global
           _saM1X::I64 = I64[Sp + 16];
           _saM1Y::P64 = P64[Sp + 8];
           I64[_saM1X::I64] = I64[_saM1X::I64] - 1;
           call MO_Touch(_saM1Y::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOjP() //  []
         { info_tbl: [(caOjP,
                       label: block_caOjP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOjP: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOhK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOk1; else goto caOk0;
       caOk1: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caOhJ_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOk0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caOhQ_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOhJ() //  [R1]
         { info_tbl: [(caOhJ,
                       label: block_caOhJ_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhJ: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caOhK() args: 0, res: 0, upd: 0;
     }
 },
 _caOhQ() //  [R1]
         { info_tbl: [(caOhQ,
                       label: block_caOhQ_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhQ: // global
           I64[Sp] = block_caOhS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOlu; else goto caOhT;
       uaOlu: // global
           call _caOhS(R1) args: 0, res: 0, upd: 0;
       caOhT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOhS() //  [R1]
         { info_tbl: [(caOhS,
                       label: block_caOhS_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhS: // global
           if (R1 & 7 == 1) goto caOk5; else goto caOkN;
       caOk5: // global
           I64[Sp + 40] = block_caOhX_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaOlv; else goto caOhY;
       uaOlv: // global
           call _caOhX(R1) args: 0, res: 0, upd: 0;
       caOhY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caOkN: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOhX() //  [R1]
         { info_tbl: [(caOhX,
                       label: block_caOhX_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOhX: // global
           _saM1p::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caOk8; else goto caOkH;
       caOk8: // global
           I64[Sp] = block_caOi2_info;
           R1 = P64[_saM1p::P64 + 8];
           if (R1 & 7 != 0) goto uaOlw; else goto caOi3;
       uaOlw: // global
           call _caOi2(R1) args: 0, res: 0, upd: 0;
       caOi3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caOkH: // global
           I64[Sp + 24] = block_caOkF_info;
           R5 = _saM1p::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOi2() //  [R1]
         { info_tbl: [(caOi2,
                       label: block_caOi2_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOi2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOkb; else goto caOka;
       caOkb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOka: // global
           _saM18::I64 = I64[Sp + 8];
           _saM2L::P64 = P64[R1 + 7];
           _saM2N::P64 = P64[R1 + 15];
           _saM2M::I64 = I64[R1 + 23];
           _saM2O::I64 = _saM18::I64 & (I64[_saM2L::P64 + 8] - 1);
           _saM2T::P64 = P64[(_saM2L::P64 + 24) + (_saM2O::I64 << 3)];
           I64[Hp - 8] = $wgo_saM2U_info;
           I64[Hp] = _saM18::I64;
           I64[Sp - 8] = block_caOkc_info;
           R2 = _saM2T::P64;
           R1 = Hp - 7;
           I64[Sp] = _saM2O::I64;
           P64[Sp + 8] = _saM2N::P64;
           I64[Sp + 16] = _saM2M::I64;
           P64[Sp + 24] = _saM2L::P64;
           Sp = Sp - 8;
           call $wgo_saM2U_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOkc() //  [R1, R2, R3]
         { info_tbl: [(caOkc,
                       label: block_caOkc_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOkc: // global
           I64[Sp - 16] = block_caOke_info;
           _saM38::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saM38::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOlB; else goto caOkg;
       uaOlB: // global
           call _caOke(R1) args: 0, res: 0, upd: 0;
       caOkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOke() //  [R1]
         { info_tbl: [(caOke,
                       label: block_caOke_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOke: // global
           if (R1 & 7 == 1) goto uaOli; else goto caOkr;
       uaOli: // global
           Sp = Sp + 56;
           call _caOky() args: 0, res: 0, upd: 0;
       caOkr: // global
           _saM2L::P64 = P64[Sp + 48];
           _saM2O::I64 = I64[Sp + 24];
           _saM38::P64 = P64[Sp + 16];
           _saM3a::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saM2L::P64 + 24) + (_saM2O::I64 << 3)] = _saM3a::P64;
           I64[_saM2L::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saM2L::P64 + 24) + ((I64[_saM2L::P64 + 8] << 3) + (_saM2O::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caOkp_info;
           R1 = _saM38::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaOlC; else goto caOks;
       uaOlC: // global
           call _caOkp(R1) args: 0, res: 0, upd: 0;
       caOks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOkp() //  [R1]
         { info_tbl: [(caOkp,
                       label: block_caOkp_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOkp: // global
           if (R1 & 7 == 1) goto uaOlj; else goto caOkC;
       uaOlj: // global
           Sp = Sp + 32;
           call _caOky() args: 0, res: 0, upd: 0;
       caOkC: // global
           _saM2M::I64 = I64[Sp + 16];
           _saM2N::P64 = P64[Sp + 8];
           I64[_saM2M::I64] = I64[_saM2M::I64] - 1;
           call MO_Touch(_saM2N::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOky() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOky: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOkF() //  []
         { info_tbl: [(caOkF,
                       label: block_caOkF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOkF: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saM3t_entry() //  [R1, R2]
         { info_tbl: [(caOlO,
                       label: io1_saM3t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOlO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOlP; else goto caOlQ;
       caOlP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOlQ: // global
           I64[Sp - 16] = block_caOlL_info;
           _saM1o::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saM1o::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOlU; else goto caOlM;
       uaOlU: // global
           call _caOlL(R1) args: 0, res: 0, upd: 0;
       caOlM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOlL() //  [R1]
         { info_tbl: [(caOlL,
                       label: block_caOlL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOlL: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saM1o_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3I_entry() //  [R1, R2]
         { info_tbl: [(caOm7,
                       label: sat_saM3I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOm8; else goto caOm9;
       caOm8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOm9: // global
           I64[Sp - 16] = block_caOm5_info;
           R3 = P64[R1 + 14];
           _saM3D::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM3D::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOm5() //  []
         { info_tbl: [(caOm5,
                       label: block_caOm5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOm5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3C_entry() //  [R1]
         { info_tbl: [(caOmg,
                       label: sat_saM3C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOmg: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3Y_entry() //  [R1, R2]
         { info_tbl: [(caOmu,
                       label: sat_saM3Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOmu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOmv; else goto caOmw;
       caOmv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOmw: // global
           I64[Sp - 16] = block_caOms_info;
           _saM3V::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM3V::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOms() //  []
         { info_tbl: [(caOms,
                       label: block_caOms_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOms: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3T_entry() //  [R1]
         { info_tbl: [(caOmD,
                       label: sat_saM3T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOmD: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3U_entry() //  [R1]
         { info_tbl: [(caOmL,
                       label: sat_saM3U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOmL: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4l_entry() //  [R1, R2]
         { info_tbl: [(caOn3,
                       label: sat_saM4l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOn3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOn4; else goto caOn5;
       caOn4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOn5: // global
           I64[Sp - 16] = block_caOn1_info;
           _saM4i::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM4i::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOn1() //  []
         { info_tbl: [(caOn1,
                       label: block_caOn1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOn1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4g_entry() //  [R1]
         { info_tbl: [(caOnc,
                       label: sat_saM4g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnc: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4h_entry() //  [R1]
         { info_tbl: [(caOnk,
                       label: sat_saM4h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnk: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4q_entry() //  [R1]
         { info_tbl: [(caOnr,
                       label: sat_saM4q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOns; else goto caOnt;
       caOns: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOnt: // global
           I64[Sp - 24] = block_caOmU_info;
           _saM1n::P64 = P64[R1 + 7];
           _saM3t::P64 = P64[R1 + 15];
           R1 = _saM1n::P64;
           P64[Sp - 16] = _saM1n::P64;
           P64[Sp - 8] = _saM3t::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOmU() //  [R1]
         { info_tbl: [(caOmU,
                       label: block_caOmU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOmU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOnw; else goto caOnv;
       caOnw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOnv: // global
           I64[Hp - 56] = sat_saM4l_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM4g_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM4h_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caOnn_info;
           R2 = Hp - 54;
           _saM4f::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saM4f::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOnn() //  [R1]
         { info_tbl: [(caOnn,
                       label: block_caOnn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnn: // global
           _saM1n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOnp_info;
           R2 = P64[Sp + 16];
           _saM4o::P64 = R1;
           R1 = _saM1n::P64;
           P64[Sp + 16] = _saM4o::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOnp() //  []
         { info_tbl: [(caOnp,
                       label: block_caOnp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4L_entry() //  [R1, R2]
         { info_tbl: [(caOnJ,
                       label: sat_saM4L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOnK; else goto caOnL;
       caOnK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOnL: // global
           I64[Sp - 16] = block_caOnH_info;
           _saM4I::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM4I::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOnH() //  []
         { info_tbl: [(caOnH,
                       label: block_caOnH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4G_entry() //  [R1]
         { info_tbl: [(caOnS,
                       label: sat_saM4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnS: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4H_entry() //  [R1]
         { info_tbl: [(caOo0,
                       label: sat_saM4H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOo0: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saM0v_entry() //  [R1]
         { info_tbl: [(caOo7,
                       label: io_saM0v_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOo7: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caOo8; else goto caOo9;
       caOo8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOo9: // global
           I64[Sp - 24] = block_caOeF_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caOeF() //  [R1]
         { info_tbl: [(caOeF,
                       label: block_caOeF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOeF: // global
           I64[Sp - 8] = block_caOeH_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caOeH() //  [R1]
         { info_tbl: [(caOeH,
                       label: block_caOeH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOeH: // global
           I64[Sp] = block_caOeJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOrp; else goto caOeK;
       uaOrp: // global
           call _caOeJ(R1) args: 0, res: 0, upd: 0;
       caOeK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOeJ() //  [R1]
         { info_tbl: [(caOeJ,
                       label: block_caOeJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOeJ: // global
           if (R1 & 7 == 1) goto caOo4; else goto caOo5;
       caOo4: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caOo5: // global
           I64[Sp] = block_caOeP_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaOrq; else goto caOeQ;
       uaOrq: // global
           call _caOeP(R1) args: 0, res: 0, upd: 0;
       caOeQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOeP() //  [R1]
         { info_tbl: [(caOeP,
                       label: block_caOeP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOeP: // global
           I64[Sp - 40] = block_caOeU_info;
           _saM0G::P64 = R1;
           _saM0H::P64 = P64[R1 + 7];
           _saM0J::P64 = P64[R1 + 23];
           _saM0L::P64 = P64[R1 + 31];
           _saM0N::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saM0H::P64;
           P64[Sp - 24] = _saM0J::P64;
           P64[Sp - 16] = _saM0L::P64;
           P64[Sp - 8] = _saM0N::P64;
           P64[Sp] = _saM0G::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaOrr; else goto caOeV;
       uaOrr: // global
           call _caOeU(R1) args: 0, res: 0, upd: 0;
       caOeV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOeU() //  [R1]
         { info_tbl: [(caOeU,
                       label: block_caOeU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOeU: // global
           I64[Sp - 8] = block_caOeZ_info;
           _saM0U::P64 = R1;
           _saM0V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM0V::I64;
           P64[Sp + 16] = _saM0U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOrs; else goto caOf0;
       uaOrs: // global
           call _caOeZ(R1) args: 0, res: 0, upd: 0;
       caOf0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOeZ() //  [R1]
         { info_tbl: [(caOeZ,
                       label: block_caOeZ_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOeZ: // global
           I64[Sp - 8] = block_caOf4_info;
           _saM0W::P64 = R1;
           _saM0X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM0X::I64;
           P64[Sp + 16] = _saM0W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOrt; else goto caOf5;
       uaOrt: // global
           call _caOf4(R1) args: 0, res: 0, upd: 0;
       caOf5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOf4() //  [R1]
         { info_tbl: [(caOf4,
                       label: block_caOf4_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOf4: // global
           _saM0q::P64 = P64[Sp + 80];
           _saM0Z::P64 = P64[R1 + 7];
           _saM11::P64 = P64[R1 + 23];
           _saM12::P64 = P64[R1 + 31];
           (_saM16::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caOfb_info;
           R1 = _saM0q::P64;
           I64[Sp - 8] = _saM16::I64;
           P64[Sp] = _saM12::P64;
           P64[Sp + 48] = _saM11::P64;
           P64[Sp + 80] = _saM0Z::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOru; else goto caOfc;
       uaOru: // global
           call _caOfb(R1) args: 0, res: 0, upd: 0;
       caOfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOfb() //  [R1]
         { info_tbl: [(caOfb,
                       label: block_caOfb_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfb: // global
           I64[Sp - 8] = block_caOfg_info;
           _saM17::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saM18::I64;
           P64[Sp + 88] = _saM17::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOrv; else goto caOfh;
       uaOrv: // global
           call _caOfg(R1) args: 0, res: 0, upd: 0;
       caOfh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOfg() //  [R1]
         { info_tbl: [(caOfg,
                       label: block_caOfg_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfg: // global
           I64[Sp - 16] = block_caOfl_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caOfl() //  [R1]
         { info_tbl: [(caOfl,
                       label: block_caOfl_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfl: // global
           _saM0U::P64 = P64[Sp + 72];
           _saM0V::I64 = I64[Sp + 56];
           _saM0W::P64 = P64[Sp + 64];
           _saM1e::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saM0V::I64,
                            _saM1e::I64)) goto caOop; else goto caOr7;
       caOr7: // global
           if (%MO_S_Gt_W64(_saM1e::I64,
                            I64[Sp + 48])) goto caOop; else goto caOoq;
       caOop: // global
           R4 = _saM1e::I64;
           R3 = _saM0U::P64;
           R2 = _saM0W::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caOoq: // global
           _saM1l::P64 = P64[P64[Sp + 80] + ((_saM1e::I64 - _saM0V::I64 << 3) + 24)];
           I64[Sp] = block_caOfB_info;
           _saM1d::I64 = R1;
           R1 = _saM1l::P64;
           I64[Sp + 80] = _saM1d::I64;
           if (R1 & 7 != 0) goto uaOrw; else goto caOfC;
       uaOrw: // global
           call _caOfB(R1) args: 0, res: 0, upd: 0;
       caOfC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOfB() //  [R1]
         { info_tbl: [(caOfB,
                       label: block_caOfB_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOfB: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caOot; else goto caOos;
       caOot: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOos: // global
           _saM1n::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saM1o_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saM3t_info;
           P64[Hp - 24] = Hp - 102;
           _caOlG::P64 = Hp - 30;
           _saM3P::I64 = I64[Sp + 80];
           if (_saM3P::I64 != 0) goto uaOrh; else goto caOpK;
       uaOrh: // global
           if (_saM3P::I64 != 1) goto caOp1; else goto caOqr;
       caOp1: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caOml_info;
           R1 = _saM1n::P64;
           P64[Sp + 112] = _saM1n::P64;
           P64[Sp + 120] = _caOlG::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caOqr: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caOnA_info;
           R1 = _saM1n::P64;
           P64[Sp + 112] = _saM1n::P64;
           P64[Sp + 120] = _caOlG::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caOpK: // global
           I64[Hp - 16] = sat_saM4q_info;
           P64[Hp - 8] = _saM1n::P64;
           P64[Hp] = _caOlG::P64;
           I64[Sp + 8] = block_caOpH_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOml() //  [R1]
         { info_tbl: [(caOml,
                       label: block_caOml_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOml: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOp4; else goto caOp3;
       caOp4: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOp3: // global
           I64[Hp - 56] = sat_saM3Y_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM3T_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM3U_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caOoV_info;
           R2 = Hp - 54;
           _saM3S::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saM3S::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOoV() //  [R1]
         { info_tbl: [(caOoV,
                       label: block_caOoV_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOoV: // global
           I64[Sp] = block_caOoX_info;
           R2 = P64[Sp + 112];
           _saM41::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM41::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOoX() //  []
         { info_tbl: [(caOoX,
                       label: block_caOoX_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOoX: // global
           I64[Sp] = block_caOoZ_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaOrz; else goto caOp7;
       uaOrz: // global
           call _caOoZ(R1) args: 0, res: 0, upd: 0;
       caOp7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOoZ() //  [R1]
         { info_tbl: [(caOoZ,
                       label: block_caOoZ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOoZ: // global
           I64[Sp] = block_caOpb_info;
           _saM44::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM44::P64;
           if (R1 & 7 != 0) goto uaOrA; else goto caOpd;
       uaOrA: // global
           call _caOpb(R1) args: 0, res: 0, upd: 0;
       caOpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOpb() //  [R1]
         { info_tbl: [(caOpb,
                       label: block_caOpb_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpb: // global
           if (R1 & 7 == 1) goto caOpm; else goto caOpz;
       caOpm: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOph_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caOpz: // global
           I64[Sp + 8] = block_caOpx_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOrB; else goto caOpA;
       uaOrB: // global
           call _caOpx(R1) args: 0, res: 0, upd: 0;
       caOpA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOph() //  []
         { info_tbl: [(caOph,
                       label: block_caOph_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOph: // global
           I64[Sp] = block_caOpj_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaOrC; else goto caOpo;
       uaOrC: // global
           call _caOpj(R1) args: 0, res: 0, upd: 0;
       caOpo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOpj() //  [R1]
         { info_tbl: [(caOpj,
                       label: block_caOpj_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOpu; else goto caOpt;
       caOpu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOpt: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOpx() //  [R1]
         { info_tbl: [(caOpx,
                       label: block_caOpx_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOpG; else goto caOpF;
       caOpG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOpF: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOnA() //  [R1]
         { info_tbl: [(caOnA,
                       label: block_caOnA_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOnA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOqu; else goto caOqt;
       caOqu: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOqt: // global
           I64[Hp - 56] = sat_saM4L_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM4G_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM4H_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caOqm_info;
           R2 = Hp - 54;
           _saM4F::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saM4F::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOqm() //  [R1]
         { info_tbl: [(caOqm,
                       label: block_caOqm_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqm: // global
           I64[Sp] = block_caOqo_info;
           R2 = P64[Sp + 112];
           _saM4O::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM4O::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOqo() //  []
         { info_tbl: [(caOqo,
                       label: block_caOqo_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqo: // global
           I64[Sp] = block_caOqq_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaOrL; else goto caOqx;
       uaOrL: // global
           call _caOqq(R1) args: 0, res: 0, upd: 0;
       caOqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOqq() //  [R1]
         { info_tbl: [(caOqq,
                       label: block_caOqq_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqq: // global
           I64[Sp] = block_caOqB_info;
           _saM4R::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM4R::P64;
           if (R1 & 7 != 0) goto uaOrM; else goto caOqD;
       uaOrM: // global
           call _caOqB(R1) args: 0, res: 0, upd: 0;
       caOqD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOqB() //  [R1]
         { info_tbl: [(caOqB,
                       label: block_caOqB_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqB: // global
           if (R1 & 7 == 1) goto caOqM; else goto caOqZ;
       caOqM: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOqH_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caOqZ: // global
           I64[Sp + 8] = block_caOqX_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOrN; else goto caOr0;
       uaOrN: // global
           call _caOqX(R1) args: 0, res: 0, upd: 0;
       caOr0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOqH() //  []
         { info_tbl: [(caOqH,
                       label: block_caOqH_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqH: // global
           I64[Sp] = block_caOqJ_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaOrO; else goto caOqO;
       uaOrO: // global
           call _caOqJ(R1) args: 0, res: 0, upd: 0;
       caOqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOqJ() //  [R1]
         { info_tbl: [(caOqJ,
                       label: block_caOqJ_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOqU; else goto caOqT;
       caOqU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOqT: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOqX() //  [R1]
         { info_tbl: [(caOqX,
                       label: block_caOqX_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOr6; else goto caOr5;
       caOr6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOr5: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOpH() //  [R1]
         { info_tbl: [(caOpH,
                       label: block_caOpH_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpH: // global
           I64[Sp] = block_caOpJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOrF; else goto caOpM;
       uaOrF: // global
           call _caOpJ(R1) args: 0, res: 0, upd: 0;
       caOpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOpJ() //  [R1]
         { info_tbl: [(caOpJ,
                       label: block_caOpJ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpJ: // global
           I64[Sp] = block_caOpQ_info;
           _saM4v::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM4v::P64;
           if (R1 & 7 != 0) goto uaOrG; else goto caOpS;
       uaOrG: // global
           call _caOpQ(R1) args: 0, res: 0, upd: 0;
       caOpS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOpQ() //  [R1]
         { info_tbl: [(caOpQ,
                       label: block_caOpQ_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpQ: // global
           if (R1 & 7 == 1) goto caOq1; else goto caOqe;
       caOq1: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOpW_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caOqe: // global
           I64[Sp + 8] = block_caOqc_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOrH; else goto caOqf;
       uaOrH: // global
           call _caOqc(R1) args: 0, res: 0, upd: 0;
       caOqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOpW() //  []
         { info_tbl: [(caOpW,
                       label: block_caOpW_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpW: // global
           I64[Sp] = block_caOpY_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaOrI; else goto caOq3;
       uaOrI: // global
           call _caOpY(R1) args: 0, res: 0, upd: 0;
       caOq3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOpY() //  [R1]
         { info_tbl: [(caOpY,
                       label: block_caOpY_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOpY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOq9; else goto caOq8;
       caOq9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOq8: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOqc() //  [R1]
         { info_tbl: [(caOqc,
                       label: block_caOqc_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOqc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOql; else goto caOqk;
       caOql: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOqk: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOlY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOlY: // global
           Hp = Hp + 40;
           _saM3A::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caOoz; else goto caOoy;
       caOoz: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caOlX_info;
           R1 = _saM3A::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOoy: // global
           I64[Hp - 32] = sat_saM3I_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = _saM3A::P64;
           I64[Hp - 8] = sat_saM3C_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_caOou_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOlX() //  [R1]
         { info_tbl: [(caOlX,
                       label: block_caOlX_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOlX: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caOlY() args: 0, res: 0, upd: 0;
     }
 },
 _caOou() //  [R1]
         { info_tbl: [(caOou,
                       label: block_caOou_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOou: // global
           I64[Sp] = block_caOow_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOry; else goto caOoB;
       uaOry: // global
           call _caOow(R1) args: 0, res: 0, upd: 0;
       caOoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOow() //  [R1]
         { info_tbl: [(caOow,
                       label: block_caOow_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOow: // global
           if (I64[R1 + 7] & 4 == 0) goto caOoR; else goto caOoL;
       caOoR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOoL: // global
           R1 = lvl28_raLJS_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.threadWaitRead1_entry() //  [R2, R3]
         { info_tbl: [(caOrV,
                       label: GHC.Event.Thread.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOrV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOrW; else goto caOrX;
       caOrW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitRead1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOrX: // global
           I64[Sp - 24] = block_caOey_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caOey() //  [R1]
         { info_tbl: [(caOey,
                       label: block_caOey_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOey: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOs0; else goto caOrZ;
       caOs0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOrZ: // global
           I64[Hp - 16] = io_saM0v_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caOeA::P64 = Hp - 15;
           if (R1 == 0) goto caOrU; else goto caOrT;
       caOrU: // global
           R1 = _caOeA::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caOrT: // global
           R1 = _caOeA::P64;
           Sp = Sp + 24;
           call io_saM0v_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.785801079 UTC

[section ""data" . threadWaitWrite1_raLJT_closure" {
     threadWaitWrite1_raLJT_closure:
         const threadWaitWrite1_raLJT_info;
         const 0;
 },
 threadWaitWrite1_raLJT_entry() //  [R2]
         { info_tbl: [(caOs5,
                       label: threadWaitWrite1_raLJT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOs5: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.786706597 UTC

[section ""data" . GHC.Event.Thread.threadWaitWrite_closure" {
     GHC.Event.Thread.threadWaitWrite_closure:
         const GHC.Event.Thread.threadWaitWrite_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caOsc,
                       label: GHC.Event.Thread.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsc: // global
           R2 = R2;
           call threadWaitWrite1_raLJT_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.787573201 UTC

[section ""data" . threadWaitRead2_raLJU_closure" {
     threadWaitRead2_raLJU_closure:
         const threadWaitRead2_raLJU_info;
         const 0;
 },
 threadWaitRead2_raLJU_entry() //  [R2]
         { info_tbl: [(caOsj,
                       label: threadWaitRead2_raLJU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsj: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.788426563 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead_closure" {
     GHC.Event.Thread.threadWaitRead_closure:
         const GHC.Event.Thread.threadWaitRead_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caOsq,
                       label: GHC.Event.Thread.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsq: // global
           R2 = R2;
           call threadWaitRead2_raLJU_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.789183361 UTC

[section ""cstring" . lvl29_raLJV_bytes" {
     lvl29_raLJV_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,48,52,58,53,45,49,55]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.790010495 UTC

[section ""data" . lvl30_raLJW_closure" {
     lvl30_raLJW_closure:
         const lvl30_raLJW_info;
         const 0;
 },
 lvl30_raLJW_entry() //  []
         { info_tbl: [(caOsz,
                       label: lvl30_raLJW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOsA; else goto caOsB;
       caOsA: // global
           R1 = lvl30_raLJW_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOsB: // global
           I64[Sp - 8] = block_caOsx_info;
           R2 = lvl29_raLJV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOsx() //  [R1]
         { info_tbl: [(caOsx,
                       label: block_caOsx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsx: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.791376033 UTC

[section ""data" . go_raLJX_closure" {
     go_raLJX_closure:
         const go_raLJX_info;
 },
 go_raLJX_entry() //  [R2]
         { info_tbl: [(caOsQ,
                       label: go_raLJX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOsR; else goto uaOt2;
       caOsR: // global
           R2 = R2;
           R1 = go_raLJX_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaOt2: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caOsG() args: 0, res: 0, upd: 0;
     }
 },
 _caOsG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsG: // global
           _saM52::P64 = P64[Sp];
           I64[Sp] = block_caOsJ_info;
           R1 = _saM52::P64;
           if (R1 & 7 != 0) goto uaOt4; else goto caOsK;
       uaOt4: // global
           call _caOsJ(R1) args: 0, res: 0, upd: 0;
       caOsK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOsJ() //  [R1]
         { info_tbl: [(caOsJ,
                       label: block_caOsJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsJ: // global
           if (R1 & 7 == 1) goto caOsN; else goto caOsO;
       caOsN: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOsO: // global
           I64[Sp - 8] = block_caOsY_info;
           _saM56::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM56::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOsY() //  []
         { info_tbl: [(caOsY,
                       label: block_caOsY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOsY: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caOsG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.79893209 UTC

[section ""data" . GHC.Event.Thread.closeFdWith1_closure" {
     GHC.Event.Thread.closeFdWith1_closure:
         const GHC.Event.Thread.closeFdWith1_info;
         const 0;
 },
 go1_saM5z_entry() //  [R1, R2]
         { info_tbl: [(caOtT,
                       label: go1_saM5z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtT: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caOtU; else goto caOtV;
       caOtU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOtV: // global
           I64[Sp - 24] = block_caOtM_info;
           _saM5z::P64 = R1;
           _saM5b::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _saM5b::P64;
           P64[Sp - 8] = _saM5z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaOv0; else goto caOtN;
       uaOv0: // global
           call _caOtM(R1) args: 0, res: 0, upd: 0;
       caOtN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOtM() //  [R1]
         { info_tbl: [(caOtM,
                       label: block_caOtM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtM: // global
           if (R1 & 7 == 1) goto caOtQ; else goto caOtR;
       caOtQ: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOtR: // global
           I64[Sp - 8] = block_caOu1_info;
           _saM5E::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM5E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOuZ; else goto caOu2;
       uaOuZ: // global
           call _caOu1(R1) args: 0, res: 0, upd: 0;
       caOu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOu1() //  [R1]
         { info_tbl: [(caOu1,
                       label: block_caOu1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOu1: // global
           I64[Sp - 16] = block_caOu6_info;
           _saM5I::P64 = P64[R1 + 23];
           _saM5K::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saM5K::P64;
           P64[Sp] = _saM5I::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOv1; else goto caOu7;
       uaOv1: // global
           call _caOu6(R1) args: 0, res: 0, upd: 0;
       caOu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOu6() //  [R1]
         { info_tbl: [(caOu6,
                       label: block_caOu6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOu6: // global
           I64[Sp - 8] = block_caOub_info;
           _saM5T::P64 = R1;
           _saM5U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM5U::I64;
           P64[Sp + 16] = _saM5T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOv2; else goto caOuc;
       uaOv2: // global
           call _caOub(R1) args: 0, res: 0, upd: 0;
       caOuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOub() //  [R1]
         { info_tbl: [(caOub,
                       label: block_caOub_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOub: // global
           I64[Sp - 8] = block_caOug_info;
           _saM5V::P64 = R1;
           _saM5W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saM5W::I64;
           P64[Sp + 40] = _saM5V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOv3; else goto caOul;
       uaOv3: // global
           call _caOug(R1) args: 0, res: 0, upd: 0;
       caOul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOug() //  [R1]
         { info_tbl: [(caOug,
                       label: block_caOug_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOug: // global
           _saM5T::P64 = P64[Sp + 32];
           _saM5U::I64 = I64[Sp + 16];
           _saM5V::P64 = P64[Sp + 48];
           _saM5Z::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saM5U::I64,
                            _saM5Z::I64)) goto caOuC; else goto caOuY;
       caOuY: // global
           if (%MO_S_Gt_W64(_saM5Z::I64,
                            I64[Sp + 8])) goto caOuC; else goto caOuS;
       caOuC: // global
           R4 = _saM5Z::I64;
           R3 = _saM5T::P64;
           R2 = _saM5V::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caOuS: // global
           _saM66::P64 = P64[P64[Sp + 24] + ((_saM5Z::I64 - _saM5U::I64 << 3) + 24)];
           I64[Sp + 32] = block_caOuI_info;
           R1 = _saM66::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uaOv4; else goto caOuJ;
       uaOv4: // global
           call _caOuI(R1) args: 0, res: 0, upd: 0;
       caOuJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOuI() //  [R1]
         { info_tbl: [(caOuI,
                       label: block_caOuI_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOuI: // global
           I64[Sp] = block_caOuN_info;
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOuN() //  [R1]
         { info_tbl: [(caOuN,
                       label: block_caOuN_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOuN: // global
           I64[Sp + 16] = block_caOuP_info;
           R2 = P64[Sp + 8];
           _saM6b::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saM6b::P64;
           Sp = Sp + 16;
           call go1_saM5z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOuP() //  [R1]
         { info_tbl: [(caOuP,
                       label: block_caOuP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOuP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOuX; else goto caOuW;
       caOuX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOuW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_saM6j_entry() //  [R1, R2, R3]
         { info_tbl: [(caOvj,
                       label: go2_saM6j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caOvk; else goto caOvl;
       caOvk: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOvl: // global
           I64[Sp - 32] = block_caOvc_info;
           _saM6j::P64 = R1;
           _saM5b::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _saM5b::P64;
           P64[Sp - 16] = _saM6j::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaOw4; else goto caOvd;
       uaOw4: // global
           call _caOvc(R1) args: 0, res: 0, upd: 0;
       caOvd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOvc() //  [R1]
         { info_tbl: [(caOvc,
                       label: block_caOvc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvc: // global
           if (R1 & 7 == 1) goto uaOw0; else goto caOvh;
       uaOw0: // global
           Sp = Sp + 32;
           call _caOvz() args: 0, res: 0, upd: 0;
       caOvh: // global
           I64[Sp - 8] = block_caOvr_info;
           _saM6o::P64 = P64[R1 + 6];
           _saM6p::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _saM6p::P64;
           P64[Sp + 24] = _saM6o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOw2; else goto caOvt;
       uaOw2: // global
           call _caOvr(R1) args: 0, res: 0, upd: 0;
       caOvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOvr() //  [R1]
         { info_tbl: [(caOvr,
                       label: block_caOvr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvr: // global
           if (R1 & 7 == 1) goto uaOw1; else goto caOvS;
       uaOw1: // global
           Sp = Sp + 40;
           call _caOvz() args: 0, res: 0, upd: 0;
       caOvS: // global
           I64[Sp - 8] = block_caOvC_info;
           _saM6s::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOw5; else goto caOvD;
       uaOw5: // global
           call _caOvC(R1) args: 0, res: 0, upd: 0;
       caOvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOvz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvz: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOvC() //  [R1]
         { info_tbl: [(caOvC,
                       label: block_caOvC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvC: // global
           I64[Sp] = block_caOvH_info;
           _saM6u::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saM6u::P64;
           if (R1 & 7 != 0) goto uaOw7; else goto caOvI;
       uaOw7: // global
           call _caOvH(R1) args: 0, res: 0, upd: 0;
       caOvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOvH() //  [R1]
         { info_tbl: [(caOvH,
                       label: block_caOvH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvH: // global
           I64[Sp] = block_caOvM_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOvM() //  [R1]
         { info_tbl: [(caOvM,
                       label: block_caOvM_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvM: // global
           _saM6j::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caOvO_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           _saM6z::P64 = R1;
           R1 = _saM6j::P64;
           P64[Sp + 40] = _saM6z::P64;
           Sp = Sp + 32;
           call go2_saM6j_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOvO() //  [R1]
         { info_tbl: [(caOvO,
                       label: block_caOvO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOvO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOvY; else goto caOvX;
       caOvY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOvX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7k_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(caOwk,
                       label: sat_saM7k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOwk: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caOwy; else goto caOwz;
       caOwy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caOwz: // global
           I64[Sp - 32] = block_caOwh_info;
           _saM5b::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _saM5b::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaOxc; else goto caOwi;
       uaOxc: // global
           call _caOwh(R1) args: 0, res: 0, upd: 0;
       caOwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOwh() //  [R1]
         { info_tbl: [(caOwh,
                       label: block_caOwh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOwh: // global
           I64[Sp - 16] = block_caOwn_info;
           _saM6S::P64 = P64[R1 + 23];
           _saM6U::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saM6U::P64;
           P64[Sp] = _saM6S::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOxb; else goto caOwo;
       uaOxb: // global
           call _caOwn(R1) args: 0, res: 0, upd: 0;
       caOwo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOwn() //  [R1]
         { info_tbl: [(caOwn,
                       label: block_caOwn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOwn: // global
           I64[Sp - 8] = block_caOws_info;
           _saM73::P64 = R1;
           _saM74::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM74::I64;
           P64[Sp + 16] = _saM73::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOxd; else goto caOwt;
       uaOxd: // global
           call _caOws(R1) args: 0, res: 0, upd: 0;
       caOwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOws() //  [R1]
         { info_tbl: [(caOws,
                       label: block_caOws_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOws: // global
           I64[Sp - 8] = block_caOwx_info;
           _saM75::P64 = R1;
           _saM76::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saM76::I64;
           P64[Sp + 32] = _saM75::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOxe; else goto caOwD;
       uaOxe: // global
           call _caOwx(R1) args: 0, res: 0, upd: 0;
       caOwD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOwx() //  [R1]
         { info_tbl: [(caOwx,
                       label: block_caOwx_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOwx: // global
           _saM73::P64 = P64[Sp + 32];
           _saM74::I64 = I64[Sp + 16];
           _saM75::P64 = P64[Sp + 40];
           _saM79::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saM74::I64,
                            _saM79::I64)) goto caOwU; else goto caOxa;
       caOxa: // global
           if (%MO_S_Gt_W64(_saM79::I64,
                            I64[Sp + 8])) goto caOwU; else goto caOx6;
       caOwU: // global
           R4 = _saM79::I64;
           R3 = _saM73::P64;
           R2 = _saM75::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caOx6: // global
           _saM7g::P64 = P64[P64[Sp + 24] + ((_saM79::I64 - _saM74::I64 << 3) + 24)];
           I64[Sp + 40] = block_caOx0_info;
           R1 = _saM7g::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaOxf; else goto caOx1;
       uaOxf: // global
           call _caOx0(R1) args: 0, res: 0, upd: 0;
       caOx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOx0() //  [R1]
         { info_tbl: [(caOx0,
                       label: block_caOx0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOx0: // global
           _saM6M::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOx5_info;
           R2 = _saM6M::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOx5() //  []
         { info_tbl: [(caOx5,
                       label: block_caOx5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOx5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7t_entry() //  [R1, R2]
         { info_tbl: [(caOxt,
                       label: sat_saM7t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOxt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOxu; else goto caOxv;
       caOxu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOxv: // global
           I64[Sp - 16] = block_caOxr_info;
           _saM7o::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7o::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOxr() //  []
         { info_tbl: [(caOxr,
                       label: block_caOxr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOxr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7n_entry() //  [R1]
         { info_tbl: [(caOxD,
                       label: sat_saM7n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOxD: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7I_entry() //  [R1, R2]
         { info_tbl: [(caOxT,
                       label: sat_saM7I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOxT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOxU; else goto caOxV;
       caOxU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOxV: // global
           I64[Sp - 16] = block_caOxR_info;
           _saM7D::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7D::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOxR() //  []
         { info_tbl: [(caOxR,
                       label: block_caOxR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOxR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7C_entry() //  [R1]
         { info_tbl: [(caOy3,
                       label: sat_saM7C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOy3: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7P_entry() //  [R1]
         { info_tbl: [(caOya,
                       label: sat_saM7P_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOya: // global
           _saM7P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caOyb; else goto caOyc;
       caOyc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOye; else goto caOyd;
       caOye: // global
           HpAlloc = 64;
           goto caOyb;
       caOyb: // global
           R1 = _saM7P::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOyd: // global
           _saM5a::P64 = P64[_saM7P::P64 + 7];
           _saM5b::P64 = P64[_saM7P::P64 + 15];
           _saM6K::P64 = P64[_saM7P::P64 + 23];
           I64[Hp - 56] = sat_saM7I_info;
           P64[Hp - 48] = _saM6K::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7C_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_caOy6_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           P64[Sp - 8] = _saM6K::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOy6() //  [R1]
         { info_tbl: [(caOy6,
                       label: block_caOy6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOy6: // global
           I64[Sp] = block_caOy8_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOy8() //  []
         { info_tbl: [(caOy8,
                       label: block_caOy8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOy8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7X_entry() //  [R1, R2]
         { info_tbl: [(caOyp,
                       label: sat_saM7X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOyp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOyq; else goto caOyr;
       caOyq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOyr: // global
           I64[Sp - 16] = block_caOyn_info;
           _saM7S::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7S::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOyn() //  []
         { info_tbl: [(caOyn,
                       label: block_caOyn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOyn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7R_entry() //  [R1]
         { info_tbl: [(caOyz,
                       label: sat_saM7R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOyz: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saM5x_entry() //  [R1]
         { info_tbl: [(caOyC,
                       label: io_saM5x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOyC: // global
           _saM5x::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto caOyD; else goto caOyE;
       caOyE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOyG; else goto caOyF;
       caOyG: // global
           HpAlloc = 16;
           goto caOyD;
       caOyD: // global
           R1 = _saM5x::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOyF: // global
           _saM5a::P64 = P64[_saM5x::P64 + 7];
           _saM5b::P64 = P64[_saM5x::P64 + 15];
           _saM5t::P64 = P64[_saM5x::P64 + 23];
           I64[Hp - 8] = go1_saM5z_info;
           P64[Hp] = _saM5b::P64;
           I64[Sp - 32] = block_caOv5_info;
           R2 = _saM5t::P64;
           R1 = Hp - 6;
           P64[Sp - 24] = _saM5a::P64;
           P64[Sp - 16] = _saM5b::P64;
           P64[Sp - 8] = _saM5t::P64;
           Sp = Sp - 32;
           call go1_saM5z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOv5() //  [R1]
         { info_tbl: [(caOv5,
                       label: block_caOv5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOv5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOyJ; else goto caOyI;
       caOyJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOyI: // global
           I64[Hp - 8] = go2_saM6j_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_caOw8_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           _saM6i::P64 = R1;
           R1 = Hp - 5;
           P64[Sp] = _saM6i::P64;
           Sp = Sp - 8;
           call go2_saM6j_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOw8() //  [R1]
         { info_tbl: [(caOw8,
                       label: block_caOw8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOw8: // global
           I64[Sp - 8] = block_caOwa_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caOwa() //  [R1]
         { info_tbl: [(caOwa,
                       label: block_caOwa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOwa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOyN; else goto caOyM;
       caOyN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOyM: // global
           I64[Hp - 8] = sat_saM7k_info;
           P64[Hp] = P64[Sp + 32];
           _saM6i::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caOxg_info;
           R5 = P64[Sp + 8];
           R4 = _saM6i::P64;
           R3 = P64[Sp + 40];
           R2 = Hp - 4;
           I64[Sp + 40] = R1;
           Sp = Sp + 16;
           call GHC.List.zipWith3_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOxg() //  [R1]
         { info_tbl: [(caOxg,
                       label: block_caOxg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOxg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caOyQ; else goto caOyP;
       caOyQ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOyP: // global
           _saM5a::P64 = P64[Sp + 8];
           _saM5b::P64 = P64[Sp + 16];
           _saM7l::I64 = I64[Sp + 24];
           if (_saM7l::I64 == 0) goto caOyZ; else goto uaOz7;
       caOyZ: // global
           I64[Hp - 56] = sat_saM7P_info;
           P64[Hp - 48] = _saM5a::P64;
           P64[Hp - 40] = _saM5b::P64;
           P64[Hp - 32] = R1;
           _caOxH::P64 = Hp - 55;
           Hp = Hp - 32;
           R1 = _caOxH::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uaOz7: // global
           if (_saM7l::I64 == 1) goto caOz3; else goto caOyV;
       caOz3: // global
           I64[Hp - 56] = sat_saM7X_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7R_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caOz0_info;
           R2 = Hp - 54;
           _saM6K::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saM6K::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caOyV: // global
           I64[Hp - 56] = sat_saM7t_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7n_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caOyR_info;
           R2 = Hp - 54;
           _saM6K::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saM6K::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOz0() //  [R1]
         { info_tbl: [(caOz0,
                       label: block_caOz0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOz0: // global
           I64[Sp] = block_caOz2_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOz2() //  []
         { info_tbl: [(caOz2,
                       label: block_caOz2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOz2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOyR() //  [R1]
         { info_tbl: [(caOyR,
                       label: block_caOyR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOyR: // global
           I64[Sp] = block_caOyT_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOyT() //  []
         { info_tbl: [(caOyT,
                       label: block_caOyT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOyT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_saM86_entry() //  [R1, R2]
         { info_tbl: [(caOzl,
                       label: go1_saM86_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOzl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caOzm; else goto caOzn;
       caOzm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOzn: // global
           _saM87::I64 = R2;
           _saM5n::P64 = P64[R1 + 14];
           _saM5p::P64 = P64[R1 + 22];
           _saM5o::I64 = I64[R1 + 30];
           if (%MO_S_Gt_W64(_saM5o::I64, R2)) goto caOzt; else goto caOzk;
       caOzk: // global
           _saM5q::I64 = I64[R1 + 38];
           if (%MO_S_Gt_W64(_saM87::I64,
                            _saM5q::I64)) goto caOzt; else goto caOzA;
       caOzt: // global
           R4 = _saM87::I64;
           R3 = _saM5n::P64;
           R2 = _saM5p::P64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caOzA: // global
           _saM8g::P64 = P64[P64[R1 + 6] + ((_saM87::I64 - _saM5o::I64 << 3) + 24)];
           I64[Sp - 32] = block_caOzz_info;
           _saM86::P64 = R1;
           R1 = _saM8g::P64;
           I64[Sp - 24] = _saM5q::I64;
           P64[Sp - 16] = _saM86::P64;
           I64[Sp - 8] = _saM87::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaOAi; else goto caOzB;
       uaOAi: // global
           call _caOzz(R1) args: 0, res: 0, upd: 0;
       caOzB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOzz() //  [R1]
         { info_tbl: [(caOzz,
                       label: block_caOzz_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOzz: // global
           if (R1 & 7 == 1) goto caOzH; else goto caOzR;
       caOzH: // global
           Sp = Sp + 32;
           call lvl30_raLJW_entry() args: 8, res: 0, upd: 8;
       caOzR: // global
           I64[Sp] = block_caOzK_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaOAj; else goto caOzL;
       uaOAj: // global
           call _caOzK(R1) args: 0, res: 0, upd: 0;
       caOzL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOzK() //  [R1]
         { info_tbl: [(caOzK,
                       label: block_caOzK_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOzK: // global
           I64[Sp] = block_caOzP_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaOAk; else goto caOzT;
       uaOAk: // global
           call _caOzP(R1) args: 0, res: 0, upd: 0;
       caOzT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOzP() //  [R1]
         { info_tbl: [(caOzP,
                       label: block_caOzP_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOzP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOzZ; else goto caOzY;
       caOzZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOzY: // global
           _saM87::I64 = I64[Sp + 24];
           if (_saM87::I64 == I64[Sp + 8]) goto caOAg; else goto caOAa;
       caOAg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOAa: // global
           Hp = Hp - 24;
           _saM86::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caOA6_info;
           R2 = _saM87::I64 + 1;
           _saM8n::P64 = R1;
           R1 = _saM86::P64;
           P64[Sp + 24] = _saM8n::P64;
           Sp = Sp + 16;
           call go1_saM86_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOA6() //  [R1]
         { info_tbl: [(caOA6,
                       label: block_caOA6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOA6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOAd; else goto caOAc;
       caOAd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOAc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaOAQ_srtd" {
     uaOAQ_srtd:
         const SaMem_srt+224;
         const 38;
         const 223338307585;
 },
 GHC.Event.Thread.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caOAl,
                       label: GHC.Event.Thread.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOAl: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caOAm; else goto caOAn;
       caOAm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.closeFdWith1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOAn: // global
           I64[Sp - 24] = block_caOtb_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaOAO; else goto caOtc;
       uaOAO: // global
           call _caOtb(R1) args: 0, res: 0, upd: 0;
       caOtc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOtb() //  [R1]
         { info_tbl: [(caOtb,
                       label: block_caOtb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtb: // global
           _saM5h::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caOtg_info;
           R1 = _saM5h::P64;
           if (R1 & 7 != 0) goto uaOAK; else goto caOth;
       uaOAK: // global
           call _caOtg(R1) args: 0, res: 0, upd: 0;
       caOth: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOtg() //  [R1]
         { info_tbl: [(caOtg,
                       label: block_caOtg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtg: // global
           I64[Sp - 16] = block_caOtl_info;
           _saM5k::P64 = P64[R1 + 15];
           _saM5m::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saM5m::P64;
           P64[Sp] = _saM5k::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOAL; else goto caOtm;
       uaOAL: // global
           call _caOtl(R1) args: 0, res: 0, upd: 0;
       caOtm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOtl() //  [R1]
         { info_tbl: [(caOtl,
                       label: block_caOtl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtl: // global
           I64[Sp - 8] = block_caOtq_info;
           _saM5n::P64 = R1;
           _saM5o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM5o::I64;
           P64[Sp + 16] = _saM5n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOAM; else goto caOtr;
       uaOAM: // global
           call _caOtq(R1) args: 0, res: 0, upd: 0;
       caOtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOtq() //  [R1]
         { info_tbl: [(caOtq,
                       label: block_caOtq_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caOAt; else goto caOAs;
       caOAt: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOAs: // global
           _saM5o::I64 = I64[Sp + 8];
           _saM5q::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saM5o::I64,
                            _saM5q::I64)) goto caOAE; else goto caOAH;
       caOAE: // global
           I64[Hp - 40] = go1_saM86_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = _saM5o::I64;
           I64[Hp] = _saM5q::I64;
           I64[Sp + 24] = block_caOAC_info;
           R2 = _saM5o::I64;
           R1 = Hp - 38;
           Sp = Sp + 24;
           call go1_saM86_entry(R2, R1) args: 8, res: 8, upd: 8;
       caOAH: // global
           Hp = Hp - 48;
           P64[Sp + 24] = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call _saM5r() args: 0, res: 0, upd: 0;
     }
 },
 _caOAC() //  [R1]
         { info_tbl: [(caOAC,
                       label: block_caOAC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOAC: // global
           P64[Sp] = R1;
           call _saM5r() args: 0, res: 0, upd: 0;
     }
 },
 _saM5r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saM5r: // global
           I64[Sp - 8] = block_caOtA_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caOtA() //  [R1]
         { info_tbl: [(caOtA,
                       label: block_caOtA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOtA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOAx; else goto caOAw;
       caOAx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOAw: // global
           I64[Hp - 24] = io_saM5x_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _caOtC::P64 = Hp - 23;
           if (R1 == 0) goto caOAB; else goto caOAA;
       caOAB: // global
           R1 = _caOtC::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caOAA: // global
           R1 = _caOtC::P64;
           Sp = Sp + 32;
           call io_saM5x_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.816543551 UTC

[section ""data" . GHC.Event.Thread.closeFdWith_closure" {
     GHC.Event.Thread.closeFdWith_closure:
         const GHC.Event.Thread.closeFdWith_info;
         const 0;
 },
 GHC.Event.Thread.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caOAV,
                       label: GHC.Event.Thread.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOAV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.817815383 UTC

[section ""data" . GHC.Event.Thread.registerDelay2_closure" {
     GHC.Event.Thread.registerDelay2_closure:
         const GHC.Event.Thread.registerDelay2_info;
 },
 GHC.Event.Thread.registerDelay2_entry() //  []
         { info_tbl: [(caOB5,
                       label: GHC.Event.Thread.registerDelay2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOB5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOB6; else goto caOB7;
       caOB6: // global
           R1 = GHC.Event.Thread.registerDelay2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOB7: // global
           I64[Sp - 8] = block_caOB2_info;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOB2() //  [R1]
         { info_tbl: [(caOB2,
                       label: block_caOB2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOB2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOBa; else goto caOB9;
       caOBa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOB9: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.821670522 UTC

[section ""data" . GHC.Event.Thread.$wregisterDelay_closure" {
     GHC.Event.Thread.$wregisterDelay_closure:
         const GHC.Event.Thread.$wregisterDelay_info;
         const 0;
 },
 w1_saM9g_entry() //  [R1]
         { info_tbl: [(caOBH,
                       label: w1_saM9g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOBL; else goto caOBM;
       caOBL: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOBM: // global
           I64[Sp - 8] = block_caOBE_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOBQ; else goto caOBF;
       uaOBQ: // global
           call _caOBE(R1) args: 0, res: 0, upd: 0;
       caOBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOBE() //  [R1]
         { info_tbl: [(caOBE,
                       label: block_caOBE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBE: // global
           I64[Sp] = block_caOBK_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOBK() //  []
         { info_tbl: [(caOBK,
                       label: block_caOBK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saM9q_entry() //  [R1]
         { info_tbl: [(caOC0,
                       label: w2_saM9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOC0: // global
           R1 = P64[R1 + 7];
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMa6_entry() //  [R1]
         { info_tbl: [(caOCC,
                       label: sat_saMa6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOCC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caOCD; else goto caOCE;
       caOCD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOCE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caOCu_info;
           _saM9x::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saM9x::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaODz; else goto caOCv;
       uaODz: // global
           call _caOCu(R1) args: 0, res: 0, upd: 0;
       caOCv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caOCu() //  [R1]
         { info_tbl: [(caOCu,
                       label: block_caOCu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOCu: // global
           _caOCB::P64 = R1 & 7;
           if (_caOCB::P64 < 3) goto uaODq; else goto uaODt;
       uaODq: // global
           _saM9x::P64 = P64[Sp + 8];
           if (_caOCB::P64 < 2) goto caOCy; else goto caOCz;
       caOCy: // global
           I64[Sp] = block_caOCH_info;
           _saM9A::I64 = I64[R1 + 39];
           R1 = _saM9x::P64;
           I64[Sp + 8] = _saM9A::I64;
           if (R1 & 7 != 0) goto uaODw; else goto caOCJ;
       uaODw: // global
           call _caOCH(R1) args: 0, res: 0, upd: 0;
       caOCJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caOCz: // global
           I64[Sp] = block_caOD0_info;
           _saM9S::I64 = I64[R1 + 22];
           R1 = _saM9x::P64;
           I64[Sp + 8] = _saM9S::I64;
           if (R1 & 7 != 0) goto uaODx; else goto caOD2;
       uaODx: // global
           call _caOD0(R1) args: 0, res: 0, upd: 0;
       caOD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaODt: // global
           Sp = Sp + 16;
           call _caOCA() args: 0, res: 0, upd: 0;
     }
 },
 _caOCH() //  [R1]
         { info_tbl: [(caOCH,
                       label: block_caOCH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOCH: // global
           _caODn::P64 = R1 & 7;
           if (_caODn::P64 < 3) goto uaODr; else goto uaODu;
       uaODr: // global
           _saM9A::I64 = I64[Sp + 8];
           if (_caODn::P64 < 2) goto caOCP; else goto caOCT;
       caOCP: // global
           R1 = I64[((_saM9A::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caOCT: // global
           R1 = I64[((_saM9A::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaODu: // global
           Sp = Sp + 16;
           call _caOCA() args: 0, res: 0, upd: 0;
     }
 },
 _caOD0() //  [R1]
         { info_tbl: [(caOD0,
                       label: block_caOD0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOD0: // global
           _caODk::P64 = R1 & 7;
           if (_caODk::P64 < 3) goto uaODs; else goto uaODv;
       uaODs: // global
           _saM9S::I64 = I64[Sp + 8];
           if (_caODk::P64 < 2) goto caOD8; else goto caODc;
       caOD8: // global
           R1 = I64[((_saM9S::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caODc: // global
           R1 = I64[((_saM9S::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaODv: // global
           Sp = Sp + 16;
           call _caOCA() args: 0, res: 0, upd: 0;
     }
 },
 _caOCA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOCA: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMa7_entry() //  [R1, R2]
         { info_tbl: [(caODC,
                       label: sat_saMa7_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caODC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caODE; else goto caODF;
       caODE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caODF: // global
           I64[Sp - 40] = block_caOCi_info;
           R3 = R2;
           _saM9v::P64 = R2;
           R2 = P64[R1 + 15];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saM9v::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOCi() //  [R1]
         { info_tbl: [(caOCi,
                       label: block_caOCi_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOCi: // global
           _saM9s::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caOCm_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saM9s::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOCm() //  [R1]
         { info_tbl: [(caOCm,
                       label: block_caOCm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOCm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caODJ; else goto caODI;
       caODJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caODI: // global
           I64[Hp - 48] = sat_saMa6_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.$wregisterDelay_entry() //  [R2]
         { info_tbl: [(caODK,
                       label: GHC.Event.Thread.$wregisterDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caODK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caODL; else goto caODM;
       caODL: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wregisterDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caODM: // global
           I64[Sp - 16] = block_caOBf_info;
           R1 = GHC.Event.Thread.registerDelay2_closure+1;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOBf() //  [R1]
         { info_tbl: [(caOBf,
                       label: block_caOBf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBf: // global
           I64[Sp - 8] = block_caOBh_info;
           _saM8U::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp] = _saM8U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOFj; else goto caOBi;
       uaOFj: // global
           call _caOBh(R1) args: 0, res: 0, upd: 0;
       caOBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOBh() //  [R1]
         { info_tbl: [(caOBh,
                       label: block_caOBh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBh: // global
           _saM8Z::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caOBm_info;
           R1 = _saM8Z::P64;
           if (R1 & 7 != 0) goto uaOFk; else goto caOBn;
       uaOFk: // global
           call _caOBm(R1) args: 0, res: 0, upd: 0;
       caOBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOBm() //  [R1]
         { info_tbl: [(caOBm,
                       label: block_caOBm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBm: // global
           if (R1 & 7 == 1) goto caODS; else goto caODU;
       caODS: // global
           Sp = Sp + 24;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caODU: // global
           I64[Sp] = block_caOBs_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaOFl; else goto caOBt;
       uaOFl: // global
           call _caOBs(R1) args: 0, res: 0, upd: 0;
       caOBt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOBs() //  [R1]
         { info_tbl: [(caOBs,
                       label: block_caOBs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOBs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caODX; else goto caODW;
       caODX: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caODW: // global
           _saM8Q::I64 = I64[Sp + 16];
           _saM8U::P64 = P64[Sp + 8];
           _saM95::P64 = P64[R1 + 15];
           _saM9c::P64 = P64[R1 + 47];
           _saM9a::I64 = I64[R1 + 71];
           (_saM9f::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 80] = w1_saM9g_info;
           P64[Hp - 72] = _saM8U::P64;
           _caOBz::P64 = Hp - 79;
           if (%MO_S_Gt_W64(_saM8Q::I64, 0)) goto caOE2; else goto caOFa;
       caOE2: // global
           (_saM9p::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 64] = w2_saM9q_info;
           P64[Hp - 56] = _caOBz::P64;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _saM9f::I64;
           I64[Hp - 32] = sat_saMa7_info;
           P64[Hp - 24] = Hp - 63;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saM9f::I64;
           I64[Hp] = _saM8Q::I64 * 1000 + _saM9p::I64;
           I64[Sp - 8] = block_caODY_info;
           R2 = Hp - 31;
           R1 = _saM95::P64;
           P64[Sp] = _saM9c::P64;
           I64[Sp + 16] = _saM9a::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caOFa: // global
           Hp = Hp - 72;
           I64[Sp] = block_caOF9_info;
           R1 = _caOBz::P64;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caODY() //  [R1]
         { info_tbl: [(caODY,
                       label: block_caODY_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caODY: // global
           I64[Sp] = block_caOE0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOFm; else goto caOE4;
       uaOFm: // global
           call _caOE0(R1) args: 0, res: 0, upd: 0;
       caOE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOE0() //  [R1]
         { info_tbl: [(caOE0,
                       label: block_caOE0_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOE0: // global
           if (R1 & 7 == 1) goto uaOFg; else goto caOF7;
       uaOFg: // global
           Sp = Sp + 16;
           goto uaOFp;
       caOF7: // global
           _saM9c::P64 = P64[Sp + 8];
           (_saMag::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 24])), 1);
           if (%MO_SS_Conv_W64_W32(_saMag::I64) == 0 :: W32) goto uaOFh; else goto caOEt;
       uaOFh: // global
           Sp = Sp + 16;
           goto uaOFp;
       uaOFp: // global
           call _caOF3() args: 0, res: 0, upd: 0;
       caOEt: // global
           (_saMal::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caOEr_info;
           R1 = P64[_saM9c::P64 + 8];
           I64[Sp + 24] = _saMal::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOFn; else goto caOEv;
       uaOFn: // global
           call _caOEr(R1) args: 0, res: 0, upd: 0;
       caOEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOEr() //  [R1]
         { info_tbl: [(caOEr,
                       label: block_caOEr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOEr: // global
           if (R1 & 7 == 1) goto caOEC; else goto caOF0;
       caOEC: // global
           I64[Sp] = block_caOEz_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caOF0: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 16]) == 9 :: W32) goto uaOFi; else goto caOEQ;
       uaOFi: // global
           Sp = Sp + 8;
           call _caOF3() args: 0, res: 0, upd: 0;
       caOEQ: // global
           I64[Sp] = block_caOEO_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOEz() //  []
         { info_tbl: [(caOEz,
                       label: block_caOEz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOEz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOF3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOF3: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOEO() //  []
         { info_tbl: [(caOEO,
                       label: block_caOEO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOEO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOF9() //  []
         { info_tbl: [(caOF9,
                       label: block_caOF9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOF9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.827879079 UTC

[section ""data" . GHC.Event.Thread.registerDelay1_closure" {
     GHC.Event.Thread.registerDelay1_closure:
         const GHC.Event.Thread.registerDelay1_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay1_entry() //  [R2]
         { info_tbl: [(caOFy,
                       label: GHC.Event.Thread.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOFy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOFz; else goto caOFA;
       caOFz: // global
           R2 = R2;
           R1 = GHC.Event.Thread.registerDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOFA: // global
           I64[Sp - 8] = block_caOFv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOFE; else goto caOFw;
       uaOFE: // global
           call _caOFv(R1) args: 0, res: 0, upd: 0;
       caOFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOFv() //  [R1]
         { info_tbl: [(caOFv,
                       label: block_caOFv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOFv: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wregisterDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.829008447 UTC

[section ""data" . GHC.Event.Thread.registerDelay_closure" {
     GHC.Event.Thread.registerDelay_closure:
         const GHC.Event.Thread.registerDelay_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay_entry() //  [R2]
         { info_tbl: [(caOFJ,
                       label: GHC.Event.Thread.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOFJ: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.834779961 UTC

[section ""data" . GHC.Event.Thread.$wthreadDelay_closure" {
     GHC.Event.Thread.$wthreadDelay_closure:
         const GHC.Event.Thread.$wthreadDelay_info;
         const 0;
 },
 sat_saMbR_entry() //  [R1]
         { info_tbl: [(caOGN,
                       label: sat_saMbR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caOGO; else goto caOGP;
       caOGO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOGP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caOGF_info;
           _saMbi::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saMbi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaOHK; else goto caOGG;
       uaOHK: // global
           call _caOGF(R1) args: 0, res: 0, upd: 0;
       caOGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caOGF() //  [R1]
         { info_tbl: [(caOGF,
                       label: block_caOGF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGF: // global
           _caOGM::P64 = R1 & 7;
           if (_caOGM::P64 < 3) goto uaOHB; else goto uaOHE;
       uaOHB: // global
           _saMbi::P64 = P64[Sp + 8];
           if (_caOGM::P64 < 2) goto caOGJ; else goto caOGK;
       caOGJ: // global
           I64[Sp] = block_caOGS_info;
           _saMbl::I64 = I64[R1 + 39];
           R1 = _saMbi::P64;
           I64[Sp + 8] = _saMbl::I64;
           if (R1 & 7 != 0) goto uaOHH; else goto caOGU;
       uaOHH: // global
           call _caOGS(R1) args: 0, res: 0, upd: 0;
       caOGU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caOGK: // global
           I64[Sp] = block_caOHb_info;
           _saMbD::I64 = I64[R1 + 22];
           R1 = _saMbi::P64;
           I64[Sp + 8] = _saMbD::I64;
           if (R1 & 7 != 0) goto uaOHI; else goto caOHd;
       uaOHI: // global
           call _caOHb(R1) args: 0, res: 0, upd: 0;
       caOHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaOHE: // global
           Sp = Sp + 16;
           call _caOGL() args: 0, res: 0, upd: 0;
     }
 },
 _caOGS() //  [R1]
         { info_tbl: [(caOGS,
                       label: block_caOGS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGS: // global
           _caOHy::P64 = R1 & 7;
           if (_caOHy::P64 < 3) goto uaOHC; else goto uaOHF;
       uaOHC: // global
           _saMbl::I64 = I64[Sp + 8];
           if (_caOHy::P64 < 2) goto caOH0; else goto caOH4;
       caOH0: // global
           R1 = I64[((_saMbl::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caOH4: // global
           R1 = I64[((_saMbl::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaOHF: // global
           Sp = Sp + 16;
           call _caOGL() args: 0, res: 0, upd: 0;
     }
 },
 _caOHb() //  [R1]
         { info_tbl: [(caOHb,
                       label: block_caOHb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOHb: // global
           _caOHv::P64 = R1 & 7;
           if (_caOHv::P64 < 3) goto uaOHD; else goto uaOHG;
       uaOHD: // global
           _saMbD::I64 = I64[Sp + 8];
           if (_caOHv::P64 < 2) goto caOHj; else goto caOHn;
       caOHj: // global
           R1 = I64[((_saMbD::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caOHn: // global
           R1 = I64[((_saMbD::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaOHG: // global
           Sp = Sp + 16;
           call _caOGL() args: 0, res: 0, upd: 0;
     }
 },
 _caOGL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGL: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMbS_entry() //  [R1, R2]
         { info_tbl: [(caOHN,
                       label: sat_saMbS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOHN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOHP; else goto caOHQ;
       caOHP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOHQ: // global
           I64[Sp - 16] = block_caOGx_info;
           R3 = R2;
           _saMbh::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _saMbh::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOGx() //  [R1]
         { info_tbl: [(caOGx,
                       label: block_caOGx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caOHT; else goto caOHS;
       caOHT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOHS: // global
           I64[Hp - 48] = sat_saMbR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMci_entry() //  [R1, R2]
         { info_tbl: [(caOI3,
                       label: sat_saMci_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOI3: // global
           _saMbf::P64 = R2;
           _saMci::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto caOI4; else goto caOI5;
       caOI5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOI7; else goto caOI6;
       caOI7: // global
           HpAlloc = 16;
           goto caOI4;
       caOI4: // global
           R2 = _saMbf::P64;
           R1 = _saMci::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOI6: // global
           _saMaY::P64 = P64[_saMci::P64 + 6];
           _saMb5::P64 = P64[_saMci::P64 + 14];
           _saMbc::P64 = P64[_saMci::P64 + 22];
           _saMb3::I64 = I64[_saMci::P64 + 30];
           I64[Hp - 8] = sat_saMbS_info;
           P64[Hp] = _saMbc::P64;
           I64[Sp - 32] = block_caOHU_info;
           R2 = Hp - 7;
           R1 = _saMaY::P64;
           I64[Sp - 24] = _saMb3::I64;
           P64[Sp - 16] = _saMb5::P64;
           P64[Sp - 8] = _saMbf::P64;
           Sp = Sp - 32;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOHU() //  [R1]
         { info_tbl: [(caOHU,
                       label: block_caOHU_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOHU: // global
           I64[Sp] = block_caOHW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOJc; else goto caOHX;
       uaOJc: // global
           call _caOHW(R1) args: 0, res: 0, upd: 0;
       caOHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOHW() //  [R1]
         { info_tbl: [(caOHW,
                       label: block_caOHW_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOHW: // global
           if (R1 & 7 == 1) goto uaOJ9; else goto caOI1;
       uaOJ9: // global
           Sp = Sp + 24;
           goto uaOJf;
       caOI1: // global
           _saMb5::P64 = P64[Sp + 16];
           (_saMc1::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saMc1::I64) == 0 :: W32) goto uaOJa; else goto caOIu;
       uaOJa: // global
           Sp = Sp + 24;
           goto uaOJf;
       uaOJf: // global
           call _caOJ4() args: 0, res: 0, upd: 0;
       caOIu: // global
           (_saMc6::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caOIs_info;
           R1 = P64[_saMb5::P64 + 8];
           I64[Sp + 16] = _saMc6::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOJd; else goto caOIw;
       uaOJd: // global
           call _caOIs(R1) args: 0, res: 0, upd: 0;
       caOIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOIs() //  [R1]
         { info_tbl: [(caOIs,
                       label: block_caOIs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOIs: // global
           if (R1 & 7 == 1) goto caOID; else goto caOJ1;
       caOID: // global
           I64[Sp + 8] = block_caOIA_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caOJ1: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaOJb; else goto caOIR;
       uaOJb: // global
           Sp = Sp + 16;
           call _caOJ4() args: 0, res: 0, upd: 0;
       caOIR: // global
           I64[Sp + 8] = block_caOIP_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOIA() //  []
         { info_tbl: [(caOIA,
                       label: block_caOIA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOIA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOJ4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOJ4: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOIP() //  []
         { info_tbl: [(caOIP,
                       label: block_caOIP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOIP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMbe_entry() //  [R1]
         { info_tbl: [(caOJm,
                       label: sat_saMbe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOJm: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 w1_saMco_entry() //  [R1]
         { info_tbl: [(caOJA,
                       label: w1_saMco_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOJA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOJB; else goto caOJC;
       caOJB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOJC: // global
           I64[Sp - 8] = block_caOJy_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOJy() //  []
         { info_tbl: [(caOJy,
                       label: block_caOJy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOJy: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMd5_entry() //  [R1]
         { info_tbl: [(caOKc,
                       label: sat_saMd5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOKc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caOKd; else goto caOKe;
       caOKd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOKe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caOK4_info;
           _saMcw::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saMcw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaOL9; else goto caOK5;
       uaOL9: // global
           call _caOK4(R1) args: 0, res: 0, upd: 0;
       caOK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caOK4() //  [R1]
         { info_tbl: [(caOK4,
                       label: block_caOK4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOK4: // global
           _caOKb::P64 = R1 & 7;
           if (_caOKb::P64 < 3) goto uaOL0; else goto uaOL3;
       uaOL0: // global
           _saMcw::P64 = P64[Sp + 8];
           if (_caOKb::P64 < 2) goto caOK8; else goto caOK9;
       caOK8: // global
           I64[Sp] = block_caOKh_info;
           _saMcz::I64 = I64[R1 + 39];
           R1 = _saMcw::P64;
           I64[Sp + 8] = _saMcz::I64;
           if (R1 & 7 != 0) goto uaOL6; else goto caOKj;
       uaOL6: // global
           call _caOKh(R1) args: 0, res: 0, upd: 0;
       caOKj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caOK9: // global
           I64[Sp] = block_caOKA_info;
           _saMcR::I64 = I64[R1 + 22];
           R1 = _saMcw::P64;
           I64[Sp + 8] = _saMcR::I64;
           if (R1 & 7 != 0) goto uaOL7; else goto caOKC;
       uaOL7: // global
           call _caOKA(R1) args: 0, res: 0, upd: 0;
       caOKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaOL3: // global
           Sp = Sp + 16;
           call _caOKa() args: 0, res: 0, upd: 0;
     }
 },
 _caOKh() //  [R1]
         { info_tbl: [(caOKh,
                       label: block_caOKh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOKh: // global
           _caOKX::P64 = R1 & 7;
           if (_caOKX::P64 < 3) goto uaOL1; else goto uaOL4;
       uaOL1: // global
           _saMcz::I64 = I64[Sp + 8];
           if (_caOKX::P64 < 2) goto caOKp; else goto caOKt;
       caOKp: // global
           R1 = I64[((_saMcz::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caOKt: // global
           R1 = I64[((_saMcz::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaOL4: // global
           Sp = Sp + 16;
           call _caOKa() args: 0, res: 0, upd: 0;
     }
 },
 _caOKA() //  [R1]
         { info_tbl: [(caOKA,
                       label: block_caOKA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOKA: // global
           _caOKU::P64 = R1 & 7;
           if (_caOKU::P64 < 3) goto uaOL2; else goto uaOL5;
       uaOL2: // global
           _saMcR::I64 = I64[Sp + 8];
           if (_caOKU::P64 < 2) goto caOKI; else goto caOKM;
       caOKI: // global
           R1 = I64[((_saMcR::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caOKM: // global
           R1 = I64[((_saMcR::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaOL5: // global
           Sp = Sp + 16;
           call _caOKa() args: 0, res: 0, upd: 0;
     }
 },
 _caOKa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOKa: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMd6_entry() //  [R1, R2]
         { info_tbl: [(caOLc,
                       label: sat_saMd6_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOLc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caOLe; else goto caOLf;
       caOLe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOLf: // global
           I64[Sp - 40] = block_caOJS_info;
           R3 = R2;
           _saMcu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 15];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saMcu::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOJS() //  [R1]
         { info_tbl: [(caOJS,
                       label: block_caOJS_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOJS: // global
           _saMcr::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caOJW_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saMcr::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOJW() //  [R1]
         { info_tbl: [(caOJW,
                       label: block_caOJW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOJW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caOLj; else goto caOLi;
       caOLj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOLi: // global
           I64[Hp - 48] = sat_saMd5_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saMaJ_entry() //  [R1]
         { info_tbl: [(caOLk,
                       label: io_saMaJ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOLk: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caOLl; else goto caOLm;
       caOLl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOLm: // global
           I64[Sp - 16] = block_caOFX_info;
           _saMaE::I64 = I64[R1 + 7];
           R1 = GHC.Event.Thread.timerManager_closure;
           I64[Sp - 8] = _saMaE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaON1; else goto caOFY;
       uaON1: // global
           call _caOFX(R1) args: 0, res: 0, upd: 0;
       caOFY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOFX() //  [R1]
         { info_tbl: [(caOFX,
                       label: block_caOFX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOFX: // global
           _saMaP::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caOG2_info;
           R1 = _saMaP::P64;
           if (R1 & 7 != 0) goto uaOMY; else goto caOG3;
       uaOMY: // global
           call _caOG2(R1) args: 0, res: 0, upd: 0;
       caOG3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOG2() //  [R1]
         { info_tbl: [(caOG2,
                       label: block_caOG2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOG2: // global
           if (R1 & 7 == 1) goto caOLr; else goto caOLt;
       caOLr: // global
           Sp = Sp + 16;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caOLt: // global
           I64[Sp - 8] = block_caOG8_info;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caOG8() //  [R1]
         { info_tbl: [(caOG8,
                       label: block_caOG8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOG8: // global
           I64[Sp] = block_caOGa_info;
           _saMaV::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saMaV::P64;
           if (R1 & 7 != 0) goto uaOMZ; else goto caOGb;
       uaOMZ: // global
           call _caOGa(R1) args: 0, res: 0, upd: 0;
       caOGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOGa() //  [R1]
         { info_tbl: [(caOGa,
                       label: block_caOGa_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caOLx; else goto caOLw;
       caOLx: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOLw: // global
           _saMaE::I64 = I64[Sp + 16];
           _saMaV::P64 = P64[Sp + 8];
           _saMaY::P64 = P64[R1 + 15];
           _saMb5::P64 = P64[R1 + 47];
           _saMb3::I64 = I64[R1 + 71];
           (_saMb8::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _saMb8::I64;
           _caOGh::P64 = Hp - 63;
           if (%MO_S_Gt_W64(_saMaE::I64, 0)) goto caOLF; else goto caOMN;
       caOLF: // global
           (_saMcn::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 48] = w1_saMco_info;
           P64[Hp - 40] = _saMaV::P64;
           I64[Hp - 32] = sat_saMd6_info;
           P64[Hp - 24] = _caOGh::P64;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saMb8::I64;
           I64[Hp] = _saMaE::I64 * 1000 + _saMcn::I64;
           I64[Sp - 24] = block_caOLB_info;
           R2 = Hp - 31;
           R1 = _saMaY::P64;
           I64[Sp - 16] = _saMb3::I64;
           P64[Sp - 8] = _saMb5::P64;
           P64[Sp] = _saMaY::P64;
           P64[Sp + 16] = _caOGh::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caOMN: // global
           Hp = Hp - 56;
           I64[Sp - 24] = block_caOMM_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saMaV::P64;
           P64[Sp + 16] = _caOGh::P64;
           P64[Sp] = _saMaY::P64;
           I64[Sp - 16] = _saMb3::I64;
           P64[Sp - 8] = _saMb5::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOLB() //  [R1]
         { info_tbl: [(caOLB,
                       label: block_caOLB_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOLB: // global
           I64[Sp] = block_caOLD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaON2; else goto caOLH;
       uaON2: // global
           call _caOLD(R1) args: 0, res: 0, upd: 0;
       caOLH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOLD() //  [R1]
         { info_tbl: [(caOLD,
                       label: block_caOLD_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOLD: // global
           if (R1 & 7 == 1) goto uaON5; else goto caOMK;
       caOMK: // global
           _saMb5::P64 = P64[Sp + 16];
           (_saMdf::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saMdf::I64) == 0 :: W32) goto uaON5; else goto caOM6;
       uaON5: // global
           call _caOMM() args: 0, res: 0, upd: 0;
       caOM6: // global
           (_saMdk::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_caOM4_info;
           R1 = P64[_saMb5::P64 + 8];
           I64[Sp] = _saMdk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaON4; else goto caOM8;
       uaON4: // global
           call _caOM4(R1) args: 0, res: 0, upd: 0;
       caOM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOM4() //  [R1]
         { info_tbl: [(caOM4,
                       label: block_caOM4_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOM4: // global
           if (R1 & 7 == 1) goto caOMf; else goto caOMD;
       caOMf: // global
           I64[Sp + 8] = block_caOMc_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caOMD: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaOMT; else goto caOMt;
       uaOMT: // global
           Sp = Sp + 8;
           call _caOMM() args: 0, res: 0, upd: 0;
       caOMt: // global
           I64[Sp + 8] = block_caOMr_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOMc() //  []
         { info_tbl: [(caOMc,
                       label: block_caOMc_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOMc: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caOGl() args: 0, res: 0, upd: 0;
     }
 },
 _caOMr() //  []
         { info_tbl: [(caOMr,
                       label: block_caOMr_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOMr: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caOGl() args: 0, res: 0, upd: 0;
     }
 },
 _caOMM() //  []
         { info_tbl: [(caOMM,
                       label: block_caOMM_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOMM: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caOGl() args: 0, res: 0, upd: 0;
     }
 },
 _caOGl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGl: // global
           Hp = Hp + 56;
           _saMbc::P64 = P64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caOLA; else goto caOLz;
       caOLA: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_caOGk_info;
           R1 = _saMbc::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOLz: // global
           I64[Hp - 48] = sat_saMci_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _saMbc::P64;
           I64[Hp - 16] = I64[Sp];
           I64[Hp - 8] = sat_saMbe_info;
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 46;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOGk() //  [R1]
         { info_tbl: [(caOGk,
                       label: block_caOGk_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOGk: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caOGl() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.$wthreadDelay_entry() //  [R2]
         { info_tbl: [(caONe,
                       label: GHC.Event.Thread.$wthreadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caONf; else goto caONg;
       caONf: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wthreadDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caONg: // global
           I64[Sp - 16] = block_caOFQ_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caOFQ() //  [R1]
         { info_tbl: [(caOFQ,
                       label: block_caOFQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOFQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caONj; else goto caONi;
       caONj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caONi: // global
           I64[Hp - 8] = io_saMaJ_info;
           I64[Hp] = I64[Sp + 8];
           _caOFS::P64 = Hp - 7;
           if (R1 == 0) goto caONd; else goto caONc;
       caONd: // global
           R1 = _caOFS::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caONc: // global
           R1 = _caOFS::P64;
           Sp = Sp + 16;
           call io_saMaJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.845405655 UTC

[section ""data" . GHC.Event.Thread.threadDelay1_closure" {
     GHC.Event.Thread.threadDelay1_closure:
         const GHC.Event.Thread.threadDelay1_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay1_entry() //  [R2]
         { info_tbl: [(caONr,
                       label: GHC.Event.Thread.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caONs; else goto caONt;
       caONs: // global
           R2 = R2;
           R1 = GHC.Event.Thread.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caONt: // global
           I64[Sp - 8] = block_caONo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaONx; else goto caONp;
       uaONx: // global
           call _caONo(R1) args: 0, res: 0, upd: 0;
       caONp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caONo() //  [R1]
         { info_tbl: [(caONo,
                       label: block_caONo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONo: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wthreadDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.846548517 UTC

[section ""data" . GHC.Event.Thread.threadDelay_closure" {
     GHC.Event.Thread.threadDelay_closure:
         const GHC.Event.Thread.threadDelay_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay_entry() //  [R2]
         { info_tbl: [(caONC,
                       label: GHC.Event.Thread.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONC: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.847248862 UTC

[section ""relreadonly" . SaMem_srt" {
     SaMem_srt:
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.Event.Thread.blockedOnBadFD2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Event.Thread.blockedOnBadFD1_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const restartPollLoop_raLJq_closure;
         const GHC.Arr.$windexError_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
         const lvl4_raLJs_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Thread.$wstartIOManagerThread_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager1_closure;
         const GHC.Arr.negRange_closure;
         const lvl9_raLJx_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
         const GHC.Event.Thread.eventManager_closure;
         const GHC.Event.Thread.numEnabledEventManagers_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
         const GHC.Event.Thread.ioManagerLock_closure;
         const GHC.Event.Thread.timerManagerThreadVar_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const lvl11_raLJz_closure;
         const lvl13_raLJB_closure;
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
         const lvl14_raLJC_closure;
         const lvl15_raLJD_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure;
         const GHC.Event.Thread.getSystemEventManager2_closure;
         const GHC.Event.Thread.getSystemEventManager1_closure;
         const lvl17_raLJF_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const lvl18_raLJG_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl24_raLJM_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const lvl19_raLJH_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const threadWaitReadSTM2_raLJN_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const threadWaitWriteSTM1_raLJO_closure;
         const lvl26_raLJQ_closure;
         const lvl27_raLJR_closure;
         const lvl28_raLJS_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const threadWaitWrite1_raLJT_closure;
         const threadWaitRead2_raLJU_closure;
         const lvl30_raLJW_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Event.Thread.$wregisterDelay_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Event.Thread.$wthreadDelay_closure;
         const GHC.Event.Thread.threadDelay1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.84849615 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:43.8497278 UTC

[section ""data" . lvl1_raLJo_closure" {
     lvl1_raLJo_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.85175029 UTC

[section ""data" . lvl2_raLJp_closure" {
     lvl2_raLJp_closure:
         const lvl2_raLJp_info;
 },
 lvl2_raLJp_entry() //  []
         { info_tbl: [(caONP,
                       label: lvl2_raLJp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caONQ; else goto caONR;
       caONQ: // global
           R1 = lvl2_raLJp_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caONR: // global
           I64[Sp - 8] = block_caONK_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caONK() //  []
         { info_tbl: [(caONK,
                       label: block_caONK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONK: // global
           I64[Sp] = block_caONM_info;
           R1 = lvl1_raLJo_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caONM() //  [R1]
         { info_tbl: [(caONM,
                       label: block_caONM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caONM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caONV; else goto caONU;
       caONV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caONU: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.858832214 UTC

[section ""data" . GHC.Event.Thread.numEnabledEventManagers_closure" {
     GHC.Event.Thread.numEnabledEventManagers_closure:
         const GHC.Event.Thread.numEnabledEventManagers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.numEnabledEventManagers_entry() //  [R1]
         { info_tbl: [(caOOg,
                       label: GHC.Event.Thread.numEnabledEventManagers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOOg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOOh; else goto caOOi;
       caOOh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOOi: // global
           (_caOOb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOOb::I64 == 0) goto caOOd; else goto caOOc;
       caOOd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOOc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOOb::I64;
           I64[Sp - 24] = block_caOOe_info;
           Sp = Sp - 24;
           call lvl2_raLJp_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caOOe() //  [R1]
         { info_tbl: [(caOOe,
                       label: block_caOOe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOOe: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.864585621 UTC

[section ""cstring" . GHC.Event.Thread.$trModule4_bytes" {
     GHC.Event.Thread.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.866420375 UTC

[section ""data" . GHC.Event.Thread.$trModule3_closure" {
     GHC.Event.Thread.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.868260909 UTC

[section ""cstring" . GHC.Event.Thread.$trModule2_bytes" {
     GHC.Event.Thread.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,104,114,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.872530866 UTC

[section ""data" . GHC.Event.Thread.$trModule1_closure" {
     GHC.Event.Thread.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.874674299 UTC

[section ""data" . GHC.Event.Thread.$trModule_closure" {
     GHC.Event.Thread.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Thread.$trModule3_closure+1;
         const GHC.Event.Thread.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.876352673 UTC

[section ""cstring" . GHC.Event.Thread.blockedOnBadFD3_bytes" {
     GHC.Event.Thread.blockedOnBadFD3_bytes:
         I8[] [97,119,97,105,116,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.878338604 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD2_closure" {
     GHC.Event.Thread.blockedOnBadFD2_closure:
         const GHC.Event.Thread.blockedOnBadFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD2_entry() //  [R1]
         { info_tbl: [(caOOI,
                       label: GHC.Event.Thread.blockedOnBadFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOOI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOOJ; else goto caOOK;
       caOOJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOOK: // global
           (_caOOF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOOF::I64 == 0) goto caOOH; else goto caOOG;
       caOOH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOOG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOOF::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.882546491 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD1_closure" {
     GHC.Event.Thread.blockedOnBadFD1_closure:
         const GHC.Event.Thread.blockedOnBadFD1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD1_entry() //  [R1]
         { info_tbl: [(caOOY,
                       label: GHC.Event.Thread.blockedOnBadFD1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOOY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOOZ; else goto caOP0;
       caOOZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOP0: // global
           (_caOOV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOOV::I64 == 0) goto caOOX; else goto caOOW;
       caOOX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOOW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOOV::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = GHC.Event.Thread.blockedOnBadFD2_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.886801761 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD_closure" {
     GHC.Event.Thread.blockedOnBadFD_closure:
         const GHC.Event.Thread.blockedOnBadFD_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD_entry() //  [R1]
         { info_tbl: [(caOPe,
                       label: GHC.Event.Thread.blockedOnBadFD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOPe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOPf; else goto caOPg;
       caOPf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOPg: // global
           (_caOPb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOPb::I64 == 0) goto caOPd; else goto caOPc;
       caOPd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOPc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOPb::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.890921175 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning7_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning7_bytes:
         I8[] [73,79,77,97,110,97,103,101,114,32,111,110,32,99,97,112,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.89487526 UTC

[section ""data" . restartPollLoop_raLJq_closure" {
     restartPollLoop_raLJq_closure:
         const restartPollLoop_raLJq_info;
         const 0;
 },
 sat_saLKx_entry() //  [R1]
         { info_tbl: [(caOPU,
                       label: sat_saLKx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOPU: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKy_entry() //  [R1]
         { info_tbl: [(caOPX,
                       label: sat_saLKy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOPX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOQ1; else goto caOQ0;
       caOQ1: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOQ0: // global
           _saLKb::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_saLKx_info;
           P64[Hp] = _saLKb::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKM_entry() //  [R1, R2]
         { info_tbl: [(caOQc,
                       label: sat_saLKM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOQg; else goto caOQh;
       caOQg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOQh: // global
           I64[Sp - 16] = block_caOQ9_info;
           _saLKB::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLKB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOQl; else goto caOQa;
       uaOQl: // global
           call _caOQ9(R1) args: 0, res: 0, upd: 0;
       caOQa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOQ9() //  [R1]
         { info_tbl: [(caOQ9,
                       label: block_caOQ9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQ9: // global
           _saLKB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOQf_info;
           R2 = I64[R1 + 7];
           R1 = _saLKB::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOQf() //  []
         { info_tbl: [(caOQf,
                       label: block_caOQf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLKF_entry() //  [R1]
         { info_tbl: [(caOQx,
                       label: sat_saLKF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOQy; else goto caOQz;
       caOQy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOQz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caOQu_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caOQu() //  [R1, R2]
         { info_tbl: [(caOQu,
                       label: block_caOQu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOQC; else goto caOQB;
       caOQC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caOQB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLKG_entry() //  [R1]
         { info_tbl: [(caOQD,
                       label: sat_saLKG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQD: // global
           _saLKG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caOQE; else goto caOQF;
       caOQF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOQH; else goto caOQG;
       caOQH: // global
           HpAlloc = 24;
           goto caOQE;
       caOQE: // global
           R1 = _saLKG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOQG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saLKG::P64;
           _saLKv::I64 = I64[_saLKG::P64 + 16];
           I64[Hp - 16] = sat_saLKF_info;
           I64[Hp] = _saLKv::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 restartPollLoop_raLJq_entry() //  [R2, R3]
         { info_tbl: [(caOQI,
                       label: restartPollLoop_raLJq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caOQJ; else goto caOQK;
       caOQJ: // global
           R3 = R3;
           R2 = R2;
           R1 = restartPollLoop_raLJq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caOQK: // global
           I64[Sp - 16] = block_caOPt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOSd; else goto caOPu;
       uaOSd: // global
           call _caOPt(R1) args: 0, res: 0, upd: 0;
       caOPu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOPt() //  [R1]
         { info_tbl: [(caOPt,
                       label: block_caOPt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOPt: // global
           I64[Sp - 24] = block_caOPy_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saLKb::P64 = R1;
           _saLKn::P64 = P64[R1 + 63];
           _saLKl::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           I64[Sp - 16] = _saLKl::I64;
           P64[Sp - 8] = _saLKn::P64;
           P64[Sp] = _saLKb::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOPy() //  [R1]
         { info_tbl: [(caOPy,
                       label: block_caOPy_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOPy: // global
           I64[Sp] = block_caOQL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOSc; else goto caOR1;
       uaOSc: // global
           call _caOQL(R1) args: 0, res: 0, upd: 0;
       caOR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOQL() //  [R1]
         { info_tbl: [(caOQL,
                       label: block_caOQL_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQL: // global
           if (R1 & 7 == 2) goto caOS4; else goto uaOS7;
       caOS4: // global
           _saLKn::P64 = P64[Sp + 16];
           (_saLKW::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saLKW::I64) == 0 :: W32) goto uaOS8; else goto caORq;
       uaOS8: // global
           Sp = Sp + 24;
           goto uaOSg;
       caORq: // global
           (_saLL1::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caORo_info;
           R1 = P64[_saLKn::P64 + 8];
           I64[Sp + 16] = _saLL1::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaOSe; else goto caORs;
       uaOSe: // global
           call _caORo(R1) args: 0, res: 0, upd: 0;
       caORs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaOS7: // global
           Sp = Sp + 24;
           goto uaOSg;
       uaOSg: // global
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _caORo() //  [R1]
         { info_tbl: [(caORo,
                       label: block_caORo_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caORo: // global
           if (R1 & 7 == 1) goto caORz; else goto caORX;
       caORz: // global
           I64[Sp + 8] = block_caORw_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caORX: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaOS9; else goto caORN;
       uaOS9: // global
           Sp = Sp + 16;
           call _saLKs() args: 0, res: 0, upd: 0;
       caORN: // global
           I64[Sp + 8] = block_caORL_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caORw() //  []
         { info_tbl: [(caORw,
                       label: block_caORw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caORw: // global
           Sp = Sp + 8;
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _caORL() //  []
         { info_tbl: [(caORL,
                       label: block_caORL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caORL: // global
           Sp = Sp + 8;
           call _saLKs() args: 0, res: 0, upd: 0;
     }
 },
 _saLKs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLKs: // global
           I64[Sp - 8] = block_caOPF_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOSk; else goto caOPG;
       uaOSk: // global
           call _caOPF(R1) args: 0, res: 0, upd: 0;
       caOPG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOPF() //  [R1]
         { info_tbl: [(caOPF,
                       label: block_caOPF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOPF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOQU; else goto caOQT;
       caOQU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOQT: // global
           _saLKv::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_saLKy_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caOQ2_info;
           R2 = Hp - 7;
           R1 = _saLKv::I64;
           I64[Sp + 16] = _saLKv::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOQ2() //  [R1]
         { info_tbl: [(caOQ2,
                       label: block_caOQ2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQ2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caOQX; else goto caOQW;
       caOQX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOQW: // global
           I64[Hp - 32] = sat_saLKM_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saLKG_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_caOQO_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 8] = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOQO() //  [R1]
         { info_tbl: [(caOQO,
                       label: block_caOQO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOQO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caOR0; else goto caOQZ;
       caOR0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOQZ: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.931291681 UTC

[section ""cstring" . lvl3_raLJr_bytes" {
     lvl3_raLJr_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.933300906 UTC

[section ""data" . lvl4_raLJs_closure" {
     lvl4_raLJs_closure:
         const lvl4_raLJs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raLJs_entry() //  [R1]
         { info_tbl: [(caOTI,
                       label: lvl4_raLJs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOTI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOTJ; else goto caOTK;
       caOTJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOTK: // global
           (_caOTF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caOTF::I64 == 0) goto caOTH; else goto caOTG;
       caOTH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caOTG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caOTF::I64;
           R2 = lvl3_raLJr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.937364517 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning8_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning8_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning8_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning8_entry() //  [R2, R3, R4]
         { info_tbl: [(caOTZ,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOTZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caOU3; else goto caOU2;
       caOU3: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caOU2: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R3;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 39;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.944450943 UTC

[section ""data" . GHC.Event.Thread.$wstartIOManagerThread_closure" {
     GHC.Event.Thread.$wstartIOManagerThread_closure:
         const GHC.Event.Thread.$wstartIOManagerThread_info;
         const 0;
 },
 GHC.Event.Thread.$wstartIOManagerThread_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOU9: // global
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM0_entry() //  [R1]
         { info_tbl: [(caOUO,
                       label: sat_saLM0_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOUO: // global
           _saLLE::P64 = P64[R1 + 7];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 15])), %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 23])));
           R2 = _saLLE::P64;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM1_entry() //  [R1]
         { info_tbl: [(caOV1,
                       label: sat_saLM1_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOV1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOV5; else goto caOV4;
       caOV5: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOV4: // global
           _saLLE::P64 = P64[R1 + 7];
           _saLLm::I64 = I64[R1 + 15];
           _saLLN::I64 = I64[R1 + 23];
           I64[Hp - 24] = sat_saLM0_info;
           P64[Hp - 16] = _saLLE::P64;
           I64[Hp - 8] = _saLLm::I64;
           I64[Hp] = _saLLN::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLMf_entry() //  [R1, R2]
         { info_tbl: [(caOVg,
                       label: sat_saLMf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOVk; else goto caOVl;
       caOVk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOVl: // global
           I64[Sp - 16] = block_caOVd_info;
           _saLM4::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLM4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaOVp; else goto caOVe;
       uaOVp: // global
           call _caOVd(R1) args: 0, res: 0, upd: 0;
       caOVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOVd() //  [R1]
         { info_tbl: [(caOVd,
                       label: block_caOVd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVd: // global
           _saLM4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caOVj_info;
           R2 = I64[R1 + 7];
           R1 = _saLM4::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOVj() //  []
         { info_tbl: [(caOVj,
                       label: block_caOVj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLM8_entry() //  [R1]
         { info_tbl: [(caOVB,
                       label: sat_saLM8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caOVC; else goto caOVD;
       caOVC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOVD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caOVy_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caOVy() //  [R1, R2]
         { info_tbl: [(caOVy,
                       label: block_caOVy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOVG; else goto caOVF;
       caOVG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caOVF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLM9_entry() //  [R1]
         { info_tbl: [(caOVH,
                       label: sat_saLM9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVH: // global
           _saLM9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caOVI; else goto caOVJ;
       caOVJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caOVL; else goto caOVK;
       caOVL: // global
           HpAlloc = 24;
           goto caOVI;
       caOVI: // global
           R1 = _saLM9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caOVK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saLM9::P64;
           _saLLm::I64 = I64[_saLM9::P64 + 16];
           I64[Hp - 16] = sat_saLM8_info;
           I64[Hp] = _saLLm::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.$wstartIOManagerThread_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(caOVP,
                       label: GHC.Event.Thread.$wstartIOManagerThread_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caOVQ; else goto caOVR;
       caOVQ: // global
           R1 = GHC.Event.Thread.$wstartIOManagerThread_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caOVR: // global
           _saLLm::I64 = R5;
           _saLLk::I64 = R3;
           _saLLj::I64 = R2;
           if (%MO_S_Gt_W64(R2, R5)) goto caOVT; else goto caOVO;
       caOVO: // global
           if (%MO_S_Gt_W64(_saLLm::I64,
                            _saLLk::I64)) goto caOVT; else goto caOW9;
       caOVT: // global
           R4 = _saLLm::I64;
           R3 = _saLLj::I64;
           R2 = _saLLk::I64;
           call GHC.Event.Thread.ensureIOManagerIsRunning8_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
       caOW9: // global
           _saLLv::P64 = P64[(R4 + 24) + (_saLLm::I64 - _saLLj::I64 << 3)];
           I64[Sp - 32] = block_caOVU_info;
           R1 = _saLLv::P64;
           I64[Sp - 24] = _saLLj::I64;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = _saLLm::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaOX6; else goto caOWa;
       uaOX6: // global
           call _caOVU(R1) args: 0, res: 0, upd: 0;
       caOWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOVU() //  [R1]
         { info_tbl: [(caOVU,
                       label: block_caOVU_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVU: // global
           if (R1 & 7 == 1) goto uaOX2; else goto caOWq;
       uaOX2: // global
           Sp = Sp + 8;
           call _saLLw() args: 0, res: 0, upd: 0;
       caOWq: // global
           I64[Sp] = block_caOWj_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaOX7; else goto caOWk;
       uaOX7: // global
           call _caOWj(R1) args: 0, res: 0, upd: 0;
       caOWk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOWj() //  [R1]
         { info_tbl: [(caOWj,
                       label: block_caOWj_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOWj: // global
           I64[Sp - 8] = block_caOWo_info;
           _saLMs::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _saLMs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOX9; else goto caOWs;
       uaOX9: // global
           call _caOWo(R1) args: 0, res: 0, upd: 0;
       caOWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOWo() //  [R1]
         { info_tbl: [(caOWo,
                       label: block_caOWo_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOWo: // global
           I64[Sp] = block_caOWw_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOWw() //  [R1]
         { info_tbl: [(caOWw,
                       label: block_caOWw_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOWw: // global
           if (R1 == 16) goto uaOX3; else goto uaOX1;
       uaOX3: // global
           Sp = Sp + 16;
           call _saLLw() args: 0, res: 0, upd: 0;
       uaOX1: // global
           if (R1 == 17) goto caOWT; else goto caOWE;
       caOWT: // global
           _saLMs::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 32])), (-1));
           I64[Sp + 8] = block_caOWS_info;
           R2 = _saLMs::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 8, upd: 8;
       caOWE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caOWS() //  []
         { info_tbl: [(caOWS,
                       label: block_caOWS_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOWS: // global
           Sp = Sp + 8;
           call _saLLw() args: 0, res: 0, upd: 0;
     }
 },
 _saLLw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLLw: // global
           I64[Sp - 8] = block_caOUt_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caOUt() //  [R1]
         { info_tbl: [(caOUt,
                       label: block_caOUt_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOUt: // global
           I64[Sp] = block_caOUv_info;
           R2 = R1;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOUv() //  [R1]
         { info_tbl: [(caOUv,
                       label: block_caOUv_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOUv: // global
           I64[Sp] = block_caOUx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaOX5; else goto caOUy;
       uaOX5: // global
           call _caOUx(R1) args: 0, res: 0, upd: 0;
       caOUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOUx() //  [R1]
         { info_tbl: [(caOUx,
                       label: block_caOUx_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOUx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOW1; else goto caOW0;
       caOW1: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOW0: // global
           _saLLN::I64 = I64[R1 + 95];
           I64[Hp - 24] = sat_saLM1_info;
           P64[Hp - 16] = R1;
           _saLLm::I64 = I64[Sp + 24];
           I64[Hp - 8] = _saLLm::I64;
           I64[Hp] = _saLLN::I64;
           I64[Sp - 8] = block_caOV6_info;
           R2 = Hp - 23;
           _saLLE::P64 = R1;
           R1 = _saLLm::I64;
           P64[Sp] = _saLLE::P64;
           Sp = Sp - 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOV6() //  [R1]
         { info_tbl: [(caOV6,
                       label: block_caOV6_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOV6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caOW4; else goto caOW3;
       caOW4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOW3: // global
           I64[Hp - 32] = sat_saLMf_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saLM9_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp - 8] = block_caOVY_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caOVY() //  [R1]
         { info_tbl: [(caOVY,
                       label: block_caOVY_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOVY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caOW8; else goto caOW7;
       caOW8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caOW7: // global
           I64[Hp - 48] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLLl::P64 = P64[Sp + 32];
           _saLMj::I64 = I64[Sp + 40] - I64[Sp + 24];
           call MO_WriteBarrier();
           P64[(_saLLl::P64 + 24) + (_saLMj::I64 << 3)] = Hp - 6;
           I64[_saLLl::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLLl::P64 + 24) + ((I64[_saLLl::P64 + 8] << 3) + (_saLMj::I64 >> 7))] = 1 :: W8;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:43.985948529 UTC

[section ""data" . lvl5_raLJt_closure" {
     lvl5_raLJt_closure:
         const lvl5_raLJt_info;
 },
 sat_saLNh_entry() //  [R1]
         { info_tbl: [(caOZc,
                       label: sat_saLNh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOZc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOZd; else goto caOZe;
       caOZd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOZe: // global
           I64[Sp - 16] = block_caOZ3_info;
           _saLMS::P64 = P64[R1 + 7];
           R1 = _saLMS::P64;
           P64[Sp - 8] = _saLMS::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOZ3() //  [R1]
         { info_tbl: [(caOZ3,
                       label: block_caOZ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOZ3: // global
           _saLMS::P64 = P64[Sp + 8];
           (_saLNc::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saLNc::I64) goto caOZb; else goto caOZa;
       caOZb: // global
           R1 = _saLMS::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOZa: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNc::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl5_raLJt_entry() //  []
         { info_tbl: [(caOZm,
                       label: lvl5_raLJt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caOZn; else goto caOZo;
       caOZn: // global
           R1 = lvl5_raLJt_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caOZo: // global
           I64[Sp - 8] = block_caOYM_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caOYM() //  []
         { info_tbl: [(caOYM,
                       label: block_caOYM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOYM: // global
           I64[Sp] = block_caOYO_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caOYO() //  [R1]
         { info_tbl: [(caOYO,
                       label: block_caOYO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOYO: // global
           I64[Sp - 8] = block_caOYQ_info;
           R2 = GHC.Base.Nothing_closure+1;
           _saLMN::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLMN::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOYQ() //  []
         { info_tbl: [(caOYQ,
                       label: block_caOYQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOYQ: // global
           I64[Sp] = block_caOYS_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caOYS() //  [R1]
         { info_tbl: [(caOYS,
                       label: block_caOYS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOYS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caOZu; else goto caOZt;
       caOZu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caOZt: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caOYU::P64 = Hp - 23;
           if (R1 == 0) goto caOZl; else goto caOZk;
       caOZl: // global
           I64[Hp - 8] = sat_saLNh_info;
           P64[Hp] = _caOYU::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caOZk: // global
           Hp = Hp - 16;
           I64[Sp] = block_caOZv_info;
           R1 = _caOYU::P64;
           P64[Sp + 8] = _caOYU::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOZv() //  [R1]
         { info_tbl: [(caOZv,
                       label: block_caOZv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOZv: // global
           _caOYU::P64 = P64[Sp + 8];
           (_saLN0::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saLN0::I64) goto caOZE; else goto caOZD;
       caOZE: // global
           R1 = _caOYU::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caOZD: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLN0::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.00237691 UTC

[section ""data" . GHC.Event.Thread.timerManagerThreadVar_closure" {
     GHC.Event.Thread.timerManagerThreadVar_closure:
         const GHC.Event.Thread.timerManagerThreadVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManagerThreadVar_entry() //  [R1]
         { info_tbl: [(caP0k,
                       label: GHC.Event.Thread.timerManagerThreadVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP0k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caP0l; else goto caP0m;
       caP0l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caP0m: // global
           (_caP0f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caP0f::I64 == 0) goto caP0h; else goto caP0g;
       caP0h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caP0g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caP0f::I64;
           I64[Sp - 24] = block_caP0i_info;
           Sp = Sp - 24;
           call lvl5_raLJt_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caP0i() //  [R1]
         { info_tbl: [(caP0i,
                       label: block_caP0i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP0i: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.008798349 UTC

[section ""data" . lvl6_raLJu_closure" {
     lvl6_raLJu_closure:
         const lvl6_raLJu_info;
 },
 sat_saLNS_entry() //  [R1]
         { info_tbl: [(caP12,
                       label: sat_saLNS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP12: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP13; else goto caP14;
       caP13: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP14: // global
           I64[Sp - 16] = block_caP0T_info;
           _saLNt::P64 = P64[R1 + 7];
           R1 = _saLNt::P64;
           P64[Sp - 8] = _saLNt::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP0T() //  [R1]
         { info_tbl: [(caP0T,
                       label: block_caP0T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP0T: // global
           _saLNt::P64 = P64[Sp + 8];
           (_saLNN::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saLNN::I64) goto caP11; else goto caP10;
       caP11: // global
           R1 = _saLNt::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caP10: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNN::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl6_raLJu_entry() //  []
         { info_tbl: [(caP1c,
                       label: lvl6_raLJu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP1d; else goto caP1e;
       caP1d: // global
           R1 = lvl6_raLJu_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP1e: // global
           I64[Sp - 8] = block_caP0E_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caP0E() //  []
         { info_tbl: [(caP0E,
                       label: block_caP0E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP0E: // global
           I64[Sp] = block_caP0G_info;
           R1 = GHC.Base.Nothing_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP0G() //  [R1]
         { info_tbl: [(caP0G,
                       label: block_caP0G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP0G: // global
           I64[Sp - 8] = block_caP0I_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caP0I() //  [R1]
         { info_tbl: [(caP0I,
                       label: block_caP0I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP0I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caP1j; else goto caP1i;
       caP1j: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caP1i: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caP0K::P64 = Hp - 23;
           if (R1 == 0) goto caP1b; else goto caP1a;
       caP1b: // global
           I64[Hp - 8] = sat_saLNS_info;
           P64[Hp] = _caP0K::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caP1a: // global
           Hp = Hp - 16;
           I64[Sp] = block_caP1k_info;
           R1 = _caP0K::P64;
           P64[Sp + 8] = _caP0K::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP1k() //  [R1]
         { info_tbl: [(caP1k,
                       label: block_caP1k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP1k: // global
           _caP0K::P64 = P64[Sp + 8];
           (_saLNB::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saLNB::I64) goto caP1t; else goto caP1s;
       caP1t: // global
           R1 = _caP0K::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caP1s: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLNB::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.022841677 UTC

[section ""data" . GHC.Event.Thread.timerManager_closure" {
     GHC.Event.Thread.timerManager_closure:
         const GHC.Event.Thread.timerManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManager_entry() //  [R1]
         { info_tbl: [(caP26,
                       label: GHC.Event.Thread.timerManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP26: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caP27; else goto caP28;
       caP27: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caP28: // global
           (_caP21::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caP21::I64 == 0) goto caP23; else goto caP22;
       caP23: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caP22: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caP21::I64;
           I64[Sp - 24] = block_caP24_info;
           Sp = Sp - 24;
           call lvl6_raLJu_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caP24() //  [R1]
         { info_tbl: [(caP24,
                       label: block_caP24_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP24: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.028808751 UTC

[section ""cstring" . lvl7_raLJv_bytes" {
     lvl7_raLJv_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,50,49,54,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.030698392 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager2_closure" {
     GHC.Event.Thread.getSystemTimerManager2_closure:
         const GHC.Event.Thread.getSystemTimerManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager2_entry() //  []
         { info_tbl: [(caP2t,
                       label: GHC.Event.Thread.getSystemTimerManager2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP2t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caP2u; else goto caP2v;
       caP2u: // global
           R1 = GHC.Event.Thread.getSystemTimerManager2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP2v: // global
           I64[Sp - 8] = block_caP2r_info;
           R2 = lvl7_raLJv_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caP2r() //  [R1]
         { info_tbl: [(caP2r,
                       label: block_caP2r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP2r: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.035920333 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager1_closure" {
     GHC.Event.Thread.getSystemTimerManager1_closure:
         const GHC.Event.Thread.getSystemTimerManager1_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager1_entry() //  []
         { info_tbl: [(caP2O,
                       label: GHC.Event.Thread.getSystemTimerManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP2O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caP2P; else goto caP2Q;
       caP2P: // global
           R1 = GHC.Event.Thread.getSystemTimerManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP2Q: // global
           I64[Sp - 8] = block_caP2L_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaP38; else goto caP2M;
       uaP38: // global
           call _caP2L(R1) args: 0, res: 0, upd: 0;
       caP2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP2L() //  [R1]
         { info_tbl: [(caP2L,
                       label: block_caP2L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP2L: // global
           _saLO3::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caP2T_info;
           R1 = _saLO3::P64;
           if (R1 & 7 != 0) goto uaP37; else goto caP2V;
       uaP37: // global
           call _caP2T(R1) args: 0, res: 0, upd: 0;
       caP2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP2T() //  [R1]
         { info_tbl: [(caP2T,
                       label: block_caP2T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP2T: // global
           if (R1 & 7 == 1) goto caP31; else goto caP35;
       caP31: // global
           Sp = Sp + 8;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caP35: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.043278599 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager_closure" {
     GHC.Event.Thread.getSystemTimerManager_closure:
         const GHC.Event.Thread.getSystemTimerManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager_entry() //  []
         { info_tbl: [(caP3u,
                       label: GHC.Event.Thread.getSystemTimerManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3u: // global
           call GHC.Event.Thread.getSystemTimerManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.047589501 UTC

[section ""data" . lvl8_raLJw_closure" {
     lvl8_raLJw_closure:
         const lvl8_raLJw_info;
 },
 sat_saLOE_entry() //  [R1]
         { info_tbl: [(caP45,
                       label: sat_saLOE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP45: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP46; else goto caP47;
       caP46: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP47: // global
           I64[Sp - 16] = block_caP3W_info;
           _saLOf::P64 = P64[R1 + 7];
           R1 = _saLOf::P64;
           P64[Sp - 8] = _saLOf::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP3W() //  [R1]
         { info_tbl: [(caP3W,
                       label: block_caP3W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3W: // global
           _saLOf::P64 = P64[Sp + 8];
           (_saLOz::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saLOz::I64) goto caP44; else goto caP43;
       caP44: // global
           R1 = _saLOf::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caP43: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLOz::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_raLJw_entry() //  []
         { info_tbl: [(caP4f,
                       label: lvl8_raLJw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP4f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP4g; else goto caP4h;
       caP4g: // global
           R1 = lvl8_raLJw_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP4h: // global
           I64[Sp - 8] = block_caP3F_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caP3F() //  []
         { info_tbl: [(caP3F,
                       label: block_caP3F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3F: // global
           I64[Sp] = block_caP3H_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caP3H() //  [R1]
         { info_tbl: [(caP3H,
                       label: block_caP3H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3H: // global
           I64[Sp - 8] = block_caP3J_info;
           R2 = GHC.Tuple.()_closure+1;
           _saLOa::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLOa::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP3J() //  []
         { info_tbl: [(caP3J,
                       label: block_caP3J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3J: // global
           I64[Sp] = block_caP3L_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caP3L() //  [R1]
         { info_tbl: [(caP3L,
                       label: block_caP3L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caP4n; else goto caP4m;
       caP4n: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caP4m: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caP3N::P64 = Hp - 23;
           if (R1 == 0) goto caP4e; else goto caP4d;
       caP4e: // global
           I64[Hp - 8] = sat_saLOE_info;
           P64[Hp] = _caP3N::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caP4d: // global
           Hp = Hp - 16;
           I64[Sp] = block_caP4o_info;
           R1 = _caP3N::P64;
           P64[Sp + 8] = _caP3N::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP4o() //  [R1]
         { info_tbl: [(caP4o,
                       label: block_caP4o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP4o: // global
           _caP3N::P64 = P64[Sp + 8];
           (_saLOn::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saLOn::I64) goto caP4x; else goto caP4w;
       caP4x: // global
           R1 = _caP3N::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caP4w: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLOn::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.063881904 UTC

[section ""data" . GHC.Event.Thread.ioManagerLock_closure" {
     GHC.Event.Thread.ioManagerLock_closure:
         const GHC.Event.Thread.ioManagerLock_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ioManagerLock_entry() //  [R1]
         { info_tbl: [(caP5d,
                       label: GHC.Event.Thread.ioManagerLock_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP5d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caP5e; else goto caP5f;
       caP5e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caP5f: // global
           (_caP58::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caP58::I64 == 0) goto caP5a; else goto caP59;
       caP5a: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caP59: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caP58::I64;
           I64[Sp - 24] = block_caP5b_info;
           Sp = Sp - 24;
           call lvl8_raLJw_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caP5b() //  [R1]
         { info_tbl: [(caP5b,
                       label: block_caP5b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP5b: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.070446275 UTC

[section ""data" . lvl9_raLJx_closure" {
     lvl9_raLJx_closure:
         const lvl9_raLJx_info;
         const 0;
 },
 sat_saLPr_entry() //  [R1]
         { info_tbl: [(caP6a,
                       label: sat_saLPr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP6a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP6b; else goto caP6c;
       caP6b: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP6c: // global
           I64[Sp - 16] = block_caP61_info;
           _saLP2::P64 = P64[R1 + 7];
           R1 = _saLP2::P64;
           P64[Sp - 8] = _saLP2::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP61() //  [R1]
         { info_tbl: [(caP61,
                       label: block_caP61_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP61: // global
           _saLP2::P64 = P64[Sp + 8];
           (_saLPm::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saLPm::I64) goto caP69; else goto caP68;
       caP69: // global
           R1 = _saLP2::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caP68: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLPm::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_raLJx_entry() //  []
         { info_tbl: [(caP6h,
                       label: lvl9_raLJx_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP6h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caP6i; else goto caP6j;
       caP6i: // global
           R1 = lvl9_raLJx_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP6j: // global
           I64[Sp - 8] = block_caP5x_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caP5x() //  []
         { info_tbl: [(caP5x,
                       label: block_caP5x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP5x: // global
           _saLON::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]) - 1;
           if (%MO_S_Gt_W64(0, _saLON::I64)) goto caP6M; else goto caP6N;
       caP6M: // global
           _saLOP::I64 = 0;
           goto saLOO;
       caP6N: // global
           _saLOP::I64 = _saLON::I64 + 1;
           goto saLOO;
       saLOO: // global
           if (%MO_S_Ge_W64(_saLOP::I64, 0)) goto caP6n; else goto caP6I;
       caP6n: // global
           I64[Sp - 16] = block_caP5K_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saLOP::I64;
           I64[Sp - 8] = _saLOP::I64;
           I64[Sp] = _saLON::I64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caP6I: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caP5K() //  [R1]
         { info_tbl: [(caP5K,
                       label: block_caP5K_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP5K: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caP6q; else goto caP6p;
       caP6q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caP6p: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = Hp - 47;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 16] = block_caP5O_info;
           R1 = Hp - 31;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP5O() //  [R1]
         { info_tbl: [(caP5O,
                       label: block_caP5O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP5O: // global
           I64[Sp - 8] = block_caP5Q_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caP5Q() //  [R1]
         { info_tbl: [(caP5Q,
                       label: block_caP5Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP5Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caP6u; else goto caP6t;
       caP6u: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caP6t: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caP5S::P64 = Hp - 23;
           if (R1 == 0) goto caP6H; else goto caP6x;
       caP6H: // global
           I64[Hp - 8] = sat_saLPr_info;
           P64[Hp] = _caP5S::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caP6x: // global
           Hp = Hp - 16;
           I64[Sp] = block_caP6v_info;
           R1 = _caP5S::P64;
           P64[Sp + 8] = _caP5S::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP6v() //  [R1]
         { info_tbl: [(caP6v,
                       label: block_caP6v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP6v: // global
           _caP5S::P64 = P64[Sp + 8];
           (_saLPa::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saLPa::I64) goto caP6G; else goto caP6F;
       caP6G: // global
           R1 = _caP5S::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caP6F: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saLPa::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.087819272 UTC

[section ""data" . GHC.Event.Thread.eventManager_closure" {
     GHC.Event.Thread.eventManager_closure:
         const GHC.Event.Thread.eventManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.eventManager_entry() //  [R1]
         { info_tbl: [(caP7B,
                       label: GHC.Event.Thread.eventManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP7B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caP7C; else goto caP7D;
       caP7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caP7D: // global
           (_caP7w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caP7w::I64 == 0) goto caP7y; else goto caP7x;
       caP7y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caP7x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caP7w::I64;
           I64[Sp - 24] = block_caP7z_info;
           Sp = Sp - 24;
           call lvl9_raLJx_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caP7z() //  [R1]
         { info_tbl: [(caP7z,
                       label: block_caP7z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP7z: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.093202152 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning5_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning5_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.095419164 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning4_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning4_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning4_entry() //  [R1]
         { info_tbl: [(caP7Y,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP7Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP7Z; else goto caP80;
       caP7Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caP80: // global
           (_caP7V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caP7V::I64 == 0) goto caP7X; else goto caP7W;
       caP7X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caP7W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caP7V::I64;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.101586124 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning3_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning3_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning3_info;
         const 0;
 },
 sat_saLPZ_entry() //  [R1]
         { info_tbl: [(caP8J,
                       label: sat_saLPZ_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caP8K; else goto caP8L;
       caP8K: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP8L: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 63];
           I64[Sp - 24] = I64[R1 + 71];
           P64[Sp - 16] = P64[R1 + 39];
           P64[Sp - 8] = P64[R1 + 47];
           Sp = Sp - 32;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_saLQ0_entry() //  [R1]
         { info_tbl: [(caP8M,
                       label: sat_saLQ0_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8M: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caP8Q; else goto caP8P;
       caP8Q: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP8P: // global
           _saLPG::P64 = P64[R1 + 7];
           _saLPH::P64 = P64[R1 + 15];
           _saLPI::P64 = P64[R1 + 23];
           _saLPJ::P64 = P64[R1 + 31];
           _saLPN::P64 = P64[R1 + 39];
           _saLPO::P64 = P64[R1 + 47];
           _saLPK::I64 = I64[R1 + 55];
           _saLPL::I64 = I64[R1 + 63];
           _saLPM::I64 = I64[R1 + 71];
           I64[Hp - 72] = sat_saLPZ_info;
           P64[Hp - 64] = _saLPG::P64;
           P64[Hp - 56] = _saLPH::P64;
           P64[Hp - 48] = _saLPI::P64;
           P64[Hp - 40] = _saLPJ::P64;
           P64[Hp - 32] = _saLPN::P64;
           P64[Hp - 24] = _saLPO::P64;
           I64[Hp - 16] = _saLPK::I64;
           I64[Hp - 8] = _saLPL::I64;
           I64[Hp] = _saLPM::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 71;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLQ9_entry() //  [R1, R2]
         { info_tbl: [(caP91,
                       label: sat_saLQ9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP91: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caP95; else goto caP96;
       caP95: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caP96: // global
           I64[Sp - 16] = block_caP8Y_info;
           _saLQ3::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLQ3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaP9a; else goto caP8Z;
       uaP9a: // global
           call _caP8Y(R1) args: 0, res: 0, upd: 0;
       caP8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP8Y() //  [R1]
         { info_tbl: [(caP8Y,
                       label: block_caP8Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8Y: // global
           _saLQ3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caP94_info;
           R2 = I64[R1 + 7];
           R1 = _saLQ3::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP94() //  []
         { info_tbl: [(caP94,
                       label: block_caP94_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP94: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.ensureIOManagerIsRunning3_entry() //  []
         { info_tbl: [(caP9b,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP9b: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caP9g; else goto caP9h;
       caP9g: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caP9h: // global
           I64[Sp - 8] = block_caP8c_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caP8c() //  [R1]
         { info_tbl: [(caP8c,
                       label: block_caP8c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8c: // global
           I64[Sp] = block_caP8e_info;
           R2 = R1;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caP8e() //  [R1]
         { info_tbl: [(caP8e,
                       label: block_caP8e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8e: // global
           I64[Sp] = block_caP8g_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaP9u; else goto caP8h;
       uaP9u: // global
           call _caP8g(R1) args: 0, res: 0, upd: 0;
       caP8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP8g() //  [R1]
         { info_tbl: [(caP8g,
                       label: block_caP8g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8g: // global
           _saLPG::P64 = P64[R1 + 7];
           _saLPH::P64 = P64[R1 + 15];
           _saLPI::P64 = P64[R1 + 23];
           _saLPJ::P64 = P64[R1 + 31];
           _saLPN::P64 = P64[R1 + 39];
           _saLPO::P64 = P64[R1 + 47];
           _saLPK::I64 = I64[R1 + 55];
           _saLPL::I64 = I64[R1 + 63];
           _saLPM::I64 = I64[R1 + 71];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLPL::I64)));
           I64[Sp - 80] = block_caP8q_info;
           _saLPF::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp - 72] = _saLPG::P64;
           P64[Sp - 64] = _saLPH::P64;
           P64[Sp - 56] = _saLPI::P64;
           P64[Sp - 48] = _saLPJ::P64;
           I64[Sp - 40] = _saLPK::I64;
           I64[Sp - 32] = _saLPL::I64;
           I64[Sp - 24] = _saLPM::I64;
           P64[Sp - 16] = _saLPN::P64;
           P64[Sp - 8] = _saLPO::P64;
           P64[Sp] = _saLPF::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uaP9v; else goto caP8r;
       uaP9v: // global
           call _caP8q(R1) args: 0, res: 0, upd: 0;
       caP8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP8q() //  [R1]
         { info_tbl: [(caP8q,
                       label: block_caP8q_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8q: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caP9n; else goto caP9m;
       caP9n: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caP9m: // global
           _saLPU::P64 = P64[R1 + 7];
           I64[Hp - 88] = GHC.Base.Just_con_info;
           P64[Hp - 80] = P64[Sp + 80];
           _saLPG::P64 = P64[Sp + 8];
           _saLPH::P64 = P64[Sp + 16];
           _saLPI::P64 = P64[Sp + 24];
           _saLPJ::P64 = P64[Sp + 32];
           _saLPK::I64 = I64[Sp + 40];
           _saLPL::I64 = I64[Sp + 48];
           _saLPM::I64 = I64[Sp + 56];
           _saLPN::P64 = P64[Sp + 64];
           _saLPO::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_saLPU::P64 + 8] = Hp - 86;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLPU::P64);
           I64[Hp - 72] = sat_saLQ0_info;
           P64[Hp - 64] = _saLPG::P64;
           P64[Hp - 56] = _saLPH::P64;
           P64[Hp - 48] = _saLPI::P64;
           P64[Hp - 40] = _saLPJ::P64;
           P64[Hp - 32] = _saLPN::P64;
           P64[Hp - 24] = _saLPO::P64;
           I64[Hp - 16] = _saLPK::I64;
           I64[Hp - 8] = _saLPL::I64;
           I64[Hp] = _saLPM::I64;
           I64[Sp + 80] = block_caP8R_info;
           R1 = Hp - 71;
           Sp = Sp + 80;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP8R() //  [R1]
         { info_tbl: [(caP8R,
                       label: block_caP8R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP8R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caP9q; else goto caP9p;
       caP9q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caP9p: // global
           I64[Hp - 8] = sat_saLQ9_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_caP9c_info;
           R4 = Hp - 6;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caP9c() //  [R1]
         { info_tbl: [(caP9c,
                       label: block_caP9c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP9c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caP9t; else goto caP9s;
       caP9t: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caP9s: // global
           I64[Hp - 24] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.128131214 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning2_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning2_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning2_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning2_entry() //  [R2]
         { info_tbl: [(caPaz,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPaz: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caPaA; else goto caPaB;
       caPaA: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPaB: // global
           I64[Sp - 8] = block_caPas_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPcm; else goto caPat;
       uaPcm: // global
           call _caPas(R1) args: 0, res: 0, upd: 0;
       caPat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPas() //  [R1]
         { info_tbl: [(caPas,
                       label: block_caPas_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPas: // global
           if (R1 & 7 == 1) goto uaPch; else goto caPax;
       uaPch: // global
           Sp = Sp + 8;
           call _caPbe() args: 0, res: 0, upd: 0;
       caPax: // global
           I64[Sp - 8] = block_caPaH_info;
           _saLQh::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saLQh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPck; else goto caPaJ;
       uaPck: // global
           call _caPaH(R1) args: 0, res: 0, upd: 0;
       caPaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPaH() //  [R1]
         { info_tbl: [(caPaH,
                       label: block_caPaH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPaH: // global
           I64[Sp] = block_caPaN_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPaN() //  [R1]
         { info_tbl: [(caPaN,
                       label: block_caPaN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPaN: // global
           if (R1 == 16) goto uaPci; else goto uaPcg;
       uaPci: // global
           Sp = Sp + 16;
           call _caPbe() args: 0, res: 0, upd: 0;
       uaPcg: // global
           if (R1 == 17) goto caPb1; else goto caPaV;
       caPb1: // global
           I64[Sp + 8] = block_caPb0_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaPcn; else goto caPb2;
       uaPcn: // global
           call _caPb0(R1) args: 0, res: 0, upd: 0;
       caPb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPaV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPb0() //  [R1]
         { info_tbl: [(caPb0,
                       label: block_caPb0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPb0: // global
           _saLQv::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caPb6_info;
           R1 = _saLQv::P64;
           if (R1 & 7 != 0) goto uaPcp; else goto caPb8;
       uaPcp: // global
           call _caPb6(R1) args: 0, res: 0, upd: 0;
       caPb8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPb6() //  [R1]
         { info_tbl: [(caPb6,
                       label: block_caPb6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPb6: // global
           if (R1 & 7 == 1) goto uaPcj; else goto caPbq;
       uaPcj: // global
           Sp = Sp + 8;
           call _caPbe() args: 0, res: 0, upd: 0;
       caPbq: // global
           _saLQx::P64 = P64[R1 + 6];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd((-1));
           I64[Sp] = block_caPbj_info;
           R1 = _saLQx::P64;
           if (R1 & 7 != 0) goto uaPcq; else goto caPbk;
       uaPcq: // global
           call _caPbj(R1) args: 0, res: 0, upd: 0;
       caPbk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPbe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPbe: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _caPbj() //  [R1]
         { info_tbl: [(caPbj,
                       label: block_caPbj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPbj: // global
           I64[Sp - 48] = block_caPbo_info;
           _saLQE::P64 = P64[R1 + 23];
           _saLQJ::P64 = P64[R1 + 39];
           _saLQK::P64 = P64[R1 + 47];
           _saLQG::I64 = I64[R1 + 55];
           _saLQH::I64 = I64[R1 + 63];
           _saLQI::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _saLQG::I64;
           I64[Sp - 32] = _saLQH::I64;
           I64[Sp - 24] = _saLQI::I64;
           P64[Sp - 16] = _saLQJ::P64;
           P64[Sp - 8] = _saLQK::P64;
           P64[Sp] = _saLQE::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaPcs; else goto caPbs;
       uaPcs: // global
           call _caPbo(R1) args: 0, res: 0, upd: 0;
       caPbs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPbo() //  [R1]
         { info_tbl: [(caPbo,
                       label: block_caPbo_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPbo: // global
           _saLQE::P64 = P64[Sp + 48];
           _saLQM::P64 = P64[R1 + 7];
           _saLQQ::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saLQE::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLQE::P64);
           I64[Sp] = block_caPbz_info;
           R2 = _saLQM::P64;
           R1 = _saLQQ::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPbz() //  []
         { info_tbl: [(caPbz,
                       label: block_caPbz_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPbz: // global
           I64[Sp] = block_caPbB_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPbB() //  []
         { info_tbl: [(caPbB,
                       label: block_caPbB_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPbB: // global
           _saLQH::I64 = I64[Sp + 16];
           _saLQJ::P64 = P64[Sp + 32];
           (_saLR2::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saLR7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQH::I64)));
           I64[Sp + 16] = block_caPbQ_info;
           R1 = _saLQJ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaPct; else goto caPbR;
       uaPct: // global
           call _caPbQ(R1) args: 0, res: 0, upd: 0;
       caPbR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPbQ() //  [R1]
         { info_tbl: [(caPbQ,
                       label: block_caPbQ_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPbQ: // global
           _saLQI::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caPbX; else goto caPc1;
       caPbX: // global
           (_saLRd::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQI::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
       caPc1: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saLRl::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saLQI::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.154200916 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning6_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning6_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning6_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning6_entry() //  [R2]
         { info_tbl: [(caPdt,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPdt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caPdH; else goto caPdI;
       caPdH: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPdI: // global
           I64[Sp - 8] = block_caPdq_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPeR; else goto caPdr;
       uaPeR: // global
           call _caPdq(R1) args: 0, res: 0, upd: 0;
       caPdr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPdq() //  [R1]
         { info_tbl: [(caPdq,
                       label: block_caPdq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPdq: // global
           _saLRs::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caPdw_info;
           R1 = _saLRs::P64;
           if (R1 & 7 != 0) goto uaPeQ; else goto caPdx;
       uaPeQ: // global
           call _caPdw(R1) args: 0, res: 0, upd: 0;
       caPdx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPdw() //  [R1]
         { info_tbl: [(caPdw,
                       label: block_caPdw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPdw: // global
           I64[Sp - 16] = block_caPdB_info;
           _saLRu::P64 = P64[R1 + 7];
           _saLRx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saLRx::P64;
           P64[Sp] = _saLRu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPeS; else goto caPdC;
       uaPeS: // global
           call _caPdB(R1) args: 0, res: 0, upd: 0;
       caPdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPdB() //  [R1]
         { info_tbl: [(caPdB,
                       label: block_caPdB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPdB: // global
           I64[Sp] = block_caPdG_info;
           _saLRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saLRz::I64;
           if (R1 & 7 != 0) goto uaPeT; else goto caPdM;
       uaPeT: // global
           call _caPdG(R1) args: 0, res: 0, upd: 0;
       caPdM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPdG() //  [R1]
         { info_tbl: [(caPdG,
                       label: block_caPdG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPdG: // global
           if (%MO_S_Le_W64(0, I64[Sp + 16])) goto caPen; else goto caPeq;
       caPen: // global
           I64[Sp - 8] = 0;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 8;
           call _caPeb() args: 0, res: 0, upd: 0;
       caPeq: // global
           I64[Sp + 8] = block_caPep_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaPeU; else goto caPer;
       uaPeU: // global
           call _caPep(R1) args: 0, res: 0, upd: 0;
       caPer: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPeb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPeb: // global
           I64[Sp - 8] = block_caPed_info;
           R5 = I64[Sp];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 24];
           R2 = I64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPed() //  []
         { info_tbl: [(caPed,
                       label: block_caPed_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPed: // global
           _saLRL::I64 = I64[Sp + 8];
           if (_saLRL::I64 == I64[Sp + 32]) goto caPel; else goto caPek;
       caPel: // global
           I64[Sp + 24] = block_caPdZ_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaPeW; else goto caPe1;
       uaPeW: // global
           call _caPdZ(R1) args: 0, res: 0, upd: 0;
       caPe1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPek: // global
           I64[Sp + 8] = _saLRL::I64 + 1;
           Sp = Sp + 8;
           call _caPeb() args: 0, res: 0, upd: 0;
     }
 },
 _caPdZ() //  [R1]
         { info_tbl: [(caPdZ,
                       label: block_caPdZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPdZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPe7; else goto caPe6;
       caPe7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPe6: // global
           _saLRG::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saLRG::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLRG::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPep() //  [R1]
         { info_tbl: [(caPep,
                       label: block_caPep_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPep: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPex; else goto caPew;
       caPex: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPew: // global
           _saLRT::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saLRT::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLRT::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.172989242 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning1_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning1_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning1_entry() //  []
         { info_tbl: [(caPfT,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPfT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPfU; else goto caPfV;
       caPfU: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPfV: // global
           (_saLS1::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saLS1::I64 == 0) goto caPfS; else goto caPfR;
       caPfS: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caPfR: // global
           I64[Sp - 8] = block_caPfX_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPgc; else goto caPfY;
       uaPgc: // global
           call _caPfX(R1) args: 0, res: 0, upd: 0;
       caPfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPfX() //  [R1]
         { info_tbl: [(caPfX,
                       label: block_caPfX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPfX: // global
           I64[Sp] = block_caPg2_info;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure+2;
           R2 = P64[R1 + 7];
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPg2() //  []
         { info_tbl: [(caPg2,
                       label: block_caPg2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPg2: // global
           I64[Sp] = block_caPg4_info;
           R1 = GHC.Event.Thread.timerManagerThreadVar_closure;
           if (R1 & 7 != 0) goto uaPgd; else goto caPg7;
       uaPgd: // global
           call _caPg4(R1) args: 0, res: 0, upd: 0;
       caPg7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPg4() //  [R1]
         { info_tbl: [(caPg4,
                       label: block_caPg4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPg4: // global
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.182458306 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caPgz,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPgz: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.186130519 UTC

[section ""cstring" . lvl10_raLJy_bytes" {
     lvl10_raLJy_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,53,51,58,49,53,45,50,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.187948617 UTC

[section ""data" . lvl11_raLJz_closure" {
     lvl11_raLJz_closure:
         const lvl11_raLJz_info;
         const 0;
 },
 lvl11_raLJz_entry() //  []
         { info_tbl: [(caPgN,
                       label: lvl11_raLJz_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPgN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPgO; else goto caPgP;
       caPgO: // global
           R1 = lvl11_raLJz_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPgP: // global
           I64[Sp - 8] = block_caPgL_info;
           R2 = lvl10_raLJy_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPgL() //  [R1]
         { info_tbl: [(caPgL,
                       label: block_caPgL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPgL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.192932436 UTC

[section ""cstring" . lvl12_raLJA_bytes" {
     lvl12_raLJA_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,51,57,58,49,55,45,51,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.195249965 UTC

[section ""data" . lvl13_raLJB_closure" {
     lvl13_raLJB_closure:
         const lvl13_raLJB_info;
         const 0;
 },
 lvl13_raLJB_entry() //  []
         { info_tbl: [(caPh8,
                       label: lvl13_raLJB_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPh8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPh9; else goto caPha;
       caPh9: // global
           R1 = lvl13_raLJB_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPha: // global
           I64[Sp - 8] = block_caPh6_info;
           R2 = lvl12_raLJA_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPh6() //  [R1]
         { info_tbl: [(caPh6,
                       label: block_caPh6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPh6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.200308534 UTC

[section ""data" . lvl14_raLJC_closure" {
     lvl14_raLJC_closure:
         const lvl14_raLJC_info;
         const 0;
 },
 lvl14_raLJC_entry() //  [R2, R3, R4]
         { info_tbl: [(caPhq,
                       label: lvl14_raLJC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPhq: // global
           R6 = lvl4_raLJs_closure;
           R5 = R4;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.203727166 UTC

[section ""data" . lvl15_raLJD_closure" {
     lvl15_raLJD_closure:
         const lvl15_raLJD_info;
         const 0;
 },
 lvl15_raLJD_entry() //  [R2, R3]
         { info_tbl: [(caPhB,
                       label: lvl15_raLJD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPhB: // global
           R6 = lvl4_raLJs_closure;
           R5 = R3;
           R4 = R2;
           R3 = lvl1_raLJo_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.212638979 UTC

[section ""data" . GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caPju,
                       label: GHC.Event.Thread.$wioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPju: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caPjv; else goto caPjw;
       caPjv: // global
           R1 = GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPjw: // global
           _saLSm::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Sp - 16] = block_caPhM_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           I64[Sp - 8] = _saLSm::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPoi; else goto caPhN;
       uaPoi: // global
           call _caPhM(R1) args: 0, res: 0, upd: 0;
       caPhN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPhM() //  [R1]
         { info_tbl: [(caPhM,
                       label: block_caPhM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPjz; else goto caPjy;
       caPjz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPjy: // global
           _saLSo::P64 = P64[R1 + 7];
           _saLSr::P64 = P64[_saLSo::P64 + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saLSo::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSo::P64);
           I64[Sp - 8] = block_caPhV_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp] = _saLSr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPo4; else goto caPhW;
       uaPo4: // global
           call _caPhV(R1) args: 0, res: 0, upd: 0;
       caPhW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPhV() //  [R1]
         { info_tbl: [(caPhV,
                       label: block_caPhV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPhV: // global
           I64[Sp - 8] = block_caPi0_info;
           _saLSv::P64 = P64[R1 + 7];
           R1 = P64[_saLSv::P64 + 8];
           P64[Sp] = _saLSv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPo5; else goto caPi1;
       uaPo5: // global
           call _caPi0(R1) args: 0, res: 0, upd: 0;
       caPi1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPi0() //  [R1]
         { info_tbl: [(caPi0,
                       label: block_caPi0_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPi0: // global
           I64[Sp - 16] = block_caPi5_info;
           _saLSA::P64 = P64[R1 + 7];
           _saLSD::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saLSD::P64;
           P64[Sp] = _saLSA::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPo6; else goto caPi6;
       uaPo6: // global
           call _caPi5(R1) args: 0, res: 0, upd: 0;
       caPi6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPi5() //  [R1]
         { info_tbl: [(caPi5,
                       label: block_caPi5_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPi5: // global
           I64[Sp - 8] = block_caPia_info;
           _saLSE::P64 = R1;
           _saLSF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLSF::I64;
           P64[Sp + 16] = _saLSE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPo7; else goto caPib;
       uaPo7: // global
           call _caPia(R1) args: 0, res: 0, upd: 0;
       caPib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPia() //  [R1]
         { info_tbl: [(caPia,
                       label: block_caPia_info
                       rep:StackRep [True, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPia: // global
           _saLSm::I64 = I64[Sp + 48];
           _saLSH::I64 = I64[R1 + 7];
           _saLSI::I64 = I64[Sp + 8] + 1;
           if (%MO_S_Le_W64(_saLSm::I64,
                            _saLSI::I64)) goto caPjF; else goto caPnr;
       caPjF: // global
           I64[Sp] = block_caPil_info;
           _saLSG::P64 = R1;
           R1 = P64[Sp + 40];
           I64[Sp + 32] = _saLSH::I64;
           P64[Sp + 40] = _saLSG::P64;
           if (R1 & 7 != 0) goto uaPo8; else goto caPim;
       uaPo8: // global
           call _caPil(R1) args: 0, res: 0, upd: 0;
       caPim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPnr: // global
           _saLTn::I64 = _saLSm::I64 - 1;
           if (%MO_S_Gt_W64(0, _saLTn::I64)) goto caPnp; else goto caPnq;
       caPnp: // global
           _saLSG::P64 = R1;
           _saLTp::I64 = 0;
           goto saLTo;
       caPnq: // global
           _saLSG::P64 = R1;
           _saLTp::I64 = _saLTn::I64 + 1;
           goto saLTo;
       saLTo: // global
           if (%MO_S_Ge_W64(_saLTp::I64, 0)) goto caPkK; else goto caPnl;
       caPkK: // global
           I64[Sp - 32] = block_caPj4_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saLTp::I64;
           I64[Sp - 24] = _saLSI::I64;
           I64[Sp - 16] = _saLTn::I64;
           I64[Sp - 8] = _saLTp::I64;
           I64[Sp] = _saLSH::I64;
           P64[Sp + 48] = _saLSG::P64;
           Sp = Sp - 32;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caPnl: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPil() //  [R1]
         { info_tbl: [(caPil,
                       label: block_caPil_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPil: // global
           _saLSm::I64 = I64[Sp + 48];
           _saLSL::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saLSm::I64,
                            _saLSL::I64)) goto uaPnO; else goto caPkH;
       uaPnO: // global
           Sp = Sp + 56;
           goto uaPoa;
       caPkH: // global
           _saLSN::I64 = _saLSm::I64 - 1;
           if (%MO_S_Le_W64(_saLSL::I64,
                            _saLSN::I64)) goto caPkF; else goto uaPnP;
       caPkF: // global
           I64[Sp] = _saLSL::I64;
           I64[Sp + 48] = _saLSN::I64;
           call _caPiH() args: 0, res: 0, upd: 0;
       uaPnP: // global
           Sp = Sp + 56;
           goto uaPoa;
       uaPoa: // global
           call _caPkG() args: 0, res: 0, upd: 0;
     }
 },
 _caPiH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPiH: // global
           Hp = Hp + 16;
           _saLSY::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caPjT; else goto caPjS;
       caPjT: // global
           HpAlloc = 16;
           I64[Sp] = block_caPiG_info;
           R1 = _saLSY::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPjS: // global
           _saLSE::P64 = P64[Sp + 24];
           _saLSG::P64 = P64[Sp + 40];
           _saLSH::I64 = I64[Sp + 32];
           if (%MO_S_Gt_W64(_saLSH::I64,
                            _saLSY::I64)) goto caPjV; else goto caPkD;
       caPjV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLSY::I64;
           R4 = Hp - 7;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caPkD: // global
           if (%MO_S_Gt_W64(_saLSY::I64,
                            I64[Sp + 8])) goto caPjX; else goto caPk3;
       caPjX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLSY::I64;
           R4 = Hp - 7;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caPk3: // global
           Hp = Hp - 16;
           _saLT7::P64 = P64[P64[Sp + 16] + ((_saLSY::I64 - _saLSH::I64 << 3) + 24)];
           I64[Sp - 8] = block_caPk2_info;
           R1 = _saLT7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPod; else goto caPk4;
       uaPod: // global
           call _caPk2(R1) args: 0, res: 0, upd: 0;
       caPk4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPiG() //  [R1]
         { info_tbl: [(caPiG,
                       label: block_caPiG_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPiG: // global
           I64[Sp] = R1;
           call _caPiH() args: 0, res: 0, upd: 0;
     }
 },
 _caPk2() //  [R1]
         { info_tbl: [(caPk2,
                       label: block_caPk2_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPk2: // global
           if (R1 & 7 == 1) goto caPka; else goto caPkf;
       caPka: // global
           Sp = Sp + 64;
           call lvl11_raLJz_entry() args: 8, res: 0, upd: 8;
       caPkf: // global
           I64[Sp] = block_caPkd_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaPoj; else goto caPkg;
       uaPoj: // global
           call _caPkd(R1) args: 0, res: 0, upd: 0;
       caPkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPkd() //  [R1]
         { info_tbl: [(caPkd,
                       label: block_caPkd_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPkd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPko; else goto caPkn;
       caPko: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPkn: // global
           _saLTc::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_caPkl_info;
           R3 = Hp - 7;
           R2 = _saLTc::P64;
           P64[Sp] = _saLTc::P64;
           Sp = Sp - 8;
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPkl() //  [R1]
         { info_tbl: [(caPkl,
                       label: block_caPkl_info
                       rep:StackRep [False, True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPkl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caPks; else goto caPkr;
       caPks: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPkr: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLSD::P64 = P64[Sp + 32];
           _saLSN::I64 = I64[Sp + 64];
           _saLSY::I64 = I64[Sp + 16];
           _saLTh::I64 = _saLSY::I64 - I64[Sp + 48];
           call MO_WriteBarrier();
           P64[(_saLSD::P64 + 24) + (_saLTh::I64 << 3)] = Hp - 6;
           I64[_saLSD::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLSD::P64 + 24) + ((I64[_saLSD::P64 + 8] << 3) + (_saLTh::I64 >> 7))] = 1 :: W8;
           if (_saLSY::I64 == _saLSN::I64) goto uaPnS; else goto caPkB;
       uaPnS: // global
           Sp = Sp + 72;
           call _caPkG() args: 0, res: 0, upd: 0;
       caPkB: // global
           I64[Sp + 16] = _saLSY::I64 + 1;
           Sp = Sp + 16;
           call _caPiH() args: 0, res: 0, upd: 0;
     }
 },
 _caPkG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPkG: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPj4() //  [R1]
         { info_tbl: [(caPj4,
                       label: block_caPj4_info
                       rep:StackRep [True, True, True, True, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPj4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPkN; else goto caPkM;
       caPkN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPkM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           _caPj6::P64 = Hp - 7;
           if (%MO_S_Le_W64(0, I64[Sp + 40])) goto caPnj; else goto uaPnU;
       caPnj: // global
           P64[Sp - 16] = R1;
           I64[Sp - 8] = 0;
           P64[Sp] = _caPj6::P64;
           Sp = Sp - 16;
           call _caPjr() args: 0, res: 0, upd: 0;
       uaPnU: // global
           P64[Sp + 72] = R1;
           P64[Sp + 80] = _caPj6::P64;
           call _caPkP() args: 0, res: 0, upd: 0;
     }
 },
 _caPjr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPjr: // global
           Hp = Hp + 16;
           _saLU8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caPlM; else goto caPlL;
       caPlM: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caPjq_info;
           R1 = _saLU8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPlL: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saLU8::I64;
           _saLSE::P64 = P64[Sp + 72];
           _saLSG::P64 = P64[Sp + 96];
           _saLSH::I64 = I64[Sp + 48];
           _caPjt::P64 = Hp - 7;
           if (%MO_S_Gt_W64(_saLSH::I64,
                            _saLU8::I64)) goto caPlQ; else goto caPnh;
       caPlQ: // global
           R4 = _caPjt::P64;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caPnh: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 56])) goto caPlW; else goto caPm3;
       caPlW: // global
           R4 = _caPjt::P64;
           R3 = _saLSG::P64;
           R2 = _saLSE::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caPm3: // global
           _saLUg::P64 = P64[P64[Sp + 64] + ((_saLU8::I64 - _saLSH::I64 << 3) + 24)];
           I64[Sp - 16] = block_caPm2_info;
           R1 = _saLUg::P64;
           P64[Sp - 8] = _caPjt::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPoh; else goto caPm4;
       uaPoh: // global
           call _caPm2(R1) args: 0, res: 0, upd: 0;
       caPm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPjq() //  [R1]
         { info_tbl: [(caPjq,
                       label: block_caPjq_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPjq: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caPjr() args: 0, res: 0, upd: 0;
     }
 },
 _caPm2() //  [R1]
         { info_tbl: [(caPm2,
                       label: block_caPm2_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPm2: // global
           if (R1 & 7 == 1) goto caPma; else goto caPmk;
       caPma: // global
           Sp = Sp + 120;
           call lvl13_raLJB_entry() args: 8, res: 0, upd: 8;
       caPmk: // global
           I64[Sp - 8] = block_caPmd_info;
           _saLUh::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saLUh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPop; else goto caPme;
       uaPop: // global
           call _caPmd(R1) args: 0, res: 0, upd: 0;
       caPme: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPmd() //  [R1]
         { info_tbl: [(caPmd,
                       label: block_caPmd_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPmd: // global
           I64[Sp - 8] = block_caPmi_info;
           _saLUl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 112];
           P64[Sp] = _saLUl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPoq; else goto caPmm;
       uaPoq: // global
           call _caPmi(R1) args: 0, res: 0, upd: 0;
       caPmm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPmi() //  [R1]
         { info_tbl: [(caPmi,
                       label: block_caPmi_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPmi: // global
           _caPjt::P64 = P64[Sp + 24];
           _saLU8::I64 = I64[Sp + 40];
           if (%MO_S_Ge_W64(_saLU8::I64,
                            I64[R1 + 7])) goto caPmw; else goto caPng;
       caPmw: // global
           I64[Sp] = block_caPmu_info;
           R3 = _caPjt::P64;
           R2 = P64[Sp + 8];
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
       caPng: // global
           _caPj6::P64 = P64[Sp + 48];
           if (%MO_S_Gt_W64(0, _saLU8::I64)) goto caPn0; else goto caPnf;
       caPn0: // global
           R3 = _caPjt::P64;
           R2 = _caPj6::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caPnf: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 64])) goto caPn6; else goto caPne;
       caPn6: // global
           R3 = _caPjt::P64;
           R2 = _caPj6::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caPne: // global
           _saLSF::I64 = I64[Sp + 88];
           _saLTt::P64 = P64[Sp + 32];
           _saLUh::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[(_saLTt::P64 + 24) + (_saLU8::I64 << 3)] = _saLUh::P64;
           I64[_saLTt::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLTt::P64 + 24) + ((I64[_saLTt::P64 + 8] << 3) + (_saLU8::I64 >> 7))] = 1 :: W8;
           if (_saLU8::I64 == _saLSF::I64) goto uaPnZ; else goto caPnc;
       uaPnZ: // global
           P64[Sp + 128] = _caPj6::P64;
           P64[Sp + 120] = _saLTt::P64;
           Sp = Sp + 48;
           call _caPkP() args: 0, res: 0, upd: 0;
       caPnc: // global
           I64[Sp + 40] = _saLU8::I64 + 1;
           Sp = Sp + 32;
           call _caPjr() args: 0, res: 0, upd: 0;
     }
 },
 _caPmu() //  [R1]
         { info_tbl: [(caPmu,
                       label: block_caPmu_info
                       rep:StackRep [False, True, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPmu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caPmA; else goto caPmz;
       caPmA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPmz: // global
           _caPj6::P64 = P64[Sp + 48];
           _caPjt::P64 = P64[Sp + 24];
           _saLU8::I64 = I64[Sp + 40];
           if (%MO_S_Gt_W64(0, _saLU8::I64)) goto caPmE; else goto caPmV;
       caPmE: // global
           Hp = Hp - 40;
           R3 = _caPjt::P64;
           R2 = _caPj6::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caPmV: // global
           if (%MO_S_Gt_W64(_saLU8::I64,
                            I64[Sp + 64])) goto caPmK; else goto caPmU;
       caPmK: // global
           Hp = Hp - 40;
           R3 = _caPjt::P64;
           R2 = _caPj6::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caPmU: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saLSF::I64 = I64[Sp + 88];
           _saLTt::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[(_saLTt::P64 + 24) + (_saLU8::I64 << 3)] = Hp - 6;
           I64[_saLTt::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLTt::P64 + 24) + ((I64[_saLTt::P64 + 8] << 3) + (_saLU8::I64 >> 7))] = 1 :: W8;
           if (_saLU8::I64 == _saLSF::I64) goto uaPnX; else goto caPmS;
       uaPnX: // global
           P64[Sp + 128] = _caPj6::P64;
           P64[Sp + 120] = _saLTt::P64;
           Sp = Sp + 48;
           call _caPkP() args: 0, res: 0, upd: 0;
       caPmS: // global
           I64[Sp + 40] = _saLU8::I64 + 1;
           Sp = Sp + 32;
           call _caPjr() args: 0, res: 0, upd: 0;
     }
 },
 _caPkP() //  []
         { info_tbl: [(caPkP,
                       label: block_caPkP_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPkP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caPkT; else goto caPkS;
       caPkT: // global
           HpAlloc = 40;
           I64[Sp] = block_caPkP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caPkS: // global
           _saLSI::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saLSI::I64,
                            I64[Sp + 16])) goto caPlk; else goto caPll;
       caPlk: // global
           Hp = Hp - 40;
           I64[Sp + 56] = _saLSI::I64;
           Sp = Sp + 16;
           call _caPl8() args: 0, res: 0, upd: 0;
       caPll: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 80];
           P64[Hp - 8] = P64[Sp + 72];
           I64[Hp] = I64[Sp + 24];
           _saLSv::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_saLSv::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSv::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPl8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPl8: // global
           I64[Sp - 8] = block_caPla_info;
           R5 = I64[Sp + 40];
           R4 = P64[Sp + 56];
           R3 = I64[Sp];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPla() //  []
         { info_tbl: [(caPla,
                       label: block_caPla_info
                       rep:StackRep [True, True, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPla: // global
           _saLTD::I64 = I64[Sp + 48];
           if (_saLTD::I64 == I64[Sp + 8]) goto uaPo2; else goto caPlh;
       uaPo2: // global
           Sp = Sp + 8;
           call _caPl0() args: 0, res: 0, upd: 0;
       caPlh: // global
           I64[Sp + 48] = _saLTD::I64 + 1;
           Sp = Sp + 8;
           call _caPl8() args: 0, res: 0, upd: 0;
     }
 },
 _caPl0() //  []
         { info_tbl: [(caPl0,
                       label: block_caPl0_info
                       rep:StackRep [True, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPl0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caPl4; else goto caPl3;
       caPl4: // global
           HpAlloc = 40;
           I64[Sp] = block_caPl0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caPl3: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 56];
           I64[Hp] = I64[Sp + 8];
           _saLSv::P64 = P64[Sp + 48];
           call MO_WriteBarrier();
           P64[_saLSv::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saLSv::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.265071336 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged2_entry() //  []
         { info_tbl: [(caPqK,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPqK: // global
           call GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.269128417 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() //  []
         { info_tbl: [(caPqY,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPqY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPqZ; else goto caPr0;
       caPqZ: // global
           R1 = GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPr0: // global
           I64[Sp - 8] = block_caPqV_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPr4; else goto caPqW;
       uaPr4: // global
           call _caPqV(R1) args: 0, res: 0, upd: 0;
       caPqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPqV() //  [R1]
         { info_tbl: [(caPqV,
                       label: block_caPqV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPqV: // global
           R3 = GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.274553031 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caPri,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPri: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.278048996 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager2_closure" {
     GHC.Event.Thread.getSystemEventManager2_closure:
         const GHC.Event.Thread.getSystemEventManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager2_entry() //  [R2, R3, R4]
         { info_tbl: [(caPru,
                       label: GHC.Event.Thread.getSystemEventManager2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPru: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPry; else goto caPrx;
       caPry: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.getSystemEventManager2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caPrx: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.28382652 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager1_closure" {
     GHC.Event.Thread.getSystemEventManager1_closure:
         const GHC.Event.Thread.getSystemEventManager1_info;
         const 0;
 },
 sat_saLVn_entry() //  [R1]
         { info_tbl: [(caPsu,
                       label: sat_saLVn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPsu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPsv; else goto caPsw;
       caPsv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPsw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saLVo_entry() //  [R1]
         { info_tbl: [(caPsB,
                       label: sat_saLVo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPsB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPsC; else goto caPsD;
       caPsC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPsD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caPsk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaPsK; else goto caPsl;
       uaPsK: // global
           call _caPsk(R1) args: 0, res: 0, upd: 0;
       caPsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caPsk() //  [R1]
         { info_tbl: [(caPsk,
                       label: block_caPsk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPsk: // global
           if (R1 & 7 == 1) goto caPsy; else goto caPsz;
       caPsy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caPsz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caPsJ; else goto caPsI;
       caPsJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caPsI: // global
           _saLVm::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_saLVn_info;
           P64[Hp - 16] = _saLVm::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.getSystemEventManager1_entry() //  []
         { info_tbl: [(caPsL,
                       label: GHC.Event.Thread.getSystemEventManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPsL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caPsM; else goto caPsN;
       caPsM: // global
           R1 = GHC.Event.Thread.getSystemEventManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPsN: // global
           I64[Sp - 8] = block_caPrH_info;
           R1 = CurrentTSO;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPrH() //  [R2]
         { info_tbl: [(caPrH,
                       label: block_caPrH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPrH: // global
           I64[Sp - 8] = block_caPrL_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           I64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPt1; else goto caPrM;
       uaPt1: // global
           call _caPrL(R1) args: 0, res: 0, upd: 0;
       caPrM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPrL() //  [R1]
         { info_tbl: [(caPrL,
                       label: block_caPrL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPrL: // global
           _saLV3::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caPrQ_info;
           R1 = _saLV3::P64;
           if (R1 & 7 != 0) goto uaPt2; else goto caPrR;
       uaPt2: // global
           call _caPrQ(R1) args: 0, res: 0, upd: 0;
       caPrR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPrQ() //  [R1]
         { info_tbl: [(caPrQ,
                       label: block_caPrQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPrQ: // global
           I64[Sp - 16] = block_caPrV_info;
           _saLV6::P64 = P64[R1 + 15];
           _saLV8::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saLV8::P64;
           P64[Sp] = _saLV6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPt3; else goto caPrW;
       uaPt3: // global
           call _caPrV(R1) args: 0, res: 0, upd: 0;
       caPrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPrV() //  [R1]
         { info_tbl: [(caPrV,
                       label: block_caPrV_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPrV: // global
           I64[Sp - 8] = block_caPs0_info;
           _saLV9::P64 = R1;
           _saLVa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVa::I64;
           P64[Sp + 16] = _saLV9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPt4; else goto caPs1;
       uaPt4: // global
           call _caPs0(R1) args: 0, res: 0, upd: 0;
       caPs1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPs0() //  [R1]
         { info_tbl: [(caPs0,
                       label: block_caPs0_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPs0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPsU; else goto caPsT;
       caPsU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPsT: // global
           _saLUX::I64 = I64[Sp + 32];
           _saLV9::P64 = P64[Sp + 24];
           _saLVa::I64 = I64[Sp + 8];
           _saLVb::P64 = R1;
           if (%MO_S_Gt_W64(_saLVa::I64,
                            _saLUX::I64)) goto caPsY; else goto caPt0;
       caPt0: // global
           if (%MO_S_Gt_W64(_saLUX::I64,
                            I64[R1 + 7])) goto caPsY; else goto caPsZ;
       caPsY: // global
           Hp = Hp - 24;
           R4 = _saLUX::I64;
           R3 = _saLV9::P64;
           R2 = _saLVb::P64;
           Sp = Sp + 40;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caPsZ: // global
           I64[Hp - 16] = sat_saLVo_info;
           P64[Hp] = P64[P64[Sp + 16] + ((_saLUX::I64 - _saLVa::I64 << 3) + 24)];
           R1 = Hp - 16;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.303397324 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager_closure" {
     GHC.Event.Thread.getSystemEventManager_closure:
         const GHC.Event.Thread.getSystemEventManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager_entry() //  []
         { info_tbl: [(caPtU,
                       label: GHC.Event.Thread.getSystemEventManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPtU: // global
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.307298455 UTC

[section ""cstring" . lvl16_raLJE_bytes" {
     lvl16_raLJE_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.309168933 UTC

[section ""data" . lvl17_raLJF_closure" {
     lvl17_raLJF_closure:
         const lvl17_raLJF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_raLJF_entry() //  [R1]
         { info_tbl: [(caPu8,
                       label: lvl17_raLJF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPu8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPu9; else goto caPua;
       caPu9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPua: // global
           (_caPu5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caPu5::I64 == 0) goto caPu7; else goto caPu6;
       caPu7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caPu6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caPu5::I64;
           R2 = lvl16_raLJE_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.313170887 UTC

[section ""data" . lvl18_raLJG_closure" {
     lvl18_raLJG_closure:
         const lvl18_raLJG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_raLJG_entry() //  [R1]
         { info_tbl: [(caPuo,
                       label: lvl18_raLJG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPuo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPup; else goto caPuq;
       caPup: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPuq: // global
           (_caPul::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caPul::I64 == 0) goto caPun; else goto caPum;
       caPun: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caPum: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caPul::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl17_raLJF_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.317599163 UTC

[section ""data" . lvl19_raLJH_closure" {
     lvl19_raLJH_closure:
         const lvl19_raLJH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_raLJH_entry() //  [R1]
         { info_tbl: [(caPuE,
                       label: lvl19_raLJH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPuE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPuF; else goto caPuG;
       caPuF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPuG: // global
           (_caPuB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caPuB::I64 == 0) goto caPuD; else goto caPuC;
       caPuD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caPuC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caPuB::I64;
           R2 = lvl18_raLJG_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.321394598 UTC

[section ""data" . lvl20_raLJI_closure" {
     lvl20_raLJI_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.323148922 UTC

[section ""data" . lvl21_raLJJ_closure" {
     lvl21_raLJJ_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.324863855 UTC

[section ""data" . lvl22_raLJK_closure" {
     lvl22_raLJK_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.326593321 UTC

[section ""cstring" . lvl23_raLJL_bytes" {
     lvl23_raLJL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,56,51,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.328485014 UTC

[section ""data" . lvl24_raLJM_closure" {
     lvl24_raLJM_closure:
         const lvl24_raLJM_info;
         const 0;
 },
 lvl24_raLJM_entry() //  []
         { info_tbl: [(caPuY,
                       label: lvl24_raLJM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPuY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPuZ; else goto caPv0;
       caPuZ: // global
           R1 = lvl24_raLJM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPv0: // global
           I64[Sp - 8] = block_caPuW_info;
           R2 = lvl23_raLJL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPuW() //  [R1]
         { info_tbl: [(caPuW,
                       label: block_caPuW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPuW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.346435076 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM1_closure" {
     GHC.Event.Thread.threadWaitReadSTM1_closure:
         const GHC.Event.Thread.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saLWA_entry() //  [R1]
         { info_tbl: [(caPwX,
                       label: sat_saLWA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPwX: // global
           _saLWA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caPwY; else goto caPwZ;
       caPwZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPx1; else goto caPx0;
       caPx1: // global
           HpAlloc = 16;
           goto caPwY;
       caPwY: // global
           R1 = _saLWA::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPx0: // global
           _saLVB::P64 = P64[_saLWA::P64 + 7];
           _saLWv::P64 = P64[_saLWA::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWv::P64;
           I64[Sp - 8] = block_caPwV_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPwV() //  []
         { info_tbl: [(caPwV,
                       label: block_caPwV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPwV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl31_saLWt_entry() //  [R1, R2, R3]
         { info_tbl: [(caPx3,
                       label: lvl31_saLWt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPx3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPx7; else goto caPx6;
       caPx7: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPx6: // global
           _saLVB::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_saLWA_info;
           P64[Hp - 8] = _saLVB::P64;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saLXa_entry() //  [R1, R2]
         { info_tbl: [(caPyd,
                       label: $wgo_saLXa_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPye; else goto caPyf;
       caPye: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPyf: // global
           I64[Sp - 24] = block_caPy6_info;
           _saLXa::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saLWa::I64;
           P64[Sp - 8] = _saLXa::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaPyC; else goto caPy7;
       uaPyC: // global
           call _caPy6(R1) args: 0, res: 0, upd: 0;
       caPy7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPy6() //  [R1]
         { info_tbl: [(caPy6,
                       label: block_caPy6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPy6: // global
           if (R1 & 7 == 1) goto caPya; else goto caPyb;
       caPya: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPyb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPyn; else goto caPym;
       caPyn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPym: // global
           _saLXe::P64 = P64[R1 + 6];
           _saLXf::P64 = P64[R1 + 14];
           _saLXd::I64 = I64[R1 + 22];
           if (_saLXd::I64 == I64[Sp + 8]) goto caPyB; else goto caPyv;
       caPyB: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLXe::P64;
           R3 = _saLXf::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPyv: // global
           Hp = Hp - 16;
           I64[Sp] = block_caPyr_info;
           R2 = _saLXf::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saLXe::P64;
           I64[Sp + 16] = _saLXd::I64;
           call $wgo_saLXa_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPyr() //  [R1, R2, R3]
         { info_tbl: [(caPyr,
                       label: block_caPyr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caPyy; else goto caPyx;
       caPyy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caPyx: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saLXZ_entry() //  [R1, R2]
         { info_tbl: [(caPzn,
                       label: $wgo_saLXZ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPzn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPzo; else goto caPzp;
       caPzo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPzp: // global
           I64[Sp - 24] = block_caPzg_info;
           _saLXZ::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saLWa::I64;
           P64[Sp - 8] = _saLXZ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaPzM; else goto caPzh;
       uaPzM: // global
           call _caPzg(R1) args: 0, res: 0, upd: 0;
       caPzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPzg() //  [R1]
         { info_tbl: [(caPzg,
                       label: block_caPzg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPzg: // global
           if (R1 & 7 == 1) goto caPzk; else goto caPzl;
       caPzk: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPzl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPzx; else goto caPzw;
       caPzx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPzw: // global
           _saLY3::P64 = P64[R1 + 6];
           _saLY4::P64 = P64[R1 + 14];
           _saLY2::I64 = I64[R1 + 22];
           if (_saLY2::I64 == I64[Sp + 8]) goto caPzL; else goto caPzF;
       caPzL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLY3::P64;
           R3 = _saLY4::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPzF: // global
           Hp = Hp - 16;
           I64[Sp] = block_caPzB_info;
           R2 = _saLY4::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saLY3::P64;
           I64[Sp + 16] = _saLY2::I64;
           call $wgo_saLXZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPzB() //  [R1, R2, R3]
         { info_tbl: [(caPzB,
                       label: block_caPzB_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPzB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caPzI; else goto caPzH;
       caPzI: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caPzH: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saLWq_entry() //  [R1, R2]
         { info_tbl: [(caPzR,
                       label: $wio_saLWq_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPzR: // global
           _saLWr::P64 = R2;
           _saLWq::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caPzS; else goto caPzT;
       caPzT: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caPzV; else goto caPzU;
       caPzV: // global
           HpAlloc = 80;
           goto caPzS;
       caPzS: // global
           R2 = _saLWr::P64;
           R1 = _saLWq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPzU: // global
           _saLVB::P64 = P64[_saLWq::P64 + 6];
           _saLW1::P64 = P64[_saLWq::P64 + 14];
           _saLW3::P64 = P64[_saLWq::P64 + 22];
           _saLW4::P64 = P64[_saLWq::P64 + 30];
           _saLW9::P64 = P64[_saLWq::P64 + 38];
           _saLW8::I64 = I64[_saLWq::P64 + 46];
           _saLWa::I64 = I64[_saLWq::P64 + 54];
           _saLWc::I64 = I64[_saLWq::P64 + 62];
           I64[Hp - 72] = lvl31_saLWt_info;
           P64[Hp - 64] = _saLVB::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saLWa::I64;
           I64[Hp - 32] = _saLW8::I64;
           I64[Hp - 24] = _saLWc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caPwx_info;
           R5 = _saLWr::P64;
           R4 = Hp - 14;
           R3 = _saLWa::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saLW1::P64;
           P64[Sp - 48] = _saLW3::P64;
           P64[Sp - 40] = _saLW4::P64;
           P64[Sp - 32] = _saLW9::P64;
           I64[Sp - 24] = _saLWa::I64;
           I64[Sp - 16] = _saLWc::I64;
           P64[Sp - 8] = _saLWr::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPwx() //  [R1]
         { info_tbl: [(caPwx,
                       label: block_caPwx_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPwx: // global
           I64[Sp - 8] = block_caPwB_info;
           _saLWF::P64 = R1;
           R1 = R1;
           P64[Sp] = _saLWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPCf; else goto caPwC;
       uaPCf: // global
           call _caPwB(R1) args: 0, res: 0, upd: 0;
       caPwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPwB() //  [R1]
         { info_tbl: [(caPwB,
                       label: block_caPwB_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPwB: // global
           if (R1 & 7 == 1) goto caPzO; else goto caPzP;
       caPzO: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saLWG() args: 0, res: 0, upd: 0;
       caPzP: // global
           I64[Sp] = block_caPwH_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPwH() //  [R1]
         { info_tbl: [(caPwH,
                       label: block_caPwH_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPwH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPBO; else goto caPBN;
       caPBO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPBN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saLWG() args: 0, res: 0, upd: 0;
     }
 },
 _saLWG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saLWG: // global
           _saLWI::P64 = P64[Sp];
           I64[Sp] = block_caPxb_info;
           R1 = _saLWI::P64;
           if (R1 & 7 != 0) goto uaPCA; else goto caPxc;
       uaPCA: // global
           call _caPxb(R1) args: 0, res: 0, upd: 0;
       caPxc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPxb() //  [R1]
         { info_tbl: [(caPxb,
                       label: block_caPxb_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxb: // global
           _saLWL::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saLWM::I64 = _saLWL::I64 & 8;
           if (_saLWM::I64 != 0) goto uaPC8; else goto uaPC7;
       uaPC8: // global
           I64[Sp] = _saLWM::I64;
           I64[Sp + 40] = _saLWL::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caPxn() args: 0, res: 0, upd: 0;
       uaPC7: // global
           I64[Sp + 32] = _saLWM::I64;
           I64[Sp + 64] = _saLWL::I64;
           Sp = Sp + 16;
           call _caPyF() args: 0, res: 0, upd: 0;
     }
 },
 _caPxn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caPA3; else goto caPA2;
       caPA3: // global
           HpAlloc = 32;
           _saLWM::I64 = I64[Sp];
           I64[Sp] = block_caPxm_info;
           R1 = _saLWM::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPA2: // global
           _saLWL::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saLWL::I64) goto caPA5; else goto caPA6;
       caPA5: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caPA6: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saLWL::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caPxB_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caPxm() //  [R1]
         { info_tbl: [(caPxm,
                       label: block_caPxm_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxm: // global
           I64[Sp] = R1;
           call _caPxn() args: 0, res: 0, upd: 0;
     }
 },
 _caPxB() //  [R1]
         { info_tbl: [(caPxB,
                       label: block_caPxB_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxB: // global
           I64[Sp] = block_caPxD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaPCl; else goto caPxE;
       uaPCl: // global
           call _caPxD(R1) args: 0, res: 0, upd: 0;
       caPxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPxD() //  [R1]
         { info_tbl: [(caPxD,
                       label: block_caPxD_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxD: // global
           if (R1 & 7 == 1) goto caPAa; else goto caPAS;
       caPAa: // global
           I64[Sp + 40] = block_caPxI_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaPCm; else goto caPxJ;
       uaPCm: // global
           call _caPxI(R1) args: 0, res: 0, upd: 0;
       caPxJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPAS: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPxI() //  [R1]
         { info_tbl: [(caPxI,
                       label: block_caPxI_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxI: // global
           _saLWr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caPAd; else goto caPAM;
       caPAd: // global
           I64[Sp] = block_caPxN_info;
           R1 = P64[_saLWr::P64 + 8];
           if (R1 & 7 != 0) goto uaPCn; else goto caPxO;
       uaPCn: // global
           call _caPxN(R1) args: 0, res: 0, upd: 0;
       caPxO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPAM: // global
           I64[Sp + 24] = block_caPAK_info;
           R5 = _saLWr::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPxN() //  [R1]
         { info_tbl: [(caPxN,
                       label: block_caPxN_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPxN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPAg; else goto caPAf;
       caPAg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPAf: // global
           _saLWa::I64 = I64[Sp + 8];
           _saLX1::P64 = P64[R1 + 7];
           _saLX3::P64 = P64[R1 + 15];
           _saLX2::I64 = I64[R1 + 23];
           _saLX4::I64 = _saLWa::I64 & (I64[_saLX1::P64 + 8] - 1);
           _saLX9::P64 = P64[(_saLX1::P64 + 24) + (_saLX4::I64 << 3)];
           I64[Hp - 8] = $wgo_saLXa_info;
           I64[Hp] = _saLWa::I64;
           I64[Sp - 8] = block_caPAh_info;
           R2 = _saLX9::P64;
           R1 = Hp - 7;
           I64[Sp] = _saLX4::I64;
           P64[Sp + 8] = _saLX3::P64;
           I64[Sp + 16] = _saLX2::I64;
           P64[Sp + 24] = _saLX1::P64;
           Sp = Sp - 8;
           call $wgo_saLXa_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPAh() //  [R1, R2, R3]
         { info_tbl: [(caPAh,
                       label: block_caPAh_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPAh: // global
           I64[Sp - 16] = block_caPAj_info;
           _saLXo::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saLXo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPCs; else goto caPAl;
       uaPCs: // global
           call _caPAj(R1) args: 0, res: 0, upd: 0;
       caPAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPAj() //  [R1]
         { info_tbl: [(caPAj,
                       label: block_caPAj_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPAj: // global
           if (R1 & 7 == 1) goto uaPCa; else goto caPAw;
       uaPCa: // global
           Sp = Sp + 56;
           call _caPBt() args: 0, res: 0, upd: 0;
       caPAw: // global
           _saLX1::P64 = P64[Sp + 48];
           _saLX4::I64 = I64[Sp + 24];
           _saLXo::P64 = P64[Sp + 16];
           _saLXq::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saLX1::P64 + 24) + (_saLX4::I64 << 3)] = _saLXq::P64;
           I64[_saLX1::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLX1::P64 + 24) + ((I64[_saLX1::P64 + 8] << 3) + (_saLX4::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caPAu_info;
           R1 = _saLXo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaPCt; else goto caPAx;
       uaPCt: // global
           call _caPAu(R1) args: 0, res: 0, upd: 0;
       caPAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPAu() //  [R1]
         { info_tbl: [(caPAu,
                       label: block_caPAu_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPAu: // global
           if (R1 & 7 == 1) goto uaPCb; else goto caPAH;
       uaPCb: // global
           Sp = Sp + 32;
           call _caPBt() args: 0, res: 0, upd: 0;
       caPAH: // global
           _saLX2::I64 = I64[Sp + 16];
           _saLX3::P64 = P64[Sp + 8];
           I64[_saLX2::I64] = I64[_saLX2::I64] - 1;
           call MO_Touch(_saLX3::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPAK() //  []
         { info_tbl: [(caPAK,
                       label: block_caPAK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPAK: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPyF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPAW; else goto caPAV;
       caPAW: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caPyE_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPAV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caPyL_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPyE() //  [R1]
         { info_tbl: [(caPyE,
                       label: block_caPyE_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyE: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caPyF() args: 0, res: 0, upd: 0;
     }
 },
 _caPyL() //  [R1]
         { info_tbl: [(caPyL,
                       label: block_caPyL_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyL: // global
           I64[Sp] = block_caPyN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaPCp; else goto caPyO;
       uaPCp: // global
           call _caPyN(R1) args: 0, res: 0, upd: 0;
       caPyO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPyN() //  [R1]
         { info_tbl: [(caPyN,
                       label: block_caPyN_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyN: // global
           if (R1 & 7 == 1) goto caPB0; else goto caPBI;
       caPB0: // global
           I64[Sp + 40] = block_caPyS_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaPCq; else goto caPyT;
       uaPCq: // global
           call _caPyS(R1) args: 0, res: 0, upd: 0;
       caPyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPBI: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPyS() //  [R1]
         { info_tbl: [(caPyS,
                       label: block_caPyS_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyS: // global
           _saLWr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caPB3; else goto caPBC;
       caPB3: // global
           I64[Sp] = block_caPyX_info;
           R1 = P64[_saLWr::P64 + 8];
           if (R1 & 7 != 0) goto uaPCr; else goto caPyY;
       uaPCr: // global
           call _caPyX(R1) args: 0, res: 0, upd: 0;
       caPyY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPBC: // global
           I64[Sp + 24] = block_caPBA_info;
           R5 = _saLWr::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPyX() //  [R1]
         { info_tbl: [(caPyX,
                       label: block_caPyX_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPyX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPB6; else goto caPB5;
       caPB6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPB5: // global
           _saLWa::I64 = I64[Sp + 8];
           _saLXQ::P64 = P64[R1 + 7];
           _saLXS::P64 = P64[R1 + 15];
           _saLXR::I64 = I64[R1 + 23];
           _saLXT::I64 = _saLWa::I64 & (I64[_saLXQ::P64 + 8] - 1);
           _saLXY::P64 = P64[(_saLXQ::P64 + 24) + (_saLXT::I64 << 3)];
           I64[Hp - 8] = $wgo_saLXZ_info;
           I64[Hp] = _saLWa::I64;
           I64[Sp - 8] = block_caPB7_info;
           R2 = _saLXY::P64;
           R1 = Hp - 7;
           I64[Sp] = _saLXT::I64;
           P64[Sp + 8] = _saLXS::P64;
           I64[Sp + 16] = _saLXR::I64;
           P64[Sp + 24] = _saLXQ::P64;
           Sp = Sp - 8;
           call $wgo_saLXZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPB7() //  [R1, R2, R3]
         { info_tbl: [(caPB7,
                       label: block_caPB7_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPB7: // global
           I64[Sp - 16] = block_caPB9_info;
           _saLYd::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saLYd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPCw; else goto caPBb;
       uaPCw: // global
           call _caPB9(R1) args: 0, res: 0, upd: 0;
       caPBb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPB9() //  [R1]
         { info_tbl: [(caPB9,
                       label: block_caPB9_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPB9: // global
           if (R1 & 7 == 1) goto uaPCd; else goto caPBm;
       uaPCd: // global
           Sp = Sp + 56;
           call _caPBt() args: 0, res: 0, upd: 0;
       caPBm: // global
           _saLXQ::P64 = P64[Sp + 48];
           _saLXT::I64 = I64[Sp + 24];
           _saLYd::P64 = P64[Sp + 16];
           _saLYf::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saLXQ::P64 + 24) + (_saLXT::I64 << 3)] = _saLYf::P64;
           I64[_saLXQ::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saLXQ::P64 + 24) + ((I64[_saLXQ::P64 + 8] << 3) + (_saLXT::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caPBk_info;
           R1 = _saLYd::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaPCx; else goto caPBn;
       uaPCx: // global
           call _caPBk(R1) args: 0, res: 0, upd: 0;
       caPBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPBk() //  [R1]
         { info_tbl: [(caPBk,
                       label: block_caPBk_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPBk: // global
           if (R1 & 7 == 1) goto uaPCe; else goto caPBx;
       uaPCe: // global
           Sp = Sp + 32;
           call _caPBt() args: 0, res: 0, upd: 0;
       caPBx: // global
           _saLXR::I64 = I64[Sp + 16];
           _saLXS::P64 = P64[Sp + 8];
           I64[_saLXR::I64] = I64[_saLXR::I64] - 1;
           call MO_Touch(_saLXS::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPBt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPBt: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPBA() //  []
         { info_tbl: [(caPBA,
                       label: block_caPBA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPBA: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saLYy_entry() //  [R1, R2]
         { info_tbl: [(caPCJ,
                       label: io1_saLYy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPCJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPCK; else goto caPCL;
       caPCK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPCL: // global
           I64[Sp - 16] = block_caPCG_info;
           _saLWq::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saLWq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPCP; else goto caPCH;
       uaPCP: // global
           call _caPCG(R1) args: 0, res: 0, upd: 0;
       caPCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPCG() //  [R1]
         { info_tbl: [(caPCG,
                       label: block_caPCG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPCG: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saLWq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLYU_entry() //  [R1]
         { info_tbl: [(caPD2,
                       label: sat_saLYU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPD2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPD3; else goto caPD4;
       caPD3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPD4: // global
           I64[Sp - 8] = block_caPD0_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPD0() //  []
         { info_tbl: [(caPD0,
                       label: block_caPD0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPD0: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLYP_entry() //  [R1]
         { info_tbl: [(caPDk,
                       label: sat_saLYP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPDk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPDl; else goto caPDm;
       caPDl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPDm: // global
           I64[Sp - 8] = block_caPDb_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPDb() //  [R1]
         { info_tbl: [(caPDb,
                       label: block_caPDb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPDb: // global
           I64[Sp] = block_caPDd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaPDP; else goto caPDe;
       uaPDP: // global
           call _caPDd(R1) args: 0, res: 0, upd: 0;
       caPDe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPDd() //  [R1]
         { info_tbl: [(caPDd,
                       label: block_caPDd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPDd: // global
           if (R1 & 7 == 1) goto caPDh; else goto caPDi;
       caPDh: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caPDi: // global
           I64[Sp] = block_caPDt_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaPDQ; else goto caPDv;
       uaPDQ: // global
           call _caPDt(R1) args: 0, res: 0, upd: 0;
       caPDv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPDt() //  [R1]
         { info_tbl: [(caPDt,
                       label: block_caPDt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPDt: // global
           if (I64[R1 + 7] & 4 == 0) goto caPDL; else goto caPDF;
       caPDL: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caPDF: // global
           R1 = lvl19_raLJH_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ5_entry() //  [R1, R2]
         { info_tbl: [(caPE2,
                       label: sat_saLZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPE2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPE3; else goto caPE4;
       caPE3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPE4: // global
           I64[Sp - 16] = block_caPE0_info;
           _saLZ2::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saLZ2::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPE0() //  []
         { info_tbl: [(caPE0,
                       label: block_caPE0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPE0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ0_entry() //  [R1]
         { info_tbl: [(caPEb,
                       label: sat_saLZ0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEb: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZ1_entry() //  [R1]
         { info_tbl: [(caPEj,
                       label: sat_saLZ1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEj: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZh_entry() //  [R1]
         { info_tbl: [(caPEI,
                       label: sat_saLZh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEI: // global
           _saLZh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caPEJ; else goto caPEK;
       caPEK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPEM; else goto caPEL;
       caPEM: // global
           HpAlloc = 16;
           goto caPEJ;
       caPEJ: // global
           R1 = _saLZh::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPEL: // global
           _saLVB::P64 = P64[_saLZh::P64 + 7];
           _saLWb::P64 = P64[_saLZh::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caPEG_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPEG() //  []
         { info_tbl: [(caPEG,
                       label: block_caPEG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZy_entry() //  [R1, R2]
         { info_tbl: [(caPF3,
                       label: sat_saLZy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPF3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPF4; else goto caPF5;
       caPF4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPF5: // global
           I64[Sp - 16] = block_caPF1_info;
           _saLZv::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saLZv::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPF1() //  []
         { info_tbl: [(caPF1,
                       label: block_caPF1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPF1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZt_entry() //  [R1]
         { info_tbl: [(caPFc,
                       label: sat_saLZt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFc: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZu_entry() //  [R1]
         { info_tbl: [(caPFk,
                       label: sat_saLZu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFk: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZD_entry() //  [R1]
         { info_tbl: [(caPFr,
                       label: sat_saLZD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPFs; else goto caPFt;
       caPFs: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPFt: // global
           I64[Sp - 24] = block_caPEU_info;
           _saLWp::P64 = P64[R1 + 7];
           _saLYy::P64 = P64[R1 + 15];
           R1 = _saLWp::P64;
           P64[Sp - 16] = _saLWp::P64;
           P64[Sp - 8] = _saLYy::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPEU() //  [R1]
         { info_tbl: [(caPEU,
                       label: block_caPEU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caPFw; else goto caPFv;
       caPFw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPFv: // global
           I64[Hp - 56] = sat_saLZy_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZt_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saLZu_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caPFn_info;
           R2 = Hp - 54;
           _saLZs::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saLZs::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPFn() //  [R1]
         { info_tbl: [(caPFn,
                       label: block_caPFn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFn: // global
           _saLWp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caPFp_info;
           R2 = P64[Sp + 16];
           _saLZB::P64 = R1;
           R1 = _saLWp::P64;
           P64[Sp + 16] = _saLZB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPFp() //  []
         { info_tbl: [(caPFp,
                       label: block_caPFp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZO_entry() //  [R1]
         { info_tbl: [(caPFT,
                       label: sat_saLZO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFT: // global
           _saLZO::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caPFU; else goto caPFV;
       caPFV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPFX; else goto caPFW;
       caPFX: // global
           HpAlloc = 16;
           goto caPFU;
       caPFU: // global
           R1 = _saLZO::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPFW: // global
           _saLVB::P64 = P64[_saLZO::P64 + 7];
           _saLWb::P64 = P64[_saLZO::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caPFR_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPFR() //  []
         { info_tbl: [(caPFR,
                       label: block_caPFR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM04_entry() //  [R1, R2]
         { info_tbl: [(caPG9,
                       label: sat_saM04_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPGa; else goto caPGb;
       caPGa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPGb: // global
           I64[Sp - 16] = block_caPG7_info;
           _saM01::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM01::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPG7() //  []
         { info_tbl: [(caPG7,
                       label: block_caPG7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPG7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saLZZ_entry() //  [R1]
         { info_tbl: [(caPGi,
                       label: sat_saLZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGi: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saLYy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM00_entry() //  [R1]
         { info_tbl: [(caPGq,
                       label: sat_saM00_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGq: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM0g_entry() //  [R1]
         { info_tbl: [(caPGP,
                       label: sat_saM0g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGP: // global
           _saM0g::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caPGQ; else goto caPGR;
       caPGR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPGT; else goto caPGS;
       caPGT: // global
           HpAlloc = 16;
           goto caPGQ;
       caPGQ: // global
           R1 = _saM0g::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPGS: // global
           _saLVB::P64 = P64[_saM0g::P64 + 7];
           _saLWb::P64 = P64[_saM0g::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saLWb::P64;
           I64[Sp - 8] = block_caPGN_info;
           R2 = Hp - 6;
           R1 = _saLVB::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPGN() //  []
         { info_tbl: [(caPGN,
                       label: block_caPGN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGN: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saLVx_entry() //  [R1]
         { info_tbl: [(caPGZ,
                       label: io_saLVx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGZ: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caPH0; else goto caPH1;
       caPH0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caPH1: // global
           I64[Sp - 24] = block_caPvn_info;
           _saLVr::P64 = P64[R1 + 7];
           _saLVs::P64 = P64[R1 + 15];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _saLVr::P64;
           P64[Sp - 8] = _saLVs::P64;
           Sp = Sp - 24;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvn() //  [R1]
         { info_tbl: [(caPvn,
                       label: block_caPvn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvn: // global
           I64[Sp - 8] = block_caPvp_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caPvp() //  [R1]
         { info_tbl: [(caPvp,
                       label: block_caPvp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvp: // global
           I64[Sp] = block_caPvr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaPJm; else goto caPvs;
       uaPJm: // global
           call _caPvr(R1) args: 0, res: 0, upd: 0;
       caPvs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvr() //  [R1]
         { info_tbl: [(caPvr,
                       label: block_caPvr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvr: // global
           if (R1 & 7 == 1) goto caPGW; else goto caPGX;
       caPGW: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caPGX: // global
           I64[Sp] = block_caPvx_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaPJn; else goto caPvy;
       uaPJn: // global
           call _caPvx(R1) args: 0, res: 0, upd: 0;
       caPvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvx() //  [R1]
         { info_tbl: [(caPvx,
                       label: block_caPvx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvx: // global
           I64[Sp - 40] = block_caPvC_info;
           _saLVI::P64 = R1;
           _saLVJ::P64 = P64[R1 + 7];
           _saLVL::P64 = P64[R1 + 23];
           _saLVN::P64 = P64[R1 + 31];
           _saLVP::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saLVJ::P64;
           P64[Sp - 24] = _saLVL::P64;
           P64[Sp - 16] = _saLVN::P64;
           P64[Sp - 8] = _saLVP::P64;
           P64[Sp] = _saLVI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaPJo; else goto caPvD;
       uaPJo: // global
           call _caPvC(R1) args: 0, res: 0, upd: 0;
       caPvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvC() //  [R1]
         { info_tbl: [(caPvC,
                       label: block_caPvC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvC: // global
           I64[Sp - 8] = block_caPvH_info;
           _saLVW::P64 = R1;
           _saLVX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVX::I64;
           P64[Sp + 16] = _saLVW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPJp; else goto caPvI;
       uaPJp: // global
           call _caPvH(R1) args: 0, res: 0, upd: 0;
       caPvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvH() //  [R1]
         { info_tbl: [(caPvH,
                       label: block_caPvH_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvH: // global
           I64[Sp - 8] = block_caPvM_info;
           _saLVY::P64 = R1;
           _saLVZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saLVZ::I64;
           P64[Sp + 16] = _saLVY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPJq; else goto caPvN;
       uaPJq: // global
           call _caPvM(R1) args: 0, res: 0, upd: 0;
       caPvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvM() //  [R1]
         { info_tbl: [(caPvM,
                       label: block_caPvM_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvM: // global
           _saLVs::P64 = P64[Sp + 80];
           _saLW1::P64 = P64[R1 + 7];
           _saLW3::P64 = P64[R1 + 23];
           _saLW4::P64 = P64[R1 + 31];
           (_saLW8::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caPvT_info;
           R1 = _saLVs::P64;
           I64[Sp - 8] = _saLW8::I64;
           P64[Sp] = _saLW4::P64;
           P64[Sp + 48] = _saLW3::P64;
           P64[Sp + 80] = _saLW1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaPJr; else goto caPvU;
       uaPJr: // global
           call _caPvT(R1) args: 0, res: 0, upd: 0;
       caPvU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvT() //  [R1]
         { info_tbl: [(caPvT,
                       label: block_caPvT_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvT: // global
           I64[Sp - 8] = block_caPvY_info;
           _saLW9::P64 = R1;
           _saLWa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saLWa::I64;
           P64[Sp + 88] = _saLW9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPJs; else goto caPvZ;
       uaPJs: // global
           call _caPvY(R1) args: 0, res: 0, upd: 0;
       caPvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPvY() //  [R1]
         { info_tbl: [(caPvY,
                       label: block_caPvY_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvY: // global
           I64[Sp - 16] = block_caPw3_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caPw3() //  [R1]
         { info_tbl: [(caPw3,
                       label: block_caPw3_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPw3: // global
           _saLVW::P64 = P64[Sp + 72];
           _saLVX::I64 = I64[Sp + 56];
           _saLVY::P64 = P64[Sp + 64];
           _saLWg::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saLVX::I64,
                            _saLWg::I64)) goto caPHh; else goto caPJ4;
       caPJ4: // global
           if (%MO_S_Gt_W64(_saLWg::I64,
                            I64[Sp + 48])) goto caPHh; else goto caPHi;
       caPHh: // global
           R4 = _saLWg::I64;
           R3 = _saLVW::P64;
           R2 = _saLVY::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caPHi: // global
           _saLWn::P64 = P64[P64[Sp + 80] + ((_saLWg::I64 - _saLVX::I64 << 3) + 24)];
           I64[Sp] = block_caPwj_info;
           _saLWf::I64 = R1;
           R1 = _saLWn::P64;
           I64[Sp + 80] = _saLWf::I64;
           if (R1 & 7 != 0) goto uaPJt; else goto caPwk;
       uaPJt: // global
           call _caPwj(R1) args: 0, res: 0, upd: 0;
       caPwk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPwj() //  [R1]
         { info_tbl: [(caPwj,
                       label: block_caPwj_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPwj: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caPHl; else goto caPHk;
       caPHl: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPHk: // global
           _saLWp::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saLWq_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saLYy_info;
           P64[Hp - 24] = Hp - 102;
           _caPCB::P64 = Hp - 30;
           _saLYW::I64 = I64[Sp + 80];
           if (_saLYW::I64 != 0) goto uaPJe; else goto caPI0;
       uaPJe: // global
           if (_saLYW::I64 != 1) goto caPHr; else goto caPIv;
       caPHr: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caPDT_info;
           R1 = _saLWp::P64;
           P64[Sp + 112] = _saLWp::P64;
           P64[Sp + 120] = _caPCB::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caPIv: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caPG0_info;
           R1 = _saLWp::P64;
           P64[Sp + 112] = _saLWp::P64;
           P64[Sp + 120] = _caPCB::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caPI0: // global
           I64[Hp - 16] = sat_saLZD_info;
           P64[Hp - 8] = _saLWp::P64;
           P64[Hp] = _caPCB::P64;
           I64[Sp + 8] = block_caPFz_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPDT() //  [R1]
         { info_tbl: [(caPDT,
                       label: block_caPDT_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPDT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caPHu; else goto caPHt;
       caPHu: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPHt: // global
           I64[Hp - 56] = sat_saLZ5_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZ0_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saLZ1_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caPEm_info;
           R2 = Hp - 54;
           _saLYZ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saLYZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPEm() //  [R1]
         { info_tbl: [(caPEm,
                       label: block_caPEm_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEm: // global
           I64[Sp] = block_caPEo_info;
           R2 = P64[Sp + 112];
           _saLZ8::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saLZ8::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPEo() //  []
         { info_tbl: [(caPEo,
                       label: block_caPEo_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEo: // global
           I64[Sp] = block_caPEq_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaPJv; else goto caPEr;
       uaPJv: // global
           call _caPEq(R1) args: 0, res: 0, upd: 0;
       caPEr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPEq() //  [R1]
         { info_tbl: [(caPEq,
                       label: block_caPEq_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEq: // global
           I64[Sp] = block_caPEv_info;
           _saLZb::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saLZb::P64;
           if (R1 & 7 != 0) goto uaPJw; else goto caPEw;
       uaPJw: // global
           call _caPEv(R1) args: 0, res: 0, upd: 0;
       caPEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPEv() //  [R1]
         { info_tbl: [(caPEv,
                       label: block_caPEv_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPEv: // global
           if (R1 & 7 == 1) goto caPHC; else goto caPHS;
       caPHC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPHF; else goto caPHE;
       caPHF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPHE: // global
           I64[Hp - 16] = sat_saLZh_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caPHy_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caPHS: // global
           I64[Sp + 8] = block_caPHQ_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaPJx; else goto caPHT;
       uaPJx: // global
           call _caPHQ(R1) args: 0, res: 0, upd: 0;
       caPHT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPHy() //  []
         { info_tbl: [(caPHy,
                       label: block_caPHy_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPHy: // global
           I64[Sp] = block_caPHA_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaPJE; else goto caPHH;
       uaPJE: // global
           call _caPHA(R1) args: 0, res: 0, upd: 0;
       caPHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPHA() //  [R1]
         { info_tbl: [(caPHA,
                       label: block_caPHA_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPHA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPHN; else goto caPHM;
       caPHN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPHM: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 _caPHQ() //  [R1]
         { info_tbl: [(caPHQ,
                       label: block_caPHQ_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPHQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPHZ; else goto caPHY;
       caPHZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPHY: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 _caPG0() //  [R1]
         { info_tbl: [(caPG0,
                       label: block_caPG0_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPG0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caPIy; else goto caPIx;
       caPIy: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPIx: // global
           I64[Hp - 56] = sat_saM04_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saLZZ_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM00_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caPGt_info;
           R2 = Hp - 54;
           _saLZY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saLZY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPGt() //  [R1]
         { info_tbl: [(caPGt,
                       label: block_caPGt_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGt: // global
           I64[Sp] = block_caPGv_info;
           R2 = P64[Sp + 112];
           _saM07::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM07::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPGv() //  []
         { info_tbl: [(caPGv,
                       label: block_caPGv_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGv: // global
           I64[Sp] = block_caPGx_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaPJB; else goto caPGy;
       uaPJB: // global
           call _caPGx(R1) args: 0, res: 0, upd: 0;
       caPGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPGx() //  [R1]
         { info_tbl: [(caPGx,
                       label: block_caPGx_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGx: // global
           I64[Sp] = block_caPGC_info;
           _saM0a::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM0a::P64;
           if (R1 & 7 != 0) goto uaPJC; else goto caPGD;
       uaPJC: // global
           call _caPGC(R1) args: 0, res: 0, upd: 0;
       caPGD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPGC() //  [R1]
         { info_tbl: [(caPGC,
                       label: block_caPGC_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPGC: // global
           if (R1 & 7 == 1) goto caPIG; else goto caPIW;
       caPIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPIJ; else goto caPII;
       caPIJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPII: // global
           I64[Hp - 16] = sat_saM0g_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caPIC_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caPIW: // global
           I64[Sp + 8] = block_caPIU_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaPJD; else goto caPIX;
       uaPJD: // global
           call _caPIU(R1) args: 0, res: 0, upd: 0;
       caPIX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPIC() //  []
         { info_tbl: [(caPIC,
                       label: block_caPIC_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPIC: // global
           I64[Sp] = block_caPIE_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaPJK; else goto caPIL;
       uaPJK: // global
           call _caPIE(R1) args: 0, res: 0, upd: 0;
       caPIL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPIE() //  [R1]
         { info_tbl: [(caPIE,
                       label: block_caPIE_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPIE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPIR; else goto caPIQ;
       caPIR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPIQ: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 _caPIU() //  [R1]
         { info_tbl: [(caPIU,
                       label: block_caPIU_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPIU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPJ3; else goto caPJ2;
       caPJ3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPJ2: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 _caPFz() //  [R1]
         { info_tbl: [(caPFz,
                       label: block_caPFz_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFz: // global
           I64[Sp] = block_caPFB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaPJy; else goto caPFC;
       uaPJy: // global
           call _caPFB(R1) args: 0, res: 0, upd: 0;
       caPFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPFB() //  [R1]
         { info_tbl: [(caPFB,
                       label: block_caPFB_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFB: // global
           I64[Sp] = block_caPFG_info;
           _saLZI::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saLZI::P64;
           if (R1 & 7 != 0) goto uaPJz; else goto caPFH;
       uaPJz: // global
           call _caPFG(R1) args: 0, res: 0, upd: 0;
       caPFH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPFG() //  [R1]
         { info_tbl: [(caPFG,
                       label: block_caPFG_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPFG: // global
           if (R1 & 7 == 1) goto caPI7; else goto caPIn;
       caPI7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPIa; else goto caPI9;
       caPIa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPI9: // global
           I64[Hp - 16] = sat_saLZO_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caPI3_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caPIn: // global
           I64[Sp + 8] = block_caPIl_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaPJA; else goto caPIo;
       uaPJA: // global
           call _caPIl(R1) args: 0, res: 0, upd: 0;
       caPIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPI3() //  []
         { info_tbl: [(caPI3,
                       label: block_caPI3_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPI3: // global
           I64[Sp] = block_caPI5_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaPJH; else goto caPIc;
       uaPJH: // global
           call _caPI5(R1) args: 0, res: 0, upd: 0;
       caPIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPI5() //  [R1]
         { info_tbl: [(caPI5,
                       label: block_caPI5_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPI5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPIi; else goto caPIh;
       caPIi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPIh: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 _caPIl() //  [R1]
         { info_tbl: [(caPIl,
                       label: block_caPIl_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPIl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPIu; else goto caPIt;
       caPIu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPIt: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 _caPCT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPCT: // global
           Hp = Hp + 64;
           _saLYF::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caPHp; else goto caPHo;
       caPHp: // global
           HpAlloc = 64;
           I64[Sp - 8] = block_caPCS_info;
           R1 = _saLYF::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPHo: // global
           I64[Hp - 56] = sat_saLYU_info;
           P64[Hp - 48] = P64[Sp];
           P64[Hp - 40] = _saLYF::P64;
           I64[Hp - 32] = sat_saLYP_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPCS() //  [R1]
         { info_tbl: [(caPCS,
                       label: block_caPCS_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPCS: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caPCT() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.threadWaitReadSTM1_entry() //  [R2, R3]
         { info_tbl: [(caPJR,
                       label: GHC.Event.Thread.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPJR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPJS; else goto caPJT;
       caPJS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPJT: // global
           I64[Sp - 24] = block_caPvg_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caPvg() //  [R1]
         { info_tbl: [(caPvg,
                       label: block_caPvg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPvg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caPJW; else goto caPJV;
       caPJW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPJV: // global
           I64[Hp - 16] = io_saLVx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caPvi::P64 = Hp - 15;
           if (R1 == 0) goto caPJQ; else goto caPJP;
       caPJQ: // global
           R1 = _caPvi::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caPJP: // global
           R1 = _caPvi::P64;
           Sp = Sp + 24;
           call io_saLVx_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.543182213 UTC

[section ""data" . threadWaitReadSTM2_raLJN_closure" {
     threadWaitReadSTM2_raLJN_closure:
         const threadWaitReadSTM2_raLJN_info;
         const 0;
 },
 threadWaitReadSTM2_raLJN_entry() //  [R2]
         { info_tbl: [(caPS6,
                       label: threadWaitReadSTM2_raLJN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPS6: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.546964411 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM_closure" {
     GHC.Event.Thread.threadWaitReadSTM_closure:
         const GHC.Event.Thread.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caPSh,
                       label: GHC.Event.Thread.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPSh: // global
           R2 = R2;
           call threadWaitReadSTM2_raLJN_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.550952319 UTC

[section ""data" . threadWaitWriteSTM1_raLJO_closure" {
     threadWaitWriteSTM1_raLJO_closure:
         const threadWaitWriteSTM1_raLJO_info;
         const 0;
 },
 threadWaitWriteSTM1_raLJO_entry() //  [R2]
         { info_tbl: [(caPSs,
                       label: threadWaitWriteSTM1_raLJO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPSs: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.554481947 UTC

[section ""data" . GHC.Event.Thread.threadWaitWriteSTM_closure" {
     GHC.Event.Thread.threadWaitWriteSTM_closure:
         const GHC.Event.Thread.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caPSD,
                       label: GHC.Event.Thread.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPSD: // global
           R2 = R2;
           call threadWaitWriteSTM1_raLJO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.557771734 UTC

[section ""cstring" . lvl25_raLJP_bytes" {
     lvl25_raLJP_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.559689697 UTC

[section ""data" . lvl26_raLJQ_closure" {
     lvl26_raLJQ_closure:
         const lvl26_raLJQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_raLJQ_entry() //  [R1]
         { info_tbl: [(caPSR,
                       label: lvl26_raLJQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPSR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPSS; else goto caPST;
       caPSS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPST: // global
           (_caPSO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caPSO::I64 == 0) goto caPSQ; else goto caPSP;
       caPSQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caPSP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caPSO::I64;
           R2 = lvl25_raLJP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.564092221 UTC

[section ""data" . lvl27_raLJR_closure" {
     lvl27_raLJR_closure:
         const lvl27_raLJR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_raLJR_entry() //  [R1]
         { info_tbl: [(caPT7,
                       label: lvl27_raLJR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPT7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPT8; else goto caPT9;
       caPT8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPT9: // global
           (_caPT4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caPT4::I64 == 0) goto caPT6; else goto caPT5;
       caPT6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caPT5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caPT4::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl26_raLJQ_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.568202765 UTC

[section ""data" . lvl28_raLJS_closure" {
     lvl28_raLJS_closure:
         const lvl28_raLJS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_raLJS_entry() //  [R1]
         { info_tbl: [(caPTn,
                       label: lvl28_raLJS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caPTo; else goto caPTp;
       caPTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caPTp: // global
           (_caPTk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caPTk::I64 == 0) goto caPTm; else goto caPTl;
       caPTm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caPTl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caPTk::I64;
           R2 = lvl27_raLJR_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.583428537 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead1_closure" {
     GHC.Event.Thread.threadWaitRead1_closure:
         const GHC.Event.Thread.threadWaitRead1_info;
         const 0;
 },
 lvl31_saM1r_entry() //  [R1, R2, R3]
         { info_tbl: [(caPVc,
                       label: lvl31_saM1r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPVd; else goto caPVe;
       caPVd: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPVe: // global
           I64[Sp - 8] = block_caPVa_info;
           R2 = R3;
           R1 = P64[R1 + 5];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPVa() //  []
         { info_tbl: [(caPVa,
                       label: block_caPVa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saM25_entry() //  [R1, R2]
         { info_tbl: [(caPWl,
                       label: $wgo_saM25_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPWm; else goto caPWn;
       caPWm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPWn: // global
           I64[Sp - 24] = block_caPWe_info;
           _saM25::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saM18::I64;
           P64[Sp - 8] = _saM25::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaPWK; else goto caPWf;
       uaPWK: // global
           call _caPWe(R1) args: 0, res: 0, upd: 0;
       caPWf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPWe() //  [R1]
         { info_tbl: [(caPWe,
                       label: block_caPWe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWe: // global
           if (R1 & 7 == 1) goto caPWi; else goto caPWj;
       caPWi: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPWj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPWv; else goto caPWu;
       caPWv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPWu: // global
           _saM29::P64 = P64[R1 + 6];
           _saM2a::P64 = P64[R1 + 14];
           _saM28::I64 = I64[R1 + 22];
           if (_saM28::I64 == I64[Sp + 8]) goto caPWJ; else goto caPWD;
       caPWJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saM29::P64;
           R3 = _saM2a::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPWD: // global
           Hp = Hp - 16;
           I64[Sp] = block_caPWz_info;
           R2 = _saM2a::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saM29::P64;
           I64[Sp + 16] = _saM28::I64;
           call $wgo_saM25_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPWz() //  [R1, R2, R3]
         { info_tbl: [(caPWz,
                       label: block_caPWz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caPWG; else goto caPWF;
       caPWG: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caPWF: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saM2U_entry() //  [R1, R2]
         { info_tbl: [(caPXv,
                       label: $wgo_saM2U_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPXv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caPXw; else goto caPXx;
       caPXw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPXx: // global
           I64[Sp - 24] = block_caPXo_info;
           _saM2U::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saM18::I64;
           P64[Sp - 8] = _saM2U::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaPXU; else goto caPXp;
       uaPXU: // global
           call _caPXo(R1) args: 0, res: 0, upd: 0;
       caPXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPXo() //  [R1]
         { info_tbl: [(caPXo,
                       label: block_caPXo_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPXo: // global
           if (R1 & 7 == 1) goto caPXs; else goto caPXt;
       caPXs: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPXt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPXF; else goto caPXE;
       caPXF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPXE: // global
           _saM2Y::P64 = P64[R1 + 6];
           _saM2Z::P64 = P64[R1 + 14];
           _saM2X::I64 = I64[R1 + 22];
           if (_saM2X::I64 == I64[Sp + 8]) goto caPXT; else goto caPXN;
       caPXT: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saM2Y::P64;
           R3 = _saM2Z::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caPXN: // global
           Hp = Hp - 16;
           I64[Sp] = block_caPXJ_info;
           R2 = _saM2Z::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saM2Y::P64;
           I64[Sp + 16] = _saM2X::I64;
           call $wgo_saM2U_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPXJ() //  [R1, R2, R3]
         { info_tbl: [(caPXJ,
                       label: block_caPXJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPXJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caPXQ; else goto caPXP;
       caPXQ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caPXP: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saM1o_entry() //  [R1, R2]
         { info_tbl: [(caPXZ,
                       label: $wio_saM1o_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPXZ: // global
           _saM1p::P64 = R2;
           _saM1o::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caPY0; else goto caPY1;
       caPY1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caPY3; else goto caPY2;
       caPY3: // global
           HpAlloc = 80;
           goto caPY0;
       caPY0: // global
           R2 = _saM1p::P64;
           R1 = _saM1o::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPY2: // global
           _saM0z::P64 = P64[_saM1o::P64 + 6];
           _saM0Z::P64 = P64[_saM1o::P64 + 14];
           _saM11::P64 = P64[_saM1o::P64 + 22];
           _saM12::P64 = P64[_saM1o::P64 + 30];
           _saM17::P64 = P64[_saM1o::P64 + 38];
           _saM16::I64 = I64[_saM1o::P64 + 46];
           _saM18::I64 = I64[_saM1o::P64 + 54];
           _saM1a::I64 = I64[_saM1o::P64 + 62];
           I64[Hp - 72] = lvl31_saM1r_info;
           P64[Hp - 64] = _saM0z::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saM18::I64;
           I64[Hp - 32] = _saM16::I64;
           I64[Hp - 24] = _saM1a::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caPUS_info;
           R5 = _saM1p::P64;
           R4 = Hp - 14;
           R3 = _saM18::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saM0Z::P64;
           P64[Sp - 48] = _saM11::P64;
           P64[Sp - 40] = _saM12::P64;
           P64[Sp - 32] = _saM17::P64;
           I64[Sp - 24] = _saM18::I64;
           I64[Sp - 16] = _saM1a::I64;
           P64[Sp - 8] = _saM1p::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPUS() //  [R1]
         { info_tbl: [(caPUS,
                       label: block_caPUS_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPUS: // global
           I64[Sp - 8] = block_caPUW_info;
           _saM1A::P64 = R1;
           R1 = R1;
           P64[Sp] = _saM1A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQ0n; else goto caPUX;
       uaQ0n: // global
           call _caPUW(R1) args: 0, res: 0, upd: 0;
       caPUX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPUW() //  [R1]
         { info_tbl: [(caPUW,
                       label: block_caPUW_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPUW: // global
           if (R1 & 7 == 1) goto caPXW; else goto caPXX;
       caPXW: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saM1B() args: 0, res: 0, upd: 0;
       caPXX: // global
           I64[Sp] = block_caPV2_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPV2() //  [R1]
         { info_tbl: [(caPV2,
                       label: block_caPV2_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPV2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPZW; else goto caPZV;
       caPZW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPZV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saM1B() args: 0, res: 0, upd: 0;
     }
 },
 _saM1B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saM1B: // global
           _saM1D::P64 = P64[Sp];
           I64[Sp] = block_caPVj_info;
           R1 = _saM1D::P64;
           if (R1 & 7 != 0) goto uaQ0I; else goto caPVk;
       uaQ0I: // global
           call _caPVj(R1) args: 0, res: 0, upd: 0;
       caPVk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPVj() //  [R1]
         { info_tbl: [(caPVj,
                       label: block_caPVj_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVj: // global
           _saM1G::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saM1H::I64 = _saM1G::I64 & 8;
           if (_saM1H::I64 != 0) goto uaQ0g; else goto uaQ0f;
       uaQ0g: // global
           I64[Sp] = _saM1H::I64;
           I64[Sp + 40] = _saM1G::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caPVv() args: 0, res: 0, upd: 0;
       uaQ0f: // global
           I64[Sp + 32] = _saM1H::I64;
           I64[Sp + 64] = _saM1G::I64;
           Sp = Sp + 16;
           call _caPWN() args: 0, res: 0, upd: 0;
     }
 },
 _caPVv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caPYb; else goto caPYa;
       caPYb: // global
           HpAlloc = 32;
           _saM1H::I64 = I64[Sp];
           I64[Sp] = block_caPVu_info;
           R1 = _saM1H::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPYa: // global
           _saM1G::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saM1G::I64) goto caPYd; else goto caPYe;
       caPYd: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caPYe: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saM1G::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caPVJ_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caPVu() //  [R1]
         { info_tbl: [(caPVu,
                       label: block_caPVu_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVu: // global
           I64[Sp] = R1;
           call _caPVv() args: 0, res: 0, upd: 0;
     }
 },
 _caPVJ() //  [R1]
         { info_tbl: [(caPVJ,
                       label: block_caPVJ_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVJ: // global
           I64[Sp] = block_caPVL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQ0t; else goto caPVM;
       uaQ0t: // global
           call _caPVL(R1) args: 0, res: 0, upd: 0;
       caPVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPVL() //  [R1]
         { info_tbl: [(caPVL,
                       label: block_caPVL_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVL: // global
           if (R1 & 7 == 1) goto caPYi; else goto caPZ0;
       caPYi: // global
           I64[Sp + 40] = block_caPVQ_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaQ0u; else goto caPVR;
       uaQ0u: // global
           call _caPVQ(R1) args: 0, res: 0, upd: 0;
       caPVR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPZ0: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPVQ() //  [R1]
         { info_tbl: [(caPVQ,
                       label: block_caPVQ_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVQ: // global
           _saM1p::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caPYl; else goto caPYU;
       caPYl: // global
           I64[Sp] = block_caPVV_info;
           R1 = P64[_saM1p::P64 + 8];
           if (R1 & 7 != 0) goto uaQ0v; else goto caPVW;
       uaQ0v: // global
           call _caPVV(R1) args: 0, res: 0, upd: 0;
       caPVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPYU: // global
           I64[Sp + 24] = block_caPYS_info;
           R5 = _saM1p::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPVV() //  [R1]
         { info_tbl: [(caPVV,
                       label: block_caPVV_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPVV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPYo; else goto caPYn;
       caPYo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPYn: // global
           _saM18::I64 = I64[Sp + 8];
           _saM1W::P64 = P64[R1 + 7];
           _saM1Y::P64 = P64[R1 + 15];
           _saM1X::I64 = I64[R1 + 23];
           _saM1Z::I64 = _saM18::I64 & (I64[_saM1W::P64 + 8] - 1);
           _saM24::P64 = P64[(_saM1W::P64 + 24) + (_saM1Z::I64 << 3)];
           I64[Hp - 8] = $wgo_saM25_info;
           I64[Hp] = _saM18::I64;
           I64[Sp - 8] = block_caPYp_info;
           R2 = _saM24::P64;
           R1 = Hp - 7;
           I64[Sp] = _saM1Z::I64;
           P64[Sp + 8] = _saM1Y::P64;
           I64[Sp + 16] = _saM1X::I64;
           P64[Sp + 24] = _saM1W::P64;
           Sp = Sp - 8;
           call $wgo_saM25_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPYp() //  [R1, R2, R3]
         { info_tbl: [(caPYp,
                       label: block_caPYp_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPYp: // global
           I64[Sp - 16] = block_caPYr_info;
           _saM2j::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saM2j::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQ0A; else goto caPYt;
       uaQ0A: // global
           call _caPYr(R1) args: 0, res: 0, upd: 0;
       caPYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPYr() //  [R1]
         { info_tbl: [(caPYr,
                       label: block_caPYr_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPYr: // global
           if (R1 & 7 == 1) goto uaQ0i; else goto caPYE;
       uaQ0i: // global
           Sp = Sp + 56;
           call _caPZB() args: 0, res: 0, upd: 0;
       caPYE: // global
           _saM1W::P64 = P64[Sp + 48];
           _saM1Z::I64 = I64[Sp + 24];
           _saM2j::P64 = P64[Sp + 16];
           _saM2l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saM1W::P64 + 24) + (_saM1Z::I64 << 3)] = _saM2l::P64;
           I64[_saM1W::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saM1W::P64 + 24) + ((I64[_saM1W::P64 + 8] << 3) + (_saM1Z::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caPYC_info;
           R1 = _saM2j::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaQ0B; else goto caPYF;
       uaQ0B: // global
           call _caPYC(R1) args: 0, res: 0, upd: 0;
       caPYF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPYC() //  [R1]
         { info_tbl: [(caPYC,
                       label: block_caPYC_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPYC: // global
           if (R1 & 7 == 1) goto uaQ0j; else goto caPYP;
       uaQ0j: // global
           Sp = Sp + 32;
           call _caPZB() args: 0, res: 0, upd: 0;
       caPYP: // global
           _saM1X::I64 = I64[Sp + 16];
           _saM1Y::P64 = P64[Sp + 8];
           I64[_saM1X::I64] = I64[_saM1X::I64] - 1;
           call MO_Touch(_saM1Y::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPYS() //  []
         { info_tbl: [(caPYS,
                       label: block_caPYS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPYS: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPWN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPZ4; else goto caPZ3;
       caPZ4: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caPWM_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caPZ3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caPWT_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPWM() //  [R1]
         { info_tbl: [(caPWM,
                       label: block_caPWM_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWM: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caPWN() args: 0, res: 0, upd: 0;
     }
 },
 _caPWT() //  [R1]
         { info_tbl: [(caPWT,
                       label: block_caPWT_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWT: // global
           I64[Sp] = block_caPWV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQ0x; else goto caPWW;
       uaQ0x: // global
           call _caPWV(R1) args: 0, res: 0, upd: 0;
       caPWW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPWV() //  [R1]
         { info_tbl: [(caPWV,
                       label: block_caPWV_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPWV: // global
           if (R1 & 7 == 1) goto caPZ8; else goto caPZQ;
       caPZ8: // global
           I64[Sp + 40] = block_caPX0_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaQ0y; else goto caPX1;
       uaQ0y: // global
           call _caPX0(R1) args: 0, res: 0, upd: 0;
       caPX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPZQ: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPX0() //  [R1]
         { info_tbl: [(caPX0,
                       label: block_caPX0_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPX0: // global
           _saM1p::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caPZb; else goto caPZK;
       caPZb: // global
           I64[Sp] = block_caPX5_info;
           R1 = P64[_saM1p::P64 + 8];
           if (R1 & 7 != 0) goto uaQ0z; else goto caPX6;
       uaQ0z: // global
           call _caPX5(R1) args: 0, res: 0, upd: 0;
       caPX6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPZK: // global
           I64[Sp + 24] = block_caPZI_info;
           R5 = _saM1p::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caPX5() //  [R1]
         { info_tbl: [(caPX5,
                       label: block_caPX5_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPX5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caPZe; else goto caPZd;
       caPZe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caPZd: // global
           _saM18::I64 = I64[Sp + 8];
           _saM2L::P64 = P64[R1 + 7];
           _saM2N::P64 = P64[R1 + 15];
           _saM2M::I64 = I64[R1 + 23];
           _saM2O::I64 = _saM18::I64 & (I64[_saM2L::P64 + 8] - 1);
           _saM2T::P64 = P64[(_saM2L::P64 + 24) + (_saM2O::I64 << 3)];
           I64[Hp - 8] = $wgo_saM2U_info;
           I64[Hp] = _saM18::I64;
           I64[Sp - 8] = block_caPZf_info;
           R2 = _saM2T::P64;
           R1 = Hp - 7;
           I64[Sp] = _saM2O::I64;
           P64[Sp + 8] = _saM2N::P64;
           I64[Sp + 16] = _saM2M::I64;
           P64[Sp + 24] = _saM2L::P64;
           Sp = Sp - 8;
           call $wgo_saM2U_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPZf() //  [R1, R2, R3]
         { info_tbl: [(caPZf,
                       label: block_caPZf_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPZf: // global
           I64[Sp - 16] = block_caPZh_info;
           _saM38::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saM38::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQ0E; else goto caPZj;
       uaQ0E: // global
           call _caPZh(R1) args: 0, res: 0, upd: 0;
       caPZj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPZh() //  [R1]
         { info_tbl: [(caPZh,
                       label: block_caPZh_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPZh: // global
           if (R1 & 7 == 1) goto uaQ0l; else goto caPZu;
       uaQ0l: // global
           Sp = Sp + 56;
           call _caPZB() args: 0, res: 0, upd: 0;
       caPZu: // global
           _saM2L::P64 = P64[Sp + 48];
           _saM2O::I64 = I64[Sp + 24];
           _saM38::P64 = P64[Sp + 16];
           _saM3a::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saM2L::P64 + 24) + (_saM2O::I64 << 3)] = _saM3a::P64;
           I64[_saM2L::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saM2L::P64 + 24) + ((I64[_saM2L::P64 + 8] << 3) + (_saM2O::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caPZs_info;
           R1 = _saM38::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaQ0F; else goto caPZv;
       uaQ0F: // global
           call _caPZs(R1) args: 0, res: 0, upd: 0;
       caPZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPZs() //  [R1]
         { info_tbl: [(caPZs,
                       label: block_caPZs_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPZs: // global
           if (R1 & 7 == 1) goto uaQ0m; else goto caPZF;
       uaQ0m: // global
           Sp = Sp + 32;
           call _caPZB() args: 0, res: 0, upd: 0;
       caPZF: // global
           _saM2M::I64 = I64[Sp + 16];
           _saM2N::P64 = P64[Sp + 8];
           I64[_saM2M::I64] = I64[_saM2M::I64] - 1;
           call MO_Touch(_saM2N::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPZB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPZB: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caPZI() //  []
         { info_tbl: [(caPZI,
                       label: block_caPZI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPZI: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saM3t_entry() //  [R1, R2]
         { info_tbl: [(caQ0R,
                       label: io1_saM3t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ0R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQ0S; else goto caQ0T;
       caQ0S: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQ0T: // global
           I64[Sp - 16] = block_caQ0O_info;
           _saM1o::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saM1o::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQ0X; else goto caQ0P;
       uaQ0X: // global
           call _caQ0O(R1) args: 0, res: 0, upd: 0;
       caQ0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ0O() //  [R1]
         { info_tbl: [(caQ0O,
                       label: block_caQ0O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ0O: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saM1o_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3I_entry() //  [R1, R2]
         { info_tbl: [(caQ1a,
                       label: sat_saM3I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQ1b; else goto caQ1c;
       caQ1b: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQ1c: // global
           I64[Sp - 16] = block_caQ18_info;
           R3 = P64[R1 + 14];
           _saM3D::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM3D::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQ18() //  []
         { info_tbl: [(caQ18,
                       label: block_caQ18_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ18: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3C_entry() //  [R1]
         { info_tbl: [(caQ1j,
                       label: sat_saM3C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1j: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3Y_entry() //  [R1, R2]
         { info_tbl: [(caQ1x,
                       label: sat_saM3Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQ1y; else goto caQ1z;
       caQ1y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQ1z: // global
           I64[Sp - 16] = block_caQ1v_info;
           _saM3V::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM3V::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ1v() //  []
         { info_tbl: [(caQ1v,
                       label: block_caQ1v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1v: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3T_entry() //  [R1]
         { info_tbl: [(caQ1G,
                       label: sat_saM3T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1G: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM3U_entry() //  [R1]
         { info_tbl: [(caQ1O,
                       label: sat_saM3U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1O: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4l_entry() //  [R1, R2]
         { info_tbl: [(caQ26,
                       label: sat_saM4l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ26: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQ27; else goto caQ28;
       caQ27: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQ28: // global
           I64[Sp - 16] = block_caQ24_info;
           _saM4i::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM4i::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ24() //  []
         { info_tbl: [(caQ24,
                       label: block_caQ24_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ24: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4g_entry() //  [R1]
         { info_tbl: [(caQ2f,
                       label: sat_saM4g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2f: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4h_entry() //  [R1]
         { info_tbl: [(caQ2n,
                       label: sat_saM4h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2n: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4q_entry() //  [R1]
         { info_tbl: [(caQ2u,
                       label: sat_saM4q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caQ2v; else goto caQ2w;
       caQ2v: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQ2w: // global
           I64[Sp - 24] = block_caQ1X_info;
           _saM1n::P64 = P64[R1 + 7];
           _saM3t::P64 = P64[R1 + 15];
           R1 = _saM1n::P64;
           P64[Sp - 16] = _saM1n::P64;
           P64[Sp - 8] = _saM3t::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ1X() //  [R1]
         { info_tbl: [(caQ1X,
                       label: block_caQ1X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1X: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caQ2z; else goto caQ2y;
       caQ2z: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ2y: // global
           I64[Hp - 56] = sat_saM4l_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM4g_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM4h_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caQ2q_info;
           R2 = Hp - 54;
           _saM4f::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saM4f::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ2q() //  [R1]
         { info_tbl: [(caQ2q,
                       label: block_caQ2q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2q: // global
           _saM1n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caQ2s_info;
           R2 = P64[Sp + 16];
           _saM4o::P64 = R1;
           R1 = _saM1n::P64;
           P64[Sp + 16] = _saM4o::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ2s() //  []
         { info_tbl: [(caQ2s,
                       label: block_caQ2s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4L_entry() //  [R1, R2]
         { info_tbl: [(caQ2M,
                       label: sat_saM4L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQ2N; else goto caQ2O;
       caQ2N: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQ2O: // global
           I64[Sp - 16] = block_caQ2K_info;
           _saM4I::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saM4I::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ2K() //  []
         { info_tbl: [(caQ2K,
                       label: block_caQ2K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2K: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4G_entry() //  [R1]
         { info_tbl: [(caQ2V,
                       label: sat_saM4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2V: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saM3t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM4H_entry() //  [R1]
         { info_tbl: [(caQ33,
                       label: sat_saM4H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ33: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saM0v_entry() //  [R1]
         { info_tbl: [(caQ3a,
                       label: io_saM0v_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ3a: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caQ3b; else goto caQ3c;
       caQ3b: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQ3c: // global
           I64[Sp - 24] = block_caPTI_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caPTI() //  [R1]
         { info_tbl: [(caPTI,
                       label: block_caPTI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTI: // global
           I64[Sp - 8] = block_caPTK_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caPTK() //  [R1]
         { info_tbl: [(caPTK,
                       label: block_caPTK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTK: // global
           I64[Sp] = block_caPTM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQ6s; else goto caPTN;
       uaQ6s: // global
           call _caPTM(R1) args: 0, res: 0, upd: 0;
       caPTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPTM() //  [R1]
         { info_tbl: [(caPTM,
                       label: block_caPTM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTM: // global
           if (R1 & 7 == 1) goto caQ37; else goto caQ38;
       caQ37: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caQ38: // global
           I64[Sp] = block_caPTS_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaQ6t; else goto caPTT;
       uaQ6t: // global
           call _caPTS(R1) args: 0, res: 0, upd: 0;
       caPTT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPTS() //  [R1]
         { info_tbl: [(caPTS,
                       label: block_caPTS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTS: // global
           I64[Sp - 40] = block_caPTX_info;
           _saM0G::P64 = R1;
           _saM0H::P64 = P64[R1 + 7];
           _saM0J::P64 = P64[R1 + 23];
           _saM0L::P64 = P64[R1 + 31];
           _saM0N::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saM0H::P64;
           P64[Sp - 24] = _saM0J::P64;
           P64[Sp - 16] = _saM0L::P64;
           P64[Sp - 8] = _saM0N::P64;
           P64[Sp] = _saM0G::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaQ6u; else goto caPTY;
       uaQ6u: // global
           call _caPTX(R1) args: 0, res: 0, upd: 0;
       caPTY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPTX() //  [R1]
         { info_tbl: [(caPTX,
                       label: block_caPTX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTX: // global
           I64[Sp - 8] = block_caPU2_info;
           _saM0U::P64 = R1;
           _saM0V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM0V::I64;
           P64[Sp + 16] = _saM0U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQ6v; else goto caPU3;
       uaQ6v: // global
           call _caPU2(R1) args: 0, res: 0, upd: 0;
       caPU3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPU2() //  [R1]
         { info_tbl: [(caPU2,
                       label: block_caPU2_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPU2: // global
           I64[Sp - 8] = block_caPU7_info;
           _saM0W::P64 = R1;
           _saM0X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM0X::I64;
           P64[Sp + 16] = _saM0W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQ6w; else goto caPU8;
       uaQ6w: // global
           call _caPU7(R1) args: 0, res: 0, upd: 0;
       caPU8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPU7() //  [R1]
         { info_tbl: [(caPU7,
                       label: block_caPU7_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPU7: // global
           _saM0q::P64 = P64[Sp + 80];
           _saM0Z::P64 = P64[R1 + 7];
           _saM11::P64 = P64[R1 + 23];
           _saM12::P64 = P64[R1 + 31];
           (_saM16::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caPUe_info;
           R1 = _saM0q::P64;
           I64[Sp - 8] = _saM16::I64;
           P64[Sp] = _saM12::P64;
           P64[Sp + 48] = _saM11::P64;
           P64[Sp + 80] = _saM0Z::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQ6x; else goto caPUf;
       uaQ6x: // global
           call _caPUe(R1) args: 0, res: 0, upd: 0;
       caPUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPUe() //  [R1]
         { info_tbl: [(caPUe,
                       label: block_caPUe_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPUe: // global
           I64[Sp - 8] = block_caPUj_info;
           _saM17::P64 = R1;
           _saM18::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saM18::I64;
           P64[Sp + 88] = _saM17::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQ6y; else goto caPUk;
       uaQ6y: // global
           call _caPUj(R1) args: 0, res: 0, upd: 0;
       caPUk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPUj() //  [R1]
         { info_tbl: [(caPUj,
                       label: block_caPUj_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPUj: // global
           I64[Sp - 16] = block_caPUo_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caPUo() //  [R1]
         { info_tbl: [(caPUo,
                       label: block_caPUo_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPUo: // global
           _saM0U::P64 = P64[Sp + 72];
           _saM0V::I64 = I64[Sp + 56];
           _saM0W::P64 = P64[Sp + 64];
           _saM1e::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saM0V::I64,
                            _saM1e::I64)) goto caQ3s; else goto caQ6a;
       caQ6a: // global
           if (%MO_S_Gt_W64(_saM1e::I64,
                            I64[Sp + 48])) goto caQ3s; else goto caQ3t;
       caQ3s: // global
           R4 = _saM1e::I64;
           R3 = _saM0U::P64;
           R2 = _saM0W::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caQ3t: // global
           _saM1l::P64 = P64[P64[Sp + 80] + ((_saM1e::I64 - _saM0V::I64 << 3) + 24)];
           I64[Sp] = block_caPUE_info;
           _saM1d::I64 = R1;
           R1 = _saM1l::P64;
           I64[Sp + 80] = _saM1d::I64;
           if (R1 & 7 != 0) goto uaQ6z; else goto caPUF;
       uaQ6z: // global
           call _caPUE(R1) args: 0, res: 0, upd: 0;
       caPUF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPUE() //  [R1]
         { info_tbl: [(caPUE,
                       label: block_caPUE_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPUE: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caQ3w; else goto caQ3v;
       caQ3w: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ3v: // global
           _saM1n::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saM1o_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saM3t_info;
           P64[Hp - 24] = Hp - 102;
           _caQ0J::P64 = Hp - 30;
           _saM3P::I64 = I64[Sp + 80];
           if (_saM3P::I64 != 0) goto uaQ6k; else goto caQ4N;
       uaQ6k: // global
           if (_saM3P::I64 != 1) goto caQ44; else goto caQ5u;
       caQ44: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caQ1o_info;
           R1 = _saM1n::P64;
           P64[Sp + 112] = _saM1n::P64;
           P64[Sp + 120] = _caQ0J::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caQ5u: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caQ2D_info;
           R1 = _saM1n::P64;
           P64[Sp + 112] = _saM1n::P64;
           P64[Sp + 120] = _caQ0J::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caQ4N: // global
           I64[Hp - 16] = sat_saM4q_info;
           P64[Hp - 8] = _saM1n::P64;
           P64[Hp] = _caQ0J::P64;
           I64[Sp + 8] = block_caQ4K_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ1o() //  [R1]
         { info_tbl: [(caQ1o,
                       label: block_caQ1o_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ1o: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caQ47; else goto caQ46;
       caQ47: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ46: // global
           I64[Hp - 56] = sat_saM3Y_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM3T_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM3U_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caQ3Y_info;
           R2 = Hp - 54;
           _saM3S::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saM3S::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ3Y() //  [R1]
         { info_tbl: [(caQ3Y,
                       label: block_caQ3Y_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ3Y: // global
           I64[Sp] = block_caQ40_info;
           R2 = P64[Sp + 112];
           _saM41::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM41::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ40() //  []
         { info_tbl: [(caQ40,
                       label: block_caQ40_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ40: // global
           I64[Sp] = block_caQ42_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaQ6C; else goto caQ4a;
       uaQ6C: // global
           call _caQ42(R1) args: 0, res: 0, upd: 0;
       caQ4a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ42() //  [R1]
         { info_tbl: [(caQ42,
                       label: block_caQ42_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ42: // global
           I64[Sp] = block_caQ4e_info;
           _saM44::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM44::P64;
           if (R1 & 7 != 0) goto uaQ6D; else goto caQ4g;
       uaQ6D: // global
           call _caQ4e(R1) args: 0, res: 0, upd: 0;
       caQ4g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ4e() //  [R1]
         { info_tbl: [(caQ4e,
                       label: block_caQ4e_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4e: // global
           if (R1 & 7 == 1) goto caQ4p; else goto caQ4C;
       caQ4p: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caQ4k_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caQ4C: // global
           I64[Sp + 8] = block_caQ4A_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaQ6E; else goto caQ4D;
       uaQ6E: // global
           call _caQ4A(R1) args: 0, res: 0, upd: 0;
       caQ4D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ4k() //  []
         { info_tbl: [(caQ4k,
                       label: block_caQ4k_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4k: // global
           I64[Sp] = block_caQ4m_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaQ6F; else goto caQ4r;
       uaQ6F: // global
           call _caQ4m(R1) args: 0, res: 0, upd: 0;
       caQ4r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ4m() //  [R1]
         { info_tbl: [(caQ4m,
                       label: block_caQ4m_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ4x; else goto caQ4w;
       caQ4x: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ4w: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ4A() //  [R1]
         { info_tbl: [(caQ4A,
                       label: block_caQ4A_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ4J; else goto caQ4I;
       caQ4J: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ4I: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ2D() //  [R1]
         { info_tbl: [(caQ2D,
                       label: block_caQ2D_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ2D: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caQ5x; else goto caQ5w;
       caQ5x: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ5w: // global
           I64[Hp - 56] = sat_saM4L_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saM4G_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saM4H_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caQ5p_info;
           R2 = Hp - 54;
           _saM4F::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saM4F::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ5p() //  [R1]
         { info_tbl: [(caQ5p,
                       label: block_caQ5p_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5p: // global
           I64[Sp] = block_caQ5r_info;
           R2 = P64[Sp + 112];
           _saM4O::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saM4O::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ5r() //  []
         { info_tbl: [(caQ5r,
                       label: block_caQ5r_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5r: // global
           I64[Sp] = block_caQ5t_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaQ6O; else goto caQ5A;
       uaQ6O: // global
           call _caQ5t(R1) args: 0, res: 0, upd: 0;
       caQ5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ5t() //  [R1]
         { info_tbl: [(caQ5t,
                       label: block_caQ5t_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5t: // global
           I64[Sp] = block_caQ5E_info;
           _saM4R::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM4R::P64;
           if (R1 & 7 != 0) goto uaQ6P; else goto caQ5G;
       uaQ6P: // global
           call _caQ5E(R1) args: 0, res: 0, upd: 0;
       caQ5G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ5E() //  [R1]
         { info_tbl: [(caQ5E,
                       label: block_caQ5E_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5E: // global
           if (R1 & 7 == 1) goto caQ5P; else goto caQ62;
       caQ5P: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caQ5K_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caQ62: // global
           I64[Sp + 8] = block_caQ60_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaQ6Q; else goto caQ63;
       uaQ6Q: // global
           call _caQ60(R1) args: 0, res: 0, upd: 0;
       caQ63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ5K() //  []
         { info_tbl: [(caQ5K,
                       label: block_caQ5K_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5K: // global
           I64[Sp] = block_caQ5M_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaQ6R; else goto caQ5R;
       uaQ6R: // global
           call _caQ5M(R1) args: 0, res: 0, upd: 0;
       caQ5R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ5M() //  [R1]
         { info_tbl: [(caQ5M,
                       label: block_caQ5M_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ5X; else goto caQ5W;
       caQ5X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ5W: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ60() //  [R1]
         { info_tbl: [(caQ60,
                       label: block_caQ60_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ60: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ69; else goto caQ68;
       caQ69: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ68: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ4K() //  [R1]
         { info_tbl: [(caQ4K,
                       label: block_caQ4K_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4K: // global
           I64[Sp] = block_caQ4M_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQ6I; else goto caQ4P;
       uaQ6I: // global
           call _caQ4M(R1) args: 0, res: 0, upd: 0;
       caQ4P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ4M() //  [R1]
         { info_tbl: [(caQ4M,
                       label: block_caQ4M_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4M: // global
           I64[Sp] = block_caQ4T_info;
           _saM4v::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saM4v::P64;
           if (R1 & 7 != 0) goto uaQ6J; else goto caQ4V;
       uaQ6J: // global
           call _caQ4T(R1) args: 0, res: 0, upd: 0;
       caQ4V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ4T() //  [R1]
         { info_tbl: [(caQ4T,
                       label: block_caQ4T_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4T: // global
           if (R1 & 7 == 1) goto caQ54; else goto caQ5h;
       caQ54: // global
           _saM19::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caQ4Z_info;
           R2 = _saM19::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caQ5h: // global
           I64[Sp + 8] = block_caQ5f_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaQ6K; else goto caQ5i;
       uaQ6K: // global
           call _caQ5f(R1) args: 0, res: 0, upd: 0;
       caQ5i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ4Z() //  []
         { info_tbl: [(caQ4Z,
                       label: block_caQ4Z_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ4Z: // global
           I64[Sp] = block_caQ51_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaQ6L; else goto caQ56;
       uaQ6L: // global
           call _caQ51(R1) args: 0, res: 0, upd: 0;
       caQ56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ51() //  [R1]
         { info_tbl: [(caQ51,
                       label: block_caQ51_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ51: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ5c; else goto caQ5b;
       caQ5c: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ5b: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ5f() //  [R1]
         { info_tbl: [(caQ5f,
                       label: block_caQ5f_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ5f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ5o; else goto caQ5n;
       caQ5o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ5n: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ11() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ11: // global
           Hp = Hp + 40;
           _saM3A::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caQ3C; else goto caQ3B;
       caQ3C: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caQ10_info;
           R1 = _saM3A::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQ3B: // global
           I64[Hp - 32] = sat_saM3I_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = _saM3A::P64;
           I64[Hp - 8] = sat_saM3C_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_caQ3x_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ10() //  [R1]
         { info_tbl: [(caQ10,
                       label: block_caQ10_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ10: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caQ11() args: 0, res: 0, upd: 0;
     }
 },
 _caQ3x() //  [R1]
         { info_tbl: [(caQ3x,
                       label: block_caQ3x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ3x: // global
           I64[Sp] = block_caQ3z_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQ6B; else goto caQ3E;
       uaQ6B: // global
           call _caQ3z(R1) args: 0, res: 0, upd: 0;
       caQ3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ3z() //  [R1]
         { info_tbl: [(caQ3z,
                       label: block_caQ3z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ3z: // global
           if (I64[R1 + 7] & 4 == 0) goto caQ3U; else goto caQ3O;
       caQ3U: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caQ3O: // global
           R1 = lvl28_raLJS_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.threadWaitRead1_entry() //  [R2, R3]
         { info_tbl: [(caQ6Y,
                       label: GHC.Event.Thread.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ6Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caQ6Z; else goto caQ70;
       caQ6Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitRead1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caQ70: // global
           I64[Sp - 24] = block_caPTB_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caPTB() //  [R1]
         { info_tbl: [(caPTB,
                       label: block_caPTB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPTB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQ73; else goto caQ72;
       caQ73: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caQ72: // global
           I64[Hp - 16] = io_saM0v_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caPTD::P64 = Hp - 15;
           if (R1 == 0) goto caQ6X; else goto caQ6W;
       caQ6X: // global
           R1 = _caPTD::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caQ6W: // global
           R1 = _caPTD::P64;
           Sp = Sp + 24;
           call io_saM0v_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.764342195 UTC

[section ""data" . threadWaitWrite1_raLJT_closure" {
     threadWaitWrite1_raLJT_closure:
         const threadWaitWrite1_raLJT_info;
         const 0;
 },
 threadWaitWrite1_raLJT_entry() //  [R2]
         { info_tbl: [(caQex,
                       label: threadWaitWrite1_raLJT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQex: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.767793325 UTC

[section ""data" . GHC.Event.Thread.threadWaitWrite_closure" {
     GHC.Event.Thread.threadWaitWrite_closure:
         const GHC.Event.Thread.threadWaitWrite_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caQeI,
                       label: GHC.Event.Thread.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQeI: // global
           R2 = R2;
           call threadWaitWrite1_raLJT_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.771130673 UTC

[section ""data" . threadWaitRead2_raLJU_closure" {
     threadWaitRead2_raLJU_closure:
         const threadWaitRead2_raLJU_info;
         const 0;
 },
 threadWaitRead2_raLJU_entry() //  [R2]
         { info_tbl: [(caQeT,
                       label: threadWaitRead2_raLJU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQeT: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.775160706 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead_closure" {
     GHC.Event.Thread.threadWaitRead_closure:
         const GHC.Event.Thread.threadWaitRead_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caQf4,
                       label: GHC.Event.Thread.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQf4: // global
           R2 = R2;
           call threadWaitRead2_raLJU_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.778240966 UTC

[section ""cstring" . lvl29_raLJV_bytes" {
     lvl29_raLJV_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,48,52,58,53,45,49,55]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.780129142 UTC

[section ""data" . lvl30_raLJW_closure" {
     lvl30_raLJW_closure:
         const lvl30_raLJW_info;
         const 0;
 },
 lvl30_raLJW_entry() //  []
         { info_tbl: [(caQfi,
                       label: lvl30_raLJW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQfi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQfj; else goto caQfk;
       caQfj: // global
           R1 = lvl30_raLJW_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQfk: // global
           I64[Sp - 8] = block_caQfg_info;
           R2 = lvl29_raLJV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQfg() //  [R1]
         { info_tbl: [(caQfg,
                       label: block_caQfg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQfg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.786589041 UTC

[section ""data" . go_raLJX_closure" {
     go_raLJX_closure:
         const go_raLJX_info;
 },
 go_raLJX_entry() //  [R2]
         { info_tbl: [(caQfH,
                       label: go_raLJX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQfH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQfI; else goto uaQfT;
       caQfI: // global
           R2 = R2;
           R1 = go_raLJX_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaQfT: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caQfx() args: 0, res: 0, upd: 0;
     }
 },
 _caQfx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQfx: // global
           _saM52::P64 = P64[Sp];
           I64[Sp] = block_caQfA_info;
           R1 = _saM52::P64;
           if (R1 & 7 != 0) goto uaQfV; else goto caQfB;
       uaQfV: // global
           call _caQfA(R1) args: 0, res: 0, upd: 0;
       caQfB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQfA() //  [R1]
         { info_tbl: [(caQfA,
                       label: block_caQfA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQfA: // global
           if (R1 & 7 == 1) goto caQfE; else goto caQfF;
       caQfE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caQfF: // global
           I64[Sp - 8] = block_caQfP_info;
           _saM56::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM56::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQfP() //  []
         { info_tbl: [(caQfP,
                       label: block_caQfP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQfP: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caQfx() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.800646268 UTC

[section ""data" . GHC.Event.Thread.closeFdWith1_closure" {
     GHC.Event.Thread.closeFdWith1_closure:
         const GHC.Event.Thread.closeFdWith1_info;
         const 0;
 },
 go1_saM5z_entry() //  [R1, R2]
         { info_tbl: [(caQh2,
                       label: go1_saM5z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQh2: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caQh3; else goto caQh4;
       caQh3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQh4: // global
           I64[Sp - 24] = block_caQgV_info;
           _saM5z::P64 = R1;
           _saM5b::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _saM5b::P64;
           P64[Sp - 8] = _saM5z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaQi9; else goto caQgW;
       uaQi9: // global
           call _caQgV(R1) args: 0, res: 0, upd: 0;
       caQgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQgV() //  [R1]
         { info_tbl: [(caQgV,
                       label: block_caQgV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQgV: // global
           if (R1 & 7 == 1) goto caQgZ; else goto caQh0;
       caQgZ: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caQh0: // global
           I64[Sp - 8] = block_caQha_info;
           _saM5E::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM5E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQi8; else goto caQhb;
       uaQi8: // global
           call _caQha(R1) args: 0, res: 0, upd: 0;
       caQhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQha() //  [R1]
         { info_tbl: [(caQha,
                       label: block_caQha_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQha: // global
           I64[Sp - 16] = block_caQhf_info;
           _saM5I::P64 = P64[R1 + 23];
           _saM5K::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saM5K::P64;
           P64[Sp] = _saM5I::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQia; else goto caQhg;
       uaQia: // global
           call _caQhf(R1) args: 0, res: 0, upd: 0;
       caQhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQhf() //  [R1]
         { info_tbl: [(caQhf,
                       label: block_caQhf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQhf: // global
           I64[Sp - 8] = block_caQhk_info;
           _saM5T::P64 = R1;
           _saM5U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM5U::I64;
           P64[Sp + 16] = _saM5T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQib; else goto caQhl;
       uaQib: // global
           call _caQhk(R1) args: 0, res: 0, upd: 0;
       caQhl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQhk() //  [R1]
         { info_tbl: [(caQhk,
                       label: block_caQhk_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQhk: // global
           I64[Sp - 8] = block_caQhp_info;
           _saM5V::P64 = R1;
           _saM5W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saM5W::I64;
           P64[Sp + 40] = _saM5V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQic; else goto caQhu;
       uaQic: // global
           call _caQhp(R1) args: 0, res: 0, upd: 0;
       caQhu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQhp() //  [R1]
         { info_tbl: [(caQhp,
                       label: block_caQhp_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQhp: // global
           _saM5T::P64 = P64[Sp + 32];
           _saM5U::I64 = I64[Sp + 16];
           _saM5V::P64 = P64[Sp + 48];
           _saM5Z::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saM5U::I64,
                            _saM5Z::I64)) goto caQhL; else goto caQi7;
       caQi7: // global
           if (%MO_S_Gt_W64(_saM5Z::I64,
                            I64[Sp + 8])) goto caQhL; else goto caQi1;
       caQhL: // global
           R4 = _saM5Z::I64;
           R3 = _saM5T::P64;
           R2 = _saM5V::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caQi1: // global
           _saM66::P64 = P64[P64[Sp + 24] + ((_saM5Z::I64 - _saM5U::I64 << 3) + 24)];
           I64[Sp + 32] = block_caQhR_info;
           R1 = _saM66::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uaQid; else goto caQhS;
       uaQid: // global
           call _caQhR(R1) args: 0, res: 0, upd: 0;
       caQhS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQhR() //  [R1]
         { info_tbl: [(caQhR,
                       label: block_caQhR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQhR: // global
           I64[Sp] = block_caQhW_info;
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQhW() //  [R1]
         { info_tbl: [(caQhW,
                       label: block_caQhW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQhW: // global
           I64[Sp + 16] = block_caQhY_info;
           R2 = P64[Sp + 8];
           _saM6b::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saM6b::P64;
           Sp = Sp + 16;
           call go1_saM5z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQhY() //  [R1]
         { info_tbl: [(caQhY,
                       label: block_caQhY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQhY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQi6; else goto caQi5;
       caQi6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQi5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_saM6j_entry() //  [R1, R2, R3]
         { info_tbl: [(caQis,
                       label: go2_saM6j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQis: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caQit; else goto caQiu;
       caQit: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caQiu: // global
           I64[Sp - 32] = block_caQil_info;
           _saM6j::P64 = R1;
           _saM5b::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _saM5b::P64;
           P64[Sp - 16] = _saM6j::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaQjd; else goto caQim;
       uaQjd: // global
           call _caQil(R1) args: 0, res: 0, upd: 0;
       caQim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQil() //  [R1]
         { info_tbl: [(caQil,
                       label: block_caQil_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQil: // global
           if (R1 & 7 == 1) goto uaQj9; else goto caQiq;
       uaQj9: // global
           Sp = Sp + 32;
           call _caQiI() args: 0, res: 0, upd: 0;
       caQiq: // global
           I64[Sp - 8] = block_caQiA_info;
           _saM6o::P64 = P64[R1 + 6];
           _saM6p::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _saM6p::P64;
           P64[Sp + 24] = _saM6o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQjb; else goto caQiC;
       uaQjb: // global
           call _caQiA(R1) args: 0, res: 0, upd: 0;
       caQiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQiA() //  [R1]
         { info_tbl: [(caQiA,
                       label: block_caQiA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQiA: // global
           if (R1 & 7 == 1) goto uaQja; else goto caQj1;
       uaQja: // global
           Sp = Sp + 40;
           call _caQiI() args: 0, res: 0, upd: 0;
       caQj1: // global
           I64[Sp - 8] = block_caQiL_info;
           _saM6s::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saM6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQje; else goto caQiM;
       uaQje: // global
           call _caQiL(R1) args: 0, res: 0, upd: 0;
       caQiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQiI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQiI: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQiL() //  [R1]
         { info_tbl: [(caQiL,
                       label: block_caQiL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQiL: // global
           I64[Sp] = block_caQiQ_info;
           _saM6u::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saM6u::P64;
           if (R1 & 7 != 0) goto uaQjg; else goto caQiR;
       uaQjg: // global
           call _caQiQ(R1) args: 0, res: 0, upd: 0;
       caQiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQiQ() //  [R1]
         { info_tbl: [(caQiQ,
                       label: block_caQiQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQiQ: // global
           I64[Sp] = block_caQiV_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQiV() //  [R1]
         { info_tbl: [(caQiV,
                       label: block_caQiV_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQiV: // global
           _saM6j::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caQiX_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           _saM6z::P64 = R1;
           R1 = _saM6j::P64;
           P64[Sp + 40] = _saM6z::P64;
           Sp = Sp + 32;
           call go2_saM6j_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQiX() //  [R1]
         { info_tbl: [(caQiX,
                       label: block_caQiX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQiX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQj7; else goto caQj6;
       caQj7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQj6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7k_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(caQjt,
                       label: sat_saM7k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjt: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caQjH; else goto caQjI;
       caQjH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQjI: // global
           I64[Sp - 32] = block_caQjq_info;
           _saM5b::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _saM5b::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaQkl; else goto caQjr;
       uaQkl: // global
           call _caQjq(R1) args: 0, res: 0, upd: 0;
       caQjr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQjq() //  [R1]
         { info_tbl: [(caQjq,
                       label: block_caQjq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjq: // global
           I64[Sp - 16] = block_caQjw_info;
           _saM6S::P64 = P64[R1 + 23];
           _saM6U::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saM6U::P64;
           P64[Sp] = _saM6S::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQkk; else goto caQjx;
       uaQkk: // global
           call _caQjw(R1) args: 0, res: 0, upd: 0;
       caQjx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQjw() //  [R1]
         { info_tbl: [(caQjw,
                       label: block_caQjw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjw: // global
           I64[Sp - 8] = block_caQjB_info;
           _saM73::P64 = R1;
           _saM74::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM74::I64;
           P64[Sp + 16] = _saM73::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQkm; else goto caQjC;
       uaQkm: // global
           call _caQjB(R1) args: 0, res: 0, upd: 0;
       caQjC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQjB() //  [R1]
         { info_tbl: [(caQjB,
                       label: block_caQjB_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjB: // global
           I64[Sp - 8] = block_caQjG_info;
           _saM75::P64 = R1;
           _saM76::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saM76::I64;
           P64[Sp + 32] = _saM75::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQkn; else goto caQjM;
       uaQkn: // global
           call _caQjG(R1) args: 0, res: 0, upd: 0;
       caQjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQjG() //  [R1]
         { info_tbl: [(caQjG,
                       label: block_caQjG_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjG: // global
           _saM73::P64 = P64[Sp + 32];
           _saM74::I64 = I64[Sp + 16];
           _saM75::P64 = P64[Sp + 40];
           _saM79::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saM74::I64,
                            _saM79::I64)) goto caQk3; else goto caQkj;
       caQkj: // global
           if (%MO_S_Gt_W64(_saM79::I64,
                            I64[Sp + 8])) goto caQk3; else goto caQkf;
       caQk3: // global
           R4 = _saM79::I64;
           R3 = _saM73::P64;
           R2 = _saM75::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caQkf: // global
           _saM7g::P64 = P64[P64[Sp + 24] + ((_saM79::I64 - _saM74::I64 << 3) + 24)];
           I64[Sp + 40] = block_caQk9_info;
           R1 = _saM7g::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaQko; else goto caQka;
       uaQko: // global
           call _caQk9(R1) args: 0, res: 0, upd: 0;
       caQka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQk9() //  [R1]
         { info_tbl: [(caQk9,
                       label: block_caQk9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQk9: // global
           _saM6M::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caQke_info;
           R2 = _saM6M::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQke() //  []
         { info_tbl: [(caQke,
                       label: block_caQke_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQke: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7t_entry() //  [R1, R2]
         { info_tbl: [(caQkC,
                       label: sat_saM7t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQkC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQkD; else goto caQkE;
       caQkD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQkE: // global
           I64[Sp - 16] = block_caQkA_info;
           _saM7o::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7o::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQkA() //  []
         { info_tbl: [(caQkA,
                       label: block_caQkA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQkA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7n_entry() //  [R1]
         { info_tbl: [(caQkM,
                       label: sat_saM7n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQkM: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7I_entry() //  [R1, R2]
         { info_tbl: [(caQl2,
                       label: sat_saM7I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQl2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQl3; else goto caQl4;
       caQl3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQl4: // global
           I64[Sp - 16] = block_caQl0_info;
           _saM7D::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7D::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQl0() //  []
         { info_tbl: [(caQl0,
                       label: block_caQl0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQl0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7C_entry() //  [R1]
         { info_tbl: [(caQlc,
                       label: sat_saM7C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlc: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7P_entry() //  [R1]
         { info_tbl: [(caQlj,
                       label: sat_saM7P_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlj: // global
           _saM7P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caQlk; else goto caQll;
       caQll: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caQln; else goto caQlm;
       caQln: // global
           HpAlloc = 64;
           goto caQlk;
       caQlk: // global
           R1 = _saM7P::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQlm: // global
           _saM5a::P64 = P64[_saM7P::P64 + 7];
           _saM5b::P64 = P64[_saM7P::P64 + 15];
           _saM6K::P64 = P64[_saM7P::P64 + 23];
           I64[Hp - 56] = sat_saM7I_info;
           P64[Hp - 48] = _saM6K::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7C_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_caQlf_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           P64[Sp - 8] = _saM6K::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQlf() //  [R1]
         { info_tbl: [(caQlf,
                       label: block_caQlf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlf: // global
           I64[Sp] = block_caQlh_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQlh() //  []
         { info_tbl: [(caQlh,
                       label: block_caQlh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7X_entry() //  [R1, R2]
         { info_tbl: [(caQly,
                       label: sat_saM7X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQlz; else goto caQlA;
       caQlz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQlA: // global
           I64[Sp - 16] = block_caQlw_info;
           _saM7S::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saM7S::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQlw() //  []
         { info_tbl: [(caQlw,
                       label: block_caQlw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saM7R_entry() //  [R1]
         { info_tbl: [(caQlI,
                       label: sat_saM7R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlI: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saM5x_entry() //  [R1]
         { info_tbl: [(caQlL,
                       label: io_saM5x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQlL: // global
           _saM5x::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto caQlM; else goto caQlN;
       caQlN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caQlP; else goto caQlO;
       caQlP: // global
           HpAlloc = 16;
           goto caQlM;
       caQlM: // global
           R1 = _saM5x::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQlO: // global
           _saM5a::P64 = P64[_saM5x::P64 + 7];
           _saM5b::P64 = P64[_saM5x::P64 + 15];
           _saM5t::P64 = P64[_saM5x::P64 + 23];
           I64[Hp - 8] = go1_saM5z_info;
           P64[Hp] = _saM5b::P64;
           I64[Sp - 32] = block_caQie_info;
           R2 = _saM5t::P64;
           R1 = Hp - 6;
           P64[Sp - 24] = _saM5a::P64;
           P64[Sp - 16] = _saM5b::P64;
           P64[Sp - 8] = _saM5t::P64;
           Sp = Sp - 32;
           call go1_saM5z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQie() //  [R1]
         { info_tbl: [(caQie,
                       label: block_caQie_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQie: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caQlS; else goto caQlR;
       caQlS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQlR: // global
           I64[Hp - 8] = go2_saM6j_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_caQjh_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           _saM6i::P64 = R1;
           R1 = Hp - 5;
           P64[Sp] = _saM6i::P64;
           Sp = Sp - 8;
           call go2_saM6j_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQjh() //  [R1]
         { info_tbl: [(caQjh,
                       label: block_caQjh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjh: // global
           I64[Sp - 8] = block_caQjj_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caQjj() //  [R1]
         { info_tbl: [(caQjj,
                       label: block_caQjj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQjj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caQlW; else goto caQlV;
       caQlW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caQlV: // global
           I64[Hp - 8] = sat_saM7k_info;
           P64[Hp] = P64[Sp + 32];
           _saM6i::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caQkp_info;
           R5 = P64[Sp + 8];
           R4 = _saM6i::P64;
           R3 = P64[Sp + 40];
           R2 = Hp - 4;
           I64[Sp + 40] = R1;
           Sp = Sp + 16;
           call GHC.List.zipWith3_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQkp() //  [R1]
         { info_tbl: [(caQkp,
                       label: block_caQkp_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQkp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caQlZ; else goto caQlY;
       caQlZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQlY: // global
           _saM5a::P64 = P64[Sp + 8];
           _saM5b::P64 = P64[Sp + 16];
           _saM7l::I64 = I64[Sp + 24];
           if (_saM7l::I64 == 0) goto caQm8; else goto uaQmg;
       caQm8: // global
           I64[Hp - 56] = sat_saM7P_info;
           P64[Hp - 48] = _saM5a::P64;
           P64[Hp - 40] = _saM5b::P64;
           P64[Hp - 32] = R1;
           _caQkQ::P64 = Hp - 55;
           Hp = Hp - 32;
           R1 = _caQkQ::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uaQmg: // global
           if (_saM7l::I64 == 1) goto caQmc; else goto caQm4;
       caQmc: // global
           I64[Hp - 56] = sat_saM7X_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7R_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caQm9_info;
           R2 = Hp - 54;
           _saM6K::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saM6K::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caQm4: // global
           I64[Hp - 56] = sat_saM7t_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saM5a::P64;
           P64[Hp - 16] = _saM5b::P64;
           I64[Hp - 8] = sat_saM7n_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caQm0_info;
           R2 = Hp - 54;
           _saM6K::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saM6K::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQm9() //  [R1]
         { info_tbl: [(caQm9,
                       label: block_caQm9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQm9: // global
           I64[Sp] = block_caQmb_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQmb() //  []
         { info_tbl: [(caQmb,
                       label: block_caQmb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQmb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQm0() //  [R1]
         { info_tbl: [(caQm0,
                       label: block_caQm0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQm0: // global
           I64[Sp] = block_caQm2_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQm2() //  []
         { info_tbl: [(caQm2,
                       label: block_caQm2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQm2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_saM86_entry() //  [R1, R2]
         { info_tbl: [(caQmu,
                       label: go1_saM86_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQmu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caQmv; else goto caQmw;
       caQmv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQmw: // global
           _saM87::I64 = R2;
           _saM5n::P64 = P64[R1 + 14];
           _saM5p::P64 = P64[R1 + 22];
           _saM5o::I64 = I64[R1 + 30];
           if (%MO_S_Gt_W64(_saM5o::I64, R2)) goto caQmC; else goto caQmt;
       caQmt: // global
           _saM5q::I64 = I64[R1 + 38];
           if (%MO_S_Gt_W64(_saM87::I64,
                            _saM5q::I64)) goto caQmC; else goto caQmJ;
       caQmC: // global
           R4 = _saM87::I64;
           R3 = _saM5n::P64;
           R2 = _saM5p::P64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caQmJ: // global
           _saM8g::P64 = P64[P64[R1 + 6] + ((_saM87::I64 - _saM5o::I64 << 3) + 24)];
           I64[Sp - 32] = block_caQmI_info;
           _saM86::P64 = R1;
           R1 = _saM8g::P64;
           I64[Sp - 24] = _saM5q::I64;
           P64[Sp - 16] = _saM86::P64;
           I64[Sp - 8] = _saM87::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaQnr; else goto caQmK;
       uaQnr: // global
           call _caQmI(R1) args: 0, res: 0, upd: 0;
       caQmK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQmI() //  [R1]
         { info_tbl: [(caQmI,
                       label: block_caQmI_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQmI: // global
           if (R1 & 7 == 1) goto caQmQ; else goto caQn0;
       caQmQ: // global
           Sp = Sp + 32;
           call lvl30_raLJW_entry() args: 8, res: 0, upd: 8;
       caQn0: // global
           I64[Sp] = block_caQmT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaQns; else goto caQmU;
       uaQns: // global
           call _caQmT(R1) args: 0, res: 0, upd: 0;
       caQmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQmT() //  [R1]
         { info_tbl: [(caQmT,
                       label: block_caQmT_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQmT: // global
           I64[Sp] = block_caQmY_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaQnt; else goto caQn2;
       uaQnt: // global
           call _caQmY(R1) args: 0, res: 0, upd: 0;
       caQn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQmY() //  [R1]
         { info_tbl: [(caQmY,
                       label: block_caQmY_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQmY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQn8; else goto caQn7;
       caQn8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQn7: // global
           _saM87::I64 = I64[Sp + 24];
           if (_saM87::I64 == I64[Sp + 8]) goto caQnp; else goto caQnj;
       caQnp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caQnj: // global
           Hp = Hp - 24;
           _saM86::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caQnf_info;
           R2 = _saM87::I64 + 1;
           _saM8n::P64 = R1;
           R1 = _saM86::P64;
           P64[Sp + 24] = _saM8n::P64;
           Sp = Sp + 16;
           call go1_saM86_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQnf() //  [R1]
         { info_tbl: [(caQnf,
                       label: block_caQnf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQnf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caQnm; else goto caQnl;
       caQnm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQnl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaQnZ_srtd" {
     uaQnZ_srtd:
         const SaMem_srt+224;
         const 38;
         const 223338307585;
 },
 GHC.Event.Thread.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caQnu,
                       label: GHC.Event.Thread.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQnu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caQnv; else goto caQnw;
       caQnv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.closeFdWith1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caQnw: // global
           I64[Sp - 24] = block_caQgk_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaQnX; else goto caQgl;
       uaQnX: // global
           call _caQgk(R1) args: 0, res: 0, upd: 0;
       caQgl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQgk() //  [R1]
         { info_tbl: [(caQgk,
                       label: block_caQgk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQgk: // global
           _saM5h::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caQgp_info;
           R1 = _saM5h::P64;
           if (R1 & 7 != 0) goto uaQnT; else goto caQgq;
       uaQnT: // global
           call _caQgp(R1) args: 0, res: 0, upd: 0;
       caQgq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQgp() //  [R1]
         { info_tbl: [(caQgp,
                       label: block_caQgp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQgp: // global
           I64[Sp - 16] = block_caQgu_info;
           _saM5k::P64 = P64[R1 + 15];
           _saM5m::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saM5m::P64;
           P64[Sp] = _saM5k::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQnU; else goto caQgv;
       uaQnU: // global
           call _caQgu(R1) args: 0, res: 0, upd: 0;
       caQgv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQgu() //  [R1]
         { info_tbl: [(caQgu,
                       label: block_caQgu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQgu: // global
           I64[Sp - 8] = block_caQgz_info;
           _saM5n::P64 = R1;
           _saM5o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saM5o::I64;
           P64[Sp + 16] = _saM5n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQnV; else goto caQgA;
       uaQnV: // global
           call _caQgz(R1) args: 0, res: 0, upd: 0;
       caQgA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQgz() //  [R1]
         { info_tbl: [(caQgz,
                       label: block_caQgz_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQgz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caQnC; else goto caQnB;
       caQnC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQnB: // global
           _saM5o::I64 = I64[Sp + 8];
           _saM5q::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saM5o::I64,
                            _saM5q::I64)) goto caQnN; else goto caQnQ;
       caQnN: // global
           I64[Hp - 40] = go1_saM86_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = _saM5o::I64;
           I64[Hp] = _saM5q::I64;
           I64[Sp + 24] = block_caQnL_info;
           R2 = _saM5o::I64;
           R1 = Hp - 38;
           Sp = Sp + 24;
           call go1_saM86_entry(R2, R1) args: 8, res: 8, upd: 8;
       caQnQ: // global
           Hp = Hp - 48;
           P64[Sp + 24] = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call _saM5r() args: 0, res: 0, upd: 0;
     }
 },
 _caQnL() //  [R1]
         { info_tbl: [(caQnL,
                       label: block_caQnL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQnL: // global
           P64[Sp] = R1;
           call _saM5r() args: 0, res: 0, upd: 0;
     }
 },
 _saM5r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saM5r: // global
           I64[Sp - 8] = block_caQgJ_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caQgJ() //  [R1]
         { info_tbl: [(caQgJ,
                       label: block_caQgJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQgJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caQnG; else goto caQnF;
       caQnG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caQnF: // global
           I64[Hp - 24] = io_saM5x_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _caQgL::P64 = Hp - 23;
           if (R1 == 0) goto caQnK; else goto caQnJ;
       caQnK: // global
           R1 = _caQgL::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caQnJ: // global
           R1 = _caQgL::P64;
           Sp = Sp + 32;
           call io_saM5x_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.910899046 UTC

[section ""data" . GHC.Event.Thread.closeFdWith_closure" {
     GHC.Event.Thread.closeFdWith_closure:
         const GHC.Event.Thread.closeFdWith_info;
         const 0;
 },
 GHC.Event.Thread.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caQs4,
                       label: GHC.Event.Thread.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQs4: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.914372557 UTC

[section ""data" . GHC.Event.Thread.registerDelay2_closure" {
     GHC.Event.Thread.registerDelay2_closure:
         const GHC.Event.Thread.registerDelay2_info;
 },
 GHC.Event.Thread.registerDelay2_entry() //  []
         { info_tbl: [(caQsi,
                       label: GHC.Event.Thread.registerDelay2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQsi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQsj; else goto caQsk;
       caQsj: // global
           R1 = GHC.Event.Thread.registerDelay2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQsk: // global
           I64[Sp - 8] = block_caQsf_info;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQsf() //  [R1]
         { info_tbl: [(caQsf,
                       label: block_caQsf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQsf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caQsn; else goto caQsm;
       caQsn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQsm: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.923199327 UTC

[section ""data" . GHC.Event.Thread.$wregisterDelay_closure" {
     GHC.Event.Thread.$wregisterDelay_closure:
         const GHC.Event.Thread.$wregisterDelay_info;
         const 0;
 },
 w1_saM9g_entry() //  [R1]
         { info_tbl: [(caQt3,
                       label: w1_saM9g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQt3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQt7; else goto caQt8;
       caQt7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQt8: // global
           I64[Sp - 8] = block_caQt0_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQtc; else goto caQt1;
       uaQtc: // global
           call _caQt0(R1) args: 0, res: 0, upd: 0;
       caQt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQt0() //  [R1]
         { info_tbl: [(caQt0,
                       label: block_caQt0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQt0: // global
           I64[Sp] = block_caQt6_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQt6() //  []
         { info_tbl: [(caQt6,
                       label: block_caQt6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQt6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saM9q_entry() //  [R1]
         { info_tbl: [(caQtm,
                       label: w2_saM9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQtm: // global
           R1 = P64[R1 + 7];
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMa6_entry() //  [R1]
         { info_tbl: [(caQtY,
                       label: sat_saMa6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQtY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caQtZ; else goto caQu0;
       caQtZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caQu0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caQtQ_info;
           _saM9x::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saM9x::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaQuV; else goto caQtR;
       uaQuV: // global
           call _caQtQ(R1) args: 0, res: 0, upd: 0;
       caQtR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caQtQ() //  [R1]
         { info_tbl: [(caQtQ,
                       label: block_caQtQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQtQ: // global
           _caQtX::P64 = R1 & 7;
           if (_caQtX::P64 < 3) goto uaQuM; else goto uaQuP;
       uaQuM: // global
           _saM9x::P64 = P64[Sp + 8];
           if (_caQtX::P64 < 2) goto caQtU; else goto caQtV;
       caQtU: // global
           I64[Sp] = block_caQu3_info;
           _saM9A::I64 = I64[R1 + 39];
           R1 = _saM9x::P64;
           I64[Sp + 8] = _saM9A::I64;
           if (R1 & 7 != 0) goto uaQuS; else goto caQu5;
       uaQuS: // global
           call _caQu3(R1) args: 0, res: 0, upd: 0;
       caQu5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caQtV: // global
           I64[Sp] = block_caQum_info;
           _saM9S::I64 = I64[R1 + 22];
           R1 = _saM9x::P64;
           I64[Sp + 8] = _saM9S::I64;
           if (R1 & 7 != 0) goto uaQuT; else goto caQuo;
       uaQuT: // global
           call _caQum(R1) args: 0, res: 0, upd: 0;
       caQuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaQuP: // global
           Sp = Sp + 16;
           call _caQtW() args: 0, res: 0, upd: 0;
     }
 },
 _caQu3() //  [R1]
         { info_tbl: [(caQu3,
                       label: block_caQu3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQu3: // global
           _caQuJ::P64 = R1 & 7;
           if (_caQuJ::P64 < 3) goto uaQuN; else goto uaQuQ;
       uaQuN: // global
           _saM9A::I64 = I64[Sp + 8];
           if (_caQuJ::P64 < 2) goto caQub; else goto caQuf;
       caQub: // global
           R1 = I64[((_saM9A::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caQuf: // global
           R1 = I64[((_saM9A::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaQuQ: // global
           Sp = Sp + 16;
           call _caQtW() args: 0, res: 0, upd: 0;
     }
 },
 _caQum() //  [R1]
         { info_tbl: [(caQum,
                       label: block_caQum_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQum: // global
           _caQuG::P64 = R1 & 7;
           if (_caQuG::P64 < 3) goto uaQuO; else goto uaQuR;
       uaQuO: // global
           _saM9S::I64 = I64[Sp + 8];
           if (_caQuG::P64 < 2) goto caQuu; else goto caQuy;
       caQuu: // global
           R1 = I64[((_saM9S::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caQuy: // global
           R1 = I64[((_saM9S::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaQuR: // global
           Sp = Sp + 16;
           call _caQtW() args: 0, res: 0, upd: 0;
     }
 },
 _caQtW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQtW: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMa7_entry() //  [R1, R2]
         { info_tbl: [(caQuY,
                       label: sat_saMa7_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQuY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caQv0; else goto caQv1;
       caQv0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQv1: // global
           I64[Sp - 40] = block_caQtE_info;
           R3 = R2;
           _saM9v::P64 = R2;
           R2 = P64[R1 + 15];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saM9v::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQtE() //  [R1]
         { info_tbl: [(caQtE,
                       label: block_caQtE_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQtE: // global
           _saM9s::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caQtI_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saM9s::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQtI() //  [R1]
         { info_tbl: [(caQtI,
                       label: block_caQtI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQtI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caQv5; else goto caQv4;
       caQv5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQv4: // global
           I64[Hp - 48] = sat_saMa6_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.$wregisterDelay_entry() //  [R2]
         { info_tbl: [(caQv6,
                       label: GHC.Event.Thread.$wregisterDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQv6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caQv7; else goto caQv8;
       caQv7: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wregisterDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQv8: // global
           I64[Sp - 16] = block_caQsB_info;
           R1 = GHC.Event.Thread.registerDelay2_closure+1;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQsB() //  [R1]
         { info_tbl: [(caQsB,
                       label: block_caQsB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQsB: // global
           I64[Sp - 8] = block_caQsD_info;
           _saM8U::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp] = _saM8U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQwF; else goto caQsE;
       uaQwF: // global
           call _caQsD(R1) args: 0, res: 0, upd: 0;
       caQsE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQsD() //  [R1]
         { info_tbl: [(caQsD,
                       label: block_caQsD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQsD: // global
           _saM8Z::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caQsI_info;
           R1 = _saM8Z::P64;
           if (R1 & 7 != 0) goto uaQwG; else goto caQsJ;
       uaQwG: // global
           call _caQsI(R1) args: 0, res: 0, upd: 0;
       caQsJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQsI() //  [R1]
         { info_tbl: [(caQsI,
                       label: block_caQsI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQsI: // global
           if (R1 & 7 == 1) goto caQve; else goto caQvg;
       caQve: // global
           Sp = Sp + 24;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caQvg: // global
           I64[Sp] = block_caQsO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaQwH; else goto caQsP;
       uaQwH: // global
           call _caQsO(R1) args: 0, res: 0, upd: 0;
       caQsP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQsO() //  [R1]
         { info_tbl: [(caQsO,
                       label: block_caQsO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQsO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caQvj; else goto caQvi;
       caQvj: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQvi: // global
           _saM8Q::I64 = I64[Sp + 16];
           _saM8U::P64 = P64[Sp + 8];
           _saM95::P64 = P64[R1 + 15];
           _saM9c::P64 = P64[R1 + 47];
           _saM9a::I64 = I64[R1 + 71];
           (_saM9f::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 80] = w1_saM9g_info;
           P64[Hp - 72] = _saM8U::P64;
           _caQsV::P64 = Hp - 79;
           if (%MO_S_Gt_W64(_saM8Q::I64, 0)) goto caQvo; else goto caQww;
       caQvo: // global
           (_saM9p::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 64] = w2_saM9q_info;
           P64[Hp - 56] = _caQsV::P64;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _saM9f::I64;
           I64[Hp - 32] = sat_saMa7_info;
           P64[Hp - 24] = Hp - 63;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saM9f::I64;
           I64[Hp] = _saM8Q::I64 * 1000 + _saM9p::I64;
           I64[Sp - 8] = block_caQvk_info;
           R2 = Hp - 31;
           R1 = _saM95::P64;
           P64[Sp] = _saM9c::P64;
           I64[Sp + 16] = _saM9a::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caQww: // global
           Hp = Hp - 72;
           I64[Sp] = block_caQwv_info;
           R1 = _caQsV::P64;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQvk() //  [R1]
         { info_tbl: [(caQvk,
                       label: block_caQvk_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQvk: // global
           I64[Sp] = block_caQvm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQwI; else goto caQvq;
       uaQwI: // global
           call _caQvm(R1) args: 0, res: 0, upd: 0;
       caQvq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQvm() //  [R1]
         { info_tbl: [(caQvm,
                       label: block_caQvm_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQvm: // global
           if (R1 & 7 == 1) goto uaQwC; else goto caQwt;
       uaQwC: // global
           Sp = Sp + 16;
           goto uaQwL;
       caQwt: // global
           _saM9c::P64 = P64[Sp + 8];
           (_saMag::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 24])), 1);
           if (%MO_SS_Conv_W64_W32(_saMag::I64) == 0 :: W32) goto uaQwD; else goto caQvP;
       uaQwD: // global
           Sp = Sp + 16;
           goto uaQwL;
       uaQwL: // global
           call _caQwp() args: 0, res: 0, upd: 0;
       caQvP: // global
           (_saMal::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caQvN_info;
           R1 = P64[_saM9c::P64 + 8];
           I64[Sp + 24] = _saMal::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaQwJ; else goto caQvR;
       uaQwJ: // global
           call _caQvN(R1) args: 0, res: 0, upd: 0;
       caQvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQvN() //  [R1]
         { info_tbl: [(caQvN,
                       label: block_caQvN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQvN: // global
           if (R1 & 7 == 1) goto caQvY; else goto caQwm;
       caQvY: // global
           I64[Sp] = block_caQvV_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caQwm: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 16]) == 9 :: W32) goto uaQwE; else goto caQwc;
       uaQwE: // global
           Sp = Sp + 8;
           call _caQwp() args: 0, res: 0, upd: 0;
       caQwc: // global
           I64[Sp] = block_caQwa_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQvV() //  []
         { info_tbl: [(caQvV,
                       label: block_caQvV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQvV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQwp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQwp: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQwa() //  []
         { info_tbl: [(caQwa,
                       label: block_caQwa_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQwa: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQwv() //  []
         { info_tbl: [(caQwv,
                       label: block_caQwv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQwv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.968442503 UTC

[section ""data" . GHC.Event.Thread.registerDelay1_closure" {
     GHC.Event.Thread.registerDelay1_closure:
         const GHC.Event.Thread.registerDelay1_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay1_entry() //  [R2]
         { info_tbl: [(caQyX,
                       label: GHC.Event.Thread.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQyX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQyY; else goto caQyZ;
       caQyY: // global
           R2 = R2;
           R1 = GHC.Event.Thread.registerDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQyZ: // global
           I64[Sp - 8] = block_caQyU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQz3; else goto caQyV;
       uaQz3: // global
           call _caQyU(R1) args: 0, res: 0, upd: 0;
       caQyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQyU() //  [R1]
         { info_tbl: [(caQyU,
                       label: block_caQyU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQyU: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wregisterDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.973867959 UTC

[section ""data" . GHC.Event.Thread.registerDelay_closure" {
     GHC.Event.Thread.registerDelay_closure:
         const GHC.Event.Thread.registerDelay_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay_entry() //  [R2]
         { info_tbl: [(caQzh,
                       label: GHC.Event.Thread.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzh: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:44.984548871 UTC

[section ""data" . GHC.Event.Thread.$wthreadDelay_closure" {
     GHC.Event.Thread.$wthreadDelay_closure:
         const GHC.Event.Thread.$wthreadDelay_info;
         const 0;
 },
 sat_saMbR_entry() //  [R1]
         { info_tbl: [(caQAp,
                       label: sat_saMbR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQAp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caQAq; else goto caQAr;
       caQAq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caQAr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caQAh_info;
           _saMbi::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saMbi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaQBm; else goto caQAi;
       uaQBm: // global
           call _caQAh(R1) args: 0, res: 0, upd: 0;
       caQAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caQAh() //  [R1]
         { info_tbl: [(caQAh,
                       label: block_caQAh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQAh: // global
           _caQAo::P64 = R1 & 7;
           if (_caQAo::P64 < 3) goto uaQBd; else goto uaQBg;
       uaQBd: // global
           _saMbi::P64 = P64[Sp + 8];
           if (_caQAo::P64 < 2) goto caQAl; else goto caQAm;
       caQAl: // global
           I64[Sp] = block_caQAu_info;
           _saMbl::I64 = I64[R1 + 39];
           R1 = _saMbi::P64;
           I64[Sp + 8] = _saMbl::I64;
           if (R1 & 7 != 0) goto uaQBj; else goto caQAw;
       uaQBj: // global
           call _caQAu(R1) args: 0, res: 0, upd: 0;
       caQAw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caQAm: // global
           I64[Sp] = block_caQAN_info;
           _saMbD::I64 = I64[R1 + 22];
           R1 = _saMbi::P64;
           I64[Sp + 8] = _saMbD::I64;
           if (R1 & 7 != 0) goto uaQBk; else goto caQAP;
       uaQBk: // global
           call _caQAN(R1) args: 0, res: 0, upd: 0;
       caQAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaQBg: // global
           Sp = Sp + 16;
           call _caQAn() args: 0, res: 0, upd: 0;
     }
 },
 _caQAu() //  [R1]
         { info_tbl: [(caQAu,
                       label: block_caQAu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQAu: // global
           _caQBa::P64 = R1 & 7;
           if (_caQBa::P64 < 3) goto uaQBe; else goto uaQBh;
       uaQBe: // global
           _saMbl::I64 = I64[Sp + 8];
           if (_caQBa::P64 < 2) goto caQAC; else goto caQAG;
       caQAC: // global
           R1 = I64[((_saMbl::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caQAG: // global
           R1 = I64[((_saMbl::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaQBh: // global
           Sp = Sp + 16;
           call _caQAn() args: 0, res: 0, upd: 0;
     }
 },
 _caQAN() //  [R1]
         { info_tbl: [(caQAN,
                       label: block_caQAN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQAN: // global
           _caQB7::P64 = R1 & 7;
           if (_caQB7::P64 < 3) goto uaQBf; else goto uaQBi;
       uaQBf: // global
           _saMbD::I64 = I64[Sp + 8];
           if (_caQB7::P64 < 2) goto caQAV; else goto caQAZ;
       caQAV: // global
           R1 = I64[((_saMbD::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caQAZ: // global
           R1 = I64[((_saMbD::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaQBi: // global
           Sp = Sp + 16;
           call _caQAn() args: 0, res: 0, upd: 0;
     }
 },
 _caQAn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQAn: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMbS_entry() //  [R1, R2]
         { info_tbl: [(caQBp,
                       label: sat_saMbS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQBp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQBr; else goto caQBs;
       caQBr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQBs: // global
           I64[Sp - 16] = block_caQA9_info;
           R3 = R2;
           _saMbh::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _saMbh::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQA9() //  [R1]
         { info_tbl: [(caQA9,
                       label: block_caQA9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQA9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caQBv; else goto caQBu;
       caQBv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQBu: // global
           I64[Hp - 48] = sat_saMbR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMci_entry() //  [R1, R2]
         { info_tbl: [(caQBF,
                       label: sat_saMci_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQBF: // global
           _saMbf::P64 = R2;
           _saMci::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto caQBG; else goto caQBH;
       caQBH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caQBJ; else goto caQBI;
       caQBJ: // global
           HpAlloc = 16;
           goto caQBG;
       caQBG: // global
           R2 = _saMbf::P64;
           R1 = _saMci::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQBI: // global
           _saMaY::P64 = P64[_saMci::P64 + 6];
           _saMb5::P64 = P64[_saMci::P64 + 14];
           _saMbc::P64 = P64[_saMci::P64 + 22];
           _saMb3::I64 = I64[_saMci::P64 + 30];
           I64[Hp - 8] = sat_saMbS_info;
           P64[Hp] = _saMbc::P64;
           I64[Sp - 32] = block_caQBw_info;
           R2 = Hp - 7;
           R1 = _saMaY::P64;
           I64[Sp - 24] = _saMb3::I64;
           P64[Sp - 16] = _saMb5::P64;
           P64[Sp - 8] = _saMbf::P64;
           Sp = Sp - 32;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQBw() //  [R1]
         { info_tbl: [(caQBw,
                       label: block_caQBw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQBw: // global
           I64[Sp] = block_caQBy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQCO; else goto caQBz;
       uaQCO: // global
           call _caQBy(R1) args: 0, res: 0, upd: 0;
       caQBz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQBy() //  [R1]
         { info_tbl: [(caQBy,
                       label: block_caQBy_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQBy: // global
           if (R1 & 7 == 1) goto uaQCL; else goto caQBD;
       uaQCL: // global
           Sp = Sp + 24;
           goto uaQCR;
       caQBD: // global
           _saMb5::P64 = P64[Sp + 16];
           (_saMc1::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saMc1::I64) == 0 :: W32) goto uaQCM; else goto caQC6;
       uaQCM: // global
           Sp = Sp + 24;
           goto uaQCR;
       uaQCR: // global
           call _caQCG() args: 0, res: 0, upd: 0;
       caQC6: // global
           (_saMc6::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caQC4_info;
           R1 = P64[_saMb5::P64 + 8];
           I64[Sp + 16] = _saMc6::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaQCP; else goto caQC8;
       uaQCP: // global
           call _caQC4(R1) args: 0, res: 0, upd: 0;
       caQC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQC4() //  [R1]
         { info_tbl: [(caQC4,
                       label: block_caQC4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQC4: // global
           if (R1 & 7 == 1) goto caQCf; else goto caQCD;
       caQCf: // global
           I64[Sp + 8] = block_caQCc_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caQCD: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaQCN; else goto caQCt;
       uaQCN: // global
           Sp = Sp + 16;
           call _caQCG() args: 0, res: 0, upd: 0;
       caQCt: // global
           I64[Sp + 8] = block_caQCr_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQCc() //  []
         { info_tbl: [(caQCc,
                       label: block_caQCc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQCc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQCG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQCG: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQCr() //  []
         { info_tbl: [(caQCr,
                       label: block_caQCr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQCr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMbe_entry() //  [R1]
         { info_tbl: [(caQCY,
                       label: sat_saMbe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQCY: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 w1_saMco_entry() //  [R1]
         { info_tbl: [(caQDc,
                       label: w1_saMco_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQDd; else goto caQDe;
       caQDd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQDe: // global
           I64[Sp - 8] = block_caQDa_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQDa() //  []
         { info_tbl: [(caQDa,
                       label: block_caQDa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saMd5_entry() //  [R1]
         { info_tbl: [(caQDO,
                       label: sat_saMd5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caQDP; else goto caQDQ;
       caQDP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caQDQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caQDG_info;
           _saMcw::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saMcw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaQEL; else goto caQDH;
       uaQEL: // global
           call _caQDG(R1) args: 0, res: 0, upd: 0;
       caQDH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caQDG() //  [R1]
         { info_tbl: [(caQDG,
                       label: block_caQDG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDG: // global
           _caQDN::P64 = R1 & 7;
           if (_caQDN::P64 < 3) goto uaQEC; else goto uaQEF;
       uaQEC: // global
           _saMcw::P64 = P64[Sp + 8];
           if (_caQDN::P64 < 2) goto caQDK; else goto caQDL;
       caQDK: // global
           I64[Sp] = block_caQDT_info;
           _saMcz::I64 = I64[R1 + 39];
           R1 = _saMcw::P64;
           I64[Sp + 8] = _saMcz::I64;
           if (R1 & 7 != 0) goto uaQEI; else goto caQDV;
       uaQEI: // global
           call _caQDT(R1) args: 0, res: 0, upd: 0;
       caQDV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caQDL: // global
           I64[Sp] = block_caQEc_info;
           _saMcR::I64 = I64[R1 + 22];
           R1 = _saMcw::P64;
           I64[Sp + 8] = _saMcR::I64;
           if (R1 & 7 != 0) goto uaQEJ; else goto caQEe;
       uaQEJ: // global
           call _caQEc(R1) args: 0, res: 0, upd: 0;
       caQEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaQEF: // global
           Sp = Sp + 16;
           call _caQDM() args: 0, res: 0, upd: 0;
     }
 },
 _caQDT() //  [R1]
         { info_tbl: [(caQDT,
                       label: block_caQDT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDT: // global
           _caQEz::P64 = R1 & 7;
           if (_caQEz::P64 < 3) goto uaQED; else goto uaQEG;
       uaQED: // global
           _saMcz::I64 = I64[Sp + 8];
           if (_caQEz::P64 < 2) goto caQE1; else goto caQE5;
       caQE1: // global
           R1 = I64[((_saMcz::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caQE5: // global
           R1 = I64[((_saMcz::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaQEG: // global
           Sp = Sp + 16;
           call _caQDM() args: 0, res: 0, upd: 0;
     }
 },
 _caQEc() //  [R1]
         { info_tbl: [(caQEc,
                       label: block_caQEc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQEc: // global
           _caQEw::P64 = R1 & 7;
           if (_caQEw::P64 < 3) goto uaQEE; else goto uaQEH;
       uaQEE: // global
           _saMcR::I64 = I64[Sp + 8];
           if (_caQEw::P64 < 2) goto caQEk; else goto caQEo;
       caQEk: // global
           R1 = I64[((_saMcR::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caQEo: // global
           R1 = I64[((_saMcR::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaQEH: // global
           Sp = Sp + 16;
           call _caQDM() args: 0, res: 0, upd: 0;
     }
 },
 _caQDM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDM: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saMd6_entry() //  [R1, R2]
         { info_tbl: [(caQEO,
                       label: sat_saMd6_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQEO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caQEQ; else goto caQER;
       caQEQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQER: // global
           I64[Sp - 40] = block_caQDu_info;
           R3 = R2;
           _saMcu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 15];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saMcu::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQDu() //  [R1]
         { info_tbl: [(caQDu,
                       label: block_caQDu_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDu: // global
           _saMcr::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caQDy_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saMcr::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQDy() //  [R1]
         { info_tbl: [(caQDy,
                       label: block_caQDy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQDy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caQEV; else goto caQEU;
       caQEV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQEU: // global
           I64[Hp - 48] = sat_saMd5_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saMaJ_entry() //  [R1]
         { info_tbl: [(caQEW,
                       label: io_saMaJ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQEW: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caQEX; else goto caQEY;
       caQEX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caQEY: // global
           I64[Sp - 16] = block_caQzz_info;
           _saMaE::I64 = I64[R1 + 7];
           R1 = GHC.Event.Thread.timerManager_closure;
           I64[Sp - 8] = _saMaE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaQGD; else goto caQzA;
       uaQGD: // global
           call _caQzz(R1) args: 0, res: 0, upd: 0;
       caQzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQzz() //  [R1]
         { info_tbl: [(caQzz,
                       label: block_caQzz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzz: // global
           _saMaP::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caQzE_info;
           R1 = _saMaP::P64;
           if (R1 & 7 != 0) goto uaQGA; else goto caQzF;
       uaQGA: // global
           call _caQzE(R1) args: 0, res: 0, upd: 0;
       caQzF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQzE() //  [R1]
         { info_tbl: [(caQzE,
                       label: block_caQzE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzE: // global
           if (R1 & 7 == 1) goto caQF3; else goto caQF5;
       caQF3: // global
           Sp = Sp + 16;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caQF5: // global
           I64[Sp - 8] = block_caQzK_info;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caQzK() //  [R1]
         { info_tbl: [(caQzK,
                       label: block_caQzK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzK: // global
           I64[Sp] = block_caQzM_info;
           _saMaV::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saMaV::P64;
           if (R1 & 7 != 0) goto uaQGB; else goto caQzN;
       uaQGB: // global
           call _caQzM(R1) args: 0, res: 0, upd: 0;
       caQzN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQzM() //  [R1]
         { info_tbl: [(caQzM,
                       label: block_caQzM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caQF9; else goto caQF8;
       caQF9: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQF8: // global
           _saMaE::I64 = I64[Sp + 16];
           _saMaV::P64 = P64[Sp + 8];
           _saMaY::P64 = P64[R1 + 15];
           _saMb5::P64 = P64[R1 + 47];
           _saMb3::I64 = I64[R1 + 71];
           (_saMb8::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _saMb8::I64;
           _caQzT::P64 = Hp - 63;
           if (%MO_S_Gt_W64(_saMaE::I64, 0)) goto caQFh; else goto caQGp;
       caQFh: // global
           (_saMcn::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 48] = w1_saMco_info;
           P64[Hp - 40] = _saMaV::P64;
           I64[Hp - 32] = sat_saMd6_info;
           P64[Hp - 24] = _caQzT::P64;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saMb8::I64;
           I64[Hp] = _saMaE::I64 * 1000 + _saMcn::I64;
           I64[Sp - 24] = block_caQFd_info;
           R2 = Hp - 31;
           R1 = _saMaY::P64;
           I64[Sp - 16] = _saMb3::I64;
           P64[Sp - 8] = _saMb5::P64;
           P64[Sp] = _saMaY::P64;
           P64[Sp + 16] = _caQzT::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caQGp: // global
           Hp = Hp - 56;
           I64[Sp - 24] = block_caQGo_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saMaV::P64;
           P64[Sp + 16] = _caQzT::P64;
           P64[Sp] = _saMaY::P64;
           I64[Sp - 16] = _saMb3::I64;
           P64[Sp - 8] = _saMb5::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQFd() //  [R1]
         { info_tbl: [(caQFd,
                       label: block_caQFd_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQFd: // global
           I64[Sp] = block_caQFf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaQGE; else goto caQFj;
       uaQGE: // global
           call _caQFf(R1) args: 0, res: 0, upd: 0;
       caQFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQFf() //  [R1]
         { info_tbl: [(caQFf,
                       label: block_caQFf_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQFf: // global
           if (R1 & 7 == 1) goto uaQGH; else goto caQGm;
       caQGm: // global
           _saMb5::P64 = P64[Sp + 16];
           (_saMdf::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saMdf::I64) == 0 :: W32) goto uaQGH; else goto caQFI;
       uaQGH: // global
           call _caQGo() args: 0, res: 0, upd: 0;
       caQFI: // global
           (_saMdk::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_caQFG_info;
           R1 = P64[_saMb5::P64 + 8];
           I64[Sp] = _saMdk::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQGG; else goto caQFK;
       uaQGG: // global
           call _caQFG(R1) args: 0, res: 0, upd: 0;
       caQFK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQFG() //  [R1]
         { info_tbl: [(caQFG,
                       label: block_caQFG_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQFG: // global
           if (R1 & 7 == 1) goto caQFR; else goto caQGf;
       caQFR: // global
           I64[Sp + 8] = block_caQFO_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caQGf: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaQGv; else goto caQG5;
       uaQGv: // global
           Sp = Sp + 8;
           call _caQGo() args: 0, res: 0, upd: 0;
       caQG5: // global
           I64[Sp + 8] = block_caQG3_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caQFO() //  []
         { info_tbl: [(caQFO,
                       label: block_caQFO_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQFO: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caQzX() args: 0, res: 0, upd: 0;
     }
 },
 _caQG3() //  []
         { info_tbl: [(caQG3,
                       label: block_caQG3_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQG3: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caQzX() args: 0, res: 0, upd: 0;
     }
 },
 _caQGo() //  []
         { info_tbl: [(caQGo,
                       label: block_caQGo_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQGo: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caQzX() args: 0, res: 0, upd: 0;
     }
 },
 _caQzX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzX: // global
           Hp = Hp + 56;
           _saMbc::P64 = P64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caQFc; else goto caQFb;
       caQFc: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_caQzW_info;
           R1 = _saMbc::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caQFb: // global
           I64[Hp - 48] = sat_saMci_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _saMbc::P64;
           I64[Hp - 16] = I64[Sp];
           I64[Hp - 8] = sat_saMbe_info;
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 46;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caQzW() //  [R1]
         { info_tbl: [(caQzW,
                       label: block_caQzW_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzW: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caQzX() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.$wthreadDelay_entry() //  [R2]
         { info_tbl: [(caQGQ,
                       label: GHC.Event.Thread.$wthreadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQGQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQGR; else goto caQGS;
       caQGR: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wthreadDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQGS: // global
           I64[Sp - 16] = block_caQzs_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caQzs() //  [R1]
         { info_tbl: [(caQzs,
                       label: block_caQzs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQzs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caQGV; else goto caQGU;
       caQGV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caQGU: // global
           I64[Hp - 8] = io_saMaJ_info;
           I64[Hp] = I64[Sp + 8];
           _caQzu::P64 = Hp - 7;
           if (R1 == 0) goto caQGP; else goto caQGO;
       caQGP: // global
           R1 = _caQzu::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caQGO: // global
           R1 = _caQzu::P64;
           Sp = Sp + 16;
           call io_saMaJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:45.065714829 UTC

[section ""data" . GHC.Event.Thread.threadDelay1_closure" {
     GHC.Event.Thread.threadDelay1_closure:
         const GHC.Event.Thread.threadDelay1_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay1_entry() //  [R2]
         { info_tbl: [(caQKr,
                       label: GHC.Event.Thread.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQKr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caQKs; else goto caQKt;
       caQKs: // global
           R2 = R2;
           R1 = GHC.Event.Thread.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caQKt: // global
           I64[Sp - 8] = block_caQKo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQKx; else goto caQKp;
       uaQKx: // global
           call _caQKo(R1) args: 0, res: 0, upd: 0;
       caQKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQKo() //  [R1]
         { info_tbl: [(caQKo,
                       label: block_caQKo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQKo: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wthreadDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:45.070955034 UTC

[section ""data" . GHC.Event.Thread.threadDelay_closure" {
     GHC.Event.Thread.threadDelay_closure:
         const GHC.Event.Thread.threadDelay_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay_entry() //  [R2]
         { info_tbl: [(caQKL,
                       label: GHC.Event.Thread.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQKL: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:45.07442066 UTC

[section ""relreadonly" . SaMem_srt" {
     SaMem_srt:
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.Event.Thread.blockedOnBadFD2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Event.Thread.blockedOnBadFD1_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const restartPollLoop_raLJq_closure;
         const GHC.Arr.$windexError_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
         const lvl4_raLJs_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Thread.$wstartIOManagerThread_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager1_closure;
         const GHC.Arr.negRange_closure;
         const lvl9_raLJx_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
         const GHC.Event.Thread.eventManager_closure;
         const GHC.Event.Thread.numEnabledEventManagers_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
         const GHC.Event.Thread.ioManagerLock_closure;
         const GHC.Event.Thread.timerManagerThreadVar_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const lvl11_raLJz_closure;
         const lvl13_raLJB_closure;
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
         const lvl14_raLJC_closure;
         const lvl15_raLJD_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure;
         const GHC.Event.Thread.getSystemEventManager2_closure;
         const GHC.Event.Thread.getSystemEventManager1_closure;
         const lvl17_raLJF_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const lvl18_raLJG_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl24_raLJM_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const lvl19_raLJH_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const threadWaitReadSTM2_raLJN_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const threadWaitWriteSTM1_raLJO_closure;
         const lvl26_raLJQ_closure;
         const lvl27_raLJR_closure;
         const lvl28_raLJS_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const threadWaitWrite1_raLJT_closure;
         const threadWaitRead2_raLJU_closure;
         const lvl30_raLJW_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Event.Thread.$wregisterDelay_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Event.Thread.$wthreadDelay_closure;
         const GHC.Event.Thread.threadDelay1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.464815675 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:52.465982154 UTC

[section ""data" . lvl1_raLJo_closure" {
     lvl1_raLJo_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.468101307 UTC

[section ""data" . lvl2_raLJp_closure" {
     lvl2_raLJp_closure:
         const lvl2_raLJp_info;
 },
 lvl2_raLJp_entry() //  []
         { info_tbl: [(caReG,
                       label: lvl2_raLJp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caReG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caReH; else goto caReI;
       caReH: // global
           R1 = lvl2_raLJp_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caReI: // global
           I64[Sp - 8] = block_caReB_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caReB() //  []
         { info_tbl: [(caReB,
                       label: block_caReB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caReB: // global
           I64[Sp] = block_caReD_info;
           R1 = lvl1_raLJo_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caReD() //  [R1]
         { info_tbl: [(caReD,
                       label: block_caReD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caReD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caReM; else goto caReL;
       caReM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caReL: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.47522583 UTC

[section ""data" . GHC.Event.Thread.numEnabledEventManagers_closure" {
     GHC.Event.Thread.numEnabledEventManagers_closure:
         const GHC.Event.Thread.numEnabledEventManagers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.numEnabledEventManagers_entry() //  [R1]
         { info_tbl: [(caRfa,
                       label: GHC.Event.Thread.numEnabledEventManagers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRfa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRfb; else goto caRfc;
       caRfb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRfc: // global
           (_caRf5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRf5::I64 == 0) goto caRf7; else goto caRf6;
       caRf7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRf6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRf5::I64;
           I64[Sp - 24] = block_caRf8_info;
           Sp = Sp - 24;
           call lvl2_raLJp_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caRf8() //  [R1]
         { info_tbl: [(caRf8,
                       label: block_caRf8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRf8: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.480680982 UTC

[section ""cstring" . GHC.Event.Thread.$trModule4_bytes" {
     GHC.Event.Thread.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.502128122 UTC

[section ""data" . GHC.Event.Thread.$trModule3_closure" {
     GHC.Event.Thread.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.503679104 UTC

[section ""cstring" . GHC.Event.Thread.$trModule2_bytes" {
     GHC.Event.Thread.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,104,114,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.505170525 UTC

[section ""data" . GHC.Event.Thread.$trModule1_closure" {
     GHC.Event.Thread.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Thread.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.506741798 UTC

[section ""data" . GHC.Event.Thread.$trModule_closure" {
     GHC.Event.Thread.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Thread.$trModule3_closure+1;
         const GHC.Event.Thread.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.508368616 UTC

[section ""cstring" . GHC.Event.Thread.blockedOnBadFD3_bytes" {
     GHC.Event.Thread.blockedOnBadFD3_bytes:
         I8[] [97,119,97,105,116,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.51031387 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD2_closure" {
     GHC.Event.Thread.blockedOnBadFD2_closure:
         const GHC.Event.Thread.blockedOnBadFD2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD2_entry() //  [R1]
         { info_tbl: [(caRfE,
                       label: GHC.Event.Thread.blockedOnBadFD2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRfE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRfF; else goto caRfG;
       caRfF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRfG: // global
           (_caRfB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRfB::I64 == 0) goto caRfD; else goto caRfC;
       caRfD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRfC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRfB::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.514538438 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD1_closure" {
     GHC.Event.Thread.blockedOnBadFD1_closure:
         const GHC.Event.Thread.blockedOnBadFD1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD1_entry() //  [R1]
         { info_tbl: [(caRfV,
                       label: GHC.Event.Thread.blockedOnBadFD1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRfV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRfW; else goto caRfX;
       caRfW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRfX: // global
           (_caRfS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRfS::I64 == 0) goto caRfU; else goto caRfT;
       caRfU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRfT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRfS::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = GHC.Event.Thread.blockedOnBadFD2_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.51873914 UTC

[section ""data" . GHC.Event.Thread.blockedOnBadFD_closure" {
     GHC.Event.Thread.blockedOnBadFD_closure:
         const GHC.Event.Thread.blockedOnBadFD_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.blockedOnBadFD_entry() //  [R1]
         { info_tbl: [(caRgf,
                       label: GHC.Event.Thread.blockedOnBadFD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRgf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRgg; else goto caRgh;
       caRgg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRgh: // global
           (_caRgc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRgc::I64 == 0) goto caRge; else goto caRgd;
       caRge: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRgd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRgc::I64;
           R2 = GHC.Event.Thread.blockedOnBadFD1_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.522644462 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning7_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning7_bytes:
         I8[] [73,79,77,97,110,97,103,101,114,32,111,110,32,99,97,112,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.52655603 UTC

[section ""data" . restartPollLoop_raLJq_closure" {
     restartPollLoop_raLJq_closure:
         const restartPollLoop_raLJq_info;
         const 0;
 },
 sat_saQLr_entry() //  [R1]
         { info_tbl: [(caRgW,
                       label: sat_saQLr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRgW: // global
           R2 = P64[R1 + 7];
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQLs_entry() //  [R1]
         { info_tbl: [(caRgZ,
                       label: sat_saQLs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRgZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRh3; else goto caRh2;
       caRh3: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRh2: // global
           _saQL5::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_saQLr_info;
           P64[Hp] = _saQL5::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQLG_entry() //  [R1, R2]
         { info_tbl: [(caRhe,
                       label: sat_saQLG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRhi; else goto caRhj;
       caRhi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caRhj: // global
           I64[Sp - 16] = block_caRhb_info;
           _saQLv::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saQLv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRhn; else goto caRhc;
       uaRhn: // global
           call _caRhb(R1) args: 0, res: 0, upd: 0;
       caRhc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRhb() //  [R1]
         { info_tbl: [(caRhb,
                       label: block_caRhb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhb: // global
           _saQLv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caRhh_info;
           R2 = I64[R1 + 7];
           R1 = _saQLv::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRhh() //  []
         { info_tbl: [(caRhh,
                       label: block_caRhh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhh: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQLz_entry() //  [R1]
         { info_tbl: [(caRhz,
                       label: sat_saQLz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRhA; else goto caRhB;
       caRhA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRhB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caRhw_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caRhw() //  [R1, R2]
         { info_tbl: [(caRhw,
                       label: block_caRhw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caRhE; else goto caRhD;
       caRhE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caRhD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saQLA_entry() //  [R1]
         { info_tbl: [(caRhF,
                       label: sat_saQLA_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhF: // global
           _saQLA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caRhG; else goto caRhH;
       caRhH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caRhJ; else goto caRhI;
       caRhJ: // global
           HpAlloc = 24;
           goto caRhG;
       caRhG: // global
           R1 = _saQLA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRhI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saQLA::P64;
           _saQLp::I64 = I64[_saQLA::P64 + 16];
           I64[Hp - 16] = sat_saQLz_info;
           I64[Hp] = _saQLp::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 restartPollLoop_raLJq_entry() //  [R2, R3]
         { info_tbl: [(caRhK,
                       label: restartPollLoop_raLJq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caRhL; else goto caRhM;
       caRhL: // global
           R3 = R3;
           R2 = R2;
           R1 = restartPollLoop_raLJq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caRhM: // global
           I64[Sp - 16] = block_caRgv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRjf; else goto caRgw;
       uaRjf: // global
           call _caRgv(R1) args: 0, res: 0, upd: 0;
       caRgw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRgv() //  [R1]
         { info_tbl: [(caRgv,
                       label: block_caRgv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRgv: // global
           I64[Sp - 24] = block_caRgA_info;
           R2 = GHC.Event.Manager.release2_closure+1;
           _saQL5::P64 = R1;
           _saQLh::P64 = P64[R1 + 63];
           _saQLf::I64 = I64[R1 + 103];
           R1 = P64[R1 + 39];
           I64[Sp - 16] = _saQLf::I64;
           P64[Sp - 8] = _saQLh::P64;
           P64[Sp] = _saQL5::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRgA() //  [R1]
         { info_tbl: [(caRgA,
                       label: block_caRgA_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRgA: // global
           I64[Sp] = block_caRhN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaRje; else goto caRi3;
       uaRje: // global
           call _caRhN(R1) args: 0, res: 0, upd: 0;
       caRi3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRhN() //  [R1]
         { info_tbl: [(caRhN,
                       label: block_caRhN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhN: // global
           if (R1 & 7 == 2) goto caRj6; else goto uaRj9;
       caRj6: // global
           _saQLh::P64 = P64[Sp + 16];
           (_saQLQ::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saQLQ::I64) == 0 :: W32) goto uaRja; else goto caRis;
       uaRja: // global
           Sp = Sp + 24;
           goto uaRji;
       caRis: // global
           (_saQLV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caRiq_info;
           R1 = P64[_saQLh::P64 + 8];
           I64[Sp + 16] = _saQLV::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaRjg; else goto caRiu;
       uaRjg: // global
           call _caRiq(R1) args: 0, res: 0, upd: 0;
       caRiu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaRj9: // global
           Sp = Sp + 24;
           goto uaRji;
       uaRji: // global
           call _saQLm() args: 0, res: 0, upd: 0;
     }
 },
 _caRiq() //  [R1]
         { info_tbl: [(caRiq,
                       label: block_caRiq_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRiq: // global
           if (R1 & 7 == 1) goto caRiB; else goto caRiZ;
       caRiB: // global
           I64[Sp + 8] = block_caRiy_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caRiZ: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaRjb; else goto caRiP;
       uaRjb: // global
           Sp = Sp + 16;
           call _saQLm() args: 0, res: 0, upd: 0;
       caRiP: // global
           I64[Sp + 8] = block_caRiN_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRiy() //  []
         { info_tbl: [(caRiy,
                       label: block_caRiy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRiy: // global
           Sp = Sp + 8;
           call _saQLm() args: 0, res: 0, upd: 0;
     }
 },
 _caRiN() //  []
         { info_tbl: [(caRiN,
                       label: block_caRiN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRiN: // global
           Sp = Sp + 8;
           call _saQLm() args: 0, res: 0, upd: 0;
     }
 },
 _saQLm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saQLm: // global
           I64[Sp - 8] = block_caRgH_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRjm; else goto caRgI;
       uaRjm: // global
           call _caRgH(R1) args: 0, res: 0, upd: 0;
       caRgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRgH() //  [R1]
         { info_tbl: [(caRgH,
                       label: block_caRgH_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRgH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRhW; else goto caRhV;
       caRhW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRhV: // global
           _saQLp::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_saQLs_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caRh4_info;
           R2 = Hp - 7;
           R1 = _saQLp::I64;
           I64[Sp + 16] = _saQLp::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRh4() //  [R1]
         { info_tbl: [(caRh4,
                       label: block_caRh4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRh4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caRhZ; else goto caRhY;
       caRhZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRhY: // global
           I64[Hp - 32] = sat_saQLG_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saQLA_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_caRhQ_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 8] = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRhQ() //  [R1]
         { info_tbl: [(caRhQ,
                       label: block_caRhQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRhQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRi2; else goto caRi1;
       caRi2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRi1: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.563873223 UTC

[section ""cstring" . lvl3_raLJr_bytes" {
     lvl3_raLJr_bytes:
         I8[] [73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.565900484 UTC

[section ""data" . lvl4_raLJs_closure" {
     lvl4_raLJs_closure:
         const lvl4_raLJs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_raLJs_entry() //  [R1]
         { info_tbl: [(caRl9,
                       label: lvl4_raLJs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRl9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRla; else goto caRlb;
       caRla: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRlb: // global
           (_caRl6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRl6::I64 == 0) goto caRl8; else goto caRl7;
       caRl8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRl7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRl6::I64;
           R2 = lvl3_raLJr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.570536412 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning8_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning8_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning8_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning8_entry() //  [R2, R3, R4]
         { info_tbl: [(caRlr,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRlr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caRlv; else goto caRlu;
       caRlv: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRlu: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R3;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 39;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.577649684 UTC

[section ""data" . GHC.Event.Thread.$wstartIOManagerThread_closure" {
     GHC.Event.Thread.$wstartIOManagerThread_closure:
         const GHC.Event.Thread.$wstartIOManagerThread_info;
         const 0;
 },
 GHC.Event.Thread.$wstartIOManagerThread_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRlE: // global
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQMU_entry() //  [R1]
         { info_tbl: [(caRmj,
                       label: sat_saQMU_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRmj: // global
           _saQMy::P64 = P64[R1 + 7];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 15])), %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 23])));
           R2 = _saQMy::P64;
           call GHC.Event.Manager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQMV_entry() //  [R1]
         { info_tbl: [(caRmw,
                       label: sat_saQMV_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRmw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRmA; else goto caRmz;
       caRmA: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRmz: // global
           _saQMy::P64 = P64[R1 + 7];
           _saQMg::I64 = I64[R1 + 15];
           _saQMH::I64 = I64[R1 + 23];
           I64[Hp - 24] = sat_saQMU_info;
           P64[Hp - 16] = _saQMy::P64;
           I64[Hp - 8] = _saQMg::I64;
           I64[Hp] = _saQMH::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQN9_entry() //  [R1, R2]
         { info_tbl: [(caRmL,
                       label: sat_saQN9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRmL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRmP; else goto caRmQ;
       caRmP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caRmQ: // global
           I64[Sp - 16] = block_caRmI_info;
           _saQMY::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saQMY::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRmU; else goto caRmJ;
       uaRmU: // global
           call _caRmI(R1) args: 0, res: 0, upd: 0;
       caRmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRmI() //  [R1]
         { info_tbl: [(caRmI,
                       label: block_caRmI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRmI: // global
           _saQMY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caRmO_info;
           R2 = I64[R1 + 7];
           R1 = _saQMY::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRmO() //  []
         { info_tbl: [(caRmO,
                       label: block_caRmO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRmO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQN2_entry() //  [R1]
         { info_tbl: [(caRn6,
                       label: sat_saQN2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRn6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRn7; else goto caRn8;
       caRn7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRn8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caRn3_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caRn3() //  [R1, R2]
         { info_tbl: [(caRn3,
                       label: block_caRn3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRn3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caRnb; else goto caRna;
       caRnb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caRna: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saQN3_entry() //  [R1]
         { info_tbl: [(caRnc,
                       label: sat_saQN3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRnc: // global
           _saQN3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caRnd; else goto caRne;
       caRne: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caRng; else goto caRnf;
       caRng: // global
           HpAlloc = 24;
           goto caRnd;
       caRnd: // global
           R1 = _saQN3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRnf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saQN3::P64;
           _saQMg::I64 = I64[_saQN3::P64 + 16];
           I64[Hp - 16] = sat_saQN2_info;
           I64[Hp] = _saQMg::I64;
           R3 = Hp - 16;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.$wstartIOManagerThread_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(caRnk,
                       label: GHC.Event.Thread.$wstartIOManagerThread_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRnk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caRnl; else goto caRnm;
       caRnl: // global
           R1 = GHC.Event.Thread.$wstartIOManagerThread_closure;
           I64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       caRnm: // global
           _saQMg::I64 = R5;
           _saQMe::I64 = R3;
           _saQMd::I64 = R2;
           if (%MO_S_Gt_W64(R2, R5)) goto caRno; else goto caRnj;
       caRnj: // global
           if (%MO_S_Gt_W64(_saQMg::I64,
                            _saQMe::I64)) goto caRno; else goto caRnE;
       caRno: // global
           R4 = _saQMg::I64;
           R3 = _saQMd::I64;
           R2 = _saQMe::I64;
           call GHC.Event.Thread.ensureIOManagerIsRunning8_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
       caRnE: // global
           _saQMp::P64 = P64[(R4 + 24) + (_saQMg::I64 - _saQMd::I64 << 3)];
           I64[Sp - 32] = block_caRnp_info;
           R1 = _saQMp::P64;
           I64[Sp - 24] = _saQMd::I64;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = _saQMg::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaRoB; else goto caRnF;
       uaRoB: // global
           call _caRnp(R1) args: 0, res: 0, upd: 0;
       caRnF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRnp() //  [R1]
         { info_tbl: [(caRnp,
                       label: block_caRnp_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRnp: // global
           if (R1 & 7 == 1) goto uaRox; else goto caRnV;
       uaRox: // global
           Sp = Sp + 8;
           call _saQMq() args: 0, res: 0, upd: 0;
       caRnV: // global
           I64[Sp] = block_caRnO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaRoC; else goto caRnP;
       uaRoC: // global
           call _caRnO(R1) args: 0, res: 0, upd: 0;
       caRnP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRnO() //  [R1]
         { info_tbl: [(caRnO,
                       label: block_caRnO_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRnO: // global
           I64[Sp - 8] = block_caRnT_info;
           _saQNm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _saQNm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRoE; else goto caRnX;
       uaRoE: // global
           call _caRnT(R1) args: 0, res: 0, upd: 0;
       caRnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRnT() //  [R1]
         { info_tbl: [(caRnT,
                       label: block_caRnT_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRnT: // global
           I64[Sp] = block_caRo1_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRo1() //  [R1]
         { info_tbl: [(caRo1,
                       label: block_caRo1_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRo1: // global
           if (R1 == 16) goto uaRoy; else goto uaRow;
       uaRoy: // global
           Sp = Sp + 16;
           call _saQMq() args: 0, res: 0, upd: 0;
       uaRow: // global
           if (R1 == 17) goto caRoo; else goto caRo9;
       caRoo: // global
           _saQNm::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [,
                                     ‘signed’]  result hints:  [] setIOManagerControlFd(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 32])), (-1));
           I64[Sp + 8] = block_caRon_info;
           R2 = _saQNm::P64;
           Sp = Sp + 8;
           call GHC.Event.Manager.cleanup1_entry(R2) args: 8, res: 8, upd: 8;
       caRo9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caRon() //  []
         { info_tbl: [(caRon,
                       label: block_caRon_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRon: // global
           Sp = Sp + 8;
           call _saQMq() args: 0, res: 0, upd: 0;
     }
 },
 _saQMq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saQMq: // global
           I64[Sp - 8] = block_caRlY_info;
           Sp = Sp - 8;
           call GHC.Event.EPoll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caRlY() //  [R1]
         { info_tbl: [(caRlY,
                       label: block_caRlY_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRlY: // global
           I64[Sp] = block_caRm0_info;
           R2 = R1;
           call GHC.Event.Manager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRm0() //  [R1]
         { info_tbl: [(caRm0,
                       label: block_caRm0_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRm0: // global
           I64[Sp] = block_caRm2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaRoA; else goto caRm3;
       uaRoA: // global
           call _caRm2(R1) args: 0, res: 0, upd: 0;
       caRm3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRm2() //  [R1]
         { info_tbl: [(caRm2,
                       label: block_caRm2_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRm2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRnw; else goto caRnv;
       caRnw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRnv: // global
           _saQMH::I64 = I64[R1 + 95];
           I64[Hp - 24] = sat_saQMV_info;
           P64[Hp - 16] = R1;
           _saQMg::I64 = I64[Sp + 24];
           I64[Hp - 8] = _saQMg::I64;
           I64[Hp] = _saQMH::I64;
           I64[Sp - 8] = block_caRmB_info;
           R2 = Hp - 23;
           _saQMy::P64 = R1;
           R1 = _saQMg::I64;
           P64[Sp] = _saQMy::P64;
           Sp = Sp - 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRmB() //  [R1]
         { info_tbl: [(caRmB,
                       label: block_caRmB_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRmB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caRnz; else goto caRny;
       caRnz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRny: // global
           I64[Hp - 32] = sat_saQN9_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_saQN3_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp - 8] = block_caRnt_info;
           R4 = Hp - 30;
           R3 = Hp - 16;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRnt() //  [R1]
         { info_tbl: [(caRnt,
                       label: block_caRnt_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRnt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caRnD; else goto caRnC;
       caRnD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRnC: // global
           I64[Hp - 48] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saQMf::P64 = P64[Sp + 32];
           _saQNd::I64 = I64[Sp + 40] - I64[Sp + 24];
           call MO_WriteBarrier();
           P64[(_saQMf::P64 + 24) + (_saQNd::I64 << 3)] = Hp - 6;
           I64[_saQMf::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saQMf::P64 + 24) + ((I64[_saQMf::P64 + 8] << 3) + (_saQNd::I64 >> 7))] = 1 :: W8;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.619713301 UTC

[section ""data" . lvl5_raLJt_closure" {
     lvl5_raLJt_closure:
         const lvl5_raLJt_info;
 },
 sat_saQOb_entry() //  [R1]
         { info_tbl: [(caRrb,
                       label: sat_saQOb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRrb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRrc; else goto caRrd;
       caRrc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRrd: // global
           I64[Sp - 16] = block_caRr2_info;
           _saQNM::P64 = P64[R1 + 7];
           R1 = _saQNM::P64;
           P64[Sp - 8] = _saQNM::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRr2() //  [R1]
         { info_tbl: [(caRr2,
                       label: block_caRr2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRr2: // global
           _saQNM::P64 = P64[Sp + 8];
           (_saQO6::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saQO6::I64) goto caRra; else goto caRr9;
       caRra: // global
           R1 = _saQNM::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRr9: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQO6::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl5_raLJt_entry() //  []
         { info_tbl: [(caRrl,
                       label: lvl5_raLJt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRrl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRrm; else goto caRrn;
       caRrm: // global
           R1 = lvl5_raLJt_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRrn: // global
           I64[Sp - 8] = block_caRqL_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caRqL() //  []
         { info_tbl: [(caRqL,
                       label: block_caRqL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRqL: // global
           I64[Sp] = block_caRqN_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caRqN() //  [R1]
         { info_tbl: [(caRqN,
                       label: block_caRqN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRqN: // global
           I64[Sp - 8] = block_caRqP_info;
           R2 = GHC.Base.Nothing_closure+1;
           _saQNH::P64 = R1;
           R1 = R1;
           P64[Sp] = _saQNH::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRqP() //  []
         { info_tbl: [(caRqP,
                       label: block_caRqP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRqP: // global
           I64[Sp] = block_caRqR_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caRqR() //  [R1]
         { info_tbl: [(caRqR,
                       label: block_caRqR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRqR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRrt; else goto caRrs;
       caRrt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caRrs: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caRqT::P64 = Hp - 23;
           if (R1 == 0) goto caRrk; else goto caRrj;
       caRrk: // global
           I64[Hp - 8] = sat_saQOb_info;
           P64[Hp] = _caRqT::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caRrj: // global
           Hp = Hp - 16;
           I64[Sp] = block_caRru_info;
           R1 = _caRqT::P64;
           P64[Sp + 8] = _caRqT::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRru() //  [R1]
         { info_tbl: [(caRru,
                       label: block_caRru_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRru: // global
           _caRqT::P64 = P64[Sp + 8];
           (_saQNU::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadIOManagerThreadStore(R1);
           if (R1 == _saQNU::I64) goto caRrD; else goto caRrC;
       caRrD: // global
           R1 = _caRqT::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRrC: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQNU::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.638684614 UTC

[section ""data" . GHC.Event.Thread.timerManagerThreadVar_closure" {
     GHC.Event.Thread.timerManagerThreadVar_closure:
         const GHC.Event.Thread.timerManagerThreadVar_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManagerThreadVar_entry() //  [R1]
         { info_tbl: [(caRss,
                       label: GHC.Event.Thread.timerManagerThreadVar_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRss: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRst; else goto caRsu;
       caRst: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRsu: // global
           (_caRsn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRsn::I64 == 0) goto caRsp; else goto caRso;
       caRsp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRso: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRsn::I64;
           I64[Sp - 24] = block_caRsq_info;
           Sp = Sp - 24;
           call lvl5_raLJt_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caRsq() //  [R1]
         { info_tbl: [(caRsq,
                       label: block_caRsq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRsq: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.647575639 UTC

[section ""data" . lvl6_raLJu_closure" {
     lvl6_raLJu_closure:
         const lvl6_raLJu_info;
 },
 sat_saQOM_entry() //  [R1]
         { info_tbl: [(caRtc,
                       label: sat_saQOM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRtc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRtd; else goto caRte;
       caRtd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRte: // global
           I64[Sp - 16] = block_caRt3_info;
           _saQOn::P64 = P64[R1 + 7];
           R1 = _saQOn::P64;
           P64[Sp - 8] = _saQOn::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRt3() //  [R1]
         { info_tbl: [(caRt3,
                       label: block_caRt3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRt3: // global
           _saQOn::P64 = P64[Sp + 8];
           (_saQOH::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saQOH::I64) goto caRtb; else goto caRta;
       caRtb: // global
           R1 = _saQOn::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRta: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQOH::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl6_raLJu_entry() //  []
         { info_tbl: [(caRtm,
                       label: lvl6_raLJu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRtm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRtn; else goto caRto;
       caRtn: // global
           R1 = lvl6_raLJu_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRto: // global
           I64[Sp - 8] = block_caRsO_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caRsO() //  []
         { info_tbl: [(caRsO,
                       label: block_caRsO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRsO: // global
           I64[Sp] = block_caRsQ_info;
           R1 = GHC.Base.Nothing_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRsQ() //  [R1]
         { info_tbl: [(caRsQ,
                       label: block_caRsQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRsQ: // global
           I64[Sp - 8] = block_caRsS_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caRsS() //  [R1]
         { info_tbl: [(caRsS,
                       label: block_caRsS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRsS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRtt; else goto caRts;
       caRtt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caRts: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caRsU::P64 = Hp - 23;
           if (R1 == 0) goto caRtl; else goto caRtk;
       caRtl: // global
           I64[Hp - 8] = sat_saQOM_info;
           P64[Hp] = _caRsU::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caRtk: // global
           Hp = Hp - 16;
           I64[Sp] = block_caRtu_info;
           R1 = _caRsU::P64;
           P64[Sp + 8] = _caRsU::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRtu() //  [R1]
         { info_tbl: [(caRtu,
                       label: block_caRtu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRtu: // global
           _caRsU::P64 = P64[Sp + 8];
           (_saQOv::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemTimerThreadEventManagerStore(R1);
           if (R1 == _saQOv::I64) goto caRtD; else goto caRtC;
       caRtD: // global
           R1 = _caRsU::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRtC: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQOv::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.662717095 UTC

[section ""data" . GHC.Event.Thread.timerManager_closure" {
     GHC.Event.Thread.timerManager_closure:
         const GHC.Event.Thread.timerManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.timerManager_entry() //  [R1]
         { info_tbl: [(caRuo,
                       label: GHC.Event.Thread.timerManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRuo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRup; else goto caRuq;
       caRup: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRuq: // global
           (_caRuj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRuj::I64 == 0) goto caRul; else goto caRuk;
       caRul: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRuk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRuj::I64;
           I64[Sp - 24] = block_caRum_info;
           Sp = Sp - 24;
           call lvl6_raLJu_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caRum() //  [R1]
         { info_tbl: [(caRum,
                       label: block_caRum_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRum: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.668097927 UTC

[section ""cstring" . lvl7_raLJv_bytes" {
     lvl7_raLJv_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,50,49,54,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.670045064 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager2_closure" {
     GHC.Event.Thread.getSystemTimerManager2_closure:
         const GHC.Event.Thread.getSystemTimerManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager2_entry() //  []
         { info_tbl: [(caRuN,
                       label: GHC.Event.Thread.getSystemTimerManager2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRuN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRuO; else goto caRuP;
       caRuO: // global
           R1 = GHC.Event.Thread.getSystemTimerManager2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRuP: // global
           I64[Sp - 8] = block_caRuL_info;
           R2 = lvl7_raLJv_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRuL() //  [R1]
         { info_tbl: [(caRuL,
                       label: block_caRuL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRuL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.675426429 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager1_closure" {
     GHC.Event.Thread.getSystemTimerManager1_closure:
         const GHC.Event.Thread.getSystemTimerManager1_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager1_entry() //  []
         { info_tbl: [(caRv9,
                       label: GHC.Event.Thread.getSystemTimerManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRv9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRva; else goto caRvb;
       caRva: // global
           R1 = GHC.Event.Thread.getSystemTimerManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRvb: // global
           I64[Sp - 8] = block_caRv6_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRvt; else goto caRv7;
       uaRvt: // global
           call _caRv6(R1) args: 0, res: 0, upd: 0;
       caRv7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRv6() //  [R1]
         { info_tbl: [(caRv6,
                       label: block_caRv6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRv6: // global
           _saQOX::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caRve_info;
           R1 = _saQOX::P64;
           if (R1 & 7 != 0) goto uaRvs; else goto caRvg;
       uaRvs: // global
           call _caRve(R1) args: 0, res: 0, upd: 0;
       caRvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRve() //  [R1]
         { info_tbl: [(caRve,
                       label: block_caRve_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRve: // global
           if (R1 & 7 == 1) goto caRvm; else goto caRvq;
       caRvm: // global
           Sp = Sp + 8;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caRvq: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.683735 UTC

[section ""data" . GHC.Event.Thread.getSystemTimerManager_closure" {
     GHC.Event.Thread.getSystemTimerManager_closure:
         const GHC.Event.Thread.getSystemTimerManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemTimerManager_entry() //  []
         { info_tbl: [(caRvR,
                       label: GHC.Event.Thread.getSystemTimerManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRvR: // global
           call GHC.Event.Thread.getSystemTimerManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.688159662 UTC

[section ""data" . lvl8_raLJw_closure" {
     lvl8_raLJw_closure:
         const lvl8_raLJw_info;
 },
 sat_saQPy_entry() //  [R1]
         { info_tbl: [(caRws,
                       label: sat_saQPy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRws: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRwt; else goto caRwu;
       caRwt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRwu: // global
           I64[Sp - 16] = block_caRwj_info;
           _saQP9::P64 = P64[R1 + 7];
           R1 = _saQP9::P64;
           P64[Sp - 8] = _saQP9::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRwj() //  [R1]
         { info_tbl: [(caRwj,
                       label: block_caRwj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRwj: // global
           _saQP9::P64 = P64[Sp + 8];
           (_saQPt::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saQPt::I64) goto caRwr; else goto caRwq;
       caRwr: // global
           R1 = _saQP9::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRwq: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQPt::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_raLJw_entry() //  []
         { info_tbl: [(caRwC,
                       label: lvl8_raLJw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRwC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRwD; else goto caRwE;
       caRwD: // global
           R1 = lvl8_raLJw_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRwE: // global
           I64[Sp - 8] = block_caRw2_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caRw2() //  []
         { info_tbl: [(caRw2,
                       label: block_caRw2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRw2: // global
           I64[Sp] = block_caRw4_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caRw4() //  [R1]
         { info_tbl: [(caRw4,
                       label: block_caRw4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRw4: // global
           I64[Sp - 8] = block_caRw6_info;
           R2 = GHC.Tuple.()_closure+1;
           _saQP4::P64 = R1;
           R1 = R1;
           P64[Sp] = _saQP4::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRw6() //  []
         { info_tbl: [(caRw6,
                       label: block_caRw6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRw6: // global
           I64[Sp] = block_caRw8_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caRw8() //  [R1]
         { info_tbl: [(caRw8,
                       label: block_caRw8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRw8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRwK; else goto caRwJ;
       caRwK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caRwJ: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caRwa::P64 = Hp - 23;
           if (R1 == 0) goto caRwB; else goto caRwA;
       caRwB: // global
           I64[Hp - 8] = sat_saQPy_info;
           P64[Hp] = _caRwa::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caRwA: // global
           Hp = Hp - 16;
           I64[Sp] = block_caRwL_info;
           R1 = _caRwa::P64;
           P64[Sp + 8] = _caRwa::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRwL() //  [R1]
         { info_tbl: [(caRwL,
                       label: block_caRwL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRwL: // global
           _caRwa::P64 = P64[Sp + 8];
           (_saQPh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadIOManagerThreadStore(R1);
           if (R1 == _saQPh::I64) goto caRwU; else goto caRwT;
       caRwU: // global
           R1 = _caRwa::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRwT: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQPh::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.70446061 UTC

[section ""data" . GHC.Event.Thread.ioManagerLock_closure" {
     GHC.Event.Thread.ioManagerLock_closure:
         const GHC.Event.Thread.ioManagerLock_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ioManagerLock_entry() //  [R1]
         { info_tbl: [(caRxJ,
                       label: GHC.Event.Thread.ioManagerLock_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRxJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRxK; else goto caRxL;
       caRxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRxL: // global
           (_caRxE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRxE::I64 == 0) goto caRxG; else goto caRxF;
       caRxG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRxF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRxE::I64;
           I64[Sp - 24] = block_caRxH_info;
           Sp = Sp - 24;
           call lvl8_raLJw_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caRxH() //  [R1]
         { info_tbl: [(caRxH,
                       label: block_caRxH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRxH: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.711093518 UTC

[section ""data" . lvl9_raLJx_closure" {
     lvl9_raLJx_closure:
         const lvl9_raLJx_info;
         const 0;
 },
 sat_saQQl_entry() //  [R1]
         { info_tbl: [(caRyI,
                       label: sat_saQQl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRyI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRyJ; else goto caRyK;
       caRyJ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRyK: // global
           I64[Sp - 16] = block_caRyz_info;
           _saQPW::P64 = P64[R1 + 7];
           R1 = _saQPW::P64;
           P64[Sp - 8] = _saQPW::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRyz() //  [R1]
         { info_tbl: [(caRyz,
                       label: block_caRyz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRyz: // global
           _saQPW::P64 = P64[Sp + 8];
           (_saQQg::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saQQg::I64) goto caRyH; else goto caRyG;
       caRyH: // global
           R1 = _saQPW::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRyG: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQQg::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_raLJx_entry() //  []
         { info_tbl: [(caRyP,
                       label: lvl9_raLJx_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRyP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRyQ; else goto caRyR;
       caRyQ: // global
           R1 = lvl9_raLJx_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRyR: // global
           I64[Sp - 8] = block_caRy5_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caRy5() //  []
         { info_tbl: [(caRy5,
                       label: block_caRy5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRy5: // global
           _saQPH::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]) - 1;
           if (%MO_S_Gt_W64(0, _saQPH::I64)) goto caRzk; else goto caRzl;
       caRzk: // global
           _saQPJ::I64 = 0;
           goto saQPI;
       caRzl: // global
           _saQPJ::I64 = _saQPH::I64 + 1;
           goto saQPI;
       saQPI: // global
           if (%MO_S_Ge_W64(_saQPJ::I64, 0)) goto caRyV; else goto caRzg;
       caRyV: // global
           I64[Sp - 16] = block_caRyi_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saQPJ::I64;
           I64[Sp - 8] = _saQPJ::I64;
           I64[Sp] = _saQPH::I64;
           Sp = Sp - 16;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caRzg: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caRyi() //  [R1]
         { info_tbl: [(caRyi,
                       label: block_caRyi_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRyi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caRyY; else goto caRyX;
       caRyY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRyX: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = Hp - 47;
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 16] = block_caRym_info;
           R1 = Hp - 31;
           Sp = Sp + 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRym() //  [R1]
         { info_tbl: [(caRym,
                       label: block_caRym_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRym: // global
           I64[Sp - 8] = block_caRyo_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caRyo() //  [R1]
         { info_tbl: [(caRyo,
                       label: block_caRyo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRyo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRz2; else goto caRz1;
       caRz2: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caRz1: // global
           I64[Hp - 24] = GHC.STRef.STRef_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _caRyq::P64 = Hp - 23;
           if (R1 == 0) goto caRzf; else goto caRz5;
       caRzf: // global
           I64[Hp - 8] = sat_saQQl_info;
           P64[Hp] = _caRyq::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caRz5: // global
           Hp = Hp - 16;
           I64[Sp] = block_caRz3_info;
           R1 = _caRyq::P64;
           P64[Sp + 8] = _caRyq::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRz3() //  [R1]
         { info_tbl: [(caRz3,
                       label: block_caRz3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRz3: // global
           _caRyq::P64 = P64[Sp + 8];
           (_saQQ4::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetSystemEventThreadEventManagerStore(R1);
           if (R1 == _saQQ4::I64) goto caRze; else goto caRzd;
       caRze: // global
           R1 = _caRyq::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRzd: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _saQQ4::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.73004719 UTC

[section ""data" . GHC.Event.Thread.eventManager_closure" {
     GHC.Event.Thread.eventManager_closure:
         const GHC.Event.Thread.eventManager_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.eventManager_entry() //  [R1]
         { info_tbl: [(caRAm,
                       label: GHC.Event.Thread.eventManager_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRAm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRAn; else goto caRAo;
       caRAn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRAo: // global
           (_caRAh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRAh::I64 == 0) goto caRAj; else goto caRAi;
       caRAj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRAi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRAh::I64;
           I64[Sp - 24] = block_caRAk_info;
           Sp = Sp - 24;
           call lvl9_raLJx_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caRAk() //  [R1]
         { info_tbl: [(caRAk,
                       label: block_caRAk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRAk: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.735447437 UTC

[section ""cstring" . GHC.Event.Thread.ensureIOManagerIsRunning5_bytes" {
     GHC.Event.Thread.ensureIOManagerIsRunning5_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.737348931 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning4_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning4_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning4_entry() //  [R1]
         { info_tbl: [(caRAL,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRAL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRAM; else goto caRAN;
       caRAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRAN: // global
           (_caRAI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRAI::I64 == 0) goto caRAK; else goto caRAJ;
       caRAK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRAJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRAI::I64;
           R2 = GHC.Event.Thread.ensureIOManagerIsRunning5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.742929555 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning3_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning3_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning3_info;
         const 0;
 },
 sat_saQQT_entry() //  [R1]
         { info_tbl: [(caRBx,
                       label: sat_saQQT_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caRBy; else goto caRBz;
       caRBy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRBz: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 63];
           I64[Sp - 24] = I64[R1 + 71];
           P64[Sp - 16] = P64[R1 + 39];
           P64[Sp - 8] = P64[R1 + 47];
           Sp = Sp - 32;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_saQQU_entry() //  [R1]
         { info_tbl: [(caRBA,
                       label: sat_saQQU_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caRBE; else goto caRBD;
       caRBE: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRBD: // global
           _saQQA::P64 = P64[R1 + 7];
           _saQQB::P64 = P64[R1 + 15];
           _saQQC::P64 = P64[R1 + 23];
           _saQQD::P64 = P64[R1 + 31];
           _saQQH::P64 = P64[R1 + 39];
           _saQQI::P64 = P64[R1 + 47];
           _saQQE::I64 = I64[R1 + 55];
           _saQQF::I64 = I64[R1 + 63];
           _saQQG::I64 = I64[R1 + 71];
           I64[Hp - 72] = sat_saQQT_info;
           P64[Hp - 64] = _saQQA::P64;
           P64[Hp - 56] = _saQQB::P64;
           P64[Hp - 48] = _saQQC::P64;
           P64[Hp - 40] = _saQQD::P64;
           P64[Hp - 32] = _saQQH::P64;
           P64[Hp - 24] = _saQQI::P64;
           I64[Hp - 16] = _saQQE::I64;
           I64[Hp - 8] = _saQQF::I64;
           I64[Hp] = _saQQG::I64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 71;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQR3_entry() //  [R1, R2]
         { info_tbl: [(caRBP,
                       label: sat_saQR3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRBT; else goto caRBU;
       caRBT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caRBU: // global
           I64[Sp - 16] = block_caRBM_info;
           _saQQX::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saQQX::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRBY; else goto caRBN;
       uaRBY: // global
           call _caRBM(R1) args: 0, res: 0, upd: 0;
       caRBN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRBM() //  [R1]
         { info_tbl: [(caRBM,
                       label: block_caRBM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBM: // global
           _saQQX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caRBS_info;
           R2 = I64[R1 + 7];
           R1 = _saQQX::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRBS() //  []
         { info_tbl: [(caRBS,
                       label: block_caRBS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.ensureIOManagerIsRunning3_entry() //  []
         { info_tbl: [(caRBZ,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBZ: // global
           if ((Sp + -88) < SpLim) (likely: False) goto caRC4; else goto caRC5;
       caRC4: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRC5: // global
           I64[Sp - 8] = block_caRB0_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caRB0() //  [R1]
         { info_tbl: [(caRB0,
                       label: block_caRB0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRB0: // global
           I64[Sp] = block_caRB2_info;
           R2 = R1;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRB2() //  [R1]
         { info_tbl: [(caRB2,
                       label: block_caRB2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRB2: // global
           I64[Sp] = block_caRB4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaRCi; else goto caRB5;
       uaRCi: // global
           call _caRB4(R1) args: 0, res: 0, upd: 0;
       caRB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRB4() //  [R1]
         { info_tbl: [(caRB4,
                       label: block_caRB4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRB4: // global
           _saQQA::P64 = P64[R1 + 7];
           _saQQB::P64 = P64[R1 + 15];
           _saQQC::P64 = P64[R1 + 23];
           _saQQD::P64 = P64[R1 + 31];
           _saQQH::P64 = P64[R1 + 39];
           _saQQI::P64 = P64[R1 + 47];
           _saQQE::I64 = I64[R1 + 55];
           _saQQF::I64 = I64[R1 + 63];
           _saQQG::I64 = I64[R1 + 71];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saQQF::I64)));
           I64[Sp - 80] = block_caRBe_info;
           _saQQz::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp - 72] = _saQQA::P64;
           P64[Sp - 64] = _saQQB::P64;
           P64[Sp - 56] = _saQQC::P64;
           P64[Sp - 48] = _saQQD::P64;
           I64[Sp - 40] = _saQQE::I64;
           I64[Sp - 32] = _saQQF::I64;
           I64[Sp - 24] = _saQQG::I64;
           P64[Sp - 16] = _saQQH::P64;
           P64[Sp - 8] = _saQQI::P64;
           P64[Sp] = _saQQz::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uaRCj; else goto caRBf;
       uaRCj: // global
           call _caRBe(R1) args: 0, res: 0, upd: 0;
       caRBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRBe() //  [R1]
         { info_tbl: [(caRBe,
                       label: block_caRBe_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBe: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto caRCb; else goto caRCa;
       caRCb: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRCa: // global
           _saQQO::P64 = P64[R1 + 7];
           I64[Hp - 88] = GHC.Base.Just_con_info;
           P64[Hp - 80] = P64[Sp + 80];
           _saQQA::P64 = P64[Sp + 8];
           _saQQB::P64 = P64[Sp + 16];
           _saQQC::P64 = P64[Sp + 24];
           _saQQD::P64 = P64[Sp + 32];
           _saQQE::I64 = I64[Sp + 40];
           _saQQF::I64 = I64[Sp + 48];
           _saQQG::I64 = I64[Sp + 56];
           _saQQH::P64 = P64[Sp + 64];
           _saQQI::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_saQQO::P64 + 8] = Hp - 86;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQQO::P64);
           I64[Hp - 72] = sat_saQQU_info;
           P64[Hp - 64] = _saQQA::P64;
           P64[Hp - 56] = _saQQB::P64;
           P64[Hp - 48] = _saQQC::P64;
           P64[Hp - 40] = _saQQD::P64;
           P64[Hp - 32] = _saQQH::P64;
           P64[Hp - 24] = _saQQI::P64;
           I64[Hp - 16] = _saQQE::I64;
           I64[Hp - 8] = _saQQF::I64;
           I64[Hp] = _saQQG::I64;
           I64[Sp + 80] = block_caRBF_info;
           R1 = Hp - 71;
           Sp = Sp + 80;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRBF() //  [R1]
         { info_tbl: [(caRBF,
                       label: block_caRBF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRBF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRCe; else goto caRCd;
       caRCe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRCd: // global
           I64[Hp - 8] = sat_saQR3_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_caRC0_info;
           R4 = Hp - 6;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRC0() //  [R1]
         { info_tbl: [(caRC0,
                       label: block_caRC0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRC0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRCh; else goto caRCg;
       caRCh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRCg: // global
           I64[Hp - 24] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.777942531 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning2_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning2_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning2_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning2_entry() //  [R2]
         { info_tbl: [(caRDD,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRDD: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caRDE; else goto caRDF;
       caRDE: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caRDF: // global
           I64[Sp - 8] = block_caRDw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRFq; else goto caRDx;
       uaRFq: // global
           call _caRDw(R1) args: 0, res: 0, upd: 0;
       caRDx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRDw() //  [R1]
         { info_tbl: [(caRDw,
                       label: block_caRDw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRDw: // global
           if (R1 & 7 == 1) goto uaRFl; else goto caRDB;
       uaRFl: // global
           Sp = Sp + 8;
           call _caREi() args: 0, res: 0, upd: 0;
       caRDB: // global
           I64[Sp - 8] = block_caRDL_info;
           _saQRb::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saQRb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRFo; else goto caRDN;
       uaRFo: // global
           call _caRDL(R1) args: 0, res: 0, upd: 0;
       caRDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRDL() //  [R1]
         { info_tbl: [(caRDL,
                       label: block_caRDL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRDL: // global
           I64[Sp] = block_caRDR_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRDR() //  [R1]
         { info_tbl: [(caRDR,
                       label: block_caRDR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRDR: // global
           if (R1 == 16) goto uaRFm; else goto uaRFk;
       uaRFm: // global
           Sp = Sp + 16;
           call _caREi() args: 0, res: 0, upd: 0;
       uaRFk: // global
           if (R1 == 17) goto caRE5; else goto caRDZ;
       caRE5: // global
           I64[Sp + 8] = block_caRE4_info;
           R1 = GHC.Event.Thread.timerManager_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaRFr; else goto caRE6;
       uaRFr: // global
           call _caRE4(R1) args: 0, res: 0, upd: 0;
       caRE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caRDZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caRE4() //  [R1]
         { info_tbl: [(caRE4,
                       label: block_caRE4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRE4: // global
           _saQRp::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caREa_info;
           R1 = _saQRp::P64;
           if (R1 & 7 != 0) goto uaRFt; else goto caREc;
       uaRFt: // global
           call _caREa(R1) args: 0, res: 0, upd: 0;
       caREc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caREa() //  [R1]
         { info_tbl: [(caREa,
                       label: block_caREa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caREa: // global
           if (R1 & 7 == 1) goto uaRFn; else goto caREu;
       uaRFn: // global
           Sp = Sp + 8;
           call _caREi() args: 0, res: 0, upd: 0;
       caREu: // global
           _saQRr::P64 = P64[R1 + 6];
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setTimerManagerControlFd((-1));
           I64[Sp] = block_caREn_info;
           R1 = _saQRr::P64;
           if (R1 & 7 != 0) goto uaRFu; else goto caREo;
       uaRFu: // global
           call _caREn(R1) args: 0, res: 0, upd: 0;
       caREo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caREi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caREi: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _caREn() //  [R1]
         { info_tbl: [(caREn,
                       label: block_caREn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caREn: // global
           I64[Sp - 48] = block_caREs_info;
           _saQRy::P64 = P64[R1 + 23];
           _saQRD::P64 = P64[R1 + 39];
           _saQRE::P64 = P64[R1 + 47];
           _saQRA::I64 = I64[R1 + 55];
           _saQRB::I64 = I64[R1 + 63];
           _saQRC::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _saQRA::I64;
           I64[Sp - 32] = _saQRB::I64;
           I64[Sp - 24] = _saQRC::I64;
           P64[Sp - 16] = _saQRD::P64;
           P64[Sp - 8] = _saQRE::P64;
           P64[Sp] = _saQRy::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaRFw; else goto caREw;
       uaRFw: // global
           call _caREs(R1) args: 0, res: 0, upd: 0;
       caREw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caREs() //  [R1]
         { info_tbl: [(caREs,
                       label: block_caREs_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caREs: // global
           _saQRy::P64 = P64[Sp + 48];
           _saQRG::P64 = P64[R1 + 7];
           _saQRK::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_saQRy::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQRy::P64);
           I64[Sp] = block_caRED_info;
           R2 = _saQRG::P64;
           R1 = _saQRK::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRED() //  []
         { info_tbl: [(caRED,
                       label: block_caRED_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRED: // global
           I64[Sp] = block_caREF_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caREF() //  []
         { info_tbl: [(caREF,
                       label: block_caREF_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caREF: // global
           _saQRB::I64 = I64[Sp + 16];
           _saQRD::P64 = P64[Sp + 32];
           (_saQRW::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_saQS1::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saQRB::I64)));
           I64[Sp + 16] = block_caREU_info;
           R1 = _saQRD::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaRFx; else goto caREV;
       uaRFx: // global
           call _caREU(R1) args: 0, res: 0, upd: 0;
       caREV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caREU() //  [R1]
         { info_tbl: [(caREU,
                       label: block_caREU_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caREU: // global
           _saQRC::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto caRF1; else goto caRF5;
       caRF1: // global
           (_saQS7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saQRC::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
       caRF5: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saQSf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_saQRC::I64)));
           Sp = Sp + 40;
           call GHC.Event.Thread.ensureIOManagerIsRunning3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.803929649 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning6_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning6_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning6_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning6_entry() //  [R2]
         { info_tbl: [(caRGK,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRGK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caRGY; else goto caRGZ;
       caRGY: // global
           R2 = R2;
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caRGZ: // global
           I64[Sp - 8] = block_caRGH_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRI8; else goto caRGI;
       uaRI8: // global
           call _caRGH(R1) args: 0, res: 0, upd: 0;
       caRGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRGH() //  [R1]
         { info_tbl: [(caRGH,
                       label: block_caRGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRGH: // global
           _saQSm::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caRGN_info;
           R1 = _saQSm::P64;
           if (R1 & 7 != 0) goto uaRI7; else goto caRGO;
       uaRI7: // global
           call _caRGN(R1) args: 0, res: 0, upd: 0;
       caRGO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRGN() //  [R1]
         { info_tbl: [(caRGN,
                       label: block_caRGN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRGN: // global
           I64[Sp - 16] = block_caRGS_info;
           _saQSo::P64 = P64[R1 + 7];
           _saQSr::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saQSr::P64;
           P64[Sp] = _saQSo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRI9; else goto caRGT;
       uaRI9: // global
           call _caRGS(R1) args: 0, res: 0, upd: 0;
       caRGT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRGS() //  [R1]
         { info_tbl: [(caRGS,
                       label: block_caRGS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRGS: // global
           I64[Sp] = block_caRGX_info;
           _saQSt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saQSt::I64;
           if (R1 & 7 != 0) goto uaRIa; else goto caRH3;
       uaRIa: // global
           call _caRGX(R1) args: 0, res: 0, upd: 0;
       caRH3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRGX() //  [R1]
         { info_tbl: [(caRGX,
                       label: block_caRGX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRGX: // global
           if (%MO_S_Le_W64(0, I64[Sp + 16])) goto caRHE; else goto caRHH;
       caRHE: // global
           I64[Sp - 8] = 0;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 8;
           call _caRHs() args: 0, res: 0, upd: 0;
       caRHH: // global
           I64[Sp + 8] = block_caRHG_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaRIb; else goto caRHI;
       uaRIb: // global
           call _caRHG(R1) args: 0, res: 0, upd: 0;
       caRHI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRHs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRHs: // global
           I64[Sp - 8] = block_caRHu_info;
           R5 = I64[Sp];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 24];
           R2 = I64[Sp + 8];
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRHu() //  []
         { info_tbl: [(caRHu,
                       label: block_caRHu_info
                       rep:StackRep [True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRHu: // global
           _saQSF::I64 = I64[Sp + 8];
           if (_saQSF::I64 == I64[Sp + 32]) goto caRHC; else goto caRHB;
       caRHC: // global
           I64[Sp + 24] = block_caRHg_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaRId; else goto caRHi;
       uaRId: // global
           call _caRHg(R1) args: 0, res: 0, upd: 0;
       caRHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caRHB: // global
           I64[Sp + 8] = _saQSF::I64 + 1;
           Sp = Sp + 8;
           call _caRHs() args: 0, res: 0, upd: 0;
     }
 },
 _caRHg() //  [R1]
         { info_tbl: [(caRHg,
                       label: block_caRHg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRHg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRHo; else goto caRHn;
       caRHo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRHn: // global
           _saQSA::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saQSA::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQSA::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caRHG() //  [R1]
         { info_tbl: [(caRHG,
                       label: block_caRHG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRHG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRHO; else goto caRHN;
       caRHO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRHN: // global
           _saQSN::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] + 1;
           call MO_WriteBarrier();
           P64[_saQSN::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQSN::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.822724168 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning1_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning1_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning1_entry() //  []
         { info_tbl: [(caRJl,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRJl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRJm; else goto caRJn;
       caRJm: // global
           R1 = GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRJn: // global
           (_saQSV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saQSV::I64 == 0) goto caRJk; else goto caRJj;
       caRJk: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caRJj: // global
           I64[Sp - 8] = block_caRJp_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRJE; else goto caRJq;
       uaRJE: // global
           call _caRJp(R1) args: 0, res: 0, upd: 0;
       caRJq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRJp() //  [R1]
         { info_tbl: [(caRJp,
                       label: block_caRJp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRJp: // global
           I64[Sp] = block_caRJu_info;
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning6_closure+2;
           R2 = P64[R1 + 7];
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRJu() //  []
         { info_tbl: [(caRJu,
                       label: block_caRJu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRJu: // global
           I64[Sp] = block_caRJw_info;
           R1 = GHC.Event.Thread.timerManagerThreadVar_closure;
           if (R1 & 7 != 0) goto uaRJF; else goto caRJz;
       uaRJF: // global
           call _caRJw(R1) args: 0, res: 0, upd: 0;
       caRJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRJw() //  [R1]
         { info_tbl: [(caRJw,
                       label: block_caRJw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRJw: // global
           R3 = GHC.Event.Thread.ensureIOManagerIsRunning2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.833134679 UTC

[section ""data" . GHC.Event.Thread.ensureIOManagerIsRunning_closure" {
     GHC.Event.Thread.ensureIOManagerIsRunning_closure:
         const GHC.Event.Thread.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Event.Thread.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caRK5,
                       label: GHC.Event.Thread.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRK5: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.83649776 UTC

[section ""cstring" . lvl10_raLJy_bytes" {
     lvl10_raLJy_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,53,51,58,49,53,45,50,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.83867012 UTC

[section ""data" . lvl11_raLJz_closure" {
     lvl11_raLJz_closure:
         const lvl11_raLJz_info;
         const 0;
 },
 lvl11_raLJz_entry() //  []
         { info_tbl: [(caRKj,
                       label: lvl11_raLJz_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRKj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRKk; else goto caRKl;
       caRKk: // global
           R1 = lvl11_raLJz_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRKl: // global
           I64[Sp - 8] = block_caRKh_info;
           R2 = lvl10_raLJy_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRKh() //  [R1]
         { info_tbl: [(caRKh,
                       label: block_caRKh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRKh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.844322151 UTC

[section ""cstring" . lvl12_raLJA_bytes" {
     lvl12_raLJA_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,51,51,57,58,49,55,45,51,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.846191623 UTC

[section ""data" . lvl13_raLJB_closure" {
     lvl13_raLJB_closure:
         const lvl13_raLJB_info;
         const 0;
 },
 lvl13_raLJB_entry() //  []
         { info_tbl: [(caRKF,
                       label: lvl13_raLJB_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRKF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRKG; else goto caRKH;
       caRKG: // global
           R1 = lvl13_raLJB_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRKH: // global
           I64[Sp - 8] = block_caRKD_info;
           R2 = lvl12_raLJA_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRKD() //  [R1]
         { info_tbl: [(caRKD,
                       label: block_caRKD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRKD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.851362068 UTC

[section ""data" . lvl14_raLJC_closure" {
     lvl14_raLJC_closure:
         const lvl14_raLJC_info;
         const 0;
 },
 lvl14_raLJC_entry() //  [R2, R3, R4]
         { info_tbl: [(caRKY,
                       label: lvl14_raLJC_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRKY: // global
           R6 = lvl4_raLJs_closure;
           R5 = R4;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.855267814 UTC

[section ""data" . lvl15_raLJD_closure" {
     lvl15_raLJD_closure:
         const lvl15_raLJD_info;
         const 0;
 },
 lvl15_raLJD_entry() //  [R2, R3]
         { info_tbl: [(caRL9,
                       label: lvl15_raLJD_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRL9: // global
           R6 = lvl4_raLJs_closure;
           R5 = R3;
           R4 = R2;
           R3 = lvl1_raLJo_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.863852566 UTC

[section ""data" . GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caRN2,
                       label: GHC.Event.Thread.$wioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRN2: // global
           if ((Sp + -136) < SpLim) (likely: False) goto caRN3; else goto caRN4;
       caRN3: // global
           R1 = GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRN4: // global
           _saQTg::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Sp - 16] = block_caRLk_info;
           R1 = GHC.Event.Thread.numEnabledEventManagers_closure;
           I64[Sp - 8] = _saQTg::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRRQ; else goto caRLl;
       uaRRQ: // global
           call _caRLk(R1) args: 0, res: 0, upd: 0;
       caRLl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRLk() //  [R1]
         { info_tbl: [(caRLk,
                       label: block_caRLk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRLk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRN7; else goto caRN6;
       caRN7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRN6: // global
           _saQTi::P64 = P64[R1 + 7];
           _saQTl::P64 = P64[_saQTi::P64 + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_saQTi::P64 + 8] = Hp - 7;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQTi::P64);
           I64[Sp - 8] = block_caRLt_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp] = _saQTl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRRC; else goto caRLu;
       uaRRC: // global
           call _caRLt(R1) args: 0, res: 0, upd: 0;
       caRLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRLt() //  [R1]
         { info_tbl: [(caRLt,
                       label: block_caRLt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRLt: // global
           I64[Sp - 8] = block_caRLy_info;
           _saQTp::P64 = P64[R1 + 7];
           R1 = P64[_saQTp::P64 + 8];
           P64[Sp] = _saQTp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRRD; else goto caRLz;
       uaRRD: // global
           call _caRLy(R1) args: 0, res: 0, upd: 0;
       caRLz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRLy() //  [R1]
         { info_tbl: [(caRLy,
                       label: block_caRLy_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRLy: // global
           I64[Sp - 16] = block_caRLD_info;
           _saQTu::P64 = P64[R1 + 7];
           _saQTx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saQTx::P64;
           P64[Sp] = _saQTu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRRE; else goto caRLE;
       uaRRE: // global
           call _caRLD(R1) args: 0, res: 0, upd: 0;
       caRLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRLD() //  [R1]
         { info_tbl: [(caRLD,
                       label: block_caRLD_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRLD: // global
           I64[Sp - 8] = block_caRLI_info;
           _saQTy::P64 = R1;
           _saQTz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saQTz::I64;
           P64[Sp + 16] = _saQTy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRRF; else goto caRLJ;
       uaRRF: // global
           call _caRLI(R1) args: 0, res: 0, upd: 0;
       caRLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRLI() //  [R1]
         { info_tbl: [(caRLI,
                       label: block_caRLI_info
                       rep:StackRep [True, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRLI: // global
           _saQTg::I64 = I64[Sp + 48];
           _saQTB::I64 = I64[R1 + 7];
           _saQTC::I64 = I64[Sp + 8] + 1;
           if (%MO_S_Le_W64(_saQTg::I64,
                            _saQTC::I64)) goto caRNd; else goto caRQZ;
       caRNd: // global
           I64[Sp] = block_caRLT_info;
           _saQTA::P64 = R1;
           R1 = P64[Sp + 40];
           I64[Sp + 32] = _saQTB::I64;
           P64[Sp + 40] = _saQTA::P64;
           if (R1 & 7 != 0) goto uaRRG; else goto caRLU;
       uaRRG: // global
           call _caRLT(R1) args: 0, res: 0, upd: 0;
       caRLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caRQZ: // global
           _saQUh::I64 = _saQTg::I64 - 1;
           if (%MO_S_Gt_W64(0, _saQUh::I64)) goto caRQX; else goto caRQY;
       caRQX: // global
           _saQTA::P64 = R1;
           _saQUj::I64 = 0;
           goto saQUi;
       caRQY: // global
           _saQTA::P64 = R1;
           _saQUj::I64 = _saQUh::I64 + 1;
           goto saQUi;
       saQUi: // global
           if (%MO_S_Ge_W64(_saQUj::I64, 0)) goto caROi; else goto caRQT;
       caROi: // global
           I64[Sp - 32] = block_caRMC_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = _saQUj::I64;
           I64[Sp - 24] = _saQTC::I64;
           I64[Sp - 16] = _saQUh::I64;
           I64[Sp - 8] = _saQUj::I64;
           I64[Sp] = _saQTB::I64;
           P64[Sp + 48] = _saQTA::P64;
           Sp = Sp - 32;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
       caRQT: // global
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 56;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caRLT() //  [R1]
         { info_tbl: [(caRLT,
                       label: block_caRLT_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRLT: // global
           _saQTg::I64 = I64[Sp + 48];
           _saQTF::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saQTg::I64,
                            _saQTF::I64)) goto uaRRm; else goto caROf;
       uaRRm: // global
           Sp = Sp + 56;
           goto uaRRI;
       caROf: // global
           _saQTH::I64 = _saQTg::I64 - 1;
           if (%MO_S_Le_W64(_saQTF::I64,
                            _saQTH::I64)) goto caROd; else goto uaRRn;
       caROd: // global
           I64[Sp] = _saQTF::I64;
           I64[Sp + 48] = _saQTH::I64;
           call _caRMf() args: 0, res: 0, upd: 0;
       uaRRn: // global
           Sp = Sp + 56;
           goto uaRRI;
       uaRRI: // global
           call _caROe() args: 0, res: 0, upd: 0;
     }
 },
 _caRMf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRMf: // global
           Hp = Hp + 16;
           _saQTS::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto caRNr; else goto caRNq;
       caRNr: // global
           HpAlloc = 16;
           I64[Sp] = block_caRMe_info;
           R1 = _saQTS::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caRNq: // global
           _saQTy::P64 = P64[Sp + 24];
           _saQTA::P64 = P64[Sp + 40];
           _saQTB::I64 = I64[Sp + 32];
           if (%MO_S_Gt_W64(_saQTB::I64,
                            _saQTS::I64)) goto caRNt; else goto caROb;
       caRNt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saQTS::I64;
           R4 = Hp - 7;
           R3 = _saQTA::P64;
           R2 = _saQTy::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caROb: // global
           if (%MO_S_Gt_W64(_saQTS::I64,
                            I64[Sp + 8])) goto caRNv; else goto caRNB;
       caRNv: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saQTS::I64;
           R4 = Hp - 7;
           R3 = _saQTA::P64;
           R2 = _saQTy::P64;
           Sp = Sp + 56;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caRNB: // global
           Hp = Hp - 16;
           _saQU1::P64 = P64[P64[Sp + 16] + ((_saQTS::I64 - _saQTB::I64 << 3) + 24)];
           I64[Sp - 8] = block_caRNA_info;
           R1 = _saQU1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRRL; else goto caRNC;
       uaRRL: // global
           call _caRNA(R1) args: 0, res: 0, upd: 0;
       caRNC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRMe() //  [R1]
         { info_tbl: [(caRMe,
                       label: block_caRMe_info
                       rep:StackRep [True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRMe: // global
           I64[Sp] = R1;
           call _caRMf() args: 0, res: 0, upd: 0;
     }
 },
 _caRNA() //  [R1]
         { info_tbl: [(caRNA,
                       label: block_caRNA_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRNA: // global
           if (R1 & 7 == 1) goto caRNI; else goto caRNN;
       caRNI: // global
           Sp = Sp + 64;
           call lvl11_raLJz_entry() args: 8, res: 0, upd: 8;
       caRNN: // global
           I64[Sp] = block_caRNL_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaRRR; else goto caRNO;
       uaRRR: // global
           call _caRNL(R1) args: 0, res: 0, upd: 0;
       caRNO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRNL() //  [R1]
         { info_tbl: [(caRNL,
                       label: block_caRNL_info
                       rep:StackRep [True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRNL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRNW; else goto caRNV;
       caRNW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRNV: // global
           _saQU6::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp - 8] = block_caRNT_info;
           R3 = Hp - 7;
           R2 = _saQU6::P64;
           P64[Sp] = _saQU6::P64;
           Sp = Sp - 8;
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRNT() //  [R1]
         { info_tbl: [(caRNT,
                       label: block_caRNT_info
                       rep:StackRep [False, True, True, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRNT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caRO0; else goto caRNZ;
       caRO0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRNZ: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saQTx::P64 = P64[Sp + 32];
           _saQTH::I64 = I64[Sp + 64];
           _saQTS::I64 = I64[Sp + 16];
           _saQUb::I64 = _saQTS::I64 - I64[Sp + 48];
           call MO_WriteBarrier();
           P64[(_saQTx::P64 + 24) + (_saQUb::I64 << 3)] = Hp - 6;
           I64[_saQTx::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saQTx::P64 + 24) + ((I64[_saQTx::P64 + 8] << 3) + (_saQUb::I64 >> 7))] = 1 :: W8;
           if (_saQTS::I64 == _saQTH::I64) goto uaRRq; else goto caRO9;
       uaRRq: // global
           Sp = Sp + 72;
           call _caROe() args: 0, res: 0, upd: 0;
       caRO9: // global
           I64[Sp + 16] = _saQTS::I64 + 1;
           Sp = Sp + 16;
           call _caRMf() args: 0, res: 0, upd: 0;
     }
 },
 _caROe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caROe: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caRMC() //  [R1]
         { info_tbl: [(caRMC,
                       label: block_caRMC_info
                       rep:StackRep [True, True, True, True, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRMC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caROl; else goto caROk;
       caROl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caROk: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 16];
           _caRME::P64 = Hp - 7;
           if (%MO_S_Le_W64(0, I64[Sp + 40])) goto caRQR; else goto uaRRs;
       caRQR: // global
           P64[Sp - 16] = R1;
           I64[Sp - 8] = 0;
           P64[Sp] = _caRME::P64;
           Sp = Sp - 16;
           call _caRMZ() args: 0, res: 0, upd: 0;
       uaRRs: // global
           P64[Sp + 72] = R1;
           P64[Sp + 80] = _caRME::P64;
           call _caROn() args: 0, res: 0, upd: 0;
     }
 },
 _caRMZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRMZ: // global
           Hp = Hp + 16;
           _saQV2::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caRPk; else goto caRPj;
       caRPk: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caRMY_info;
           R1 = _saQV2::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caRPj: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saQV2::I64;
           _saQTy::P64 = P64[Sp + 72];
           _saQTA::P64 = P64[Sp + 96];
           _saQTB::I64 = I64[Sp + 48];
           _caRN1::P64 = Hp - 7;
           if (%MO_S_Gt_W64(_saQTB::I64,
                            _saQV2::I64)) goto caRPo; else goto caRQP;
       caRPo: // global
           R4 = _caRN1::P64;
           R3 = _saQTA::P64;
           R2 = _saQTy::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caRQP: // global
           if (%MO_S_Gt_W64(_saQV2::I64,
                            I64[Sp + 56])) goto caRPu; else goto caRPB;
       caRPu: // global
           R4 = _caRN1::P64;
           R3 = _saQTA::P64;
           R2 = _saQTy::P64;
           Sp = Sp + 104;
           call lvl14_raLJC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       caRPB: // global
           _saQVa::P64 = P64[P64[Sp + 64] + ((_saQV2::I64 - _saQTB::I64 << 3) + 24)];
           I64[Sp - 16] = block_caRPA_info;
           R1 = _saQVa::P64;
           P64[Sp - 8] = _caRN1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRRP; else goto caRPC;
       uaRRP: // global
           call _caRPA(R1) args: 0, res: 0, upd: 0;
       caRPC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRMY() //  [R1]
         { info_tbl: [(caRMY,
                       label: block_caRMY_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRMY: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _caRMZ() args: 0, res: 0, upd: 0;
     }
 },
 _caRPA() //  [R1]
         { info_tbl: [(caRPA,
                       label: block_caRPA_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRPA: // global
           if (R1 & 7 == 1) goto caRPI; else goto caRPS;
       caRPI: // global
           Sp = Sp + 120;
           call lvl13_raLJB_entry() args: 8, res: 0, upd: 8;
       caRPS: // global
           I64[Sp - 8] = block_caRPL_info;
           _saQVb::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _saQVb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRRX; else goto caRPM;
       uaRRX: // global
           call _caRPL(R1) args: 0, res: 0, upd: 0;
       caRPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRPL() //  [R1]
         { info_tbl: [(caRPL,
                       label: block_caRPL_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRPL: // global
           I64[Sp - 8] = block_caRPQ_info;
           _saQVf::P64 = P64[R1 + 15];
           R1 = P64[Sp + 112];
           P64[Sp] = _saQVf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRRY; else goto caRPU;
       uaRRY: // global
           call _caRPQ(R1) args: 0, res: 0, upd: 0;
       caRPU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRPQ() //  [R1]
         { info_tbl: [(caRPQ,
                       label: block_caRPQ_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRPQ: // global
           _caRN1::P64 = P64[Sp + 24];
           _saQV2::I64 = I64[Sp + 40];
           if (%MO_S_Ge_W64(_saQV2::I64,
                            I64[R1 + 7])) goto caRQ4; else goto caRQO;
       caRQ4: // global
           I64[Sp] = block_caRQ2_info;
           R3 = _caRN1::P64;
           R2 = P64[Sp + 8];
           call restartPollLoop_raLJq_entry(R3, R2) args: 8, res: 8, upd: 8;
       caRQO: // global
           _caRME::P64 = P64[Sp + 48];
           if (%MO_S_Gt_W64(0, _saQV2::I64)) goto caRQy; else goto caRQN;
       caRQy: // global
           R3 = _caRN1::P64;
           R2 = _caRME::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caRQN: // global
           if (%MO_S_Gt_W64(_saQV2::I64,
                            I64[Sp + 64])) goto caRQE; else goto caRQM;
       caRQE: // global
           R3 = _caRN1::P64;
           R2 = _caRME::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caRQM: // global
           _saQTz::I64 = I64[Sp + 88];
           _saQUn::P64 = P64[Sp + 32];
           _saQVb::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[(_saQUn::P64 + 24) + (_saQV2::I64 << 3)] = _saQVb::P64;
           I64[_saQUn::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saQUn::P64 + 24) + ((I64[_saQUn::P64 + 8] << 3) + (_saQV2::I64 >> 7))] = 1 :: W8;
           if (_saQV2::I64 == _saQTz::I64) goto uaRRx; else goto caRQK;
       uaRRx: // global
           P64[Sp + 128] = _caRME::P64;
           P64[Sp + 120] = _saQUn::P64;
           Sp = Sp + 48;
           call _caROn() args: 0, res: 0, upd: 0;
       caRQK: // global
           I64[Sp + 40] = _saQV2::I64 + 1;
           Sp = Sp + 32;
           call _caRMZ() args: 0, res: 0, upd: 0;
     }
 },
 _caRQ2() //  [R1]
         { info_tbl: [(caRQ2,
                       label: block_caRQ2_info
                       rep:StackRep [False, True, False, False, True, False, True, True,
                                     True, True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRQ2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caRQ8; else goto caRQ7;
       caRQ8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRQ7: // global
           _caRME::P64 = P64[Sp + 48];
           _caRN1::P64 = P64[Sp + 24];
           _saQV2::I64 = I64[Sp + 40];
           if (%MO_S_Gt_W64(0, _saQV2::I64)) goto caRQc; else goto caRQt;
       caRQc: // global
           Hp = Hp - 40;
           R3 = _caRN1::P64;
           R2 = _caRME::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caRQt: // global
           if (%MO_S_Gt_W64(_saQV2::I64,
                            I64[Sp + 64])) goto caRQi; else goto caRQs;
       caRQi: // global
           Hp = Hp - 40;
           R3 = _caRN1::P64;
           R2 = _caRME::P64;
           Sp = Sp + 136;
           call lvl15_raLJD_entry(R3, R2) args: 8, res: 0, upd: 8;
       caRQs: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           _saQTz::I64 = I64[Sp + 88];
           _saQUn::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[(_saQUn::P64 + 24) + (_saQV2::I64 << 3)] = Hp - 6;
           I64[_saQUn::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saQUn::P64 + 24) + ((I64[_saQUn::P64 + 8] << 3) + (_saQV2::I64 >> 7))] = 1 :: W8;
           if (_saQV2::I64 == _saQTz::I64) goto uaRRv; else goto caRQq;
       uaRRv: // global
           P64[Sp + 128] = _caRME::P64;
           P64[Sp + 120] = _saQUn::P64;
           Sp = Sp + 48;
           call _caROn() args: 0, res: 0, upd: 0;
       caRQq: // global
           I64[Sp + 40] = _saQV2::I64 + 1;
           Sp = Sp + 32;
           call _caRMZ() args: 0, res: 0, upd: 0;
     }
 },
 _caROn() //  []
         { info_tbl: [(caROn,
                       label: block_caROn_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caROn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caROr; else goto caROq;
       caROr: // global
           HpAlloc = 40;
           I64[Sp] = block_caROn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caROq: // global
           _saQTC::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saQTC::I64,
                            I64[Sp + 16])) goto caROS; else goto caROT;
       caROS: // global
           Hp = Hp - 40;
           I64[Sp + 56] = _saQTC::I64;
           Sp = Sp + 16;
           call _caROG() args: 0, res: 0, upd: 0;
       caROT: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 80];
           P64[Hp - 8] = P64[Sp + 72];
           I64[Hp] = I64[Sp + 24];
           _saQTp::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_saQTp::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQTp::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caROG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caROG: // global
           I64[Sp - 8] = block_caROI_info;
           R5 = I64[Sp + 40];
           R4 = P64[Sp + 56];
           R3 = I64[Sp];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Event.Thread.$wstartIOManagerThread_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _caROI() //  []
         { info_tbl: [(caROI,
                       label: block_caROI_info
                       rep:StackRep [True, True, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caROI: // global
           _saQUx::I64 = I64[Sp + 48];
           if (_saQUx::I64 == I64[Sp + 8]) goto uaRRA; else goto caROP;
       uaRRA: // global
           Sp = Sp + 8;
           call _caROy() args: 0, res: 0, upd: 0;
       caROP: // global
           I64[Sp + 48] = _saQUx::I64 + 1;
           Sp = Sp + 8;
           call _caROG() args: 0, res: 0, upd: 0;
     }
 },
 _caROy() //  []
         { info_tbl: [(caROy,
                       label: block_caROy_info
                       rep:StackRep [True, True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caROy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caROC; else goto caROB;
       caROC: // global
           HpAlloc = 40;
           I64[Sp] = block_caROy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caROB: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl1_raLJo_closure+1;
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 56];
           I64[Hp] = I64[Sp + 8];
           _saQTp::P64 = P64[Sp + 48];
           call MO_WriteBarrier();
           P64[_saQTp::P64 + 8] = Hp - 31;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _saQTp::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.919311689 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged2_entry() //  []
         { info_tbl: [(caRUX,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRUX: // global
           call GHC.Event.Thread.$wioManagerCapabilitiesChanged_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.922748118 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() //  []
         { info_tbl: [(caRVb,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRVb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRVc; else goto caRVd;
       caRVc: // global
           R1 = GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRVd: // global
           I64[Sp - 8] = block_caRV8_info;
           R1 = GHC.Event.Thread.ioManagerLock_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRVh; else goto caRV9;
       uaRVh: // global
           call _caRV8(R1) args: 0, res: 0, upd: 0;
       caRV9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRV8() //  [R1]
         { info_tbl: [(caRV8,
                       label: block_caRV8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRV8: // global
           R3 = GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure+2;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.928267738 UTC

[section ""data" . GHC.Event.Thread.ioManagerCapabilitiesChanged_closure" {
     GHC.Event.Thread.ioManagerCapabilitiesChanged_closure:
         const GHC.Event.Thread.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Event.Thread.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caRVw,
                       label: GHC.Event.Thread.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRVw: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.93201699 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager2_closure" {
     GHC.Event.Thread.getSystemEventManager2_closure:
         const GHC.Event.Thread.getSystemEventManager2_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager2_entry() //  [R2, R3, R4]
         { info_tbl: [(caRVI,
                       label: GHC.Event.Thread.getSystemEventManager2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRVI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caRVM; else goto caRVL;
       caRVM: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.getSystemEventManager2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRVL: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R4;
           R6 = lvl4_raLJs_closure;
           R5 = Hp - 7;
           R4 = R2;
           R3 = R3;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.$windexError_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.938760376 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager1_closure" {
     GHC.Event.Thread.getSystemEventManager1_closure:
         const GHC.Event.Thread.getSystemEventManager1_info;
         const 0;
 },
 sat_saQWh_entry() //  [R1]
         { info_tbl: [(caRWJ,
                       label: sat_saQWh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRWJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRWK; else goto caRWL;
       caRWK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRWL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saQWi_entry() //  [R1]
         { info_tbl: [(caRWQ,
                       label: sat_saQWi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRWQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caRWR; else goto caRWS;
       caRWR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRWS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caRWz_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaRWZ; else goto caRWA;
       uaRWZ: // global
           call _caRWz(R1) args: 0, res: 0, upd: 0;
       caRWA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caRWz() //  [R1]
         { info_tbl: [(caRWz,
                       label: block_caRWz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRWz: // global
           if (R1 & 7 == 1) goto caRWN; else goto caRWO;
       caRWN: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caRWO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caRWY; else goto caRWX;
       caRWY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caRWX: // global
           _saQWg::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_saQWh_info;
           P64[Hp - 16] = _saQWg::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Thread.getSystemEventManager1_entry() //  []
         { info_tbl: [(caRX0,
                       label: GHC.Event.Thread.getSystemEventManager1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRX0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caRX1; else goto caRX2;
       caRX1: // global
           R1 = GHC.Event.Thread.getSystemEventManager1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRX2: // global
           I64[Sp - 8] = block_caRVW_info;
           R1 = CurrentTSO;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRVW() //  [R2]
         { info_tbl: [(caRVW,
                       label: block_caRVW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRVW: // global
           I64[Sp - 8] = block_caRW0_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           I64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRXg; else goto caRW1;
       uaRXg: // global
           call _caRW0(R1) args: 0, res: 0, upd: 0;
       caRW1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRW0() //  [R1]
         { info_tbl: [(caRW0,
                       label: block_caRW0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRW0: // global
           _saQVX::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caRW5_info;
           R1 = _saQVX::P64;
           if (R1 & 7 != 0) goto uaRXh; else goto caRW6;
       uaRXh: // global
           call _caRW5(R1) args: 0, res: 0, upd: 0;
       caRW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRW5() //  [R1]
         { info_tbl: [(caRW5,
                       label: block_caRW5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRW5: // global
           I64[Sp - 16] = block_caRWa_info;
           _saQW0::P64 = P64[R1 + 15];
           _saQW2::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saQW2::P64;
           P64[Sp] = _saQW0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaRXi; else goto caRWb;
       uaRXi: // global
           call _caRWa(R1) args: 0, res: 0, upd: 0;
       caRWb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRWa() //  [R1]
         { info_tbl: [(caRWa,
                       label: block_caRWa_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRWa: // global
           I64[Sp - 8] = block_caRWf_info;
           _saQW3::P64 = R1;
           _saQW4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saQW4::I64;
           P64[Sp + 16] = _saQW3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaRXj; else goto caRWg;
       uaRXj: // global
           call _caRWf(R1) args: 0, res: 0, upd: 0;
       caRWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRWf() //  [R1]
         { info_tbl: [(caRWf,
                       label: block_caRWf_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRWf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caRX9; else goto caRX8;
       caRX9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRX8: // global
           _saQVR::I64 = I64[Sp + 32];
           _saQW3::P64 = P64[Sp + 24];
           _saQW4::I64 = I64[Sp + 8];
           _saQW5::P64 = R1;
           if (%MO_S_Gt_W64(_saQW4::I64,
                            _saQVR::I64)) goto caRXd; else goto caRXf;
       caRXf: // global
           if (%MO_S_Gt_W64(_saQVR::I64,
                            I64[R1 + 7])) goto caRXd; else goto caRXe;
       caRXd: // global
           Hp = Hp - 24;
           R4 = _saQVR::I64;
           R3 = _saQW3::P64;
           R2 = _saQW5::P64;
           Sp = Sp + 40;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caRXe: // global
           I64[Hp - 16] = sat_saQWi_info;
           P64[Hp] = P64[P64[Sp + 16] + ((_saQVR::I64 - _saQW4::I64 << 3) + 24)];
           R1 = Hp - 16;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.960050759 UTC

[section ""data" . GHC.Event.Thread.getSystemEventManager_closure" {
     GHC.Event.Thread.getSystemEventManager_closure:
         const GHC.Event.Thread.getSystemEventManager_info;
         const 0;
 },
 GHC.Event.Thread.getSystemEventManager_entry() //  []
         { info_tbl: [(caRYl,
                       label: GHC.Event.Thread.getSystemEventManager_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRYl: // global
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.963098593 UTC

[section ""cstring" . lvl16_raLJE_bytes" {
     lvl16_raLJE_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.964891444 UTC

[section ""data" . lvl17_raLJF_closure" {
     lvl17_raLJF_closure:
         const lvl17_raLJF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_raLJF_entry() //  [R1]
         { info_tbl: [(caRYz,
                       label: lvl17_raLJF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRYz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRYA; else goto caRYB;
       caRYA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRYB: // global
           (_caRYw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRYw::I64 == 0) goto caRYy; else goto caRYx;
       caRYy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRYx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRYw::I64;
           R2 = lvl16_raLJE_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.968894349 UTC

[section ""data" . lvl18_raLJG_closure" {
     lvl18_raLJG_closure:
         const lvl18_raLJG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_raLJG_entry() //  [R1]
         { info_tbl: [(caRYQ,
                       label: lvl18_raLJG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRYQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRYR; else goto caRYS;
       caRYR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRYS: // global
           (_caRYN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRYN::I64 == 0) goto caRYP; else goto caRYO;
       caRYP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRYO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRYN::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl17_raLJF_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.972887955 UTC

[section ""data" . lvl19_raLJH_closure" {
     lvl19_raLJH_closure:
         const lvl19_raLJH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_raLJH_entry() //  [R1]
         { info_tbl: [(caRZ9,
                       label: lvl19_raLJH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRZa; else goto caRZb;
       caRZa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRZb: // global
           (_caRZ6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caRZ6::I64 == 0) goto caRZ8; else goto caRZ7;
       caRZ8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caRZ7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caRZ6::I64;
           R2 = lvl18_raLJG_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.977306994 UTC

[section ""data" . lvl20_raLJI_closure" {
     lvl20_raLJI_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.979013131 UTC

[section ""data" . lvl21_raLJJ_closure" {
     lvl21_raLJJ_closure:
         const (,)_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.980751596 UTC

[section ""data" . lvl22_raLJK_closure" {
     lvl22_raLJK_closure:
         const (,)_con_info;
         const GHC.Types.True_closure+2;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.982544692 UTC

[section ""cstring" . lvl23_raLJL_bytes" {
     lvl23_raLJL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,56,51,58,51,45,49,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:52.984449294 UTC

[section ""data" . lvl24_raLJM_closure" {
     lvl24_raLJM_closure:
         const lvl24_raLJM_info;
         const 0;
 },
 lvl24_raLJM_entry() //  []
         { info_tbl: [(caRZu,
                       label: lvl24_raLJM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caRZv; else goto caRZw;
       caRZv: // global
           R1 = lvl24_raLJM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caRZw: // global
           I64[Sp - 8] = block_caRZs_info;
           R2 = lvl23_raLJL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caRZs() //  [R1]
         { info_tbl: [(caRZs,
                       label: block_caRZs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.002866645 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM1_closure" {
     GHC.Event.Thread.threadWaitReadSTM1_closure:
         const GHC.Event.Thread.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saQXu_entry() //  [R1]
         { info_tbl: [(caS1u,
                       label: sat_saQXu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1u: // global
           _saQXu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caS1v; else goto caS1w;
       caS1w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS1y; else goto caS1x;
       caS1y: // global
           HpAlloc = 16;
           goto caS1v;
       caS1v: // global
           R1 = _saQXu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caS1x: // global
           _saQWv::P64 = P64[_saQXu::P64 + 7];
           _saQXp::P64 = P64[_saQXu::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saQXp::P64;
           I64[Sp - 8] = block_caS1s_info;
           R2 = Hp - 6;
           R1 = _saQWv::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS1s() //  []
         { info_tbl: [(caS1s,
                       label: block_caS1s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1s: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl31_saQXn_entry() //  [R1, R2, R3]
         { info_tbl: [(caS1A,
                       label: lvl31_saQXn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caS1E; else goto caS1D;
       caS1E: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS1D: // global
           _saQWv::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_saQXu_info;
           P64[Hp - 8] = _saQWv::P64;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saQY4_entry() //  [R1, R2]
         { info_tbl: [(caS2K,
                       label: $wgo_saQY4_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS2K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caS2L; else goto caS2M;
       caS2L: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caS2M: // global
           I64[Sp - 24] = block_caS2D_info;
           _saQY4::P64 = R1;
           _saQX4::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saQX4::I64;
           P64[Sp - 8] = _saQY4::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaS39; else goto caS2E;
       uaS39: // global
           call _caS2D(R1) args: 0, res: 0, upd: 0;
       caS2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS2D() //  [R1]
         { info_tbl: [(caS2D,
                       label: block_caS2D_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS2D: // global
           if (R1 & 7 == 1) goto caS2H; else goto caS2I;
       caS2H: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS2I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS2U; else goto caS2T;
       caS2U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caS2T: // global
           _saQY8::P64 = P64[R1 + 6];
           _saQY9::P64 = P64[R1 + 14];
           _saQY7::I64 = I64[R1 + 22];
           if (_saQY7::I64 == I64[Sp + 8]) goto caS38; else goto caS32;
       caS38: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saQY8::P64;
           R3 = _saQY9::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS32: // global
           Hp = Hp - 16;
           I64[Sp] = block_caS2Y_info;
           R2 = _saQY9::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saQY8::P64;
           I64[Sp + 16] = _saQY7::I64;
           call $wgo_saQY4_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS2Y() //  [R1, R2, R3]
         { info_tbl: [(caS2Y,
                       label: block_caS2Y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS2Y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caS35; else goto caS34;
       caS35: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caS34: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saQYT_entry() //  [R1, R2]
         { info_tbl: [(caS3U,
                       label: $wgo_saQYT_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caS3V; else goto caS3W;
       caS3V: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caS3W: // global
           I64[Sp - 24] = block_caS3N_info;
           _saQYT::P64 = R1;
           _saQX4::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saQX4::I64;
           P64[Sp - 8] = _saQYT::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaS4j; else goto caS3O;
       uaS4j: // global
           call _caS3N(R1) args: 0, res: 0, upd: 0;
       caS3O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS3N() //  [R1]
         { info_tbl: [(caS3N,
                       label: block_caS3N_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3N: // global
           if (R1 & 7 == 1) goto caS3R; else goto caS3S;
       caS3R: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS3S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS44; else goto caS43;
       caS44: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caS43: // global
           _saQYX::P64 = P64[R1 + 6];
           _saQYY::P64 = P64[R1 + 14];
           _saQYW::I64 = I64[R1 + 22];
           if (_saQYW::I64 == I64[Sp + 8]) goto caS4i; else goto caS4c;
       caS4i: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saQYX::P64;
           R3 = _saQYY::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS4c: // global
           Hp = Hp - 16;
           I64[Sp] = block_caS48_info;
           R2 = _saQYY::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saQYX::P64;
           I64[Sp + 16] = _saQYW::I64;
           call $wgo_saQYT_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS48() //  [R1, R2, R3]
         { info_tbl: [(caS48,
                       label: block_caS48_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS48: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caS4f; else goto caS4e;
       caS4f: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caS4e: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saQXk_entry() //  [R1, R2]
         { info_tbl: [(caS4o,
                       label: $wio_saQXk_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS4o: // global
           _saQXl::P64 = R2;
           _saQXk::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caS4p; else goto caS4q;
       caS4q: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caS4s; else goto caS4r;
       caS4s: // global
           HpAlloc = 80;
           goto caS4p;
       caS4p: // global
           R2 = _saQXl::P64;
           R1 = _saQXk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caS4r: // global
           _saQWv::P64 = P64[_saQXk::P64 + 6];
           _saQWV::P64 = P64[_saQXk::P64 + 14];
           _saQWX::P64 = P64[_saQXk::P64 + 22];
           _saQWY::P64 = P64[_saQXk::P64 + 30];
           _saQX3::P64 = P64[_saQXk::P64 + 38];
           _saQX2::I64 = I64[_saQXk::P64 + 46];
           _saQX4::I64 = I64[_saQXk::P64 + 54];
           _saQX6::I64 = I64[_saQXk::P64 + 62];
           I64[Hp - 72] = lvl31_saQXn_info;
           P64[Hp - 64] = _saQWv::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saQX4::I64;
           I64[Hp - 32] = _saQX2::I64;
           I64[Hp - 24] = _saQX6::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caS14_info;
           R5 = _saQXl::P64;
           R4 = Hp - 14;
           R3 = _saQX4::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saQWV::P64;
           P64[Sp - 48] = _saQWX::P64;
           P64[Sp - 40] = _saQWY::P64;
           P64[Sp - 32] = _saQX3::P64;
           I64[Sp - 24] = _saQX4::I64;
           I64[Sp - 16] = _saQX6::I64;
           P64[Sp - 8] = _saQXl::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caS14() //  [R1]
         { info_tbl: [(caS14,
                       label: block_caS14_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS14: // global
           I64[Sp - 8] = block_caS18_info;
           _saQXz::P64 = R1;
           R1 = R1;
           P64[Sp] = _saQXz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaS6M; else goto caS19;
       uaS6M: // global
           call _caS18(R1) args: 0, res: 0, upd: 0;
       caS19: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS18() //  [R1]
         { info_tbl: [(caS18,
                       label: block_caS18_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS18: // global
           if (R1 & 7 == 1) goto caS4l; else goto caS4m;
       caS4l: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saQXA() args: 0, res: 0, upd: 0;
       caS4m: // global
           I64[Sp] = block_caS1e_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caS1e() //  [R1]
         { info_tbl: [(caS1e,
                       label: block_caS1e_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS6l; else goto caS6k;
       caS6l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caS6k: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saQXA() args: 0, res: 0, upd: 0;
     }
 },
 _saQXA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saQXA: // global
           _saQXC::P64 = P64[Sp];
           I64[Sp] = block_caS1I_info;
           R1 = _saQXC::P64;
           if (R1 & 7 != 0) goto uaS77; else goto caS1J;
       uaS77: // global
           call _caS1I(R1) args: 0, res: 0, upd: 0;
       caS1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS1I() //  [R1]
         { info_tbl: [(caS1I,
                       label: block_caS1I_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1I: // global
           _saQXF::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saQXG::I64 = _saQXF::I64 & 8;
           if (_saQXG::I64 != 0) goto uaS6F; else goto uaS6E;
       uaS6F: // global
           I64[Sp] = _saQXG::I64;
           I64[Sp + 40] = _saQXF::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caS1U() args: 0, res: 0, upd: 0;
       uaS6E: // global
           I64[Sp + 32] = _saQXG::I64;
           I64[Sp + 64] = _saQXF::I64;
           Sp = Sp + 16;
           call _caS3c() args: 0, res: 0, upd: 0;
     }
 },
 _caS1U() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1U: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caS4A; else goto caS4z;
       caS4A: // global
           HpAlloc = 32;
           _saQXG::I64 = I64[Sp];
           I64[Sp] = block_caS1T_info;
           R1 = _saQXG::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caS4z: // global
           _saQXF::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saQXF::I64) goto caS4C; else goto caS4D;
       caS4C: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caS4D: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saQXF::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caS28_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caS1T() //  [R1]
         { info_tbl: [(caS1T,
                       label: block_caS1T_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1T: // global
           I64[Sp] = R1;
           call _caS1U() args: 0, res: 0, upd: 0;
     }
 },
 _caS28() //  [R1]
         { info_tbl: [(caS28,
                       label: block_caS28_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS28: // global
           I64[Sp] = block_caS2a_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaS6S; else goto caS2b;
       uaS6S: // global
           call _caS2a(R1) args: 0, res: 0, upd: 0;
       caS2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS2a() //  [R1]
         { info_tbl: [(caS2a,
                       label: block_caS2a_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS2a: // global
           if (R1 & 7 == 1) goto caS4H; else goto caS5p;
       caS4H: // global
           I64[Sp + 40] = block_caS2f_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaS6T; else goto caS2g;
       uaS6T: // global
           call _caS2f(R1) args: 0, res: 0, upd: 0;
       caS2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caS5p: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS2f() //  [R1]
         { info_tbl: [(caS2f,
                       label: block_caS2f_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS2f: // global
           _saQXl::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caS4K; else goto caS5j;
       caS4K: // global
           I64[Sp] = block_caS2k_info;
           R1 = P64[_saQXl::P64 + 8];
           if (R1 & 7 != 0) goto uaS6U; else goto caS2l;
       uaS6U: // global
           call _caS2k(R1) args: 0, res: 0, upd: 0;
       caS2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caS5j: // global
           I64[Sp + 24] = block_caS5h_info;
           R5 = _saQXl::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caS2k() //  [R1]
         { info_tbl: [(caS2k,
                       label: block_caS2k_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS2k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS4N; else goto caS4M;
       caS4N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caS4M: // global
           _saQX4::I64 = I64[Sp + 8];
           _saQXV::P64 = P64[R1 + 7];
           _saQXX::P64 = P64[R1 + 15];
           _saQXW::I64 = I64[R1 + 23];
           _saQXY::I64 = _saQX4::I64 & (I64[_saQXV::P64 + 8] - 1);
           _saQY3::P64 = P64[(_saQXV::P64 + 24) + (_saQXY::I64 << 3)];
           I64[Hp - 8] = $wgo_saQY4_info;
           I64[Hp] = _saQX4::I64;
           I64[Sp - 8] = block_caS4O_info;
           R2 = _saQY3::P64;
           R1 = Hp - 7;
           I64[Sp] = _saQXY::I64;
           P64[Sp + 8] = _saQXX::P64;
           I64[Sp + 16] = _saQXW::I64;
           P64[Sp + 24] = _saQXV::P64;
           Sp = Sp - 8;
           call $wgo_saQY4_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS4O() //  [R1, R2, R3]
         { info_tbl: [(caS4O,
                       label: block_caS4O_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS4O: // global
           I64[Sp - 16] = block_caS4Q_info;
           _saQYi::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saQYi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaS6Z; else goto caS4S;
       uaS6Z: // global
           call _caS4Q(R1) args: 0, res: 0, upd: 0;
       caS4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS4Q() //  [R1]
         { info_tbl: [(caS4Q,
                       label: block_caS4Q_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS4Q: // global
           if (R1 & 7 == 1) goto uaS6H; else goto caS53;
       uaS6H: // global
           Sp = Sp + 56;
           call _caS60() args: 0, res: 0, upd: 0;
       caS53: // global
           _saQXV::P64 = P64[Sp + 48];
           _saQXY::I64 = I64[Sp + 24];
           _saQYi::P64 = P64[Sp + 16];
           _saQYk::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saQXV::P64 + 24) + (_saQXY::I64 << 3)] = _saQYk::P64;
           I64[_saQXV::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saQXV::P64 + 24) + ((I64[_saQXV::P64 + 8] << 3) + (_saQXY::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caS51_info;
           R1 = _saQYi::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaS70; else goto caS54;
       uaS70: // global
           call _caS51(R1) args: 0, res: 0, upd: 0;
       caS54: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS51() //  [R1]
         { info_tbl: [(caS51,
                       label: block_caS51_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS51: // global
           if (R1 & 7 == 1) goto uaS6I; else goto caS5e;
       uaS6I: // global
           Sp = Sp + 32;
           call _caS60() args: 0, res: 0, upd: 0;
       caS5e: // global
           _saQXW::I64 = I64[Sp + 16];
           _saQXX::P64 = P64[Sp + 8];
           I64[_saQXW::I64] = I64[_saQXW::I64] - 1;
           call MO_Touch(_saQXX::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS5h() //  []
         { info_tbl: [(caS5h,
                       label: block_caS5h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS5h: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS3c() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS5t; else goto caS5s;
       caS5t: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caS3b_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caS5s: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caS3i_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS3b() //  [R1]
         { info_tbl: [(caS3b,
                       label: block_caS3b_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3b: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caS3c() args: 0, res: 0, upd: 0;
     }
 },
 _caS3i() //  [R1]
         { info_tbl: [(caS3i,
                       label: block_caS3i_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3i: // global
           I64[Sp] = block_caS3k_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaS6W; else goto caS3l;
       uaS6W: // global
           call _caS3k(R1) args: 0, res: 0, upd: 0;
       caS3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS3k() //  [R1]
         { info_tbl: [(caS3k,
                       label: block_caS3k_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3k: // global
           if (R1 & 7 == 1) goto caS5x; else goto caS6f;
       caS5x: // global
           I64[Sp + 40] = block_caS3p_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaS6X; else goto caS3q;
       uaS6X: // global
           call _caS3p(R1) args: 0, res: 0, upd: 0;
       caS3q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caS6f: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS3p() //  [R1]
         { info_tbl: [(caS3p,
                       label: block_caS3p_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3p: // global
           _saQXl::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caS5A; else goto caS69;
       caS5A: // global
           I64[Sp] = block_caS3u_info;
           R1 = P64[_saQXl::P64 + 8];
           if (R1 & 7 != 0) goto uaS6Y; else goto caS3v;
       uaS6Y: // global
           call _caS3u(R1) args: 0, res: 0, upd: 0;
       caS3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caS69: // global
           I64[Sp + 24] = block_caS67_info;
           R5 = _saQXl::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caS3u() //  [R1]
         { info_tbl: [(caS3u,
                       label: block_caS3u_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS3u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS5D; else goto caS5C;
       caS5D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caS5C: // global
           _saQX4::I64 = I64[Sp + 8];
           _saQYK::P64 = P64[R1 + 7];
           _saQYM::P64 = P64[R1 + 15];
           _saQYL::I64 = I64[R1 + 23];
           _saQYN::I64 = _saQX4::I64 & (I64[_saQYK::P64 + 8] - 1);
           _saQYS::P64 = P64[(_saQYK::P64 + 24) + (_saQYN::I64 << 3)];
           I64[Hp - 8] = $wgo_saQYT_info;
           I64[Hp] = _saQX4::I64;
           I64[Sp - 8] = block_caS5E_info;
           R2 = _saQYS::P64;
           R1 = Hp - 7;
           I64[Sp] = _saQYN::I64;
           P64[Sp + 8] = _saQYM::P64;
           I64[Sp + 16] = _saQYL::I64;
           P64[Sp + 24] = _saQYK::P64;
           Sp = Sp - 8;
           call $wgo_saQYT_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS5E() //  [R1, R2, R3]
         { info_tbl: [(caS5E,
                       label: block_caS5E_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS5E: // global
           I64[Sp - 16] = block_caS5G_info;
           _saQZ7::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saQZ7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaS73; else goto caS5I;
       uaS73: // global
           call _caS5G(R1) args: 0, res: 0, upd: 0;
       caS5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS5G() //  [R1]
         { info_tbl: [(caS5G,
                       label: block_caS5G_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS5G: // global
           if (R1 & 7 == 1) goto uaS6K; else goto caS5T;
       uaS6K: // global
           Sp = Sp + 56;
           call _caS60() args: 0, res: 0, upd: 0;
       caS5T: // global
           _saQYK::P64 = P64[Sp + 48];
           _saQYN::I64 = I64[Sp + 24];
           _saQZ7::P64 = P64[Sp + 16];
           _saQZ9::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saQYK::P64 + 24) + (_saQYN::I64 << 3)] = _saQZ9::P64;
           I64[_saQYK::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saQYK::P64 + 24) + ((I64[_saQYK::P64 + 8] << 3) + (_saQYN::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caS5R_info;
           R1 = _saQZ7::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaS74; else goto caS5U;
       uaS74: // global
           call _caS5R(R1) args: 0, res: 0, upd: 0;
       caS5U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS5R() //  [R1]
         { info_tbl: [(caS5R,
                       label: block_caS5R_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS5R: // global
           if (R1 & 7 == 1) goto uaS6L; else goto caS64;
       uaS6L: // global
           Sp = Sp + 32;
           call _caS60() args: 0, res: 0, upd: 0;
       caS64: // global
           _saQYL::I64 = I64[Sp + 16];
           _saQYM::P64 = P64[Sp + 8];
           I64[_saQYL::I64] = I64[_saQYL::I64] - 1;
           call MO_Touch(_saQYM::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS60() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS60: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS67() //  []
         { info_tbl: [(caS67,
                       label: block_caS67_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS67: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saQZs_entry() //  [R1, R2]
         { info_tbl: [(caS7g,
                       label: io1_saQZs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caS7h; else goto caS7i;
       caS7h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caS7i: // global
           I64[Sp - 16] = block_caS7d_info;
           _saQXk::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saQXk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaS7m; else goto caS7e;
       uaS7m: // global
           call _caS7d(R1) args: 0, res: 0, upd: 0;
       caS7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS7d() //  [R1]
         { info_tbl: [(caS7d,
                       label: block_caS7d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7d: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saQXk_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQZO_entry() //  [R1]
         { info_tbl: [(caS7z,
                       label: sat_saQZO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caS7A; else goto caS7B;
       caS7A: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caS7B: // global
           I64[Sp - 8] = block_caS7x_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caS7x() //  []
         { info_tbl: [(caS7x,
                       label: block_caS7x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7x: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQZJ_entry() //  [R1]
         { info_tbl: [(caS7R,
                       label: sat_saQZJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caS7S; else goto caS7T;
       caS7S: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caS7T: // global
           I64[Sp - 8] = block_caS7I_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS7I() //  [R1]
         { info_tbl: [(caS7I,
                       label: block_caS7I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7I: // global
           I64[Sp] = block_caS7K_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaS8m; else goto caS7L;
       uaS8m: // global
           call _caS7K(R1) args: 0, res: 0, upd: 0;
       caS7L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS7K() //  [R1]
         { info_tbl: [(caS7K,
                       label: block_caS7K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7K: // global
           if (R1 & 7 == 1) goto caS7O; else goto caS7P;
       caS7O: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caS7P: // global
           I64[Sp] = block_caS80_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaS8n; else goto caS82;
       uaS8n: // global
           call _caS80(R1) args: 0, res: 0, upd: 0;
       caS82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS80() //  [R1]
         { info_tbl: [(caS80,
                       label: block_caS80_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS80: // global
           if (I64[R1 + 7] & 4 == 0) goto caS8i; else goto caS8c;
       caS8i: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caS8c: // global
           R1 = lvl19_raLJH_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQZZ_entry() //  [R1, R2]
         { info_tbl: [(caS8z,
                       label: sat_saQZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caS8A; else goto caS8B;
       caS8A: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caS8B: // global
           I64[Sp - 16] = block_caS8x_info;
           _saQZW::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saQZW::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS8x() //  []
         { info_tbl: [(caS8x,
                       label: block_caS8x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8x: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQZU_entry() //  [R1]
         { info_tbl: [(caS8I,
                       label: sat_saQZU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8I: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saQZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saQZV_entry() //  [R1]
         { info_tbl: [(caS8Q,
                       label: sat_saQZV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8Q: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0b_entry() //  [R1]
         { info_tbl: [(caS9f,
                       label: sat_saR0b_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9f: // global
           _saR0b::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caS9g; else goto caS9h;
       caS9h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caS9j; else goto caS9i;
       caS9j: // global
           HpAlloc = 16;
           goto caS9g;
       caS9g: // global
           R1 = _saR0b::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caS9i: // global
           _saQWv::P64 = P64[_saR0b::P64 + 7];
           _saQX5::P64 = P64[_saR0b::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saQX5::P64;
           I64[Sp - 8] = block_caS9d_info;
           R2 = Hp - 6;
           R1 = _saQWv::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS9d() //  []
         { info_tbl: [(caS9d,
                       label: block_caS9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9d: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0s_entry() //  [R1, R2]
         { info_tbl: [(caS9A,
                       label: sat_saR0s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caS9B; else goto caS9C;
       caS9B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caS9C: // global
           I64[Sp - 16] = block_caS9y_info;
           _saR0p::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saR0p::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS9y() //  []
         { info_tbl: [(caS9y,
                       label: block_caS9y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9y: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0n_entry() //  [R1]
         { info_tbl: [(caS9J,
                       label: sat_saR0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9J: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saQZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0o_entry() //  [R1]
         { info_tbl: [(caS9R,
                       label: sat_saR0o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9R: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0x_entry() //  [R1]
         { info_tbl: [(caS9Y,
                       label: sat_saR0x_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caS9Z; else goto caSa0;
       caS9Z: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSa0: // global
           I64[Sp - 24] = block_caS9r_info;
           _saQXj::P64 = P64[R1 + 7];
           _saQZs::P64 = P64[R1 + 15];
           R1 = _saQXj::P64;
           P64[Sp - 16] = _saQXj::P64;
           P64[Sp - 8] = _saQZs::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS9r() //  [R1]
         { info_tbl: [(caS9r,
                       label: block_caS9r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9r: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSa3; else goto caSa2;
       caSa3: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSa2: // global
           I64[Hp - 56] = sat_saR0s_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saR0n_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saR0o_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caS9U_info;
           R2 = Hp - 54;
           _saR0m::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saR0m::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS9U() //  [R1]
         { info_tbl: [(caS9U,
                       label: block_caS9U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9U: // global
           _saQXj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caS9W_info;
           R2 = P64[Sp + 16];
           _saR0v::P64 = R1;
           R1 = _saQXj::P64;
           P64[Sp + 16] = _saR0v::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS9W() //  []
         { info_tbl: [(caS9W,
                       label: block_caS9W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS9W: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0I_entry() //  [R1]
         { info_tbl: [(caSaq,
                       label: sat_saR0I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSaq: // global
           _saR0I::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caSar; else goto caSas;
       caSas: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSau; else goto caSat;
       caSau: // global
           HpAlloc = 16;
           goto caSar;
       caSar: // global
           R1 = _saR0I::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSat: // global
           _saQWv::P64 = P64[_saR0I::P64 + 7];
           _saQX5::P64 = P64[_saR0I::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saQX5::P64;
           I64[Sp - 8] = block_caSao_info;
           R2 = Hp - 6;
           R1 = _saQWv::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSao() //  []
         { info_tbl: [(caSao,
                       label: block_caSao_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSao: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0Y_entry() //  [R1, R2]
         { info_tbl: [(caSaG,
                       label: sat_saR0Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSaG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSaH; else goto caSaI;
       caSaH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSaI: // global
           I64[Sp - 16] = block_caSaE_info;
           _saR0V::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saR0V::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSaE() //  []
         { info_tbl: [(caSaE,
                       label: block_caSaE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSaE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0T_entry() //  [R1]
         { info_tbl: [(caSaP,
                       label: sat_saR0T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSaP: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saQZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR0U_entry() //  [R1]
         { info_tbl: [(caSaX,
                       label: sat_saR0U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSaX: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR1a_entry() //  [R1]
         { info_tbl: [(caSbm,
                       label: sat_saR1a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSbm: // global
           _saR1a::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caSbn; else goto caSbo;
       caSbo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSbq; else goto caSbp;
       caSbq: // global
           HpAlloc = 16;
           goto caSbn;
       caSbn: // global
           R1 = _saR1a::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSbp: // global
           _saQWv::P64 = P64[_saR1a::P64 + 7];
           _saQX5::P64 = P64[_saR1a::P64 + 15];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saQX5::P64;
           I64[Sp - 8] = block_caSbk_info;
           R2 = Hp - 6;
           R1 = _saQWv::P64;
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSbk() //  []
         { info_tbl: [(caSbk,
                       label: block_caSbk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSbk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saQWr_entry() //  [R1]
         { info_tbl: [(caSbw,
                       label: io_saQWr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSbw: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caSbx; else goto caSby;
       caSbx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSby: // global
           I64[Sp - 24] = block_caRZU_info;
           _saQWl::P64 = P64[R1 + 7];
           _saQWm::P64 = P64[R1 + 15];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _saQWl::P64;
           P64[Sp - 8] = _saQWm::P64;
           Sp = Sp - 24;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRZU() //  [R1]
         { info_tbl: [(caRZU,
                       label: block_caRZU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZU: // global
           I64[Sp - 8] = block_caRZW_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caRZW() //  [R1]
         { info_tbl: [(caRZW,
                       label: block_caRZW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZW: // global
           I64[Sp] = block_caRZY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSdT; else goto caRZZ;
       uaSdT: // global
           call _caRZY(R1) args: 0, res: 0, upd: 0;
       caRZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRZY() //  [R1]
         { info_tbl: [(caRZY,
                       label: block_caRZY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZY: // global
           if (R1 & 7 == 1) goto caSbt; else goto caSbu;
       caSbt: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caSbu: // global
           I64[Sp] = block_caS04_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaSdU; else goto caS05;
       uaSdU: // global
           call _caS04(R1) args: 0, res: 0, upd: 0;
       caS05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS04() //  [R1]
         { info_tbl: [(caS04,
                       label: block_caS04_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS04: // global
           I64[Sp - 40] = block_caS09_info;
           _saQWC::P64 = R1;
           _saQWD::P64 = P64[R1 + 7];
           _saQWF::P64 = P64[R1 + 23];
           _saQWH::P64 = P64[R1 + 31];
           _saQWJ::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saQWD::P64;
           P64[Sp - 24] = _saQWF::P64;
           P64[Sp - 16] = _saQWH::P64;
           P64[Sp - 8] = _saQWJ::P64;
           P64[Sp] = _saQWC::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaSdV; else goto caS0a;
       uaSdV: // global
           call _caS09(R1) args: 0, res: 0, upd: 0;
       caS0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS09() //  [R1]
         { info_tbl: [(caS09,
                       label: block_caS09_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS09: // global
           I64[Sp - 8] = block_caS0e_info;
           _saQWQ::P64 = R1;
           _saQWR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saQWR::I64;
           P64[Sp + 16] = _saQWQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSdW; else goto caS0f;
       uaSdW: // global
           call _caS0e(R1) args: 0, res: 0, upd: 0;
       caS0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS0e() //  [R1]
         { info_tbl: [(caS0e,
                       label: block_caS0e_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS0e: // global
           I64[Sp - 8] = block_caS0j_info;
           _saQWS::P64 = R1;
           _saQWT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saQWT::I64;
           P64[Sp + 16] = _saQWS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSdX; else goto caS0k;
       uaSdX: // global
           call _caS0j(R1) args: 0, res: 0, upd: 0;
       caS0k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS0j() //  [R1]
         { info_tbl: [(caS0j,
                       label: block_caS0j_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS0j: // global
           _saQWm::P64 = P64[Sp + 80];
           _saQWV::P64 = P64[R1 + 7];
           _saQWX::P64 = P64[R1 + 23];
           _saQWY::P64 = P64[R1 + 31];
           (_saQX2::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caS0q_info;
           R1 = _saQWm::P64;
           I64[Sp - 8] = _saQX2::I64;
           P64[Sp] = _saQWY::P64;
           P64[Sp + 48] = _saQWX::P64;
           P64[Sp + 80] = _saQWV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSdY; else goto caS0r;
       uaSdY: // global
           call _caS0q(R1) args: 0, res: 0, upd: 0;
       caS0r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS0q() //  [R1]
         { info_tbl: [(caS0q,
                       label: block_caS0q_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS0q: // global
           I64[Sp - 8] = block_caS0v_info;
           _saQX3::P64 = R1;
           _saQX4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saQX4::I64;
           P64[Sp + 88] = _saQX3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSdZ; else goto caS0w;
       uaSdZ: // global
           call _caS0v(R1) args: 0, res: 0, upd: 0;
       caS0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS0v() //  [R1]
         { info_tbl: [(caS0v,
                       label: block_caS0v_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS0v: // global
           I64[Sp - 16] = block_caS0A_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caS0A() //  [R1]
         { info_tbl: [(caS0A,
                       label: block_caS0A_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS0A: // global
           _saQWQ::P64 = P64[Sp + 72];
           _saQWR::I64 = I64[Sp + 56];
           _saQWS::P64 = P64[Sp + 64];
           _saQXa::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saQWR::I64,
                            _saQXa::I64)) goto caSbO; else goto caSdB;
       caSdB: // global
           if (%MO_S_Gt_W64(_saQXa::I64,
                            I64[Sp + 48])) goto caSbO; else goto caSbP;
       caSbO: // global
           R4 = _saQXa::I64;
           R3 = _saQWQ::P64;
           R2 = _saQWS::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caSbP: // global
           _saQXh::P64 = P64[P64[Sp + 80] + ((_saQXa::I64 - _saQWR::I64 << 3) + 24)];
           I64[Sp] = block_caS0Q_info;
           _saQX9::I64 = R1;
           R1 = _saQXh::P64;
           I64[Sp + 80] = _saQX9::I64;
           if (R1 & 7 != 0) goto uaSe0; else goto caS0R;
       uaSe0: // global
           call _caS0Q(R1) args: 0, res: 0, upd: 0;
       caS0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS0Q() //  [R1]
         { info_tbl: [(caS0Q,
                       label: block_caS0Q_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS0Q: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caSbS; else goto caSbR;
       caSbS: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSbR: // global
           _saQXj::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saQXk_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saQZs_info;
           P64[Hp - 24] = Hp - 102;
           _caS78::P64 = Hp - 30;
           _saQZQ::I64 = I64[Sp + 80];
           if (_saQZQ::I64 != 0) goto uaSdL; else goto caScx;
       uaSdL: // global
           if (_saQZQ::I64 != 1) goto caSbY; else goto caSd2;
       caSbY: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caS8q_info;
           R1 = _saQXj::P64;
           P64[Sp + 112] = _saQXj::P64;
           P64[Sp + 120] = _caS78::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caSd2: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caSax_info;
           R1 = _saQXj::P64;
           P64[Sp + 112] = _saQXj::P64;
           P64[Sp + 120] = _caS78::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caScx: // global
           I64[Hp - 16] = sat_saR0x_info;
           P64[Hp - 8] = _saQXj::P64;
           P64[Hp] = _caS78::P64;
           I64[Sp + 8] = block_caSa6_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS8q() //  [R1]
         { info_tbl: [(caS8q,
                       label: block_caS8q_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8q: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSc1; else goto caSc0;
       caSc1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSc0: // global
           I64[Hp - 56] = sat_saQZZ_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saQZU_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saQZV_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caS8T_info;
           R2 = Hp - 54;
           _saQZT::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saQZT::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS8T() //  [R1]
         { info_tbl: [(caS8T,
                       label: block_caS8T_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8T: // global
           I64[Sp] = block_caS8V_info;
           R2 = P64[Sp + 112];
           _saR02::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saR02::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS8V() //  []
         { info_tbl: [(caS8V,
                       label: block_caS8V_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8V: // global
           I64[Sp] = block_caS8X_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaSe2; else goto caS8Y;
       uaSe2: // global
           call _caS8X(R1) args: 0, res: 0, upd: 0;
       caS8Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS8X() //  [R1]
         { info_tbl: [(caS8X,
                       label: block_caS8X_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS8X: // global
           I64[Sp] = block_caS92_info;
           _saR05::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saR05::P64;
           if (R1 & 7 != 0) goto uaSe3; else goto caS93;
       uaSe3: // global
           call _caS92(R1) args: 0, res: 0, upd: 0;
       caS93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caS92() //  [R1]
         { info_tbl: [(caS92,
                       label: block_caS92_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS92: // global
           if (R1 & 7 == 1) goto caSc9; else goto caScp;
       caSc9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caScc; else goto caScb;
       caScc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caScb: // global
           I64[Hp - 16] = sat_saR0b_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caSc5_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caScp: // global
           I64[Sp + 8] = block_caScn_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaSe4; else goto caScq;
       uaSe4: // global
           call _caScn(R1) args: 0, res: 0, upd: 0;
       caScq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSc5() //  []
         { info_tbl: [(caSc5,
                       label: block_caSc5_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSc5: // global
           I64[Sp] = block_caSc7_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaSeb; else goto caSce;
       uaSeb: // global
           call _caSc7(R1) args: 0, res: 0, upd: 0;
       caSce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSc7() //  [R1]
         { info_tbl: [(caSc7,
                       label: block_caSc7_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSc7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSck; else goto caScj;
       caSck: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caScj: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 _caScn() //  [R1]
         { info_tbl: [(caScn,
                       label: block_caScn_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caScn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caScw; else goto caScv;
       caScw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caScv: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 _caSax() //  [R1]
         { info_tbl: [(caSax,
                       label: block_caSax_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSax: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSd5; else goto caSd4;
       caSd5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSd4: // global
           I64[Hp - 56] = sat_saR0Y_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saR0T_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saR0U_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caSb0_info;
           R2 = Hp - 54;
           _saR0S::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saR0S::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSb0() //  [R1]
         { info_tbl: [(caSb0,
                       label: block_caSb0_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSb0: // global
           I64[Sp] = block_caSb2_info;
           R2 = P64[Sp + 112];
           _saR11::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saR11::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSb2() //  []
         { info_tbl: [(caSb2,
                       label: block_caSb2_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSb2: // global
           I64[Sp] = block_caSb4_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaSe8; else goto caSb5;
       uaSe8: // global
           call _caSb4(R1) args: 0, res: 0, upd: 0;
       caSb5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSb4() //  [R1]
         { info_tbl: [(caSb4,
                       label: block_caSb4_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSb4: // global
           I64[Sp] = block_caSb9_info;
           _saR14::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saR14::P64;
           if (R1 & 7 != 0) goto uaSe9; else goto caSba;
       uaSe9: // global
           call _caSb9(R1) args: 0, res: 0, upd: 0;
       caSba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSb9() //  [R1]
         { info_tbl: [(caSb9,
                       label: block_caSb9_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSb9: // global
           if (R1 & 7 == 1) goto caSdd; else goto caSdt;
       caSdd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSdg; else goto caSdf;
       caSdg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSdf: // global
           I64[Hp - 16] = sat_saR1a_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caSd9_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caSdt: // global
           I64[Sp + 8] = block_caSdr_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaSea; else goto caSdu;
       uaSea: // global
           call _caSdr(R1) args: 0, res: 0, upd: 0;
       caSdu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSd9() //  []
         { info_tbl: [(caSd9,
                       label: block_caSd9_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSd9: // global
           I64[Sp] = block_caSdb_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaSeh; else goto caSdi;
       uaSeh: // global
           call _caSdb(R1) args: 0, res: 0, upd: 0;
       caSdi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSdb() //  [R1]
         { info_tbl: [(caSdb,
                       label: block_caSdb_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSdb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSdo; else goto caSdn;
       caSdo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSdn: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 _caSdr() //  [R1]
         { info_tbl: [(caSdr,
                       label: block_caSdr_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSdr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSdA; else goto caSdz;
       caSdA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSdz: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 _caSa6() //  [R1]
         { info_tbl: [(caSa6,
                       label: block_caSa6_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSa6: // global
           I64[Sp] = block_caSa8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSe5; else goto caSa9;
       uaSe5: // global
           call _caSa8(R1) args: 0, res: 0, upd: 0;
       caSa9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSa8() //  [R1]
         { info_tbl: [(caSa8,
                       label: block_caSa8_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSa8: // global
           I64[Sp] = block_caSad_info;
           _saR0C::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saR0C::P64;
           if (R1 & 7 != 0) goto uaSe6; else goto caSae;
       uaSe6: // global
           call _caSad(R1) args: 0, res: 0, upd: 0;
       caSae: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSad() //  [R1]
         { info_tbl: [(caSad,
                       label: block_caSad_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSad: // global
           if (R1 & 7 == 1) goto caScE; else goto caScU;
       caScE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caScH; else goto caScG;
       caScH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caScG: // global
           I64[Hp - 16] = sat_saR0I_info;
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_caScA_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
       caScU: // global
           I64[Sp + 8] = block_caScS_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaSe7; else goto caScV;
       uaSe7: // global
           call _caScS(R1) args: 0, res: 0, upd: 0;
       caScV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caScA() //  []
         { info_tbl: [(caScA,
                       label: block_caScA_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caScA: // global
           I64[Sp] = block_caScC_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaSee; else goto caScJ;
       uaSee: // global
           call _caScC(R1) args: 0, res: 0, upd: 0;
       caScJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caScC() //  [R1]
         { info_tbl: [(caScC,
                       label: block_caScC_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caScC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caScP; else goto caScO;
       caScP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caScO: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 _caScS() //  [R1]
         { info_tbl: [(caScS,
                       label: block_caScS_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caScS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSd1; else goto caSd0;
       caSd1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSd0: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 _caS7q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7q: // global
           Hp = Hp + 64;
           _saQZz::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caSbW; else goto caSbV;
       caSbW: // global
           HpAlloc = 64;
           I64[Sp - 8] = block_caS7p_info;
           R1 = _saQZz::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSbV: // global
           I64[Hp - 56] = sat_saQZO_info;
           P64[Hp - 48] = P64[Sp];
           P64[Hp - 40] = _saQZz::P64;
           I64[Hp - 32] = sat_saQZJ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caS7p() //  [R1]
         { info_tbl: [(caS7p,
                       label: block_caS7p_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS7p: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caS7q() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.threadWaitReadSTM1_entry() //  [R2, R3]
         { info_tbl: [(caSeo,
                       label: GHC.Event.Thread.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSeo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caSep; else goto caSeq;
       caSep: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSeq: // global
           I64[Sp - 24] = block_caRZN_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caRZN() //  [R1]
         { info_tbl: [(caRZN,
                       label: block_caRZN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRZN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSet; else goto caSes;
       caSet: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSes: // global
           I64[Hp - 16] = io_saQWr_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caRZP::P64 = Hp - 15;
           if (R1 == 0) goto caSen; else goto caSem;
       caSen: // global
           R1 = _caRZP::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caSem: // global
           R1 = _caRZP::P64;
           Sp = Sp + 24;
           call io_saQWr_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.200881271 UTC

[section ""data" . threadWaitReadSTM2_raLJN_closure" {
     threadWaitReadSTM2_raLJN_closure:
         const threadWaitReadSTM2_raLJN_info;
         const 0;
 },
 threadWaitReadSTM2_raLJN_entry() //  [R2]
         { info_tbl: [(caSoW,
                       label: threadWaitReadSTM2_raLJN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSoW: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.204343652 UTC

[section ""data" . GHC.Event.Thread.threadWaitReadSTM_closure" {
     GHC.Event.Thread.threadWaitReadSTM_closure:
         const GHC.Event.Thread.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caSp7,
                       label: GHC.Event.Thread.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSp7: // global
           R2 = R2;
           call threadWaitReadSTM2_raLJN_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.208082643 UTC

[section ""data" . threadWaitWriteSTM1_raLJO_closure" {
     threadWaitWriteSTM1_raLJO_closure:
         const threadWaitWriteSTM1_raLJO_info;
         const 0;
 },
 threadWaitWriteSTM1_raLJO_entry() //  [R2]
         { info_tbl: [(caSpi,
                       label: threadWaitWriteSTM1_raLJO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSpi: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.211397026 UTC

[section ""data" . GHC.Event.Thread.threadWaitWriteSTM_closure" {
     GHC.Event.Thread.threadWaitWriteSTM_closure:
         const GHC.Event.Thread.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caSpt,
                       label: GHC.Event.Thread.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSpt: // global
           R2 = R2;
           call threadWaitWriteSTM1_raLJO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.215169424 UTC

[section ""cstring" . lvl25_raLJP_bytes" {
     lvl25_raLJP_bytes:
         I8[] [116,104,114,101,97,100,87,97,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.216967302 UTC

[section ""data" . lvl26_raLJQ_closure" {
     lvl26_raLJQ_closure:
         const lvl26_raLJQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_raLJQ_entry() //  [R1]
         { info_tbl: [(caSpH,
                       label: lvl26_raLJQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSpH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSpI; else goto caSpJ;
       caSpI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSpJ: // global
           (_caSpE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caSpE::I64 == 0) goto caSpG; else goto caSpF;
       caSpG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caSpF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caSpE::I64;
           R2 = lvl25_raLJP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.221297695 UTC

[section ""data" . lvl27_raLJR_closure" {
     lvl27_raLJR_closure:
         const lvl27_raLJR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl27_raLJR_entry() //  [R1]
         { info_tbl: [(caSpY,
                       label: lvl27_raLJR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSpY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSpZ; else goto caSq0;
       caSpZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSq0: // global
           (_caSpV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caSpV::I64 == 0) goto caSpX; else goto caSpW;
       caSpX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caSpW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caSpV::I64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = 9;
           R2 = lvl26_raLJQ_closure;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.225556419 UTC

[section ""data" . lvl28_raLJS_closure" {
     lvl28_raLJS_closure:
         const lvl28_raLJS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_raLJS_entry() //  [R1]
         { info_tbl: [(caSqh,
                       label: lvl28_raLJS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSqi; else goto caSqj;
       caSqi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSqj: // global
           (_caSqe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caSqe::I64 == 0) goto caSqg; else goto caSqf;
       caSqg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caSqf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caSqe::I64;
           R2 = lvl27_raLJR_closure;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.2408153 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead1_closure" {
     GHC.Event.Thread.threadWaitRead1_closure:
         const GHC.Event.Thread.threadWaitRead1_info;
         const 0;
 },
 lvl31_saR2l_entry() //  [R1, R2, R3]
         { info_tbl: [(caSs7,
                       label: lvl31_saR2l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSs7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caSs8; else goto caSs9;
       caSs8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSs9: // global
           I64[Sp - 8] = block_caSs5_info;
           R2 = R3;
           R1 = P64[R1 + 5];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSs5() //  []
         { info_tbl: [(caSs5,
                       label: block_caSs5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSs5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saR2Z_entry() //  [R1, R2]
         { info_tbl: [(caStg,
                       label: $wgo_saR2Z_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caSth; else goto caSti;
       caSth: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSti: // global
           I64[Sp - 24] = block_caSt9_info;
           _saR2Z::P64 = R1;
           _saR22::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saR22::I64;
           P64[Sp - 8] = _saR2Z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaStF; else goto caSta;
       uaStF: // global
           call _caSt9(R1) args: 0, res: 0, upd: 0;
       caSta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSt9() //  [R1]
         { info_tbl: [(caSt9,
                       label: block_caSt9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSt9: // global
           if (R1 & 7 == 1) goto caStd; else goto caSte;
       caStd: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSte: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caStq; else goto caStp;
       caStq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caStp: // global
           _saR33::P64 = P64[R1 + 6];
           _saR34::P64 = P64[R1 + 14];
           _saR32::I64 = I64[R1 + 22];
           if (_saR32::I64 == I64[Sp + 8]) goto caStE; else goto caSty;
       caStE: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saR33::P64;
           R3 = _saR34::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSty: // global
           Hp = Hp - 16;
           I64[Sp] = block_caStu_info;
           R2 = _saR34::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saR33::P64;
           I64[Sp + 16] = _saR32::I64;
           call $wgo_saR2Z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caStu() //  [R1, R2, R3]
         { info_tbl: [(caStu,
                       label: block_caStu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caStB; else goto caStA;
       caStB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caStA: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wgo_saR3O_entry() //  [R1, R2]
         { info_tbl: [(caSuq,
                       label: $wgo_saR3O_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSuq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caSur; else goto caSus;
       caSur: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSus: // global
           I64[Sp - 24] = block_caSuj_info;
           _saR3O::P64 = R1;
           _saR22::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 16] = _saR22::I64;
           P64[Sp - 8] = _saR3O::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaSuP; else goto caSuk;
       uaSuP: // global
           call _caSuj(R1) args: 0, res: 0, upd: 0;
       caSuk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSuj() //  [R1]
         { info_tbl: [(caSuj,
                       label: block_caSuj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSuj: // global
           if (R1 & 7 == 1) goto caSun; else goto caSuo;
       caSun: // global
           R3 = GHC.Event.IntTable.Empty_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSuo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSuA; else goto caSuz;
       caSuA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSuz: // global
           _saR3S::P64 = P64[R1 + 6];
           _saR3T::P64 = P64[R1 + 14];
           _saR3R::I64 = I64[R1 + 22];
           if (_saR3R::I64 == I64[Sp + 8]) goto caSuO; else goto caSuI;
       caSuO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saR3S::P64;
           R3 = _saR3T::P64;
           R2 = Hp - 6;
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSuI: // global
           Hp = Hp - 16;
           I64[Sp] = block_caSuE_info;
           R2 = _saR3T::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _saR3S::P64;
           I64[Sp + 16] = _saR3R::I64;
           call $wgo_saR3O_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSuE() //  [R1, R2, R3]
         { info_tbl: [(caSuE,
                       label: block_caSuE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSuE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caSuL; else goto caSuK;
       caSuL: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caSuK: // global
           I64[Hp - 24] = GHC.Event.IntTable.Bucket_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R3;
           I64[Hp] = I64[Sp + 16];
           R3 = Hp - 22;
           R2 = R2;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_saR2i_entry() //  [R1, R2]
         { info_tbl: [(caSuU,
                       label: $wio_saR2i_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSuU: // global
           _saR2j::P64 = R2;
           _saR2i::P64 = R1;
           if ((Sp + -80) < SpLim) (likely: False) goto caSuV; else goto caSuW;
       caSuW: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caSuY; else goto caSuX;
       caSuY: // global
           HpAlloc = 80;
           goto caSuV;
       caSuV: // global
           R2 = _saR2j::P64;
           R1 = _saR2i::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSuX: // global
           _saR1t::P64 = P64[_saR2i::P64 + 6];
           _saR1T::P64 = P64[_saR2i::P64 + 14];
           _saR1V::P64 = P64[_saR2i::P64 + 22];
           _saR1W::P64 = P64[_saR2i::P64 + 30];
           _saR21::P64 = P64[_saR2i::P64 + 38];
           _saR20::I64 = I64[_saR2i::P64 + 46];
           _saR22::I64 = I64[_saR2i::P64 + 54];
           _saR24::I64 = I64[_saR2i::P64 + 62];
           I64[Hp - 72] = lvl31_saR2l_info;
           P64[Hp - 64] = _saR1t::P64;
           I64[Hp - 56] = GHC.Event.Manager.FdData_con_info;
           P64[Hp - 48] = Hp - 69;
           I64[Hp - 40] = _saR22::I64;
           I64[Hp - 32] = _saR20::I64;
           I64[Hp - 24] = _saR24::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 64] = block_caSrN_info;
           R5 = _saR2j::P64;
           R4 = Hp - 14;
           R3 = _saR22::I64;
           R2 = GHC.Base.++_closure+2;
           P64[Sp - 56] = _saR1T::P64;
           P64[Sp - 48] = _saR1V::P64;
           P64[Sp - 40] = _saR1W::P64;
           P64[Sp - 32] = _saR21::P64;
           I64[Sp - 24] = _saR22::I64;
           I64[Sp - 16] = _saR24::I64;
           P64[Sp - 8] = _saR2j::P64;
           Sp = Sp - 64;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSrN() //  [R1]
         { info_tbl: [(caSrN,
                       label: block_caSrN_info
                       rep:StackRep [False, False, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSrN: // global
           I64[Sp - 8] = block_caSrR_info;
           _saR2u::P64 = R1;
           R1 = R1;
           P64[Sp] = _saR2u::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSxi; else goto caSrS;
       uaSxi: // global
           call _caSrR(R1) args: 0, res: 0, upd: 0;
       caSrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSrR() //  [R1]
         { info_tbl: [(caSrR,
                       label: block_caSrR_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSrR: // global
           if (R1 & 7 == 1) goto caSuR; else goto caSuS;
       caSuR: // global
           I64[Sp] = 0;
           P64[Sp - 8] = GHC.Event.Internal.$fMonoidEventLifetime1_closure;
           Sp = Sp - 8;
           call _saR2v() args: 0, res: 0, upd: 0;
       caSuS: // global
           I64[Sp] = block_caSrX_info;
           R2 = P64[R1 + 6];
           call GHC.Event.Manager.$weventsOf_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSrX() //  [R1]
         { info_tbl: [(caSrX,
                       label: block_caSrX_info
                       rep:StackRep [False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSrX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSwR; else goto caSwQ;
       caSwR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSwQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           P64[Sp - 8] = Hp - 7;
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _saR2v() args: 0, res: 0, upd: 0;
     }
 },
 _saR2v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saR2v: // global
           _saR2x::P64 = P64[Sp];
           I64[Sp] = block_caSse_info;
           R1 = _saR2x::P64;
           if (R1 & 7 != 0) goto uaSxD; else goto caSsf;
       uaSxD: // global
           call _caSse(R1) args: 0, res: 0, upd: 0;
       caSsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSse() //  [R1]
         { info_tbl: [(caSse,
                       label: block_caSse_info
                       rep:StackRep [True, False, False, False, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSse: // global
           _saR2A::I64 = I64[Sp + 8] | I64[Sp + 64];
           _saR2B::I64 = _saR2A::I64 & 8;
           if (_saR2B::I64 != 0) goto uaSxb; else goto uaSxa;
       uaSxb: // global
           I64[Sp] = _saR2B::I64;
           I64[Sp + 40] = _saR2A::I64;
           I64[Sp + 64] = I64[R1 + 7];
           call _caSsq() args: 0, res: 0, upd: 0;
       uaSxa: // global
           I64[Sp + 32] = _saR2B::I64;
           I64[Sp + 64] = _saR2A::I64;
           Sp = Sp + 16;
           call _caStI() args: 0, res: 0, upd: 0;
     }
 },
 _caSsq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSsq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caSv6; else goto caSv5;
       caSv6: // global
           HpAlloc = 32;
           _saR2B::I64 = I64[Sp];
           I64[Sp] = block_caSsp_info;
           R1 = _saR2B::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSv5: // global
           _saR2A::I64 = I64[Sp + 40];
           if (I64[Sp + 64] == _saR2A::I64) goto caSv8; else goto caSv9;
       caSv8: // global
           Hp = Hp - 32;
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caSv9: // global
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saR2A::I64 & 7;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] & 7;
           I64[Sp + 8] = block_caSsE_info;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 32];
           I64[Sp] = stg_ap_v_info;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _caSsp() //  [R1]
         { info_tbl: [(caSsp,
                       label: block_caSsp_info
                       rep:StackRep [True, False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSsp: // global
           I64[Sp] = R1;
           call _caSsq() args: 0, res: 0, upd: 0;
     }
 },
 _caSsE() //  [R1]
         { info_tbl: [(caSsE,
                       label: block_caSsE_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSsE: // global
           I64[Sp] = block_caSsG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSxo; else goto caSsH;
       uaSxo: // global
           call _caSsG(R1) args: 0, res: 0, upd: 0;
       caSsH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSsG() //  [R1]
         { info_tbl: [(caSsG,
                       label: block_caSsG_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSsG: // global
           if (R1 & 7 == 1) goto caSvd; else goto caSvV;
       caSvd: // global
           I64[Sp + 40] = block_caSsL_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaSxp; else goto caSsM;
       uaSxp: // global
           call _caSsL(R1) args: 0, res: 0, upd: 0;
       caSsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caSvV: // global
           R1 = lvl22_raLJK_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caSsL() //  [R1]
         { info_tbl: [(caSsL,
                       label: block_caSsL_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSsL: // global
           _saR2j::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caSvg; else goto caSvP;
       caSvg: // global
           I64[Sp] = block_caSsQ_info;
           R1 = P64[_saR2j::P64 + 8];
           if (R1 & 7 != 0) goto uaSxq; else goto caSsR;
       uaSxq: // global
           call _caSsQ(R1) args: 0, res: 0, upd: 0;
       caSsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caSvP: // global
           I64[Sp + 24] = block_caSvN_info;
           R5 = _saR2j::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSsQ() //  [R1]
         { info_tbl: [(caSsQ,
                       label: block_caSsQ_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSsQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSvj; else goto caSvi;
       caSvj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSvi: // global
           _saR22::I64 = I64[Sp + 8];
           _saR2Q::P64 = P64[R1 + 7];
           _saR2S::P64 = P64[R1 + 15];
           _saR2R::I64 = I64[R1 + 23];
           _saR2T::I64 = _saR22::I64 & (I64[_saR2Q::P64 + 8] - 1);
           _saR2Y::P64 = P64[(_saR2Q::P64 + 24) + (_saR2T::I64 << 3)];
           I64[Hp - 8] = $wgo_saR2Z_info;
           I64[Hp] = _saR22::I64;
           I64[Sp - 8] = block_caSvk_info;
           R2 = _saR2Y::P64;
           R1 = Hp - 7;
           I64[Sp] = _saR2T::I64;
           P64[Sp + 8] = _saR2S::P64;
           I64[Sp + 16] = _saR2R::I64;
           P64[Sp + 24] = _saR2Q::P64;
           Sp = Sp - 8;
           call $wgo_saR2Z_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSvk() //  [R1, R2, R3]
         { info_tbl: [(caSvk,
                       label: block_caSvk_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSvk: // global
           I64[Sp - 16] = block_caSvm_info;
           _saR3d::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saR3d::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSxv; else goto caSvo;
       uaSxv: // global
           call _caSvm(R1) args: 0, res: 0, upd: 0;
       caSvo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSvm() //  [R1]
         { info_tbl: [(caSvm,
                       label: block_caSvm_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSvm: // global
           if (R1 & 7 == 1) goto uaSxd; else goto caSvz;
       uaSxd: // global
           Sp = Sp + 56;
           call _caSww() args: 0, res: 0, upd: 0;
       caSvz: // global
           _saR2Q::P64 = P64[Sp + 48];
           _saR2T::I64 = I64[Sp + 24];
           _saR3d::P64 = P64[Sp + 16];
           _saR3f::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saR2Q::P64 + 24) + (_saR2T::I64 << 3)] = _saR3f::P64;
           I64[_saR2Q::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saR2Q::P64 + 24) + ((I64[_saR2Q::P64 + 8] << 3) + (_saR2T::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caSvx_info;
           R1 = _saR3d::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaSxw; else goto caSvA;
       uaSxw: // global
           call _caSvx(R1) args: 0, res: 0, upd: 0;
       caSvA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSvx() //  [R1]
         { info_tbl: [(caSvx,
                       label: block_caSvx_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSvx: // global
           if (R1 & 7 == 1) goto uaSxe; else goto caSvK;
       uaSxe: // global
           Sp = Sp + 32;
           call _caSww() args: 0, res: 0, upd: 0;
       caSvK: // global
           _saR2R::I64 = I64[Sp + 16];
           _saR2S::P64 = P64[Sp + 8];
           I64[_saR2R::I64] = I64[_saR2R::I64] - 1;
           call MO_Touch(_saR2S::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caSvN() //  []
         { info_tbl: [(caSvN,
                       label: block_caSvN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSvN: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caStI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSvZ; else goto caSvY;
       caSvZ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_caStH_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSvY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48] & 7;
           I64[Sp - 8] = block_caStO_info;
           R4 = Hp - 7;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caStH() //  [R1]
         { info_tbl: [(caStH,
                       label: block_caStH_info
                       rep:StackRep [False, False, True, False, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStH: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _caStI() args: 0, res: 0, upd: 0;
     }
 },
 _caStO() //  [R1]
         { info_tbl: [(caStO,
                       label: block_caStO_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStO: // global
           I64[Sp] = block_caStQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSxs; else goto caStR;
       uaSxs: // global
           call _caStQ(R1) args: 0, res: 0, upd: 0;
       caStR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caStQ() //  [R1]
         { info_tbl: [(caStQ,
                       label: block_caStQ_info
                       rep:StackRep [False, True, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStQ: // global
           if (R1 & 7 == 1) goto caSw3; else goto caSwL;
       caSw3: // global
           I64[Sp + 40] = block_caStV_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaSxt; else goto caStW;
       uaSxt: // global
           call _caStV(R1) args: 0, res: 0, upd: 0;
       caStW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caSwL: // global
           R1 = lvl20_raLJI_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caStV() //  [R1]
         { info_tbl: [(caStV,
                       label: block_caStV_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caStV: // global
           _saR2j::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto caSw6; else goto caSwF;
       caSw6: // global
           I64[Sp] = block_caSu0_info;
           R1 = P64[_saR2j::P64 + 8];
           if (R1 & 7 != 0) goto uaSxu; else goto caSu1;
       uaSxu: // global
           call _caSu0(R1) args: 0, res: 0, upd: 0;
       caSu1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caSwF: // global
           I64[Sp + 24] = block_caSwD_info;
           R5 = _saR2j::P64;
           R4 = P64[R1 + 6];
           R3 = I64[Sp + 8];
           R2 = GHC.Base.const_closure+2;
           Sp = Sp + 24;
           call GHC.Event.IntTable.$winsertWith_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSu0() //  [R1]
         { info_tbl: [(caSu0,
                       label: block_caSu0_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSu0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSw9; else goto caSw8;
       caSw9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSw8: // global
           _saR22::I64 = I64[Sp + 8];
           _saR3F::P64 = P64[R1 + 7];
           _saR3H::P64 = P64[R1 + 15];
           _saR3G::I64 = I64[R1 + 23];
           _saR3I::I64 = _saR22::I64 & (I64[_saR3F::P64 + 8] - 1);
           _saR3N::P64 = P64[(_saR3F::P64 + 24) + (_saR3I::I64 << 3)];
           I64[Hp - 8] = $wgo_saR3O_info;
           I64[Hp] = _saR22::I64;
           I64[Sp - 8] = block_caSwa_info;
           R2 = _saR3N::P64;
           R1 = Hp - 7;
           I64[Sp] = _saR3I::I64;
           P64[Sp + 8] = _saR3H::P64;
           I64[Sp + 16] = _saR3G::I64;
           P64[Sp + 24] = _saR3F::P64;
           Sp = Sp - 8;
           call $wgo_saR3O_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSwa() //  [R1, R2, R3]
         { info_tbl: [(caSwa,
                       label: block_caSwa_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSwa: // global
           I64[Sp - 16] = block_caSwc_info;
           _saR42::P64 = R1;
           R1 = R2;
           P64[Sp - 8] = R3;
           P64[Sp] = _saR42::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSxz; else goto caSwe;
       uaSxz: // global
           call _caSwc(R1) args: 0, res: 0, upd: 0;
       caSwe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSwc() //  [R1]
         { info_tbl: [(caSwc,
                       label: block_caSwc_info
                       rep:StackRep [False, False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSwc: // global
           if (R1 & 7 == 1) goto uaSxg; else goto caSwp;
       uaSxg: // global
           Sp = Sp + 56;
           call _caSww() args: 0, res: 0, upd: 0;
       caSwp: // global
           _saR3F::P64 = P64[Sp + 48];
           _saR3I::I64 = I64[Sp + 24];
           _saR42::P64 = P64[Sp + 16];
           _saR44::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[(_saR3F::P64 + 24) + (_saR3I::I64 << 3)] = _saR44::P64;
           I64[_saR3F::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saR3F::P64 + 24) + ((I64[_saR3F::P64 + 8] << 3) + (_saR3I::I64 >> 7))] = 1 :: W8;
           I64[Sp + 24] = block_caSwn_info;
           R1 = _saR42::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaSxA; else goto caSwq;
       uaSxA: // global
           call _caSwn(R1) args: 0, res: 0, upd: 0;
       caSwq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSwn() //  [R1]
         { info_tbl: [(caSwn,
                       label: block_caSwn_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSwn: // global
           if (R1 & 7 == 1) goto uaSxh; else goto caSwA;
       uaSxh: // global
           Sp = Sp + 32;
           call _caSww() args: 0, res: 0, upd: 0;
       caSwA: // global
           _saR3G::I64 = I64[Sp + 16];
           _saR3H::P64 = P64[Sp + 8];
           I64[_saR3G::I64] = I64[_saR3G::I64] - 1;
           call MO_Touch(_saR3H::P64);
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caSww() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSww: // global
           R1 = lvl21_raLJJ_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caSwD() //  []
         { info_tbl: [(caSwD,
                       label: block_caSwD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSwD: // global
           R1 = lvl21_raLJJ_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_saR4n_entry() //  [R1, R2]
         { info_tbl: [(caSxM,
                       label: io1_saR4n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSxM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSxN; else goto caSxO;
       caSxN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSxO: // global
           I64[Sp - 16] = block_caSxJ_info;
           _saR2i::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _saR2i::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSxS; else goto caSxK;
       uaSxS: // global
           call _caSxJ(R1) args: 0, res: 0, upd: 0;
       caSxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSxJ() //  [R1]
         { info_tbl: [(caSxJ,
                       label: block_caSxJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSxJ: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wio_saR2i_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR4C_entry() //  [R1, R2]
         { info_tbl: [(caSy5,
                       label: sat_saR4C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSy5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSy6; else goto caSy7;
       caSy6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSy7: // global
           I64[Sp - 16] = block_caSy3_info;
           R3 = P64[R1 + 14];
           _saR4x::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saR4x::P64;
           Sp = Sp - 16;
           call GHC.Event.Manager.unregisterFd2_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSy3() //  []
         { info_tbl: [(caSy3,
                       label: block_caSy3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSy3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR4w_entry() //  [R1]
         { info_tbl: [(caSye,
                       label: sat_saR4w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSye: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR4S_entry() //  [R1, R2]
         { info_tbl: [(caSys,
                       label: sat_saR4S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSys: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSyt; else goto caSyu;
       caSyt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSyu: // global
           I64[Sp - 16] = block_caSyq_info;
           _saR4P::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saR4P::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSyq() //  []
         { info_tbl: [(caSyq,
                       label: block_caSyq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSyq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR4N_entry() //  [R1]
         { info_tbl: [(caSyB,
                       label: sat_saR4N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSyB: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saR4n_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR4O_entry() //  [R1]
         { info_tbl: [(caSyJ,
                       label: sat_saR4O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSyJ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5f_entry() //  [R1, R2]
         { info_tbl: [(caSz1,
                       label: sat_saR5f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSz1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSz2; else goto caSz3;
       caSz2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSz3: // global
           I64[Sp - 16] = block_caSyZ_info;
           _saR5c::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saR5c::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSyZ() //  []
         { info_tbl: [(caSyZ,
                       label: block_caSyZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSyZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5a_entry() //  [R1]
         { info_tbl: [(caSza,
                       label: sat_saR5a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSza: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saR4n_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5b_entry() //  [R1]
         { info_tbl: [(caSzi,
                       label: sat_saR5b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzi: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5k_entry() //  [R1]
         { info_tbl: [(caSzp,
                       label: sat_saR5k_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caSzq; else goto caSzr;
       caSzq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSzr: // global
           I64[Sp - 24] = block_caSyS_info;
           _saR2h::P64 = P64[R1 + 7];
           _saR4n::P64 = P64[R1 + 15];
           R1 = _saR2h::P64;
           P64[Sp - 16] = _saR2h::P64;
           P64[Sp - 8] = _saR4n::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSyS() //  [R1]
         { info_tbl: [(caSyS,
                       label: block_caSyS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSyS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSzu; else goto caSzt;
       caSzu: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSzt: // global
           I64[Hp - 56] = sat_saR5f_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saR5a_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saR5b_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caSzl_info;
           R2 = Hp - 54;
           _saR59::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _saR59::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSzl() //  [R1]
         { info_tbl: [(caSzl,
                       label: block_caSzl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzl: // global
           _saR2h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caSzn_info;
           R2 = P64[Sp + 16];
           _saR5i::P64 = R1;
           R1 = _saR2h::P64;
           P64[Sp + 16] = _saR5i::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSzn() //  []
         { info_tbl: [(caSzn,
                       label: block_caSzn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5F_entry() //  [R1, R2]
         { info_tbl: [(caSzH,
                       label: sat_saR5F_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSzI; else goto caSzJ;
       caSzI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSzJ: // global
           I64[Sp - 16] = block_caSzF_info;
           _saR5C::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saR5C::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSzF() //  []
         { info_tbl: [(caSzF,
                       label: block_caSzF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5A_entry() //  [R1]
         { info_tbl: [(caSzQ,
                       label: sat_saR5A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzQ: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io1_saR4n_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR5B_entry() //  [R1]
         { info_tbl: [(caSzY,
                       label: sat_saR5B_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzY: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saR1p_entry() //  [R1]
         { info_tbl: [(caSA5,
                       label: io_saR1p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSA5: // global
           if ((Sp + -128) < SpLim) (likely: False) goto caSA6; else goto caSA7;
       caSA6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSA7: // global
           I64[Sp - 24] = block_caSqD_info;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caSqD() //  [R1]
         { info_tbl: [(caSqD,
                       label: block_caSqD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqD: // global
           I64[Sp - 8] = block_caSqF_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Thread.getSystemEventManager1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _caSqF() //  [R1]
         { info_tbl: [(caSqF,
                       label: block_caSqF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqF: // global
           I64[Sp] = block_caSqH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSDn; else goto caSqI;
       uaSDn: // global
           call _caSqH(R1) args: 0, res: 0, upd: 0;
       caSqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSqH() //  [R1]
         { info_tbl: [(caSqH,
                       label: block_caSqH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqH: // global
           if (R1 & 7 == 1) goto caSA2; else goto caSA3;
       caSA2: // global
           Sp = Sp + 32;
           call lvl24_raLJM_entry() args: 8, res: 0, upd: 8;
       caSA3: // global
           I64[Sp] = block_caSqN_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaSDo; else goto caSqO;
       uaSDo: // global
           call _caSqN(R1) args: 0, res: 0, upd: 0;
       caSqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSqN() //  [R1]
         { info_tbl: [(caSqN,
                       label: block_caSqN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqN: // global
           I64[Sp - 40] = block_caSqS_info;
           _saR1A::P64 = R1;
           _saR1B::P64 = P64[R1 + 7];
           _saR1D::P64 = P64[R1 + 23];
           _saR1F::P64 = P64[R1 + 31];
           _saR1H::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _saR1B::P64;
           P64[Sp - 24] = _saR1D::P64;
           P64[Sp - 16] = _saR1F::P64;
           P64[Sp - 8] = _saR1H::P64;
           P64[Sp] = _saR1A::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaSDp; else goto caSqT;
       uaSDp: // global
           call _caSqS(R1) args: 0, res: 0, upd: 0;
       caSqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSqS() //  [R1]
         { info_tbl: [(caSqS,
                       label: block_caSqS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqS: // global
           I64[Sp - 8] = block_caSqX_info;
           _saR1O::P64 = R1;
           _saR1P::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saR1P::I64;
           P64[Sp + 16] = _saR1O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSDq; else goto caSqY;
       uaSDq: // global
           call _caSqX(R1) args: 0, res: 0, upd: 0;
       caSqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSqX() //  [R1]
         { info_tbl: [(caSqX,
                       label: block_caSqX_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqX: // global
           I64[Sp - 8] = block_caSr2_info;
           _saR1Q::P64 = R1;
           _saR1R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saR1R::I64;
           P64[Sp + 16] = _saR1Q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSDr; else goto caSr3;
       uaSDr: // global
           call _caSr2(R1) args: 0, res: 0, upd: 0;
       caSr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSr2() //  [R1]
         { info_tbl: [(caSr2,
                       label: block_caSr2_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSr2: // global
           _saR1k::P64 = P64[Sp + 80];
           _saR1T::P64 = P64[R1 + 7];
           _saR1V::P64 = P64[R1 + 23];
           _saR1W::P64 = P64[R1 + 31];
           (_saR20::I64) = call MO_AtomicRMW W64 AMO_Add(P64[Sp + 48] + 16, 1);
           I64[Sp - 16] = block_caSr9_info;
           R1 = _saR1k::P64;
           I64[Sp - 8] = _saR20::I64;
           P64[Sp] = _saR1W::P64;
           P64[Sp + 48] = _saR1V::P64;
           P64[Sp + 80] = _saR1T::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSDs; else goto caSra;
       uaSDs: // global
           call _caSr9(R1) args: 0, res: 0, upd: 0;
       caSra: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSr9() //  [R1]
         { info_tbl: [(caSr9,
                       label: block_caSr9_info
                       rep:StackRep [True, False, True, True, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSr9: // global
           I64[Sp - 8] = block_caSre_info;
           _saR21::P64 = R1;
           _saR22::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp] = _saR22::I64;
           P64[Sp + 88] = _saR21::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSDt; else goto caSrf;
       uaSDt: // global
           call _caSre(R1) args: 0, res: 0, upd: 0;
       caSrf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSre() //  [R1]
         { info_tbl: [(caSre,
                       label: block_caSre_info
                       rep:StackRep [True, True, False, True, True, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSre: // global
           I64[Sp - 16] = block_caSrj_info;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caSrj() //  [R1]
         { info_tbl: [(caSrj,
                       label: block_caSrj_info
                       rep:StackRep [True, False, True, True, False, True, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSrj: // global
           _saR1O::P64 = P64[Sp + 72];
           _saR1P::I64 = I64[Sp + 56];
           _saR1Q::P64 = P64[Sp + 64];
           _saR28::I64 = I64[Sp + 24] & 31;
           if (%MO_S_Gt_W64(_saR1P::I64,
                            _saR28::I64)) goto caSAn; else goto caSD5;
       caSD5: // global
           if (%MO_S_Gt_W64(_saR28::I64,
                            I64[Sp + 48])) goto caSAn; else goto caSAo;
       caSAn: // global
           R4 = _saR28::I64;
           R3 = _saR1O::P64;
           R2 = _saR1Q::P64;
           Sp = Sp + 128;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caSAo: // global
           _saR2f::P64 = P64[P64[Sp + 80] + ((_saR28::I64 - _saR1P::I64 << 3) + 24)];
           I64[Sp] = block_caSrz_info;
           _saR27::I64 = R1;
           R1 = _saR2f::P64;
           I64[Sp + 80] = _saR27::I64;
           if (R1 & 7 != 0) goto uaSDu; else goto caSrA;
       uaSDu: // global
           call _caSrz(R1) args: 0, res: 0, upd: 0;
       caSrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSrz() //  [R1]
         { info_tbl: [(caSrz,
                       label: block_caSrz_info
                       rep:StackRep [True, False, True, True, False, True, True, True,
                                     True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSrz: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto caSAr; else goto caSAq;
       caSAr: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSAq: // global
           _saR2h::P64 = P64[R1 + 7];
           I64[Hp - 104] = $wio_saR2i_info;
           P64[Hp - 96] = P64[Sp + 104];
           P64[Hp - 88] = P64[Sp + 120];
           P64[Hp - 80] = P64[Sp + 88];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 112];
           I64[Hp - 56] = I64[Sp + 32];
           I64[Hp - 48] = I64[Sp + 24];
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = io1_saR4n_info;
           P64[Hp - 24] = Hp - 102;
           _caSxE::P64 = Hp - 30;
           _saR4J::I64 = I64[Sp + 80];
           if (_saR4J::I64 != 0) goto uaSDf; else goto caSBI;
       uaSDf: // global
           if (_saR4J::I64 != 1) goto caSAZ; else goto caSCp;
       caSAZ: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caSyj_info;
           R1 = _saR2h::P64;
           P64[Sp + 112] = _saR2h::P64;
           P64[Sp + 120] = _caSxE::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caSCp: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caSzy_info;
           R1 = _saR2h::P64;
           P64[Sp + 112] = _saR2h::P64;
           P64[Sp + 120] = _caSxE::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caSBI: // global
           I64[Hp - 16] = sat_saR5k_info;
           P64[Hp - 8] = _saR2h::P64;
           P64[Hp] = _caSxE::P64;
           I64[Sp + 8] = block_caSBF_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSyj() //  [R1]
         { info_tbl: [(caSyj,
                       label: block_caSyj_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSyj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSB2; else goto caSB1;
       caSB2: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSB1: // global
           I64[Hp - 56] = sat_saR4S_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saR4N_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saR4O_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caSAT_info;
           R2 = Hp - 54;
           _saR4M::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saR4M::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSAT() //  [R1]
         { info_tbl: [(caSAT,
                       label: block_caSAT_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSAT: // global
           I64[Sp] = block_caSAV_info;
           R2 = P64[Sp + 112];
           _saR4V::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saR4V::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSAV() //  []
         { info_tbl: [(caSAV,
                       label: block_caSAV_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSAV: // global
           I64[Sp] = block_caSAX_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaSDx; else goto caSB5;
       uaSDx: // global
           call _caSAX(R1) args: 0, res: 0, upd: 0;
       caSB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSAX() //  [R1]
         { info_tbl: [(caSAX,
                       label: block_caSAX_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSAX: // global
           I64[Sp] = block_caSB9_info;
           _saR4Y::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saR4Y::P64;
           if (R1 & 7 != 0) goto uaSDy; else goto caSBb;
       uaSDy: // global
           call _caSB9(R1) args: 0, res: 0, upd: 0;
       caSBb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSB9() //  [R1]
         { info_tbl: [(caSB9,
                       label: block_caSB9_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSB9: // global
           if (R1 & 7 == 1) goto caSBk; else goto caSBx;
       caSBk: // global
           _saR23::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caSBf_info;
           R2 = _saR23::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caSBx: // global
           I64[Sp + 8] = block_caSBv_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaSDz; else goto caSBy;
       uaSDz: // global
           call _caSBv(R1) args: 0, res: 0, upd: 0;
       caSBy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSBf() //  []
         { info_tbl: [(caSBf,
                       label: block_caSBf_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBf: // global
           I64[Sp] = block_caSBh_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaSDA; else goto caSBm;
       uaSDA: // global
           call _caSBh(R1) args: 0, res: 0, upd: 0;
       caSBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSBh() //  [R1]
         { info_tbl: [(caSBh,
                       label: block_caSBh_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSBs; else goto caSBr;
       caSBs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSBr: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSBv() //  [R1]
         { info_tbl: [(caSBv,
                       label: block_caSBv_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSBE; else goto caSBD;
       caSBE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSBD: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSzy() //  [R1]
         { info_tbl: [(caSzy,
                       label: block_caSzy_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSzy: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSCs; else goto caSCr;
       caSCs: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSCr: // global
           I64[Hp - 56] = sat_saR5F_info;
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saR5A_info;
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saR5B_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caSCk_info;
           R2 = Hp - 54;
           _saR5z::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 112] = _saR5z::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSCk() //  [R1]
         { info_tbl: [(caSCk,
                       label: block_caSCk_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCk: // global
           I64[Sp] = block_caSCm_info;
           R2 = P64[Sp + 112];
           _saR5I::P64 = R1;
           R1 = P64[Sp + 104];
           P64[Sp + 112] = _saR5I::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSCm() //  []
         { info_tbl: [(caSCm,
                       label: block_caSCm_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCm: // global
           I64[Sp] = block_caSCo_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto uaSDJ; else goto caSCv;
       uaSDJ: // global
           call _caSCo(R1) args: 0, res: 0, upd: 0;
       caSCv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSCo() //  [R1]
         { info_tbl: [(caSCo,
                       label: block_caSCo_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCo: // global
           I64[Sp] = block_caSCz_info;
           _saR5L::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saR5L::P64;
           if (R1 & 7 != 0) goto uaSDK; else goto caSCB;
       uaSDK: // global
           call _caSCz(R1) args: 0, res: 0, upd: 0;
       caSCB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSCz() //  [R1]
         { info_tbl: [(caSCz,
                       label: block_caSCz_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCz: // global
           if (R1 & 7 == 1) goto caSCK; else goto caSCX;
       caSCK: // global
           _saR23::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caSCF_info;
           R2 = _saR23::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caSCX: // global
           I64[Sp + 8] = block_caSCV_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaSDL; else goto caSCY;
       uaSDL: // global
           call _caSCV(R1) args: 0, res: 0, upd: 0;
       caSCY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSCF() //  []
         { info_tbl: [(caSCF,
                       label: block_caSCF_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCF: // global
           I64[Sp] = block_caSCH_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaSDM; else goto caSCM;
       uaSDM: // global
           call _caSCH(R1) args: 0, res: 0, upd: 0;
       caSCM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSCH() //  [R1]
         { info_tbl: [(caSCH,
                       label: block_caSCH_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSCS; else goto caSCR;
       caSCS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSCR: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSCV() //  [R1]
         { info_tbl: [(caSCV,
                       label: block_caSCV_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSD4; else goto caSD3;
       caSD4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSD3: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSBF() //  [R1]
         { info_tbl: [(caSBF,
                       label: block_caSBF_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBF: // global
           I64[Sp] = block_caSBH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSDD; else goto caSBK;
       uaSDD: // global
           call _caSBH(R1) args: 0, res: 0, upd: 0;
       caSBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSBH() //  [R1]
         { info_tbl: [(caSBH,
                       label: block_caSBH_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBH: // global
           I64[Sp] = block_caSBO_info;
           _saR5p::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 112] = _saR5p::P64;
           if (R1 & 7 != 0) goto uaSDE; else goto caSBQ;
       uaSDE: // global
           call _caSBO(R1) args: 0, res: 0, upd: 0;
       caSBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSBO() //  [R1]
         { info_tbl: [(caSBO,
                       label: block_caSBO_info
                       rep:StackRep [False, True, True, True, True, True, True, True,
                                     True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBO: // global
           if (R1 & 7 == 1) goto caSBZ; else goto caSCc;
       caSBZ: // global
           _saR23::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caSBU_info;
           R2 = _saR23::P64;
           R1 = P64[Sp + 96];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       caSCc: // global
           I64[Sp + 8] = block_caSCa_info;
           R1 = P64[Sp + 112];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaSDF; else goto caSCd;
       uaSDF: // global
           call _caSCa(R1) args: 0, res: 0, upd: 0;
       caSCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSBU() //  []
         { info_tbl: [(caSBU,
                       label: block_caSBU_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBU: // global
           I64[Sp] = block_caSBW_info;
           R1 = P64[Sp + 104];
           if (R1 & 7 != 0) goto uaSDG; else goto caSC1;
       uaSDG: // global
           call _caSBW(R1) args: 0, res: 0, upd: 0;
       caSC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSBW() //  [R1]
         { info_tbl: [(caSBW,
                       label: block_caSBW_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSBW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSC7; else goto caSC6;
       caSC7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSC6: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSCa() //  [R1]
         { info_tbl: [(caSCa,
                       label: block_caSCa_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSCa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSCj; else goto caSCi;
       caSCj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSCi: // global
           I64[Hp - 16] = GHC.Event.Manager.FdKey_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           P64[Sp + 104] = Hp - 15;
           Sp = Sp + 80;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSxW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSxW: // global
           Hp = Hp + 40;
           _saR4u::P64 = P64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto caSAx; else goto caSAw;
       caSAx: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_caSxV_info;
           R1 = _saR4u::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSAw: // global
           I64[Hp - 32] = sat_saR4C_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = _saR4u::P64;
           I64[Hp - 8] = sat_saR4w_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_caSAs_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSxV() //  [R1]
         { info_tbl: [(caSxV,
                       label: block_caSxV_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSxV: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caSxW() args: 0, res: 0, upd: 0;
     }
 },
 _caSAs() //  [R1]
         { info_tbl: [(caSAs,
                       label: block_caSAs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSAs: // global
           I64[Sp] = block_caSAu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaSDw; else goto caSAz;
       uaSDw: // global
           call _caSAu(R1) args: 0, res: 0, upd: 0;
       caSAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSAu() //  [R1]
         { info_tbl: [(caSAu,
                       label: block_caSAu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSAu: // global
           if (I64[R1 + 7] & 4 == 0) goto caSAP; else goto caSAJ;
       caSAP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caSAJ: // global
           R1 = lvl28_raLJS_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.threadWaitRead1_entry() //  [R2, R3]
         { info_tbl: [(caSDT,
                       label: GHC.Event.Thread.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSDT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caSDU; else goto caSDV;
       caSDU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.threadWaitRead1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSDV: // global
           I64[Sp - 24] = block_caSqw_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caSqw() //  [R1]
         { info_tbl: [(caSqw,
                       label: block_caSqw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSqw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSDY; else goto caSDX;
       caSDY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSDX: // global
           I64[Hp - 16] = io_saR1p_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _caSqy::P64 = Hp - 15;
           if (R1 == 0) goto caSDS; else goto caSDR;
       caSDS: // global
           R1 = _caSqy::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caSDR: // global
           R1 = _caSqy::P64;
           Sp = Sp + 24;
           call io_saR1p_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.422274755 UTC

[section ""data" . threadWaitWrite1_raLJT_closure" {
     threadWaitWrite1_raLJT_closure:
         const threadWaitWrite1_raLJT_info;
         const 0;
 },
 threadWaitWrite1_raLJT_entry() //  [R2]
         { info_tbl: [(caSNt,
                       label: threadWaitWrite1_raLJT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSNt: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.425606015 UTC

[section ""data" . GHC.Event.Thread.threadWaitWrite_closure" {
     GHC.Event.Thread.threadWaitWrite_closure:
         const GHC.Event.Thread.threadWaitWrite_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caSNE,
                       label: GHC.Event.Thread.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSNE: // global
           R2 = R2;
           call threadWaitWrite1_raLJT_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.428841451 UTC

[section ""data" . threadWaitRead2_raLJU_closure" {
     threadWaitRead2_raLJU_closure:
         const threadWaitRead2_raLJU_info;
         const 0;
 },
 threadWaitRead2_raLJU_entry() //  [R2]
         { info_tbl: [(caSNP,
                       label: threadWaitRead2_raLJU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSNP: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.432265074 UTC

[section ""data" . GHC.Event.Thread.threadWaitRead_closure" {
     GHC.Event.Thread.threadWaitRead_closure:
         const GHC.Event.Thread.threadWaitRead_info;
         const 0;
 },
 GHC.Event.Thread.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caSO0,
                       label: GHC.Event.Thread.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSO0: // global
           R2 = R2;
           call threadWaitRead2_raLJU_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.435852124 UTC

[section ""cstring" . lvl29_raLJV_bytes" {
     lvl29_raLJV_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,69,118,101,110,116,47,84,104,114,101,97,100,46,104,115,58,49,48,52,58,53,45,49,55]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.437715291 UTC

[section ""data" . lvl30_raLJW_closure" {
     lvl30_raLJW_closure:
         const lvl30_raLJW_info;
         const 0;
 },
 lvl30_raLJW_entry() //  []
         { info_tbl: [(caSOe,
                       label: lvl30_raLJW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSOe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caSOf; else goto caSOg;
       caSOf: // global
           R1 = lvl30_raLJW_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSOg: // global
           I64[Sp - 8] = block_caSOc_info;
           R2 = lvl29_raLJV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSOc() //  [R1]
         { info_tbl: [(caSOc,
                       label: block_caSOc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSOc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.443751888 UTC

[section ""data" . go_raLJX_closure" {
     go_raLJX_closure:
         const go_raLJX_info;
 },
 go_raLJX_entry() //  [R2]
         { info_tbl: [(caSOE,
                       label: go_raLJX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSOE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSOF; else goto uaSOQ;
       caSOF: // global
           R2 = R2;
           R1 = go_raLJX_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uaSOQ: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _caSOu() args: 0, res: 0, upd: 0;
     }
 },
 _caSOu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSOu: // global
           _saR5W::P64 = P64[Sp];
           I64[Sp] = block_caSOx_info;
           R1 = _saR5W::P64;
           if (R1 & 7 != 0) goto uaSOS; else goto caSOy;
       uaSOS: // global
           call _caSOx(R1) args: 0, res: 0, upd: 0;
       caSOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSOx() //  [R1]
         { info_tbl: [(caSOx,
                       label: block_caSOx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSOx: // global
           if (R1 & 7 == 1) goto caSOB; else goto caSOC;
       caSOB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caSOC: // global
           I64[Sp - 8] = block_caSOM_info;
           _saR60::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saR60::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSOM() //  []
         { info_tbl: [(caSOM,
                       label: block_caSOM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSOM: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _caSOu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.457792851 UTC

[section ""data" . GHC.Event.Thread.closeFdWith1_closure" {
     GHC.Event.Thread.closeFdWith1_closure:
         const GHC.Event.Thread.closeFdWith1_info;
         const 0;
 },
 go1_saR6t_entry() //  [R1, R2]
         { info_tbl: [(caSQ2,
                       label: go1_saR6t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQ2: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caSQ3; else goto caSQ4;
       caSQ3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSQ4: // global
           I64[Sp - 24] = block_caSPV_info;
           _saR6t::P64 = R1;
           _saR65::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _saR65::P64;
           P64[Sp - 8] = _saR6t::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaSR9; else goto caSPW;
       uaSR9: // global
           call _caSPV(R1) args: 0, res: 0, upd: 0;
       caSPW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSPV() //  [R1]
         { info_tbl: [(caSPV,
                       label: block_caSPV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSPV: // global
           if (R1 & 7 == 1) goto caSPZ; else goto caSQ0;
       caSPZ: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caSQ0: // global
           I64[Sp - 8] = block_caSQa_info;
           _saR6y::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saR6y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSR8; else goto caSQb;
       uaSR8: // global
           call _caSQa(R1) args: 0, res: 0, upd: 0;
       caSQb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQa() //  [R1]
         { info_tbl: [(caSQa,
                       label: block_caSQa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQa: // global
           I64[Sp - 16] = block_caSQf_info;
           _saR6C::P64 = P64[R1 + 23];
           _saR6E::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saR6E::P64;
           P64[Sp] = _saR6C::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSRa; else goto caSQg;
       uaSRa: // global
           call _caSQf(R1) args: 0, res: 0, upd: 0;
       caSQg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQf() //  [R1]
         { info_tbl: [(caSQf,
                       label: block_caSQf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQf: // global
           I64[Sp - 8] = block_caSQk_info;
           _saR6N::P64 = R1;
           _saR6O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saR6O::I64;
           P64[Sp + 16] = _saR6N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSRb; else goto caSQl;
       uaSRb: // global
           call _caSQk(R1) args: 0, res: 0, upd: 0;
       caSQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQk() //  [R1]
         { info_tbl: [(caSQk,
                       label: block_caSQk_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQk: // global
           I64[Sp - 8] = block_caSQp_info;
           _saR6P::P64 = R1;
           _saR6Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp] = _saR6Q::I64;
           P64[Sp + 40] = _saR6P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSRc; else goto caSQu;
       uaSRc: // global
           call _caSQp(R1) args: 0, res: 0, upd: 0;
       caSQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQp() //  [R1]
         { info_tbl: [(caSQp,
                       label: block_caSQp_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQp: // global
           _saR6N::P64 = P64[Sp + 32];
           _saR6O::I64 = I64[Sp + 16];
           _saR6P::P64 = P64[Sp + 48];
           _saR6T::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saR6O::I64,
                            _saR6T::I64)) goto caSQL; else goto caSR7;
       caSR7: // global
           if (%MO_S_Gt_W64(_saR6T::I64,
                            I64[Sp + 8])) goto caSQL; else goto caSR1;
       caSQL: // global
           R4 = _saR6T::I64;
           R3 = _saR6N::P64;
           R2 = _saR6P::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caSR1: // global
           _saR70::P64 = P64[P64[Sp + 24] + ((_saR6T::I64 - _saR6O::I64 << 3) + 24)];
           I64[Sp + 32] = block_caSQR_info;
           R1 = _saR70::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uaSRd; else goto caSQS;
       uaSRd: // global
           call _caSQR(R1) args: 0, res: 0, upd: 0;
       caSQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQR() //  [R1]
         { info_tbl: [(caSQR,
                       label: block_caSQR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQR: // global
           I64[Sp] = block_caSQW_info;
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQW() //  [R1]
         { info_tbl: [(caSQW,
                       label: block_caSQW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQW: // global
           I64[Sp + 16] = block_caSQY_info;
           R2 = P64[Sp + 8];
           _saR75::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saR75::P64;
           Sp = Sp + 16;
           call go1_saR6t_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSQY() //  [R1]
         { info_tbl: [(caSQY,
                       label: block_caSQY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSQY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSR6; else goto caSR5;
       caSR6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSR5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_saR7d_entry() //  [R1, R2, R3]
         { info_tbl: [(caSRs,
                       label: go2_saR7d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caSRt; else goto caSRu;
       caSRt: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSRu: // global
           I64[Sp - 32] = block_caSRl_info;
           _saR7d::P64 = R1;
           _saR65::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _saR65::P64;
           P64[Sp - 16] = _saR7d::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaSSd; else goto caSRm;
       uaSSd: // global
           call _caSRl(R1) args: 0, res: 0, upd: 0;
       caSRm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSRl() //  [R1]
         { info_tbl: [(caSRl,
                       label: block_caSRl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRl: // global
           if (R1 & 7 == 1) goto uaSS9; else goto caSRq;
       uaSS9: // global
           Sp = Sp + 32;
           call _caSRI() args: 0, res: 0, upd: 0;
       caSRq: // global
           I64[Sp - 8] = block_caSRA_info;
           _saR7i::P64 = P64[R1 + 6];
           _saR7j::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _saR7j::P64;
           P64[Sp + 24] = _saR7i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSSb; else goto caSRC;
       uaSSb: // global
           call _caSRA(R1) args: 0, res: 0, upd: 0;
       caSRC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSRA() //  [R1]
         { info_tbl: [(caSRA,
                       label: block_caSRA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRA: // global
           if (R1 & 7 == 1) goto uaSSa; else goto caSS1;
       uaSSa: // global
           Sp = Sp + 40;
           call _caSRI() args: 0, res: 0, upd: 0;
       caSS1: // global
           I64[Sp - 8] = block_caSRL_info;
           _saR7m::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saR7m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSSe; else goto caSRM;
       uaSSe: // global
           call _caSRL(R1) args: 0, res: 0, upd: 0;
       caSRM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSRI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRI: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caSRL() //  [R1]
         { info_tbl: [(caSRL,
                       label: block_caSRL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRL: // global
           I64[Sp] = block_caSRQ_info;
           _saR7o::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _saR7o::P64;
           if (R1 & 7 != 0) goto uaSSg; else goto caSRR;
       uaSSg: // global
           call _caSRQ(R1) args: 0, res: 0, upd: 0;
       caSRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSRQ() //  [R1]
         { info_tbl: [(caSRQ,
                       label: block_caSRQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRQ: // global
           I64[Sp] = block_caSRV_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           call GHC.Event.Manager.$wcloseFd__entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSRV() //  [R1]
         { info_tbl: [(caSRV,
                       label: block_caSRV_info
                       rep:StackRep [False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRV: // global
           _saR7d::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caSRX_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           _saR7t::P64 = R1;
           R1 = _saR7d::P64;
           P64[Sp + 40] = _saR7t::P64;
           Sp = Sp + 32;
           call go2_saR7d_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSRX() //  [R1]
         { info_tbl: [(caSRX,
                       label: block_caSRX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSS7; else goto caSS6;
       caSS7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSS6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8e_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(caSSt,
                       label: sat_saR8e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSt: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caSSH; else goto caSSI;
       caSSH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caSSI: // global
           I64[Sp - 32] = block_caSSq_info;
           _saR65::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _saR65::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaSTl; else goto caSSr;
       uaSTl: // global
           call _caSSq(R1) args: 0, res: 0, upd: 0;
       caSSr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSSq() //  [R1]
         { info_tbl: [(caSSq,
                       label: block_caSSq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSq: // global
           I64[Sp - 16] = block_caSSw_info;
           _saR7M::P64 = P64[R1 + 23];
           _saR7O::P64 = P64[R1 + 31];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saR7O::P64;
           P64[Sp] = _saR7M::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSTk; else goto caSSx;
       uaSTk: // global
           call _caSSw(R1) args: 0, res: 0, upd: 0;
       caSSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSSw() //  [R1]
         { info_tbl: [(caSSw,
                       label: block_caSSw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSw: // global
           I64[Sp - 8] = block_caSSB_info;
           _saR7X::P64 = R1;
           _saR7Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saR7Y::I64;
           P64[Sp + 16] = _saR7X::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSTm; else goto caSSC;
       uaSTm: // global
           call _caSSB(R1) args: 0, res: 0, upd: 0;
       caSSC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSSB() //  [R1]
         { info_tbl: [(caSSB,
                       label: block_caSSB_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSB: // global
           I64[Sp - 8] = block_caSSG_info;
           _saR7Z::P64 = R1;
           _saR80::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp] = _saR80::I64;
           P64[Sp + 32] = _saR7Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSTn; else goto caSSM;
       uaSTn: // global
           call _caSSG(R1) args: 0, res: 0, upd: 0;
       caSSM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSSG() //  [R1]
         { info_tbl: [(caSSG,
                       label: block_caSSG_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSG: // global
           _saR7X::P64 = P64[Sp + 32];
           _saR7Y::I64 = I64[Sp + 16];
           _saR7Z::P64 = P64[Sp + 40];
           _saR83::I64 = I64[R1 + 7] & 31;
           if (%MO_S_Gt_W64(_saR7Y::I64,
                            _saR83::I64)) goto caST3; else goto caSTj;
       caSTj: // global
           if (%MO_S_Gt_W64(_saR83::I64,
                            I64[Sp + 8])) goto caST3; else goto caSTf;
       caST3: // global
           R4 = _saR83::I64;
           R3 = _saR7X::P64;
           R2 = _saR7Z::P64;
           Sp = Sp + 64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caSTf: // global
           _saR8a::P64 = P64[P64[Sp + 24] + ((_saR83::I64 - _saR7Y::I64 << 3) + 24)];
           I64[Sp + 40] = block_caST9_info;
           R1 = _saR8a::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaSTo; else goto caSTa;
       uaSTo: // global
           call _caST9(R1) args: 0, res: 0, upd: 0;
       caSTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caST9() //  [R1]
         { info_tbl: [(caST9,
                       label: block_caST9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caST9: // global
           _saR7G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caSTe_info;
           R2 = _saR7G::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSTe() //  []
         { info_tbl: [(caSTe,
                       label: block_caSTe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSTe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8n_entry() //  [R1, R2]
         { info_tbl: [(caSTC,
                       label: sat_saR8n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSTC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSTD; else goto caSTE;
       caSTD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSTE: // global
           I64[Sp - 16] = block_caSTA_info;
           _saR8i::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saR8i::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSTA() //  []
         { info_tbl: [(caSTA,
                       label: block_caSTA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSTA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8h_entry() //  [R1]
         { info_tbl: [(caSTM,
                       label: sat_saR8h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSTM: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8C_entry() //  [R1, R2]
         { info_tbl: [(caSU2,
                       label: sat_saR8C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSU2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSU3; else goto caSU4;
       caSU3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSU4: // global
           I64[Sp - 16] = block_caSU0_info;
           _saR8x::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saR8x::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSU0() //  []
         { info_tbl: [(caSU0,
                       label: block_caSU0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSU0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8w_entry() //  [R1]
         { info_tbl: [(caSUc,
                       label: sat_saR8w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUc: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8J_entry() //  [R1]
         { info_tbl: [(caSUj,
                       label: sat_saR8J_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUj: // global
           _saR8J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caSUk; else goto caSUl;
       caSUl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSUn; else goto caSUm;
       caSUn: // global
           HpAlloc = 64;
           goto caSUk;
       caSUk: // global
           R1 = _saR8J::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSUm: // global
           _saR64::P64 = P64[_saR8J::P64 + 7];
           _saR65::P64 = P64[_saR8J::P64 + 15];
           _saR7E::P64 = P64[_saR8J::P64 + 23];
           I64[Hp - 56] = sat_saR8C_info;
           P64[Hp - 48] = _saR7E::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saR64::P64;
           P64[Hp - 16] = _saR65::P64;
           I64[Hp - 8] = sat_saR8w_info;
           P64[Hp] = Hp - 40;
           I64[Sp - 16] = block_caSUf_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           P64[Sp - 8] = _saR7E::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSUf() //  [R1]
         { info_tbl: [(caSUf,
                       label: block_caSUf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUf: // global
           I64[Sp] = block_caSUh_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSUh() //  []
         { info_tbl: [(caSUh,
                       label: block_caSUh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8R_entry() //  [R1, R2]
         { info_tbl: [(caSUy,
                       label: sat_saR8R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caSUz; else goto caSUA;
       caSUz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSUA: // global
           I64[Sp - 16] = block_caSUw_info;
           _saR8M::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _saR8M::P64;
           Sp = Sp - 16;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSUw() //  []
         { info_tbl: [(caSUw,
                       label: block_caSUw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saR8L_entry() //  [R1]
         { info_tbl: [(caSUI,
                       label: sat_saR8L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUI: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saR6r_entry() //  [R1]
         { info_tbl: [(caSUL,
                       label: io_saR6r_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSUL: // global
           _saR6r::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto caSUM; else goto caSUN;
       caSUN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSUP; else goto caSUO;
       caSUP: // global
           HpAlloc = 16;
           goto caSUM;
       caSUM: // global
           R1 = _saR6r::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caSUO: // global
           _saR64::P64 = P64[_saR6r::P64 + 7];
           _saR65::P64 = P64[_saR6r::P64 + 15];
           _saR6n::P64 = P64[_saR6r::P64 + 23];
           I64[Hp - 8] = go1_saR6t_info;
           P64[Hp] = _saR65::P64;
           I64[Sp - 32] = block_caSRe_info;
           R2 = _saR6n::P64;
           R1 = Hp - 6;
           P64[Sp - 24] = _saR64::P64;
           P64[Sp - 16] = _saR65::P64;
           P64[Sp - 8] = _saR6n::P64;
           Sp = Sp - 32;
           call go1_saR6t_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSRe() //  [R1]
         { info_tbl: [(caSRe,
                       label: block_caSRe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSRe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSUS; else goto caSUR;
       caSUS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSUR: // global
           I64[Hp - 8] = go2_saR7d_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 8] = block_caSSh_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           _saR7c::P64 = R1;
           R1 = Hp - 5;
           P64[Sp] = _saR7c::P64;
           Sp = Sp - 8;
           call go2_saR7d_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSSh() //  [R1]
         { info_tbl: [(caSSh,
                       label: block_caSSh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSh: // global
           I64[Sp - 8] = block_caSSj_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caSSj() //  [R1]
         { info_tbl: [(caSSj,
                       label: block_caSSj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSSj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caSUW; else goto caSUV;
       caSUW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSUV: // global
           I64[Hp - 8] = sat_saR8e_info;
           P64[Hp] = P64[Sp + 32];
           _saR7c::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caSTp_info;
           R5 = P64[Sp + 8];
           R4 = _saR7c::P64;
           R3 = P64[Sp + 40];
           R2 = Hp - 4;
           I64[Sp + 40] = R1;
           Sp = Sp + 16;
           call GHC.List.zipWith3_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSTp() //  [R1]
         { info_tbl: [(caSTp,
                       label: block_caSTp_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSTp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caSUZ; else goto caSUY;
       caSUZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSUY: // global
           _saR64::P64 = P64[Sp + 8];
           _saR65::P64 = P64[Sp + 16];
           _saR8f::I64 = I64[Sp + 24];
           if (_saR8f::I64 == 0) goto caSV8; else goto uaSVg;
       caSV8: // global
           I64[Hp - 56] = sat_saR8J_info;
           P64[Hp - 48] = _saR64::P64;
           P64[Hp - 40] = _saR65::P64;
           P64[Hp - 32] = R1;
           _caSTQ::P64 = Hp - 55;
           Hp = Hp - 32;
           R1 = _caSTQ::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uaSVg: // global
           if (_saR8f::I64 == 1) goto caSVc; else goto caSV4;
       caSVc: // global
           I64[Hp - 56] = sat_saR8R_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saR64::P64;
           P64[Hp - 16] = _saR65::P64;
           I64[Hp - 8] = sat_saR8L_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caSV9_info;
           R2 = Hp - 54;
           _saR7E::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saR7E::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caSV4: // global
           I64[Hp - 56] = sat_saR8n_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _saR64::P64;
           P64[Hp - 16] = _saR65::P64;
           I64[Hp - 8] = sat_saR8h_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 16] = block_caSV0_info;
           R2 = Hp - 54;
           _saR7E::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 24] = _saR7E::P64;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSV9() //  [R1]
         { info_tbl: [(caSV9,
                       label: block_caSV9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSV9: // global
           I64[Sp] = block_caSVb_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSVb() //  []
         { info_tbl: [(caSVb,
                       label: block_caSVb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSVb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caSV0() //  [R1]
         { info_tbl: [(caSV0,
                       label: block_caSV0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSV0: // global
           I64[Sp] = block_caSV2_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call go_raLJX_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caSV2() //  []
         { info_tbl: [(caSV2,
                       label: block_caSV2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSV2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_saR90_entry() //  [R1, R2]
         { info_tbl: [(caSVu,
                       label: go1_saR90_info
                       rep:HeapRep 3 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSVu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caSVv; else goto caSVw;
       caSVv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSVw: // global
           _saR91::I64 = R2;
           _saR6h::P64 = P64[R1 + 14];
           _saR6j::P64 = P64[R1 + 22];
           _saR6i::I64 = I64[R1 + 30];
           if (%MO_S_Gt_W64(_saR6i::I64, R2)) goto caSVC; else goto caSVt;
       caSVt: // global
           _saR6k::I64 = I64[R1 + 38];
           if (%MO_S_Gt_W64(_saR91::I64,
                            _saR6k::I64)) goto caSVC; else goto caSVJ;
       caSVC: // global
           R4 = _saR91::I64;
           R3 = _saR6h::P64;
           R2 = _saR6j::P64;
           call GHC.Event.Thread.getSystemEventManager2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       caSVJ: // global
           _saR9a::P64 = P64[P64[R1 + 6] + ((_saR91::I64 - _saR6i::I64 << 3) + 24)];
           I64[Sp - 32] = block_caSVI_info;
           _saR90::P64 = R1;
           R1 = _saR9a::P64;
           I64[Sp - 24] = _saR6k::I64;
           P64[Sp - 16] = _saR90::P64;
           I64[Sp - 8] = _saR91::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaSWr; else goto caSVK;
       uaSWr: // global
           call _caSVI(R1) args: 0, res: 0, upd: 0;
       caSVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSVI() //  [R1]
         { info_tbl: [(caSVI,
                       label: block_caSVI_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSVI: // global
           if (R1 & 7 == 1) goto caSVQ; else goto caSW0;
       caSVQ: // global
           Sp = Sp + 32;
           call lvl30_raLJW_entry() args: 8, res: 0, upd: 8;
       caSW0: // global
           I64[Sp] = block_caSVT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaSWs; else goto caSVU;
       uaSWs: // global
           call _caSVT(R1) args: 0, res: 0, upd: 0;
       caSVU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSVT() //  [R1]
         { info_tbl: [(caSVT,
                       label: block_caSVT_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSVT: // global
           I64[Sp] = block_caSVY_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaSWt; else goto caSW2;
       uaSWt: // global
           call _caSVY(R1) args: 0, res: 0, upd: 0;
       caSW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSVY() //  [R1]
         { info_tbl: [(caSVY,
                       label: block_caSVY_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSVY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSW8; else goto caSW7;
       caSW8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSW7: // global
           _saR91::I64 = I64[Sp + 24];
           if (_saR91::I64 == I64[Sp + 8]) goto caSWp; else goto caSWj;
       caSWp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caSWj: // global
           Hp = Hp - 24;
           _saR90::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caSWf_info;
           R2 = _saR91::I64 + 1;
           _saR9h::P64 = R1;
           R1 = _saR90::P64;
           P64[Sp + 24] = _saR9h::P64;
           Sp = Sp + 16;
           call go1_saR90_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSWf() //  [R1]
         { info_tbl: [(caSWf,
                       label: block_caSWf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSWf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSWm; else goto caSWl;
       caSWm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSWl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaSWZ_srtd" {
     uaSWZ_srtd:
         const SaRfY_srt+224;
         const 38;
         const 223338307585;
 },
 GHC.Event.Thread.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caSWu,
                       label: GHC.Event.Thread.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSWu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caSWv; else goto caSWw;
       caSWv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Thread.closeFdWith1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSWw: // global
           I64[Sp - 24] = block_caSPk_info;
           R1 = GHC.Event.Thread.eventManager_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaSWX; else goto caSPl;
       uaSWX: // global
           call _caSPk(R1) args: 0, res: 0, upd: 0;
       caSPl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSPk() //  [R1]
         { info_tbl: [(caSPk,
                       label: block_caSPk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSPk: // global
           _saR6b::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caSPp_info;
           R1 = _saR6b::P64;
           if (R1 & 7 != 0) goto uaSWT; else goto caSPq;
       uaSWT: // global
           call _caSPp(R1) args: 0, res: 0, upd: 0;
       caSPq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSPp() //  [R1]
         { info_tbl: [(caSPp,
                       label: block_caSPp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSPp: // global
           I64[Sp - 16] = block_caSPu_info;
           _saR6e::P64 = P64[R1 + 15];
           _saR6g::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saR6g::P64;
           P64[Sp] = _saR6e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaSWU; else goto caSPv;
       uaSWU: // global
           call _caSPu(R1) args: 0, res: 0, upd: 0;
       caSPv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSPu() //  [R1]
         { info_tbl: [(caSPu,
                       label: block_caSPu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSPu: // global
           I64[Sp - 8] = block_caSPz_info;
           _saR6h::P64 = R1;
           _saR6i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp] = _saR6i::I64;
           P64[Sp + 16] = _saR6h::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaSWV; else goto caSPA;
       uaSWV: // global
           call _caSPz(R1) args: 0, res: 0, upd: 0;
       caSPA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caSPz() //  [R1]
         { info_tbl: [(caSPz,
                       label: block_caSPz_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSPz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caSWC; else goto caSWB;
       caSWC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caSWB: // global
           _saR6i::I64 = I64[Sp + 8];
           _saR6k::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_saR6i::I64,
                            _saR6k::I64)) goto caSWN; else goto caSWQ;
       caSWN: // global
           I64[Hp - 40] = go1_saR90_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = _saR6i::I64;
           I64[Hp] = _saR6k::I64;
           I64[Sp + 24] = block_caSWL_info;
           R2 = _saR6i::I64;
           R1 = Hp - 38;
           Sp = Sp + 24;
           call go1_saR90_entry(R2, R1) args: 8, res: 8, upd: 8;
       caSWQ: // global
           Hp = Hp - 48;
           P64[Sp + 24] = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call _saR6l() args: 0, res: 0, upd: 0;
     }
 },
 _caSWL() //  [R1]
         { info_tbl: [(caSWL,
                       label: block_caSWL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSWL: // global
           P64[Sp] = R1;
           call _saR6l() args: 0, res: 0, upd: 0;
     }
 },
 _saR6l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       saR6l: // global
           I64[Sp - 8] = block_caSPJ_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caSPJ() //  [R1]
         { info_tbl: [(caSPJ,
                       label: block_caSPJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSPJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caSWG; else goto caSWF;
       caSWG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caSWF: // global
           I64[Hp - 24] = io_saR6r_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _caSPL::P64 = Hp - 23;
           if (R1 == 0) goto caSWK; else goto caSWJ;
       caSWK: // global
           R1 = _caSPL::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caSWJ: // global
           R1 = _caSPL::P64;
           Sp = Sp + 32;
           call io_saR6r_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.570849707 UTC

[section ""data" . GHC.Event.Thread.closeFdWith_closure" {
     GHC.Event.Thread.closeFdWith_closure:
         const GHC.Event.Thread.closeFdWith_info;
         const 0;
 },
 GHC.Event.Thread.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caT2a,
                       label: GHC.Event.Thread.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2a: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.574444407 UTC

[section ""data" . GHC.Event.Thread.registerDelay2_closure" {
     GHC.Event.Thread.registerDelay2_closure:
         const GHC.Event.Thread.registerDelay2_info;
 },
 GHC.Event.Thread.registerDelay2_entry() //  []
         { info_tbl: [(caT2o,
                       label: GHC.Event.Thread.registerDelay2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caT2p; else goto caT2q;
       caT2p: // global
           R1 = GHC.Event.Thread.registerDelay2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caT2q: // global
           I64[Sp - 8] = block_caT2l_info;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT2l() //  [R1]
         { info_tbl: [(caT2l,
                       label: block_caT2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caT2t; else goto caT2s;
       caT2t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caT2s: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.584172854 UTC

[section ""data" . GHC.Event.Thread.$wregisterDelay_closure" {
     GHC.Event.Thread.$wregisterDelay_closure:
         const GHC.Event.Thread.$wregisterDelay_info;
         const 0;
 },
 w1_saRaa_entry() //  [R1]
         { info_tbl: [(caT3c,
                       label: w1_saRaa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT3c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caT3g; else goto caT3h;
       caT3g: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caT3h: // global
           I64[Sp - 8] = block_caT39_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaT3l; else goto caT3a;
       uaT3l: // global
           call _caT39(R1) args: 0, res: 0, upd: 0;
       caT3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT39() //  [R1]
         { info_tbl: [(caT39,
                       label: block_caT39_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT39: // global
           I64[Sp] = block_caT3f_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT3f() //  []
         { info_tbl: [(caT3f,
                       label: block_caT3f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT3f: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w2_saRak_entry() //  [R1]
         { info_tbl: [(caT3v,
                       label: w2_saRak_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT3v: // global
           R1 = P64[R1 + 7];
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saRb0_entry() //  [R1]
         { info_tbl: [(caT47,
                       label: sat_saRb0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT47: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caT48; else goto caT49;
       caT48: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caT49: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caT3Z_info;
           _saRar::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saRar::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaT54; else goto caT40;
       uaT54: // global
           call _caT3Z(R1) args: 0, res: 0, upd: 0;
       caT40: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caT3Z() //  [R1]
         { info_tbl: [(caT3Z,
                       label: block_caT3Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT3Z: // global
           _caT46::P64 = R1 & 7;
           if (_caT46::P64 < 3) goto uaT4V; else goto uaT4Y;
       uaT4V: // global
           _saRar::P64 = P64[Sp + 8];
           if (_caT46::P64 < 2) goto caT43; else goto caT44;
       caT43: // global
           I64[Sp] = block_caT4c_info;
           _saRau::I64 = I64[R1 + 39];
           R1 = _saRar::P64;
           I64[Sp + 8] = _saRau::I64;
           if (R1 & 7 != 0) goto uaT51; else goto caT4e;
       uaT51: // global
           call _caT4c(R1) args: 0, res: 0, upd: 0;
       caT4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caT44: // global
           I64[Sp] = block_caT4v_info;
           _saRaM::I64 = I64[R1 + 22];
           R1 = _saRar::P64;
           I64[Sp + 8] = _saRaM::I64;
           if (R1 & 7 != 0) goto uaT52; else goto caT4x;
       uaT52: // global
           call _caT4v(R1) args: 0, res: 0, upd: 0;
       caT4x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaT4Y: // global
           Sp = Sp + 16;
           call _caT45() args: 0, res: 0, upd: 0;
     }
 },
 _caT4c() //  [R1]
         { info_tbl: [(caT4c,
                       label: block_caT4c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT4c: // global
           _caT4S::P64 = R1 & 7;
           if (_caT4S::P64 < 3) goto uaT4W; else goto uaT4Z;
       uaT4W: // global
           _saRau::I64 = I64[Sp + 8];
           if (_caT4S::P64 < 2) goto caT4k; else goto caT4o;
       caT4k: // global
           R1 = I64[((_saRau::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caT4o: // global
           R1 = I64[((_saRau::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaT4Z: // global
           Sp = Sp + 16;
           call _caT45() args: 0, res: 0, upd: 0;
     }
 },
 _caT4v() //  [R1]
         { info_tbl: [(caT4v,
                       label: block_caT4v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT4v: // global
           _caT4P::P64 = R1 & 7;
           if (_caT4P::P64 < 3) goto uaT4X; else goto uaT50;
       uaT4X: // global
           _saRaM::I64 = I64[Sp + 8];
           if (_caT4P::P64 < 2) goto caT4D; else goto caT4H;
       caT4D: // global
           R1 = I64[((_saRaM::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caT4H: // global
           R1 = I64[((_saRaM::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaT50: // global
           Sp = Sp + 16;
           call _caT45() args: 0, res: 0, upd: 0;
     }
 },
 _caT45() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT45: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saRb1_entry() //  [R1, R2]
         { info_tbl: [(caT57,
                       label: sat_saRb1_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT57: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caT59; else goto caT5a;
       caT59: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caT5a: // global
           I64[Sp - 40] = block_caT3N_info;
           R3 = R2;
           _saRap::P64 = R2;
           R2 = P64[R1 + 15];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saRap::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caT3N() //  [R1]
         { info_tbl: [(caT3N,
                       label: block_caT3N_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT3N: // global
           _saRam::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caT3R_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saRam::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caT3R() //  [R1]
         { info_tbl: [(caT3R,
                       label: block_caT3R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT3R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caT5e; else goto caT5d;
       caT5e: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caT5d: // global
           I64[Hp - 48] = sat_saRb0_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Thread.$wregisterDelay_entry() //  [R2]
         { info_tbl: [(caT5f,
                       label: GHC.Event.Thread.$wregisterDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT5f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caT5g; else goto caT5h;
       caT5g: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wregisterDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caT5h: // global
           I64[Sp - 16] = block_caT2K_info;
           R1 = GHC.Event.Thread.registerDelay2_closure+1;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT2K() //  [R1]
         { info_tbl: [(caT2K,
                       label: block_caT2K_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2K: // global
           I64[Sp - 8] = block_caT2M_info;
           _saR9O::P64 = R1;
           R1 = GHC.Event.Thread.timerManager_closure;
           P64[Sp] = _saR9O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaT6O; else goto caT2N;
       uaT6O: // global
           call _caT2M(R1) args: 0, res: 0, upd: 0;
       caT2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT2M() //  [R1]
         { info_tbl: [(caT2M,
                       label: block_caT2M_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2M: // global
           _saR9T::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caT2R_info;
           R1 = _saR9T::P64;
           if (R1 & 7 != 0) goto uaT6P; else goto caT2S;
       uaT6P: // global
           call _caT2R(R1) args: 0, res: 0, upd: 0;
       caT2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT2R() //  [R1]
         { info_tbl: [(caT2R,
                       label: block_caT2R_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2R: // global
           if (R1 & 7 == 1) goto caT5n; else goto caT5p;
       caT5n: // global
           Sp = Sp + 24;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caT5p: // global
           I64[Sp] = block_caT2X_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaT6Q; else goto caT2Y;
       uaT6Q: // global
           call _caT2X(R1) args: 0, res: 0, upd: 0;
       caT2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT2X() //  [R1]
         { info_tbl: [(caT2X,
                       label: block_caT2X_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT2X: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caT5s; else goto caT5r;
       caT5s: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caT5r: // global
           _saR9K::I64 = I64[Sp + 16];
           _saR9O::P64 = P64[Sp + 8];
           _saR9Z::P64 = P64[R1 + 15];
           _saRa6::P64 = P64[R1 + 47];
           _saRa4::I64 = I64[R1 + 71];
           (_saRa9::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 80] = w1_saRaa_info;
           P64[Hp - 72] = _saR9O::P64;
           _caT34::P64 = Hp - 79;
           if (%MO_S_Gt_W64(_saR9K::I64, 0)) goto caT5x; else goto caT6F;
       caT5x: // global
           (_saRaj::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 64] = w2_saRak_info;
           P64[Hp - 56] = _caT34::P64;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _saRa9::I64;
           I64[Hp - 32] = sat_saRb1_info;
           P64[Hp - 24] = Hp - 63;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saRa9::I64;
           I64[Hp] = _saR9K::I64 * 1000 + _saRaj::I64;
           I64[Sp - 8] = block_caT5t_info;
           R2 = Hp - 31;
           R1 = _saR9Z::P64;
           P64[Sp] = _saRa6::P64;
           I64[Sp + 16] = _saRa4::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caT6F: // global
           Hp = Hp - 72;
           I64[Sp] = block_caT6E_info;
           R1 = _caT34::P64;
           call stg_atomically#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT5t() //  [R1]
         { info_tbl: [(caT5t,
                       label: block_caT5t_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT5t: // global
           I64[Sp] = block_caT5v_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaT6R; else goto caT5z;
       uaT6R: // global
           call _caT5v(R1) args: 0, res: 0, upd: 0;
       caT5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT5v() //  [R1]
         { info_tbl: [(caT5v,
                       label: block_caT5v_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT5v: // global
           if (R1 & 7 == 1) goto uaT6L; else goto caT6C;
       uaT6L: // global
           Sp = Sp + 16;
           goto uaT6U;
       caT6C: // global
           _saRa6::P64 = P64[Sp + 8];
           (_saRba::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 24])), 1);
           if (%MO_SS_Conv_W64_W32(_saRba::I64) == 0 :: W32) goto uaT6M; else goto caT5Y;
       uaT6M: // global
           Sp = Sp + 16;
           goto uaT6U;
       uaT6U: // global
           call _caT6y() args: 0, res: 0, upd: 0;
       caT5Y: // global
           (_saRbf::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caT5W_info;
           R1 = P64[_saRa6::P64 + 8];
           I64[Sp + 24] = _saRbf::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaT6S; else goto caT60;
       uaT6S: // global
           call _caT5W(R1) args: 0, res: 0, upd: 0;
       caT60: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT5W() //  [R1]
         { info_tbl: [(caT5W,
                       label: block_caT5W_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT5W: // global
           if (R1 & 7 == 1) goto caT67; else goto caT6v;
       caT67: // global
           I64[Sp] = block_caT64_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caT6v: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 16]) == 9 :: W32) goto uaT6N; else goto caT6l;
       uaT6N: // global
           Sp = Sp + 8;
           call _caT6y() args: 0, res: 0, upd: 0;
       caT6l: // global
           I64[Sp] = block_caT6j_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caT64() //  []
         { info_tbl: [(caT64,
                       label: block_caT64_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT64: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caT6y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT6y: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caT6j() //  []
         { info_tbl: [(caT6j,
                       label: block_caT6j_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT6j: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caT6E() //  []
         { info_tbl: [(caT6E,
                       label: block_caT6E_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT6E: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.630870298 UTC

[section ""data" . GHC.Event.Thread.registerDelay1_closure" {
     GHC.Event.Thread.registerDelay1_closure:
         const GHC.Event.Thread.registerDelay1_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay1_entry() //  [R2]
         { info_tbl: [(caT9B,
                       label: GHC.Event.Thread.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT9B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caT9C; else goto caT9D;
       caT9C: // global
           R2 = R2;
           R1 = GHC.Event.Thread.registerDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caT9D: // global
           I64[Sp - 8] = block_caT9y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaT9H; else goto caT9z;
       uaT9H: // global
           call _caT9y(R1) args: 0, res: 0, upd: 0;
       caT9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caT9y() //  [R1]
         { info_tbl: [(caT9y,
                       label: block_caT9y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT9y: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wregisterDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.636385265 UTC

[section ""data" . GHC.Event.Thread.registerDelay_closure" {
     GHC.Event.Thread.registerDelay_closure:
         const GHC.Event.Thread.registerDelay_info;
         const 0;
 },
 GHC.Event.Thread.registerDelay_entry() //  [R2]
         { info_tbl: [(caT9W,
                       label: GHC.Event.Thread.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT9W: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.645050151 UTC

[section ""data" . GHC.Event.Thread.$wthreadDelay_closure" {
     GHC.Event.Thread.$wthreadDelay_closure:
         const GHC.Event.Thread.$wthreadDelay_info;
         const 0;
 },
 sat_saRcL_entry() //  [R1]
         { info_tbl: [(caTb4,
                       label: sat_saRcL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTb4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caTb5; else goto caTb6;
       caTb5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caTb6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caTaW_info;
           _saRcc::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saRcc::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaTc1; else goto caTaX;
       uaTc1: // global
           call _caTaW(R1) args: 0, res: 0, upd: 0;
       caTaX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caTaW() //  [R1]
         { info_tbl: [(caTaW,
                       label: block_caTaW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTaW: // global
           _caTb3::P64 = R1 & 7;
           if (_caTb3::P64 < 3) goto uaTbS; else goto uaTbV;
       uaTbS: // global
           _saRcc::P64 = P64[Sp + 8];
           if (_caTb3::P64 < 2) goto caTb0; else goto caTb1;
       caTb0: // global
           I64[Sp] = block_caTb9_info;
           _saRcf::I64 = I64[R1 + 39];
           R1 = _saRcc::P64;
           I64[Sp + 8] = _saRcf::I64;
           if (R1 & 7 != 0) goto uaTbY; else goto caTbb;
       uaTbY: // global
           call _caTb9(R1) args: 0, res: 0, upd: 0;
       caTbb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caTb1: // global
           I64[Sp] = block_caTbs_info;
           _saRcx::I64 = I64[R1 + 22];
           R1 = _saRcc::P64;
           I64[Sp + 8] = _saRcx::I64;
           if (R1 & 7 != 0) goto uaTbZ; else goto caTbu;
       uaTbZ: // global
           call _caTbs(R1) args: 0, res: 0, upd: 0;
       caTbu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaTbV: // global
           Sp = Sp + 16;
           call _caTb2() args: 0, res: 0, upd: 0;
     }
 },
 _caTb9() //  [R1]
         { info_tbl: [(caTb9,
                       label: block_caTb9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTb9: // global
           _caTbP::P64 = R1 & 7;
           if (_caTbP::P64 < 3) goto uaTbT; else goto uaTbW;
       uaTbT: // global
           _saRcf::I64 = I64[Sp + 8];
           if (_caTbP::P64 < 2) goto caTbh; else goto caTbl;
       caTbh: // global
           R1 = I64[((_saRcf::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caTbl: // global
           R1 = I64[((_saRcf::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaTbW: // global
           Sp = Sp + 16;
           call _caTb2() args: 0, res: 0, upd: 0;
     }
 },
 _caTbs() //  [R1]
         { info_tbl: [(caTbs,
                       label: block_caTbs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTbs: // global
           _caTbM::P64 = R1 & 7;
           if (_caTbM::P64 < 3) goto uaTbU; else goto uaTbX;
       uaTbU: // global
           _saRcx::I64 = I64[Sp + 8];
           if (_caTbM::P64 < 2) goto caTbA; else goto caTbE;
       caTbA: // global
           R1 = I64[((_saRcx::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caTbE: // global
           R1 = I64[((_saRcx::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaTbX: // global
           Sp = Sp + 16;
           call _caTb2() args: 0, res: 0, upd: 0;
     }
 },
 _caTb2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTb2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saRcM_entry() //  [R1, R2]
         { info_tbl: [(caTc4,
                       label: sat_saRcM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTc4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTc6; else goto caTc7;
       caTc6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTc7: // global
           I64[Sp - 16] = block_caTaO_info;
           R3 = R2;
           _saRcb::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _saRcb::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caTaO() //  [R1]
         { info_tbl: [(caTaO,
                       label: block_caTaO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTaO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTca; else goto caTc9;
       caTca: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTc9: // global
           I64[Hp - 48] = sat_saRcL_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saRdc_entry() //  [R1, R2]
         { info_tbl: [(caTck,
                       label: sat_saRdc_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTck: // global
           _saRc9::P64 = R2;
           _saRdc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto caTcl; else goto caTcm;
       caTcm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTco; else goto caTcn;
       caTco: // global
           HpAlloc = 16;
           goto caTcl;
       caTcl: // global
           R2 = _saRc9::P64;
           R1 = _saRdc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTcn: // global
           _saRbS::P64 = P64[_saRdc::P64 + 6];
           _saRbZ::P64 = P64[_saRdc::P64 + 14];
           _saRc6::P64 = P64[_saRdc::P64 + 22];
           _saRbX::I64 = I64[_saRdc::P64 + 30];
           I64[Hp - 8] = sat_saRcM_info;
           P64[Hp] = _saRc6::P64;
           I64[Sp - 32] = block_caTcb_info;
           R2 = Hp - 7;
           R1 = _saRbS::P64;
           I64[Sp - 24] = _saRbX::I64;
           P64[Sp - 16] = _saRbZ::P64;
           P64[Sp - 8] = _saRc9::P64;
           Sp = Sp - 32;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTcb() //  [R1]
         { info_tbl: [(caTcb,
                       label: block_caTcb_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTcb: // global
           I64[Sp] = block_caTcd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTdt; else goto caTce;
       uaTdt: // global
           call _caTcd(R1) args: 0, res: 0, upd: 0;
       caTce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTcd() //  [R1]
         { info_tbl: [(caTcd,
                       label: block_caTcd_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTcd: // global
           if (R1 & 7 == 1) goto uaTdq; else goto caTci;
       uaTdq: // global
           Sp = Sp + 24;
           goto uaTdw;
       caTci: // global
           _saRbZ::P64 = P64[Sp + 16];
           (_saRcV::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saRcV::I64) == 0 :: W32) goto uaTdr; else goto caTcL;
       uaTdr: // global
           Sp = Sp + 24;
           goto uaTdw;
       uaTdw: // global
           call _caTdl() args: 0, res: 0, upd: 0;
       caTcL: // global
           (_saRd0::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caTcJ_info;
           R1 = P64[_saRbZ::P64 + 8];
           I64[Sp + 16] = _saRd0::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaTdu; else goto caTcN;
       uaTdu: // global
           call _caTcJ(R1) args: 0, res: 0, upd: 0;
       caTcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTcJ() //  [R1]
         { info_tbl: [(caTcJ,
                       label: block_caTcJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTcJ: // global
           if (R1 & 7 == 1) goto caTcU; else goto caTdi;
       caTcU: // global
           I64[Sp + 8] = block_caTcR_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caTdi: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaTds; else goto caTd8;
       uaTds: // global
           Sp = Sp + 16;
           call _caTdl() args: 0, res: 0, upd: 0;
       caTd8: // global
           I64[Sp + 8] = block_caTd6_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caTcR() //  []
         { info_tbl: [(caTcR,
                       label: block_caTcR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTcR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caTdl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTdl: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caTd6() //  []
         { info_tbl: [(caTd6,
                       label: block_caTd6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTd6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saRc8_entry() //  [R1]
         { info_tbl: [(caTdD,
                       label: sat_saRc8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTdD: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 w1_saRdi_entry() //  [R1]
         { info_tbl: [(caTdR,
                       label: w1_saRdi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTdR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTdS; else goto caTdT;
       caTdS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTdT: // global
           I64[Sp - 8] = block_caTdP_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTdP() //  []
         { info_tbl: [(caTdP,
                       label: block_caTdP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTdP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saRdZ_entry() //  [R1]
         { info_tbl: [(caTet,
                       label: sat_saRdZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTet: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caTeu; else goto caTev;
       caTeu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caTev: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caTel_info;
           _saRdq::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _saRdq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaTfq; else goto caTem;
       uaTfq: // global
           call _caTel(R1) args: 0, res: 0, upd: 0;
       caTem: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caTel() //  [R1]
         { info_tbl: [(caTel,
                       label: block_caTel_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTel: // global
           _caTes::P64 = R1 & 7;
           if (_caTes::P64 < 3) goto uaTfh; else goto uaTfk;
       uaTfh: // global
           _saRdq::P64 = P64[Sp + 8];
           if (_caTes::P64 < 2) goto caTep; else goto caTeq;
       caTep: // global
           I64[Sp] = block_caTey_info;
           _saRdt::I64 = I64[R1 + 39];
           R1 = _saRdq::P64;
           I64[Sp + 8] = _saRdt::I64;
           if (R1 & 7 != 0) goto uaTfn; else goto caTeA;
       uaTfn: // global
           call _caTey(R1) args: 0, res: 0, upd: 0;
       caTeA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caTeq: // global
           I64[Sp] = block_caTeR_info;
           _saRdL::I64 = I64[R1 + 22];
           R1 = _saRdq::P64;
           I64[Sp + 8] = _saRdL::I64;
           if (R1 & 7 != 0) goto uaTfo; else goto caTeT;
       uaTfo: // global
           call _caTeR(R1) args: 0, res: 0, upd: 0;
       caTeT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaTfk: // global
           Sp = Sp + 16;
           call _caTer() args: 0, res: 0, upd: 0;
     }
 },
 _caTey() //  [R1]
         { info_tbl: [(caTey,
                       label: block_caTey_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTey: // global
           _caTfe::P64 = R1 & 7;
           if (_caTfe::P64 < 3) goto uaTfi; else goto uaTfl;
       uaTfi: // global
           _saRdt::I64 = I64[Sp + 8];
           if (_caTfe::P64 < 2) goto caTeG; else goto caTeK;
       caTeG: // global
           R1 = I64[((_saRdt::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caTeK: // global
           R1 = I64[((_saRdt::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaTfl: // global
           Sp = Sp + 16;
           call _caTer() args: 0, res: 0, upd: 0;
     }
 },
 _caTeR() //  [R1]
         { info_tbl: [(caTeR,
                       label: block_caTeR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTeR: // global
           _caTfb::P64 = R1 & 7;
           if (_caTfb::P64 < 3) goto uaTfj; else goto uaTfm;
       uaTfj: // global
           _saRdL::I64 = I64[Sp + 8];
           if (_caTfb::P64 < 2) goto caTeZ; else goto caTf3;
       caTeZ: // global
           R1 = I64[((_saRdL::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caTf3: // global
           R1 = I64[((_saRdL::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaTfm: // global
           Sp = Sp + 16;
           call _caTer() args: 0, res: 0, upd: 0;
     }
 },
 _caTer() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTer: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saRe0_entry() //  [R1, R2]
         { info_tbl: [(caTft,
                       label: sat_saRe0_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTft: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caTfv; else goto caTfw;
       caTfv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTfw: // global
           I64[Sp - 40] = block_caTe9_info;
           R3 = R2;
           _saRdo::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 15];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _saRdo::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caTe9() //  [R1]
         { info_tbl: [(caTe9,
                       label: block_caTe9_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTe9: // global
           _saRdl::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_caTed_info;
           R5 = R1;
           R4 = P64[Sp + 16];
           R3 = _saRdl::I64;
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _caTed() //  [R1]
         { info_tbl: [(caTed,
                       label: block_caTed_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTed: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTfA; else goto caTfz;
       caTfA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTfz: // global
           I64[Hp - 48] = sat_saRdZ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saRbD_entry() //  [R1]
         { info_tbl: [(caTfB,
                       label: io_saRbD_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTfB: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caTfC; else goto caTfD;
       caTfC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTfD: // global
           I64[Sp - 16] = block_caTae_info;
           _saRby::I64 = I64[R1 + 7];
           R1 = GHC.Event.Thread.timerManager_closure;
           I64[Sp - 8] = _saRby::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaThi; else goto caTaf;
       uaThi: // global
           call _caTae(R1) args: 0, res: 0, upd: 0;
       caTaf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTae() //  [R1]
         { info_tbl: [(caTae,
                       label: block_caTae_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTae: // global
           _saRbJ::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_caTaj_info;
           R1 = _saRbJ::P64;
           if (R1 & 7 != 0) goto uaThf; else goto caTak;
       uaThf: // global
           call _caTaj(R1) args: 0, res: 0, upd: 0;
       caTak: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTaj() //  [R1]
         { info_tbl: [(caTaj,
                       label: block_caTaj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTaj: // global
           if (R1 & 7 == 1) goto caTfI; else goto caTfK;
       caTfI: // global
           Sp = Sp + 16;
           call GHC.Event.Thread.getSystemTimerManager2_entry() args: 8, res: 0, upd: 8;
       caTfK: // global
           I64[Sp - 8] = block_caTap_info;
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _caTap() //  [R1]
         { info_tbl: [(caTap,
                       label: block_caTap_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTap: // global
           I64[Sp] = block_caTar_info;
           _saRbP::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saRbP::P64;
           if (R1 & 7 != 0) goto uaThg; else goto caTas;
       uaThg: // global
           call _caTar(R1) args: 0, res: 0, upd: 0;
       caTas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTar() //  [R1]
         { info_tbl: [(caTar,
                       label: block_caTar_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTar: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caTfO; else goto caTfN;
       caTfO: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTfN: // global
           _saRby::I64 = I64[Sp + 16];
           _saRbP::P64 = P64[Sp + 8];
           _saRbS::P64 = P64[R1 + 15];
           _saRbZ::P64 = P64[R1 + 47];
           _saRbX::I64 = I64[R1 + 71];
           (_saRc2::I64) = call MO_AtomicRMW W64 AMO_Add(P64[R1 + 31] + 16, 1);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _saRc2::I64;
           _caTay::P64 = Hp - 63;
           if (%MO_S_Gt_W64(_saRby::I64, 0)) goto caTfW; else goto caTh4;
       caTfW: // global
           (_saRdh::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 48] = w1_saRdi_info;
           P64[Hp - 40] = _saRbP::P64;
           I64[Hp - 32] = sat_saRe0_info;
           P64[Hp - 24] = _caTay::P64;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = _saRc2::I64;
           I64[Hp] = _saRby::I64 * 1000 + _saRdh::I64;
           I64[Sp - 24] = block_caTfS_info;
           R2 = Hp - 31;
           R1 = _saRbS::P64;
           I64[Sp - 16] = _saRbX::I64;
           P64[Sp - 8] = _saRbZ::P64;
           P64[Sp] = _saRbS::P64;
           P64[Sp + 16] = _caTay::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caTh4: // global
           Hp = Hp - 56;
           I64[Sp - 24] = block_caTh3_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _saRbP::P64;
           P64[Sp + 16] = _caTay::P64;
           P64[Sp] = _saRbS::P64;
           I64[Sp - 16] = _saRbX::I64;
           P64[Sp - 8] = _saRbZ::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTfS() //  [R1]
         { info_tbl: [(caTfS,
                       label: block_caTfS_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTfS: // global
           I64[Sp] = block_caTfU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaThj; else goto caTfY;
       uaThj: // global
           call _caTfU(R1) args: 0, res: 0, upd: 0;
       caTfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTfU() //  [R1]
         { info_tbl: [(caTfU,
                       label: block_caTfU_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTfU: // global
           if (R1 & 7 == 1) goto uaThm; else goto caTh1;
       caTh1: // global
           _saRbZ::P64 = P64[Sp + 16];
           (_saRe9::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), 1);
           if (%MO_SS_Conv_W64_W32(_saRe9::I64) == 0 :: W32) goto uaThm; else goto caTgn;
       uaThm: // global
           call _caTh3() args: 0, res: 0, upd: 0;
       caTgn: // global
           (_saRee::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_caTgl_info;
           R1 = P64[_saRbZ::P64 + 8];
           I64[Sp] = _saRee::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaThl; else goto caTgp;
       uaThl: // global
           call _caTgl(R1) args: 0, res: 0, upd: 0;
       caTgp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTgl() //  [R1]
         { info_tbl: [(caTgl,
                       label: block_caTgl_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTgl: // global
           if (R1 & 7 == 1) goto caTgw; else goto caTgU;
       caTgw: // global
           I64[Sp + 8] = block_caTgt_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       caTgU: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uaTha; else goto caTgK;
       uaTha: // global
           Sp = Sp + 8;
           call _caTh3() args: 0, res: 0, upd: 0;
       caTgK: // global
           I64[Sp + 8] = block_caTgI_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caTgt() //  []
         { info_tbl: [(caTgt,
                       label: block_caTgt_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTgt: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caTaC() args: 0, res: 0, upd: 0;
     }
 },
 _caTgI() //  []
         { info_tbl: [(caTgI,
                       label: block_caTgI_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTgI: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caTaC() args: 0, res: 0, upd: 0;
     }
 },
 _caTh3() //  []
         { info_tbl: [(caTh3,
                       label: block_caTh3_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTh3: // global
           P64[Sp + 40] = P64[Sp + 40];
           Sp = Sp + 8;
           call _caTaC() args: 0, res: 0, upd: 0;
     }
 },
 _caTaC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTaC: // global
           Hp = Hp + 56;
           _saRc6::P64 = P64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto caTfR; else goto caTfQ;
       caTfR: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_caTaB_info;
           R1 = _saRc6::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTfQ: // global
           I64[Hp - 48] = sat_saRdc_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _saRc6::P64;
           I64[Hp - 16] = I64[Sp];
           I64[Hp - 8] = sat_saRc8_info;
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 46;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _caTaB() //  [R1]
         { info_tbl: [(caTaB,
                       label: block_caTaB_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTaB: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _caTaC() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Event.Thread.$wthreadDelay_entry() //  [R2]
         { info_tbl: [(caThv,
                       label: GHC.Event.Thread.$wthreadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caThv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caThw; else goto caThx;
       caThw: // global
           R2 = R2;
           R1 = GHC.Event.Thread.$wthreadDelay_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caThx: // global
           I64[Sp - 16] = block_caTa7_info;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caTa7() //  [R1]
         { info_tbl: [(caTa7,
                       label: block_caTa7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTa7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caThA; else goto caThz;
       caThA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caThz: // global
           I64[Hp - 8] = io_saRbD_info;
           I64[Hp] = I64[Sp + 8];
           _caTa9::P64 = Hp - 7;
           if (R1 == 0) goto caThu; else goto caTht;
       caThu: // global
           R1 = _caTa9::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caTht: // global
           R1 = _caTa9::P64;
           Sp = Sp + 16;
           call io_saRbD_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.723843968 UTC

[section ""data" . GHC.Event.Thread.threadDelay1_closure" {
     GHC.Event.Thread.threadDelay1_closure:
         const GHC.Event.Thread.threadDelay1_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay1_entry() //  [R2]
         { info_tbl: [(caTlX,
                       label: GHC.Event.Thread.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTlX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTlY; else goto caTlZ;
       caTlY: // global
           R2 = R2;
           R1 = GHC.Event.Thread.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTlZ: // global
           I64[Sp - 8] = block_caTlU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTm3; else goto caTlV;
       uaTm3: // global
           call _caTlU(R1) args: 0, res: 0, upd: 0;
       caTlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTlU() //  [R1]
         { info_tbl: [(caTlU,
                       label: block_caTlU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTlU: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Event.Thread.$wthreadDelay_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.729075905 UTC

[section ""data" . GHC.Event.Thread.threadDelay_closure" {
     GHC.Event.Thread.threadDelay_closure:
         const GHC.Event.Thread.threadDelay_info;
         const 0;
 },
 GHC.Event.Thread.threadDelay_entry() //  [R2]
         { info_tbl: [(caTmi,
                       label: GHC.Event.Thread.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTmi: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.732366775 UTC

[section ""relreadonly" . SaRfY_srt" {
     SaRfY_srt:
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.Event.Thread.blockedOnBadFD2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Event.Thread.blockedOnBadFD1_closure;
         const GHC.Event.Manager.loop1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const restartPollLoop_raLJq_closure;
         const GHC.Arr.$windexError_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning8_closure;
         const lvl4_raLJs_closure;
         const GHC.Event.EPoll.new1_closure;
         const GHC.Event.Manager.new2_closure;
         const GHC.Event.Thread.$wstartIOManagerThread_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager1_closure;
         const GHC.Arr.negRange_closure;
         const lvl9_raLJx_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning3_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning4_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning2_closure;
         const GHC.Event.Thread.eventManager_closure;
         const GHC.Event.Thread.numEnabledEventManagers_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning6_closure;
         const GHC.Event.Thread.ioManagerLock_closure;
         const GHC.Event.Thread.timerManagerThreadVar_closure;
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const lvl11_raLJz_closure;
         const lvl13_raLJB_closure;
         const GHC.Event.Thread.$wioManagerCapabilitiesChanged_closure;
         const lvl14_raLJC_closure;
         const lvl15_raLJD_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged2_closure;
         const GHC.Event.Thread.getSystemEventManager2_closure;
         const GHC.Event.Thread.getSystemEventManager1_closure;
         const lvl17_raLJF_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const lvl18_raLJG_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl24_raLJM_closure;
         const GHC.Event.Manager.$weventsOf_closure;
         const GHC.Event.Manager.unregisterFd2_closure;
         const lvl19_raLJH_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const threadWaitReadSTM2_raLJN_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const threadWaitWriteSTM1_raLJO_closure;
         const lvl26_raLJQ_closure;
         const lvl27_raLJR_closure;
         const lvl28_raLJS_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const threadWaitWrite1_raLJT_closure;
         const threadWaitRead2_raLJU_closure;
         const lvl30_raLJW_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Event.Manager.$wcloseFd__closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Event.Thread.$wregisterDelay_closure;
         const GHC.Event.Thread.timerManager_closure;
         const GHC.Event.Thread.getSystemTimerManager2_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Event.Thread.$wthreadDelay_closure;
         const GHC.Event.Thread.threadDelay1_closure;
 }]

