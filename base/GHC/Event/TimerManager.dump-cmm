
==================== Output Cmm ====================
2018-03-16 16:05:27.246841617 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:27.248277441 UTC

[section ""data" . GHC.Event.TimerManager.$WTimerManager_closure" {
     GHC.Event.TimerManager.$WTimerManager_closure:
         const GHC.Event.TimerManager.$WTimerManager_info;
 },
 GHC.Event.TimerManager.$WTimerManager_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(casTD,
                       label: GHC.Event.TimerManager.$WTimerManager_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casTD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto casU1; else goto casU2;
       casU1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$WTimerManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       casU2: // global
           I64[Sp - 40] = block_casTA_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uasUb; else goto casTB;
       uasUb: // global
           call _casTA(R1) args: 0, res: 0, upd: 0;
       casTB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casTA() //  [R1]
         { info_tbl: [(casTA,
                       label: block_casTA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casTA: // global
           I64[Sp] = block_casTG_info;
           _sasE5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sasE5::P64;
           if (R1 & 7 != 0) goto uasUa; else goto casTH;
       uasUa: // global
           call _casTG(R1) args: 0, res: 0, upd: 0;
       casTH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casTG() //  [R1]
         { info_tbl: [(casTG,
                       label: block_casTG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casTG: // global
           I64[Sp] = block_casTL_info;
           _sasE7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sasE7::P64;
           if (R1 & 7 != 0) goto uasUc; else goto casTM;
       uasUc: // global
           call _casTL(R1) args: 0, res: 0, upd: 0;
       casTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casTL() //  [R1]
         { info_tbl: [(casTL,
                       label: block_casTL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casTL: // global
           I64[Sp] = block_casTQ_info;
           _sasE9::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sasE9::P64;
           if (R1 & 7 != 0) goto uasUd; else goto casTR;
       uasUd: // global
           call _casTQ(R1) args: 0, res: 0, upd: 0;
       casTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casTQ() //  [R1]
         { info_tbl: [(casTQ,
                       label: block_casTQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casTQ: // global
           I64[Sp] = block_casTV_info;
           _sasEb::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sasEb::P64;
           if (R1 & 7 != 0) goto uasUe; else goto casTW;
       uasUe: // global
           call _casTV(R1) args: 0, res: 0, upd: 0;
       casTW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casTV() //  [R1]
         { info_tbl: [(casTV,
                       label: block_casTV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casTV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto casU9; else goto casU8;
       casU9: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       casU8: // global
           _sasEg::P64 = P64[R1 + 7];
           _sasEh::P64 = P64[R1 + 15];
           _sasEd::I64 = I64[R1 + 23];
           _sasEe::I64 = I64[R1 + 31];
           _sasEf::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sasEg::P64;
           P64[Hp - 24] = _sasEh::P64;
           I64[Hp - 16] = _sasEd::I64;
           I64[Hp - 8] = _sasEe::I64;
           I64[Hp] = _sasEf::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.250596688 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState8_bytes" {
     GHC.Event.TimerManager.$fShowState8_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.25134408 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState7_closure" {
     GHC.Event.TimerManager.$fShowState7_closure:
         const GHC.Event.TimerManager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState7_entry() //  [R1]
         { info_tbl: [(casUl,
                       label: GHC.Event.TimerManager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casUl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casUm; else goto casUn;
       casUm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       casUn: // global
           (_casUi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_casUi::I64 == 0) goto casUk; else goto casUj;
       casUk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       casUj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _casUi::I64;
           R2 = GHC.Event.TimerManager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.252238336 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState6_bytes" {
     GHC.Event.TimerManager.$fShowState6_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.252948921 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState5_closure" {
     GHC.Event.TimerManager.$fShowState5_closure:
         const GHC.Event.TimerManager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState5_entry() //  [R1]
         { info_tbl: [(casUu,
                       label: GHC.Event.TimerManager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casUu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casUv; else goto casUw;
       casUv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       casUw: // global
           (_casUr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_casUr::I64 == 0) goto casUt; else goto casUs;
       casUt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       casUs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _casUr::I64;
           R2 = GHC.Event.TimerManager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.253934004 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState4_bytes" {
     GHC.Event.TimerManager.$fShowState4_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.256463852 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState3_closure" {
     GHC.Event.TimerManager.$fShowState3_closure:
         const GHC.Event.TimerManager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState3_entry() //  [R1]
         { info_tbl: [(casUD,
                       label: GHC.Event.TimerManager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casUD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casUE; else goto casUF;
       casUE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       casUF: // global
           (_casUA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_casUA::I64 == 0) goto casUC; else goto casUB;
       casUC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       casUB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _casUA::I64;
           R2 = GHC.Event.TimerManager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.257425373 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState2_bytes" {
     GHC.Event.TimerManager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.258142879 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState1_closure" {
     GHC.Event.TimerManager.$fShowState1_closure:
         const GHC.Event.TimerManager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState1_entry() //  [R1]
         { info_tbl: [(casUM,
                       label: GHC.Event.TimerManager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casUM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casUN; else goto casUO;
       casUN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       casUO: // global
           (_casUJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_casUJ::I64 == 0) goto casUL; else goto casUK;
       casUL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       casUK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _casUJ::I64;
           R2 = GHC.Event.TimerManager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.259412398 UTC

[section ""data" . GHC.Event.TimerManager.$w$cshowsPrec_closure" {
     GHC.Event.TimerManager.$w$cshowsPrec_closure:
         const GHC.Event.TimerManager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(casV2,
                       label: GHC.Event.TimerManager.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casV2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casV3; else goto casV4;
       casV3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       casV4: // global
           I64[Sp - 16] = block_casUT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uasVj; else goto casUU;
       uasVj: // global
           call _casUT(R1) args: 0, res: 0, upd: 0;
       casUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casUT() //  [R1]
         { info_tbl: [(casUT,
                       label: block_casUT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casUT: // global
           _sasEj::P64 = P64[Sp + 8];
           _casV1::P64 = R1 & 7;
           if (_casV1::P64 < 3) goto uasVh; else goto uasVi;
       uasVh: // global
           if (_casV1::P64 < 2) goto casUX; else goto casUY;
       casUX: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       casUY: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uasVi: // global
           if (_casV1::P64 < 4) goto casUZ; else goto casV0;
       casUZ: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       casV0: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.260801962 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(casVp,
                       label: GHC.Event.TimerManager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casVp: // global
           _sasEm::P64 = R3;
           R3 = R4;
           R2 = _sasEm::P64;
           call GHC.Event.TimerManager.$w$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.262380619 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c==_closure" {
     GHC.Event.TimerManager.$fEqState_$c==_closure:
         const GHC.Event.TimerManager.$fEqState_$c==_info;
 },
 GHC.Event.TimerManager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(casVF,
                       label: GHC.Event.TimerManager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casVF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casVG; else goto casVH;
       casVG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       casVH: // global
           I64[Sp - 16] = block_casVw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uasWY; else goto casVx;
       uasWY: // global
           call _casVw(R1) args: 0, res: 0, upd: 0;
       casVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casVw() //  [R1]
         { info_tbl: [(casVw,
                       label: block_casVw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casVw: // global
           _sasEp::P64 = P64[Sp + 8];
           _casVE::P64 = R1 & 7;
           if (_casVE::P64 < 3) goto uasWK; else goto uasWL;
       uasWK: // global
           if (_casVE::P64 < 2) goto casVA; else goto casVB;
       casVA: // global
           I64[Sp + 8] = block_casVK_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uasWU; else goto casVM;
       uasWU: // global
           call _casVK(R1) args: 0, res: 0, upd: 0;
       casVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       casVB: // global
           I64[Sp + 8] = block_casVZ_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uasWV; else goto casW1;
       uasWV: // global
           call _casVZ(R1) args: 0, res: 0, upd: 0;
       casW1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uasWL: // global
           if (_casVE::P64 < 4) goto casVC; else goto casVD;
       casVC: // global
           I64[Sp + 8] = block_casWe_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uasWW; else goto casWg;
       uasWW: // global
           call _casWe(R1) args: 0, res: 0, upd: 0;
       casWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       casVD: // global
           I64[Sp + 8] = block_casWt_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uasWX; else goto casWv;
       uasWX: // global
           call _casWt(R1) args: 0, res: 0, upd: 0;
       casWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casVK() //  [R1]
         { info_tbl: [(casVK,
                       label: block_casVK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casVK: // global
           if (R1 & 7 == 1) goto uasWM; else goto uasWN;
       uasWM: // global
           Sp = Sp + 8;
           call _casWF() args: 0, res: 0, upd: 0;
       uasWN: // global
           Sp = Sp + 8;
           call _casWB() args: 0, res: 0, upd: 0;
     }
 },
 _casVZ() //  [R1]
         { info_tbl: [(casVZ,
                       label: block_casVZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casVZ: // global
           if (R1 & 7 == 2) goto uasWO; else goto uasWP;
       uasWO: // global
           Sp = Sp + 8;
           call _casWF() args: 0, res: 0, upd: 0;
       uasWP: // global
           Sp = Sp + 8;
           call _casWB() args: 0, res: 0, upd: 0;
     }
 },
 _casWe() //  [R1]
         { info_tbl: [(casWe,
                       label: block_casWe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casWe: // global
           if (R1 & 7 == 3) goto uasWQ; else goto uasWR;
       uasWQ: // global
           Sp = Sp + 8;
           call _casWF() args: 0, res: 0, upd: 0;
       uasWR: // global
           Sp = Sp + 8;
           call _casWB() args: 0, res: 0, upd: 0;
     }
 },
 _casWt() //  [R1]
         { info_tbl: [(casWt,
                       label: block_casWt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casWt: // global
           if (R1 & 7 == 4) goto uasWS; else goto uasWT;
       uasWS: // global
           Sp = Sp + 8;
           call _casWF() args: 0, res: 0, upd: 0;
       uasWT: // global
           Sp = Sp + 8;
           call _casWB() args: 0, res: 0, upd: 0;
     }
 },
 _casWF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casWF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _casWB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casWB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.264490422 UTC

[section ""data" . GHC.Event.TimerManager.$fEqTimeoutKey_closure" {
     GHC.Event.TimerManager.$fEqTimeoutKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.eqInt_closure+2;
         const GHC.Classes.neInt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.265416034 UTC

[section ""data" . GHC.Event.TimerManager.emControl_closure" {
     GHC.Event.TimerManager.emControl_closure:
         const GHC.Event.TimerManager.emControl_info;
 },
 GHC.Event.TimerManager.emControl_entry() //  [R2]
         { info_tbl: [(casXe,
                       label: GHC.Event.TimerManager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casXe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casXi; else goto casXj;
       casXi: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casXj: // global
           I64[Sp - 8] = block_casXb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasXn; else goto casXc;
       uasXn: // global
           call _casXb(R1) args: 0, res: 0, upd: 0;
       casXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casXb() //  [R1]
         { info_tbl: [(casXb,
                       label: block_casXb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casXb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto casXm; else goto casXl;
       casXm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       casXl: // global
           _sasEE::P64 = P64[R1 + 39];
           _sasEF::P64 = P64[R1 + 47];
           _sasEB::I64 = I64[R1 + 55];
           _sasEC::I64 = I64[R1 + 63];
           _sasED::I64 = I64[R1 + 71];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _sasEE::P64;
           P64[Hp - 24] = _sasEF::P64;
           I64[Hp - 16] = _sasEB::I64;
           I64[Hp - 8] = _sasEC::I64;
           I64[Hp] = _sasED::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.266810702 UTC

[section ""data" . GHC.Event.TimerManager.emUniqueSource_closure" {
     GHC.Event.TimerManager.emUniqueSource_closure:
         const GHC.Event.TimerManager.emUniqueSource_info;
 },
 GHC.Event.TimerManager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(casXv,
                       label: GHC.Event.TimerManager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casXv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casXz; else goto casXA;
       casXz: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casXA: // global
           I64[Sp - 8] = block_casXs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasXE; else goto casXt;
       uasXE: // global
           call _casXs(R1) args: 0, res: 0, upd: 0;
       casXt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casXs() //  [R1]
         { info_tbl: [(casXs,
                       label: block_casXs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casXs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto casXD; else goto casXC;
       casXD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       casXC: // global
           _sasEL::P64 = P64[R1 + 31];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _sasEL::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.268093967 UTC

[section ""data" . GHC.Event.TimerManager.emState_closure" {
     GHC.Event.TimerManager.emState_closure:
         const GHC.Event.TimerManager.emState_info;
 },
 GHC.Event.TimerManager.emState_entry() //  [R2]
         { info_tbl: [(casXM,
                       label: GHC.Event.TimerManager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casXM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casXQ; else goto casXR;
       casXQ: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casXR: // global
           I64[Sp - 8] = block_casXJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasXV; else goto casXK;
       uasXV: // global
           call _casXJ(R1) args: 0, res: 0, upd: 0;
       casXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casXJ() //  [R1]
         { info_tbl: [(casXJ,
                       label: block_casXJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casXJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto casXU; else goto casXT;
       casXU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       casXT: // global
           _sasEV::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sasEV::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.269474046 UTC

[section ""data" . GHC.Event.TimerManager.emTimeouts_closure" {
     GHC.Event.TimerManager.emTimeouts_closure:
         const GHC.Event.TimerManager.emTimeouts_info;
 },
 GHC.Event.TimerManager.emTimeouts_entry() //  [R2]
         { info_tbl: [(casY3,
                       label: GHC.Event.TimerManager.emTimeouts_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casY3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casY7; else goto casY8;
       casY7: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emTimeouts_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casY8: // global
           I64[Sp - 8] = block_casY0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasYc; else goto casY1;
       uasYc: // global
           call _casY0(R1) args: 0, res: 0, upd: 0;
       casY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casY0() //  [R1]
         { info_tbl: [(casY0,
                       label: block_casY0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casY0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto casYb; else goto casYa;
       casYb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       casYa: // global
           _sasF5::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sasF5::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.270741694 UTC

[section ""data" . GHC.Event.TimerManager.emBackend_closure" {
     GHC.Event.TimerManager.emBackend_closure:
         const GHC.Event.TimerManager.emBackend_info;
 },
 GHC.Event.TimerManager.emBackend_entry() //  [R2]
         { info_tbl: [(casYk,
                       label: GHC.Event.TimerManager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casYl; else goto casYm;
       casYl: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casYm: // global
           I64[Sp - 8] = block_casYh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasYq; else goto casYi;
       uasYq: // global
           call _casYh(R1) args: 0, res: 0, upd: 0;
       casYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casYh() //  [R1]
         { info_tbl: [(casYh,
                       label: block_casYh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYh: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.271794864 UTC

[section ""data" . GHC.Event.TimerManager.newDefaultBackend_closure" {
     GHC.Event.TimerManager.newDefaultBackend_closure:
         const GHC.Event.TimerManager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.TimerManager.newDefaultBackend_entry() //  []
         { info_tbl: [(casYv,
                       label: GHC.Event.TimerManager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYv: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.272621647 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager1_closure" {
     GHC.Event.TimerManager.wakeManager1_closure:
         const GHC.Event.TimerManager.wakeManager1_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager1_entry() //  [R2]
         { info_tbl: [(casYF,
                       label: GHC.Event.TimerManager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casYG; else goto casYH;
       casYG: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.wakeManager1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casYH: // global
           I64[Sp - 8] = block_casYC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasYL; else goto casYD;
       uasYL: // global
           call _casYC(R1) args: 0, res: 0, upd: 0;
       casYD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casYC() //  [R1]
         { info_tbl: [(casYC,
                       label: block_casYC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYC: // global
           R3 = P64[R1 + 47];
           R2 = I64[R1 + 71];
           Sp = Sp + 8;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.273755058 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager_closure" {
     GHC.Event.TimerManager.wakeManager_closure:
         const GHC.Event.TimerManager.wakeManager_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager_entry() //  [R2]
         { info_tbl: [(casYQ,
                       label: GHC.Event.TimerManager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYQ: // global
           R2 = R2;
           call GHC.Event.TimerManager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.274450155 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule4_bytes" {
     GHC.Event.TimerManager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.27500151 UTC

[section ""data" . GHC.Event.TimerManager.$trModule3_closure" {
     GHC.Event.TimerManager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.275516955 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule2_bytes" {
     GHC.Event.TimerManager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.276018955 UTC

[section ""data" . GHC.Event.TimerManager.$trModule1_closure" {
     GHC.Event.TimerManager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.276563313 UTC

[section ""data" . GHC.Event.TimerManager.$trModule_closure" {
     GHC.Event.TimerManager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.TimerManager.$trModule3_closure+1;
         const GHC.Event.TimerManager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.277122323 UTC

[section ""data" . $krep_rasDC_closure" {
     $krep_rasDC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.277757078 UTC

[section ""data" . $krep1_rasDD_closure" {
     $krep1_rasDD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.278292117 UTC

[section ""data" . $krep2_rasDE_closure" {
     $krep2_rasDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.278875462 UTC

[section ""data" . $krep3_rasDF_closure" {
     $krep3_rasDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.279435261 UTC

[section ""data" . $krep4_rasDG_closure" {
     $krep4_rasDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.280027463 UTC

[section ""data" . $krep5_rasDH_closure" {
     $krep5_rasDH_closure:
         const :_con_info;
         const $krep3_rasDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.280599619 UTC

[section ""data" . $krep6_rasDI_closure" {
     $krep6_rasDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep5_rasDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.281177103 UTC

[section ""data" . $krep7_rasDJ_closure" {
     $krep7_rasDJ_closure:
         const :_con_info;
         const $krep6_rasDI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.281794952 UTC

[section ""data" . $krep8_rasDK_closure" {
     $krep8_rasDK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.PSQ.$tcIntPSQ_closure;
         const $krep7_rasDJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.282375421 UTC

[section ""data" . $krep9_rasDL_closure" {
     $krep9_rasDL_closure:
         const :_con_info;
         const $krep8_rasDK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.282956011 UTC

[section ""data" . $krep10_rasDM_closure" {
     $krep10_rasDM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep9_rasDL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.28353282 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimeoutKey2_bytes" {
     GHC.Event.TimerManager.$tcTimeoutKey2_bytes:
         I8[] [84,105,109,101,111,117,116,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.284091578 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey1_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.284643323 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimeoutKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11465769786694886755;
         const 8841886228133799087;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.285616452 UTC

[section ""data" . $krep11_rasDN_closure" {
     $krep11_rasDN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.286158821 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK1_closure" {
     GHC.Event.TimerManager.$tc'TK1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rasDC_closure+1;
         const $krep11_rasDN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.286699723 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TK3_bytes" {
     GHC.Event.TimerManager.$tc'TK3_bytes:
         I8[] [39,84,75]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.287207746 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK2_closure" {
     GHC.Event.TimerManager.$tc'TK2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TK3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.287732314 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK_closure" {
     GHC.Event.TimerManager.$tc'TK_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TK2_closure+1;
         const GHC.Event.TimerManager.$tc'TK1_closure+4;
         const 4362213157428095811;
         const 13641506162182658721;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.288312175 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcState2_bytes" {
     GHC.Event.TimerManager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.288858196 UTC

[section ""data" . GHC.Event.TimerManager.$tcState1_closure" {
     GHC.Event.TimerManager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.289445784 UTC

[section ""data" . GHC.Event.TimerManager.$tcState_closure" {
     GHC.Event.TimerManager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10067362680685980057;
         const 6560547589611231606;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.291339045 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created1_closure" {
     GHC.Event.TimerManager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.291898915 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Created3_bytes" {
     GHC.Event.TimerManager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.292470043 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created2_closure" {
     GHC.Event.TimerManager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.29303219 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created_closure" {
     GHC.Event.TimerManager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Created2_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 7473777249114724674;
         const 2904627795268885228;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.293681739 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Running2_bytes" {
     GHC.Event.TimerManager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.294226412 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running1_closure" {
     GHC.Event.TimerManager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.294778927 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running_closure" {
     GHC.Event.TimerManager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Running1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 15425377252641674582;
         const 12404533232809671740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.295389381 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Dying2_bytes" {
     GHC.Event.TimerManager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.295952627 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying1_closure" {
     GHC.Event.TimerManager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.296522641 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying_closure" {
     GHC.Event.TimerManager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Dying1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 13405772281963838681;
         const 437803396301020926;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.297141962 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Finished2_bytes" {
     GHC.Event.TimerManager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.297723847 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished1_closure" {
     GHC.Event.TimerManager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.298313372 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished_closure" {
     GHC.Event.TimerManager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Finished1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 1288208730452846229;
         const 15347214930365004647;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.298894044 UTC

[section ""data" . $krep12_rasDO_closure" {
     $krep12_rasDO_closure:
         const :_con_info;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.299433514 UTC

[section ""data" . $krep13_rasDP_closure" {
     $krep13_rasDP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep12_rasDO_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.29997042 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimerManager2_bytes" {
     GHC.Event.TimerManager.$tcTimerManager2_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.300483115 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager1_closure" {
     GHC.Event.TimerManager.$tcTimerManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimerManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.30105813 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager_closure" {
     GHC.Event.TimerManager.$tcTimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimerManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 3987042711794726631;
         const 6993782799294290901;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.302189913 UTC

[section ""data" . $krep14_rasDQ_closure" {
     $krep14_rasDQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimerManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.302744272 UTC

[section ""data" . $krep15_rasDR_closure" {
     $krep15_rasDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rasDD_closure+1;
         const $krep14_rasDQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.303272918 UTC

[section ""data" . $krep16_rasDS_closure" {
     $krep16_rasDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rasDE_closure+1;
         const $krep15_rasDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.303830814 UTC

[section ""data" . $krep17_rasDT_closure" {
     $krep17_rasDT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_rasDP_closure+1;
         const $krep16_rasDS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.304395974 UTC

[section ""data" . $krep18_rasDU_closure" {
     $krep18_rasDU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rasDM_closure+1;
         const $krep17_rasDT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.30496454 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager1_closure" {
     GHC.Event.TimerManager.$tc'TimerManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rasDG_closure+1;
         const $krep18_rasDU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.305462972 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TimerManager3_bytes" {
     GHC.Event.TimerManager.$tc'TimerManager3_bytes:
         I8[] [39,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.306014489 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager2_closure" {
     GHC.Event.TimerManager.$tc'TimerManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TimerManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.306583513 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager_closure" {
     GHC.Event.TimerManager.$tc'TimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager2_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager1_closure+4;
         const 451007785877958328;
         const 8145550165147362681;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.307648054 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshow_closure" {
     GHC.Event.TimerManager.$fShowState_$cshow_closure:
         const GHC.Event.TimerManager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(casZ6,
                       label: GHC.Event.TimerManager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casZ6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto casZ7; else goto casZ8;
       casZ7: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       casZ8: // global
           I64[Sp - 8] = block_casYX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasZn; else goto casYY;
       uasZn: // global
           call _casYX(R1) args: 0, res: 0, upd: 0;
       casYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casYX() //  [R1]
         { info_tbl: [(casYX,
                       label: block_casYX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casYX: // global
           _casZ5::P64 = R1 & 7;
           if (_casZ5::P64 < 3) goto uasZl; else goto uasZm;
       uasZl: // global
           if (_casZ5::P64 < 2) goto casZ1; else goto casZ2;
       casZ1: // global
           R1 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       casZ2: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uasZm: // global
           if (_casZ5::P64 < 4) goto casZ3; else goto casZ4;
       casZ3: // global
           R1 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       casZ4: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.308998393 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowList_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowList_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(casZs,
                       label: GHC.Event.TimerManager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casZs: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.TimerManager.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.310183658 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_closure" {
     GHC.Event.TimerManager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure+1;
         const GHC.Event.TimerManager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.3115234 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c/=_closure" {
     GHC.Event.TimerManager.$fEqState_$c/=_closure:
         const GHC.Event.TimerManager.$fEqState_$c/=_info;
 },
 GHC.Event.TimerManager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(casZI,
                       label: GHC.Event.TimerManager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casZI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto casZJ; else goto casZK;
       casZJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       casZK: // global
           I64[Sp - 16] = block_casZz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uat11; else goto casZA;
       uat11: // global
           call _casZz(R1) args: 0, res: 0, upd: 0;
       casZA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casZz() //  [R1]
         { info_tbl: [(casZz,
                       label: block_casZz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casZz: // global
           _sasFF::P64 = P64[Sp + 8];
           _casZH::P64 = R1 & 7;
           if (_casZH::P64 < 3) goto uat0N; else goto uat0O;
       uat0N: // global
           if (_casZH::P64 < 2) goto casZD; else goto casZE;
       casZD: // global
           I64[Sp + 8] = block_casZN_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uat0X; else goto casZP;
       uat0X: // global
           call _casZN(R1) args: 0, res: 0, upd: 0;
       casZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       casZE: // global
           I64[Sp + 8] = block_cat02_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uat0Y; else goto cat04;
       uat0Y: // global
           call _cat02(R1) args: 0, res: 0, upd: 0;
       cat04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uat0O: // global
           if (_casZH::P64 < 4) goto casZF; else goto casZG;
       casZF: // global
           I64[Sp + 8] = block_cat0h_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uat0Z; else goto cat0j;
       uat0Z: // global
           call _cat0h(R1) args: 0, res: 0, upd: 0;
       cat0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       casZG: // global
           I64[Sp + 8] = block_cat0w_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uat10; else goto cat0y;
       uat10: // global
           call _cat0w(R1) args: 0, res: 0, upd: 0;
       cat0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casZN() //  [R1]
         { info_tbl: [(casZN,
                       label: block_casZN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casZN: // global
           if (R1 & 7 == 1) goto uat0P; else goto uat0Q;
       uat0P: // global
           Sp = Sp + 8;
           call _cat0I() args: 0, res: 0, upd: 0;
       uat0Q: // global
           Sp = Sp + 8;
           call _cat0E() args: 0, res: 0, upd: 0;
     }
 },
 _cat02() //  [R1]
         { info_tbl: [(cat02,
                       label: block_cat02_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat02: // global
           if (R1 & 7 == 2) goto uat0R; else goto uat0S;
       uat0R: // global
           Sp = Sp + 8;
           call _cat0I() args: 0, res: 0, upd: 0;
       uat0S: // global
           Sp = Sp + 8;
           call _cat0E() args: 0, res: 0, upd: 0;
     }
 },
 _cat0h() //  [R1]
         { info_tbl: [(cat0h,
                       label: block_cat0h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat0h: // global
           if (R1 & 7 == 3) goto uat0T; else goto uat0U;
       uat0T: // global
           Sp = Sp + 8;
           call _cat0I() args: 0, res: 0, upd: 0;
       uat0U: // global
           Sp = Sp + 8;
           call _cat0E() args: 0, res: 0, upd: 0;
     }
 },
 _cat0w() //  [R1]
         { info_tbl: [(cat0w,
                       label: block_cat0w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat0w: // global
           if (R1 & 7 == 4) goto uat0V; else goto uat0W;
       uat0V: // global
           Sp = Sp + 8;
           call _cat0I() args: 0, res: 0, upd: 0;
       uat0W: // global
           Sp = Sp + 8;
           call _cat0E() args: 0, res: 0, upd: 0;
     }
 },
 _cat0I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat0I: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cat0E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat0E: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.31363534 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_closure" {
     GHC.Event.TimerManager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.TimerManager.$fEqState_$c==_closure+2;
         const GHC.Event.TimerManager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.315727041 UTC

[section ""data" . GHC.Event.TimerManager.$weditTimeouts_closure" {
     GHC.Event.TimerManager.$weditTimeouts_closure:
         const GHC.Event.TimerManager.$weditTimeouts_info;
         const 0;
 },
 GHC.Event.TimerManager.$weditTimeouts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1b: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sasGs_entry() //  [R1]
         { info_tbl: [(cat1A,
                       label: sat_sasGs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cat1B; else goto cat1C;
       cat1B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cat1C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cat1s_info;
           _sasFT::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasFT::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uat2x; else goto cat1t;
       uat2x: // global
           call _cat1s(R1) args: 0, res: 0, upd: 0;
       cat1t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cat1s() //  [R1]
         { info_tbl: [(cat1s,
                       label: block_cat1s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1s: // global
           _cat1z::P64 = R1 & 7;
           if (_cat1z::P64 < 3) goto uat2o; else goto uat2r;
       uat2o: // global
           _sasFT::P64 = P64[Sp + 8];
           if (_cat1z::P64 < 2) goto cat1w; else goto cat1x;
       cat1w: // global
           I64[Sp] = block_cat1F_info;
           _sasFW::I64 = I64[R1 + 39];
           R1 = _sasFT::P64;
           I64[Sp + 8] = _sasFW::I64;
           if (R1 & 7 != 0) goto uat2u; else goto cat1H;
       uat2u: // global
           call _cat1F(R1) args: 0, res: 0, upd: 0;
       cat1H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cat1x: // global
           I64[Sp] = block_cat1Y_info;
           _sasGe::I64 = I64[R1 + 22];
           R1 = _sasFT::P64;
           I64[Sp + 8] = _sasGe::I64;
           if (R1 & 7 != 0) goto uat2v; else goto cat20;
       uat2v: // global
           call _cat1Y(R1) args: 0, res: 0, upd: 0;
       cat20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uat2r: // global
           Sp = Sp + 16;
           call _cat1y() args: 0, res: 0, upd: 0;
     }
 },
 _cat1F() //  [R1]
         { info_tbl: [(cat1F,
                       label: block_cat1F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1F: // global
           _cat2l::P64 = R1 & 7;
           if (_cat2l::P64 < 3) goto uat2p; else goto uat2s;
       uat2p: // global
           _sasFW::I64 = I64[Sp + 8];
           if (_cat2l::P64 < 2) goto cat1N; else goto cat1R;
       cat1N: // global
           R1 = I64[((_sasFW::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cat1R: // global
           R1 = I64[((_sasFW::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uat2s: // global
           Sp = Sp + 16;
           call _cat1y() args: 0, res: 0, upd: 0;
     }
 },
 _cat1Y() //  [R1]
         { info_tbl: [(cat1Y,
                       label: block_cat1Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1Y: // global
           _cat2i::P64 = R1 & 7;
           if (_cat2i::P64 < 3) goto uat2q; else goto uat2t;
       uat2q: // global
           _sasGe::I64 = I64[Sp + 8];
           if (_cat2i::P64 < 2) goto cat26; else goto cat2a;
       cat26: // global
           R1 = I64[((_sasGe::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cat2a: // global
           R1 = I64[((_sasGe::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uat2t: // global
           Sp = Sp + 16;
           call _cat1y() args: 0, res: 0, upd: 0;
     }
 },
 _cat1y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1y: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasGt_entry() //  [R1, R2]
         { info_tbl: [(cat2A,
                       label: sat_sasGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat2A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cat2C; else goto cat2D;
       cat2C: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cat2D: // global
           I64[Sp - 16] = block_cat1k_info;
           _sasFS::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sasFS::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat1k() //  [R1]
         { info_tbl: [(cat1k,
                       label: block_cat1k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat1k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cat2G; else goto cat2F;
       cat2G: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cat2F: // global
           I64[Hp - 48] = sat_sasGs_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$weditTimeouts_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cat2Q,
                       label: GHC.Event.TimerManager.$weditTimeouts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat2Q: // global
           _sasFP::P64 = R6;
           _sasFO::I64 = R5;
           _sasFN::P64 = R4;
           _sasFM::P64 = R3;
           _sasFL::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cat2R; else goto cat2S;
       cat2S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cat2U; else goto cat2T;
       cat2U: // global
           HpAlloc = 16;
           goto cat2R;
       cat2R: // global
           R1 = GHC.Event.TimerManager.$weditTimeouts_closure;
           P64[Sp - 40] = _sasFL::P64;
           P64[Sp - 32] = _sasFM::P64;
           P64[Sp - 24] = _sasFN::P64;
           I64[Sp - 16] = _sasFO::I64;
           P64[Sp - 8] = _sasFP::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cat2T: // global
           I64[Hp - 8] = sat_sasGt_info;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_cat2H_info;
           R2 = Hp - 7;
           R1 = _sasFL::P64;
           P64[Sp - 8] = _sasFP::P64;
           I64[Sp] = _sasFO::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat2H() //  [R1]
         { info_tbl: [(cat2H,
                       label: block_cat2H_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat2H: // global
           I64[Sp] = block_cat2J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uat32; else goto cat2K;
       uat32: // global
           call _cat2J(R1) args: 0, res: 0, upd: 0;
       cat2K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat2J() //  [R1]
         { info_tbl: [(cat2J,
                       label: block_cat2J_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat2J: // global
           if (R1 & 7 == 1) goto cat2N; else goto cat2O;
       cat2N: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cat2O: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.319437875 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout2_closure" {
     GHC.Event.TimerManager.unregisterTimeout2_closure:
         const GHC.Event.TimerManager.unregisterTimeout2_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout2_entry() //  [R2, R3]
         { info_tbl: [(cat3a,
                       label: GHC.Event.TimerManager.unregisterTimeout2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cat3b; else goto cat3c;
       cat3b: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cat3c: // global
           I64[Sp - 16] = block_cat37_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uat3g; else goto cat38;
       uat3g: // global
           call _cat37(R1) args: 0, res: 0, upd: 0;
       cat38: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat37() //  [R1]
         { info_tbl: [(cat37,
                       label: block_cat37_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat37: // global
           R6 = P64[R1 + 47];
           R5 = I64[R1 + 71];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.322137344 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout1_closure" {
     GHC.Event.TimerManager.unregisterTimeout1_closure:
         const GHC.Event.TimerManager.unregisterTimeout1_info;
         const 0;
 },
 sat_sasHy_entry() //  [R1]
         { info_tbl: [(cat3L,
                       label: sat_sasHy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cat3M; else goto cat3N;
       cat3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cat3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cat3D_info;
           _sasGZ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasGZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uat4I; else goto cat3E;
       uat4I: // global
           call _cat3D(R1) args: 0, res: 0, upd: 0;
       cat3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cat3D() //  [R1]
         { info_tbl: [(cat3D,
                       label: block_cat3D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3D: // global
           _cat3K::P64 = R1 & 7;
           if (_cat3K::P64 < 3) goto uat4z; else goto uat4C;
       uat4z: // global
           _sasGZ::P64 = P64[Sp + 8];
           if (_cat3K::P64 < 2) goto cat3H; else goto cat3I;
       cat3H: // global
           I64[Sp] = block_cat3Q_info;
           _sasH2::I64 = I64[R1 + 39];
           R1 = _sasGZ::P64;
           I64[Sp + 8] = _sasH2::I64;
           if (R1 & 7 != 0) goto uat4F; else goto cat3S;
       uat4F: // global
           call _cat3Q(R1) args: 0, res: 0, upd: 0;
       cat3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cat3I: // global
           I64[Sp] = block_cat49_info;
           _sasHk::I64 = I64[R1 + 22];
           R1 = _sasGZ::P64;
           I64[Sp + 8] = _sasHk::I64;
           if (R1 & 7 != 0) goto uat4G; else goto cat4b;
       uat4G: // global
           call _cat49(R1) args: 0, res: 0, upd: 0;
       cat4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uat4C: // global
           Sp = Sp + 16;
           call _cat3J() args: 0, res: 0, upd: 0;
     }
 },
 _cat3Q() //  [R1]
         { info_tbl: [(cat3Q,
                       label: block_cat3Q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3Q: // global
           _cat4w::P64 = R1 & 7;
           if (_cat4w::P64 < 3) goto uat4A; else goto uat4D;
       uat4A: // global
           _sasH2::I64 = I64[Sp + 8];
           if (_cat4w::P64 < 2) goto cat3Y; else goto cat42;
       cat3Y: // global
           R1 = I64[((_sasH2::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cat42: // global
           R1 = I64[((_sasH2::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uat4D: // global
           Sp = Sp + 16;
           call _cat3J() args: 0, res: 0, upd: 0;
     }
 },
 _cat49() //  [R1]
         { info_tbl: [(cat49,
                       label: block_cat49_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat49: // global
           _cat4t::P64 = R1 & 7;
           if (_cat4t::P64 < 3) goto uat4B; else goto uat4E;
       uat4B: // global
           _sasHk::I64 = I64[Sp + 8];
           if (_cat4t::P64 < 2) goto cat4h; else goto cat4l;
       cat4h: // global
           R1 = I64[((_sasHk::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cat4l: // global
           R1 = I64[((_sasHk::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uat4E: // global
           Sp = Sp + 16;
           call _cat3J() args: 0, res: 0, upd: 0;
     }
 },
 _cat3J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3J: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasHz_entry() //  [R1, R2]
         { info_tbl: [(cat4L,
                       label: sat_sasHz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cat4N; else goto cat4O;
       cat4N: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cat4O: // global
           I64[Sp - 16] = block_cat3v_info;
           R3 = R2;
           _sasGY::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sasGY::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cat3v() //  [R1]
         { info_tbl: [(cat3v,
                       label: block_cat3v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3v: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cat4R; else goto cat4Q;
       cat4R: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cat4Q: // global
           I64[Hp - 48] = sat_sasHy_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.unregisterTimeout1_entry() //  [R2, R3]
         { info_tbl: [(cat4S,
                       label: GHC.Event.TimerManager.unregisterTimeout1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat4S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cat4T; else goto cat4U;
       cat4T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cat4U: // global
           I64[Sp - 16] = block_cat3l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uat5e; else goto cat3m;
       uat5e: // global
           call _cat3l(R1) args: 0, res: 0, upd: 0;
       cat3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat3l() //  [R1]
         { info_tbl: [(cat3l,
                       label: block_cat3l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat3l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cat50; else goto cat4Z;
       cat50: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cat4Z: // global
           _sasGQ::P64 = P64[R1 + 15];
           _sasGX::P64 = P64[R1 + 47];
           _sasGV::I64 = I64[R1 + 71];
           I64[Hp - 8] = sat_sasHz_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cat4V_info;
           R2 = Hp - 7;
           R1 = _sasGQ::P64;
           P64[Sp] = _sasGX::P64;
           I64[Sp + 8] = _sasGV::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat4V() //  [R1]
         { info_tbl: [(cat4V,
                       label: block_cat4V_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat4V: // global
           I64[Sp] = block_cat4X_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uat5f; else goto cat52;
       uat5f: // global
           call _cat4X(R1) args: 0, res: 0, upd: 0;
       cat52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat4X() //  [R1]
         { info_tbl: [(cat4X,
                       label: block_cat4X_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat4X: // global
           if (R1 & 7 == 1) goto cat58; else goto cat5c;
       cat58: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cat5c: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.325624218 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout_closure" {
     GHC.Event.TimerManager.unregisterTimeout_closure:
         const GHC.Event.TimerManager.unregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout_entry() //  [R2, R3]
         { info_tbl: [(cat5k,
                       label: GHC.Event.TimerManager.unregisterTimeout_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat5k: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.unregisterTimeout1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.32849915 UTC

[section ""data" . GHC.Event.TimerManager.$wregisterTimeout_closure" {
     GHC.Event.TimerManager.$wregisterTimeout_closure:
         const GHC.Event.TimerManager.$wregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.$wregisterTimeout_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat5o: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2,
                                                               R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sasIz_entry() //  [R1]
         { info_tbl: [(cat67,
                       label: sat_sasIz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat67: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cat68; else goto cat69;
       cat68: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cat69: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cat5Z_info;
           _sasI0::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasI0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uat74; else goto cat60;
       uat74: // global
           call _cat5Z(R1) args: 0, res: 0, upd: 0;
       cat60: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cat5Z() //  [R1]
         { info_tbl: [(cat5Z,
                       label: block_cat5Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat5Z: // global
           _cat66::P64 = R1 & 7;
           if (_cat66::P64 < 3) goto uat6V; else goto uat6Y;
       uat6V: // global
           _sasI0::P64 = P64[Sp + 8];
           if (_cat66::P64 < 2) goto cat63; else goto cat64;
       cat63: // global
           I64[Sp] = block_cat6c_info;
           _sasI3::I64 = I64[R1 + 39];
           R1 = _sasI0::P64;
           I64[Sp + 8] = _sasI3::I64;
           if (R1 & 7 != 0) goto uat71; else goto cat6e;
       uat71: // global
           call _cat6c(R1) args: 0, res: 0, upd: 0;
       cat6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cat64: // global
           I64[Sp] = block_cat6v_info;
           _sasIl::I64 = I64[R1 + 22];
           R1 = _sasI0::P64;
           I64[Sp + 8] = _sasIl::I64;
           if (R1 & 7 != 0) goto uat72; else goto cat6x;
       uat72: // global
           call _cat6v(R1) args: 0, res: 0, upd: 0;
       cat6x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uat6Y: // global
           Sp = Sp + 16;
           call _cat65() args: 0, res: 0, upd: 0;
     }
 },
 _cat6c() //  [R1]
         { info_tbl: [(cat6c,
                       label: block_cat6c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat6c: // global
           _cat6S::P64 = R1 & 7;
           if (_cat6S::P64 < 3) goto uat6W; else goto uat6Z;
       uat6W: // global
           _sasI3::I64 = I64[Sp + 8];
           if (_cat6S::P64 < 2) goto cat6k; else goto cat6o;
       cat6k: // global
           R1 = I64[((_sasI3::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cat6o: // global
           R1 = I64[((_sasI3::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uat6Z: // global
           Sp = Sp + 16;
           call _cat65() args: 0, res: 0, upd: 0;
     }
 },
 _cat6v() //  [R1]
         { info_tbl: [(cat6v,
                       label: block_cat6v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat6v: // global
           _cat6P::P64 = R1 & 7;
           if (_cat6P::P64 < 3) goto uat6X; else goto uat70;
       uat6X: // global
           _sasIl::I64 = I64[Sp + 8];
           if (_cat6P::P64 < 2) goto cat6D; else goto cat6H;
       cat6D: // global
           R1 = I64[((_sasIl::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cat6H: // global
           R1 = I64[((_sasIl::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uat70: // global
           Sp = Sp + 16;
           call _cat65() args: 0, res: 0, upd: 0;
     }
 },
 _cat65() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat65: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasIA_entry() //  [R1, R2]
         { info_tbl: [(cat77,
                       label: sat_sasIA_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat77: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cat79; else goto cat7a;
       cat79: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cat7a: // global
           I64[Sp - 40] = block_cat5N_info;
           R3 = R2;
           _sasHY::P64 = R2;
           R2 = P64[R1 + 15];
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 23];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _sasHY::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cat5N() //  [R1]
         { info_tbl: [(cat5N,
                       label: block_cat5N_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat5N: // global
           _sasHV::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cat5R_info;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _sasHV::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cat5R() //  [R1]
         { info_tbl: [(cat5R,
                       label: block_cat5R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat5R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cat7e; else goto cat7d;
       cat7e: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cat7d: // global
           I64[Hp - 48] = sat_sasIz_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wregisterTimeout_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cat7i,
                       label: GHC.Event.TimerManager.$wregisterTimeout_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat7i: // global
           _sasHI::P64 = R6;
           _sasHH::I64 = R5;
           _sasHG::P64 = R4;
           _sasHF::P64 = R3;
           _sasHE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cat7j; else goto cat7k;
       cat7k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cat7m; else goto cat7l;
       cat7m: // global
           HpAlloc = 56;
           goto cat7j;
       cat7j: // global
           R1 = GHC.Event.TimerManager.$wregisterTimeout_closure;
           P64[Sp - 40] = _sasHE::P64;
           P64[Sp - 32] = _sasHF::P64;
           P64[Sp - 24] = _sasHG::P64;
           I64[Sp - 16] = _sasHH::I64;
           P64[Sp - 8] = _sasHI::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cat7l: // global
           _sasHJ::I64 = I64[Sp];
           _sasHK::P64 = P64[Sp + 8];
           (_sasHO::I64) = call MO_AtomicRMW W64 AMO_Add(_sasHG::P64 + 16, 1);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sasHO::I64;
           _cat5u::P64 = Hp - 47;
           if (%MO_S_Gt_W64(_sasHJ::I64, 0)) goto cat7g; else goto cat7h;
       cat7g: // global
           (_sasHU::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 32] = sat_sasIA_info;
           P64[Hp - 24] = _sasHK::P64;
           P64[Hp - 16] = _cat5u::P64;
           I64[Hp - 8] = _sasHO::I64;
           I64[Hp] = _sasHJ::I64 * 1000 + _sasHU::I64;
           I64[Sp - 16] = block_cat7n_info;
           R2 = Hp - 31;
           R1 = _sasHE::P64;
           P64[Sp - 8] = _sasHI::P64;
           I64[Sp] = _sasHH::I64;
           P64[Sp + 8] = _cat5u::P64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       cat7h: // global
           Hp = Hp - 40;
           I64[Sp] = block_cat8w_info;
           R1 = _sasHK::P64;
           P64[Sp + 8] = _cat5u::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat7n() //  [R1]
         { info_tbl: [(cat7n,
                       label: block_cat7n_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat7n: // global
           I64[Sp] = block_cat7p_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uat8E; else goto cat7r;
       uat8E: // global
           call _cat7p(R1) args: 0, res: 0, upd: 0;
       cat7r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat7p() //  [R1]
         { info_tbl: [(cat7p,
                       label: block_cat7p_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat7p: // global
           if (R1 & 7 == 1) goto uat8B; else goto cat8u;
       uat8B: // global
           Sp = Sp + 24;
           goto uat8H;
       cat8u: // global
           _sasHI::P64 = P64[Sp + 8];
           (_sasIJ::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])), 1);
           if (%MO_SS_Conv_W64_W32(_sasIJ::I64) == 0 :: W32) goto uat8C; else goto cat7Q;
       uat8C: // global
           Sp = Sp + 24;
           goto uat8H;
       uat8H: // global
           call _cat8q() args: 0, res: 0, upd: 0;
       cat7Q: // global
           (_sasIO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_cat7O_info;
           R1 = P64[_sasHI::P64 + 8];
           I64[Sp + 16] = _sasIO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uat8F; else goto cat7S;
       uat8F: // global
           call _cat7O(R1) args: 0, res: 0, upd: 0;
       cat7S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat7O() //  [R1]
         { info_tbl: [(cat7O,
                       label: block_cat7O_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat7O: // global
           if (R1 & 7 == 1) goto cat7Z; else goto cat8n;
       cat7Z: // global
           I64[Sp + 8] = block_cat7W_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       cat8n: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uat8D; else goto cat8d;
       uat8D: // global
           Sp = Sp + 16;
           call _cat8q() args: 0, res: 0, upd: 0;
       cat8d: // global
           I64[Sp + 8] = block_cat8b_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cat7W() //  []
         { info_tbl: [(cat7W,
                       label: block_cat7W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat7W: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cat8q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat8q: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cat8b() //  []
         { info_tbl: [(cat8b,
                       label: block_cat8b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat8b: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cat8w() //  []
         { info_tbl: [(cat8w,
                       label: block_cat8w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat8w: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.33382713 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout1_closure" {
     GHC.Event.TimerManager.registerTimeout1_closure:
         const GHC.Event.TimerManager.registerTimeout1_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(cat8Q,
                       label: GHC.Event.TimerManager.registerTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat8Q: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cat8U; else goto cat8V;
       cat8U: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.registerTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cat8V: // global
           I64[Sp - 24] = block_cat8N_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uat93; else goto cat8O;
       uat93: // global
           call _cat8N(R1) args: 0, res: 0, upd: 0;
       cat8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat8N() //  [R1]
         { info_tbl: [(cat8N,
                       label: block_cat8N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat8N: // global
           I64[Sp - 32] = block_cat8T_info;
           _sasJ9::P64 = P64[R1 + 15];
           _sasJa::P64 = P64[R1 + 23];
           _sasJb::P64 = P64[R1 + 31];
           _sasJg::P64 = P64[R1 + 47];
           _sasJe::I64 = I64[R1 + 71];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sasJb::P64;
           I64[Sp - 16] = _sasJe::I64;
           P64[Sp - 8] = _sasJg::P64;
           P64[Sp] = _sasJa::P64;
           P64[Sp + 8] = _sasJ9::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uat92; else goto cat8X;
       uat92: // global
           call _cat8T(R1) args: 0, res: 0, upd: 0;
       cat8X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat8T() //  [R1]
         { info_tbl: [(cat8T,
                       label: block_cat8T_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat8T: // global
           R6 = P64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.335292033 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout_closure" {
     GHC.Event.TimerManager.registerTimeout_closure:
         const GHC.Event.TimerManager.registerTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(cat98,
                       label: GHC.Event.TimerManager.registerTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat98: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.registerTimeout1_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.338601227 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout1_closure" {
     GHC.Event.TimerManager.updateTimeout1_closure:
         const GHC.Event.TimerManager.updateTimeout1_info;
         const 0;
 },
 x_sasJB_entry() //  [R1]
         { info_tbl: [(cat9s,
                       label: x_sasJB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat9s: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cat9F; else goto cat9G;
       cat9F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cat9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cat9p_info;
           _sasJq::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sasJq::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uat9K; else goto cat9q;
       uat9K: // global
           call _cat9p(R1) args: 0, res: 0, upd: 0;
       cat9q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cat9p() //  [R1]
         { info_tbl: [(cat9p,
                       label: block_cat9p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat9p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cat9J; else goto cat9I;
       cat9J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cat9I: // global
           _sasJG::I64 = I64[R1 + 7] * 1000 + I64[Sp + 8];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sasJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasJL_entry() //  [R1]
         { info_tbl: [(cataa,
                       label: sat_sasJL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catab; else goto catac;
       catab: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catac: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cata3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uataj; else goto cata4;
       uataj: // global
           call _cata3(R1) args: 0, res: 0, upd: 0;
       cata4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cata3() //  [R1]
         { info_tbl: [(cata3,
                       label: block_cata3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cata3: // global
           if (R1 & 7 == 3) goto cata8; else goto cata7;
       cata8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cata7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasKu_entry() //  [R1]
         { info_tbl: [(cataR,
                       label: sat_sasKu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cataS; else goto cataT;
       cataS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cataT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cataJ_info;
           _sasJV::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasJV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatbO; else goto cataK;
       uatbO: // global
           call _cataJ(R1) args: 0, res: 0, upd: 0;
       cataK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cataJ() //  [R1]
         { info_tbl: [(cataJ,
                       label: block_cataJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataJ: // global
           _cataQ::P64 = R1 & 7;
           if (_cataQ::P64 < 3) goto uatbF; else goto uatbI;
       uatbF: // global
           _sasJV::P64 = P64[Sp + 8];
           if (_cataQ::P64 < 2) goto cataN; else goto cataO;
       cataN: // global
           I64[Sp] = block_cataW_info;
           _sasJY::I64 = I64[R1 + 39];
           R1 = _sasJV::P64;
           I64[Sp + 8] = _sasJY::I64;
           if (R1 & 7 != 0) goto uatbL; else goto cataY;
       uatbL: // global
           call _cataW(R1) args: 0, res: 0, upd: 0;
       cataY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cataO: // global
           I64[Sp] = block_catbf_info;
           _sasKg::I64 = I64[R1 + 22];
           R1 = _sasJV::P64;
           I64[Sp + 8] = _sasKg::I64;
           if (R1 & 7 != 0) goto uatbM; else goto catbh;
       uatbM: // global
           call _catbf(R1) args: 0, res: 0, upd: 0;
       catbh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uatbI: // global
           Sp = Sp + 16;
           call _cataP() args: 0, res: 0, upd: 0;
     }
 },
 _cataW() //  [R1]
         { info_tbl: [(cataW,
                       label: block_cataW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataW: // global
           _catbC::P64 = R1 & 7;
           if (_catbC::P64 < 3) goto uatbG; else goto uatbJ;
       uatbG: // global
           _sasJY::I64 = I64[Sp + 8];
           if (_catbC::P64 < 2) goto catb4; else goto catb8;
       catb4: // global
           R1 = I64[((_sasJY::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catb8: // global
           R1 = I64[((_sasJY::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatbJ: // global
           Sp = Sp + 16;
           call _cataP() args: 0, res: 0, upd: 0;
     }
 },
 _catbf() //  [R1]
         { info_tbl: [(catbf,
                       label: block_catbf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catbf: // global
           _catbz::P64 = R1 & 7;
           if (_catbz::P64 < 3) goto uatbH; else goto uatbK;
       uatbH: // global
           _sasKg::I64 = I64[Sp + 8];
           if (_catbz::P64 < 2) goto catbn; else goto catbr;
       catbn: // global
           R1 = I64[((_sasKg::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catbr: // global
           R1 = I64[((_sasKg::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatbK: // global
           Sp = Sp + 16;
           call _cataP() args: 0, res: 0, upd: 0;
     }
 },
 _cataP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasKv_entry() //  [R1, R2]
         { info_tbl: [(catbV,
                       label: sat_sasKv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catbV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto catbW; else goto catbX;
       catbW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catbX: // global
           I64[Sp - 32] = block_cat9Q_info;
           R3 = R2;
           _sasJH::P64 = R2;
           _sasJk::P64 = P64[R1 + 7];
           R2 = _sasJk::P64;
           P64[Sp - 24] = _sasJk::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sasJH::P64;
           Sp = Sp - 32;
           call GHC.Event.PSQ.deleteView_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cat9Q() //  [R1]
         { info_tbl: [(cat9Q,
                       label: block_cat9Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat9Q: // global
           if (R1 & 7 == 1) goto catbS; else goto catbT;
       catbS: // global
           _sasJH::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cat9U_info;
           R1 = _sasJH::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uatcb; else goto cat9V;
       uatcb: // global
           call _cat9U(R1) args: 0, res: 0, upd: 0;
       cat9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       catbT: // global
           I64[Sp] = block_catam_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uatcc; else goto catan;
       uatcc: // global
           call _catam(R1) args: 0, res: 0, upd: 0;
       catan: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat9U() //  [R1]
         { info_tbl: [(cat9U,
                       label: block_cat9U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat9U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto catc2; else goto catc1;
       catc2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catc1: // global
           I64[Hp - 40] = sat_sasJL_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catam() //  [R1]
         { info_tbl: [(catam,
                       label: block_catam_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catam: // global
           I64[Sp - 8] = block_catar_info;
           _sasJP::P64 = P64[R1 + 15];
           _sasJQ::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp] = _sasJQ::P64;
           P64[Sp + 8] = _sasJP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatcd; else goto catas;
       uatcd: // global
           call _catar(R1) args: 0, res: 0, upd: 0;
       catas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catar() //  [R1]
         { info_tbl: [(catar,
                       label: block_catar_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catar: // global
           I64[Sp] = block_cataw_info;
           _sasJS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sasJS::I64;
           if (R1 & 7 != 0) goto uatce; else goto catax;
       uatce: // global
           call _cataw(R1) args: 0, res: 0, upd: 0;
       catax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cataw() //  [R1]
         { info_tbl: [(cataw,
                       label: block_cataw_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataw: // global
           _sasJS::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cataB_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = _sasJS::I64;
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cataB() //  [R1]
         { info_tbl: [(cataB,
                       label: block_cataB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cataB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catca; else goto catc9;
       catca: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catc9: // global
           I64[Hp - 48] = sat_sasKu_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.updateTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(catcf,
                       label: GHC.Event.TimerManager.updateTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catcf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catcg; else goto catch;
       catcg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.updateTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       catch: // global
           _sasJl::P64 = R4;
           _sasJk::P64 = R3;
           (_sasJq::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 32] = block_cat9g_info;
           R1 = R2;
           P64[Sp - 24] = _sasJk::P64;
           P64[Sp - 16] = _sasJl::P64;
           I64[Sp - 8] = _sasJq::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatcB; else goto cat9h;
       uatcB: // global
           call _cat9g(R1) args: 0, res: 0, upd: 0;
       cat9h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cat9g() //  [R1]
         { info_tbl: [(cat9g,
                       label: block_cat9g_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat9g: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catcn; else goto catcm;
       catcn: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catcm: // global
           _sasJt::P64 = P64[R1 + 15];
           _sasJA::P64 = P64[R1 + 47];
           _sasJy::I64 = I64[R1 + 71];
           I64[Hp - 48] = x_sasJB_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = sat_sasKv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           I64[Sp + 8] = block_catci_info;
           R2 = Hp - 15;
           R1 = _sasJt::P64;
           P64[Sp + 16] = _sasJA::P64;
           I64[Sp + 24] = _sasJy::I64;
           Sp = Sp + 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catci() //  [R1]
         { info_tbl: [(catci,
                       label: block_catci_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catci: // global
           I64[Sp] = block_catck_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatcC; else goto catcp;
       uatcC: // global
           call _catck(R1) args: 0, res: 0, upd: 0;
       catcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catck() //  [R1]
         { info_tbl: [(catck,
                       label: block_catck_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catck: // global
           if (R1 & 7 == 1) goto catcv; else goto catcz;
       catcv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catcz: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.344492861 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout_closure" {
     GHC.Event.TimerManager.updateTimeout_closure:
         const GHC.Event.TimerManager.updateTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.updateTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(catcH,
                       label: GHC.Event.TimerManager.updateTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catcH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.updateTimeout1_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.346029143 UTC

[section ""data" . GHC.Event.TimerManager.cleanup1_closure" {
     GHC.Event.TimerManager.cleanup1_closure:
         const GHC.Event.TimerManager.cleanup1_info;
 },
 GHC.Event.TimerManager.cleanup1_entry() //  [R2]
         { info_tbl: [(catcR,
                       label: GHC.Event.TimerManager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catcR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catcV; else goto catcW;
       catcV: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catcW: // global
           I64[Sp - 8] = block_catcO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatdM; else goto catcP;
       uatdM: // global
           call _catcO(R1) args: 0, res: 0, upd: 0;
       catcP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catcO() //  [R1]
         { info_tbl: [(catcO,
                       label: block_catcO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catcO: // global
           I64[Sp - 48] = block_catcU_info;
           _sasKF::P64 = P64[R1 + 23];
           _sasKK::P64 = P64[R1 + 39];
           _sasKL::P64 = P64[R1 + 47];
           _sasKH::I64 = I64[R1 + 55];
           _sasKI::I64 = I64[R1 + 63];
           _sasKJ::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _sasKH::I64;
           I64[Sp - 32] = _sasKI::I64;
           I64[Sp - 24] = _sasKJ::I64;
           P64[Sp - 16] = _sasKK::P64;
           P64[Sp - 8] = _sasKL::P64;
           P64[Sp] = _sasKF::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uatdL; else goto catcY;
       uatdL: // global
           call _catcU(R1) args: 0, res: 0, upd: 0;
       catcY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catcU() //  [R1]
         { info_tbl: [(catcU,
                       label: block_catcU_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catcU: // global
           _sasKF::P64 = P64[Sp + 48];
           _sasKN::P64 = P64[R1 + 7];
           _sasKR::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_sasKF::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasKF::P64);
           I64[Sp] = block_catd5_info;
           R2 = _sasKN::P64;
           R1 = _sasKR::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catd5() //  []
         { info_tbl: [(catd5,
                       label: block_catd5_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catd5: // global
           I64[Sp] = block_catd7_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catd7() //  []
         { info_tbl: [(catd7,
                       label: block_catd7_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catd7: // global
           _sasKI::I64 = I64[Sp + 16];
           _sasKK::P64 = P64[Sp + 32];
           (_sasL3::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasL8::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKI::I64)));
           I64[Sp + 16] = block_catdm_info;
           R1 = _sasKK::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatdN; else goto catdn;
       uatdN: // global
           call _catdm(R1) args: 0, res: 0, upd: 0;
       catdn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catdm() //  [R1]
         { info_tbl: [(catdm,
                       label: block_catdm_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catdm: // global
           _sasKJ::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto catdt; else goto catdx;
       catdt: // global
           (_sasLe::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKJ::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catdx: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasLm::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKJ::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.348275997 UTC

[section ""data" . GHC.Event.TimerManager.cleanup_closure" {
     GHC.Event.TimerManager.cleanup_closure:
         const GHC.Event.TimerManager.cleanup_info;
 },
 GHC.Event.TimerManager.cleanup_entry() //  [R2]
         { info_tbl: [(catdS,
                       label: GHC.Event.TimerManager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catdS: // global
           R2 = R2;
           call GHC.Event.TimerManager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.351148434 UTC

[section ""data" . GHC.Event.TimerManager.finished1_closure" {
     GHC.Event.TimerManager.finished1_closure:
         const GHC.Event.TimerManager.finished1_info;
 },
 sat_sasLD_entry() //  [R1]
         { info_tbl: [(catef,
                       label: sat_sasLD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catef: // global
           if ((Sp + -24) < SpLim) (likely: False) goto categ; else goto cateh;
       categ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cateh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cate8_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uateo; else goto cate9;
       uateo: // global
           call _cate8(R1) args: 0, res: 0, upd: 0;
       cate9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cate8() //  [R1]
         { info_tbl: [(cate8,
                       label: block_cate8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cate8: // global
           if (R1 & 7 == 4) goto cated; else goto catec;
       cated: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catec: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.finished1_entry() //  [R2]
         { info_tbl: [(catep,
                       label: GHC.Event.TimerManager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catep: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cateq; else goto cater;
       cateq: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cater: // global
           I64[Sp - 8] = block_catdZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatev; else goto cate0;
       uatev: // global
           call _catdZ(R1) args: 0, res: 0, upd: 0;
       cate0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catdZ() //  [R1]
         { info_tbl: [(catdZ,
                       label: block_catdZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catdZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cateu; else goto catet;
       cateu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catet: // global
           _sasLB::P64 = P64[P64[R1 + 23] + 8];
           I64[Hp - 16] = sat_sasLD_info;
           P64[Hp] = _sasLB::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.352772426 UTC

[section ""data" . GHC.Event.TimerManager.finished_closure" {
     GHC.Event.TimerManager.finished_closure:
         const GHC.Event.TimerManager.finished_info;
 },
 GHC.Event.TimerManager.finished_entry() //  [R2]
         { info_tbl: [(cateA,
                       label: GHC.Event.TimerManager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cateA: // global
           R2 = R2;
           call GHC.Event.TimerManager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.353654743 UTC

[section ""data" . GHC.Event.TimerManager.shutdown2_closure" {
     GHC.Event.TimerManager.shutdown2_closure:
         const GHC.Event.TimerManager.shutdown2_info;
 },
 GHC.Event.TimerManager.shutdown2_entry() //  [R2]
         { info_tbl: [(cateI,
                       label: GHC.Event.TimerManager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cateI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cateM; else goto cateL;
       cateM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cateL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.35485643 UTC

[section ""data" . GHC.Event.TimerManager.shutdown1_closure" {
     GHC.Event.TimerManager.shutdown1_closure:
         const GHC.Event.TimerManager.shutdown1_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown1_entry() //  [R2]
         { info_tbl: [(cateU,
                       label: GHC.Event.TimerManager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cateU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cateV; else goto cateW;
       cateV: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cateW: // global
           I64[Sp - 8] = block_cateR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatfg; else goto cateS;
       uatfg: // global
           call _cateR(R1) args: 0, res: 0, upd: 0;
       cateS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cateR() //  [R1]
         { info_tbl: [(cateR,
                       label: block_cateR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cateR: // global
           I64[Sp - 16] = block_cateZ_info;
           R2 = GHC.Event.TimerManager.shutdown2_closure+1;
           _sasLQ::P64 = P64[R1 + 47];
           _sasLN::I64 = I64[R1 + 63];
           R1 = P64[R1 + 23];
           P64[Sp - 8] = _sasLQ::P64;
           I64[Sp] = _sasLN::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cateZ() //  [R1]
         { info_tbl: [(cateZ,
                       label: block_cateZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cateZ: // global
           I64[Sp] = block_catf1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatfh; else goto catf4;
       uatfh: // global
           call _catf1(R1) args: 0, res: 0, upd: 0;
       catf4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catf1() //  [R1]
         { info_tbl: [(catf1,
                       label: block_catf1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catf1: // global
           if (R1 & 7 == 2) goto catfe; else goto catfa;
       catfe: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       catfa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.35635042 UTC

[section ""data" . GHC.Event.TimerManager.shutdown_closure" {
     GHC.Event.TimerManager.shutdown_closure:
         const GHC.Event.TimerManager.shutdown_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown_entry() //  [R2]
         { info_tbl: [(catfm,
                       label: GHC.Event.TimerManager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfm: // global
           R2 = R2;
           call GHC.Event.TimerManager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.357196574 UTC

[section ""data" . GHC.Event.TimerManager.new3_closure" {
     GHC.Event.TimerManager.new3_closure:
         const GHC.Event.TimerManager.new3_info;
 },
 GHC.Event.TimerManager.new3_entry() //  [R2]
         { info_tbl: [(catfu,
                       label: GHC.Event.TimerManager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catfy; else goto catfx;
       catfy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.new3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catfx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Finished_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.359828227 UTC

[section ""data" . GHC.Event.TimerManager.new2_closure" {
     GHC.Event.TimerManager.new2_closure:
         const GHC.Event.TimerManager.new2_info;
         const 0;
 },
 sat_sasMp_entry() //  [R1]
         { info_tbl: [(catfX,
                       label: sat_sasMp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catfY; else goto catfZ;
       catfY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       catfZ: // global
           I64[Sp - 24] = block_catfO_info;
           R2 = GHC.Event.TimerManager.new3_closure+1;
           _sasLW::P64 = P64[R1 + 7];
           _sasM3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sasLW::P64;
           P64[Sp - 8] = _sasM3::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catfO() //  [R1]
         { info_tbl: [(catfO,
                       label: block_catfO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfO: // global
           I64[Sp] = block_catfQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatgg; else goto catfR;
       uatgg: // global
           call _catfQ(R1) args: 0, res: 0, upd: 0;
       catfR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catfQ() //  [R1]
         { info_tbl: [(catfQ,
                       label: block_catfQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfQ: // global
           if (R1 & 7 == 4) goto catfV; else goto catfU;
       catfV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catfU: // global
           _sasLW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_catg3_info;
           R1 = _sasLW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatgh; else goto catg4;
       uatgh: // global
           call _catg3(R1) args: 0, res: 0, upd: 0;
       catg4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catg3() //  [R1]
         { info_tbl: [(catg3,
                       label: block_catg3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catg3: // global
           I64[Sp] = block_catg8_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catg8() //  []
         { info_tbl: [(catg8,
                       label: block_catg8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catg8: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasMz_entry() //  [R1]
         { info_tbl: [(catgu,
                       label: sat_sasMz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catgv; else goto catgw;
       catgv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catgw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlReadFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasMD_entry() //  [R1]
         { info_tbl: [(catgD,
                       label: sat_sasMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catgE; else goto catgF;
       catgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlEventFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasMN_entry() //  [R1]
         { info_tbl: [(catgP,
                       label: sat_sasMN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgP: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catgT; else goto catgU;
       catgT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catgU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_catgM_info;
           _sasM0::P64 = P64[R1 + 16];
           _sasM6::P64 = P64[R1 + 32];
           _sasM9::P64 = P64[R1 + 40];
           _sasMt::P64 = P64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sasM0::P64;
           P64[Sp - 40] = _sasM6::P64;
           P64[Sp - 32] = _sasM9::P64;
           P64[Sp - 24] = _sasMt::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uatgY; else goto catgN;
       uatgY: // global
           call _catgM(R1) args: 0, res: 0, upd: 0;
       catgN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catgM() //  [R1]
         { info_tbl: [(catgM,
                       label: block_catgM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgM: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catgX; else goto catgW;
       catgX: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       catgW: // global
           _sasML::P64 = P64[R1 + 7];
           _sasMM::P64 = P64[R1 + 15];
           _sasMI::I64 = I64[R1 + 23];
           _sasMJ::I64 = I64[R1 + 31];
           _sasMK::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sasML::P64;
           P64[Hp - 24] = _sasMM::P64;
           I64[Hp - 16] = _sasMI::I64;
           I64[Hp - 8] = _sasMJ::I64;
           I64[Hp] = _sasMK::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.new2_entry() //  [R2]
         { info_tbl: [(catgZ,
                       label: GHC.Event.TimerManager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgZ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cath0; else goto cath1;
       cath0: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cath1: // global
           I64[Sp - 16] = block_catfD_info;
           R1 = GHC.Event.PSQ.Nil_closure+3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catfD() //  [R1]
         { info_tbl: [(catfD,
                       label: block_catfD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfD: // global
           I64[Sp - 8] = block_catfF_info;
           R2 = GHC.Types.True_closure+2;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _catfF() //  [R1]
         { info_tbl: [(catfF,
                       label: block_catfF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfF: // global
           I64[Sp - 8] = block_catfH_info;
           _sasM3::P64 = R1;
           R1 = GHC.Event.TimerManager.Created_closure+1;
           P64[Sp] = _sasM3::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catfH() //  [R1]
         { info_tbl: [(catfH,
                       label: block_catfH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catfH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cath6; else goto cath5;
       cath6: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cath5: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_sasMp_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_catgj_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _sasM6::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _sasM6::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catgj() //  []
         { info_tbl: [(catgj,
                       label: block_catgj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgj: // global
           I64[Sp] = block_catgl_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uathh; else goto catgm;
       uathh: // global
           call _catgl(R1) args: 0, res: 0, upd: 0;
       catgm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catgl() //  [R1]
         { info_tbl: [(catgl,
                       label: block_catgl_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catha; else goto cath9;
       catha: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cath9: // global
           _sasMu::P64 = P64[R1 + 7];
           _sasMw::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sasMz_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp - 16] = block_catgx_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _sasMu::P64;
           _sasMt::P64 = R1;
           R1 = _sasMw::P64;
           I64[Sp - 24] = stg_ap_v_info;
           P64[Sp - 8] = _sasMw::P64;
           P64[Sp] = _sasMu::P64;
           P64[Sp + 40] = _sasMt::P64;
           Sp = Sp - 24;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _catgx() //  [R1]
         { info_tbl: [(catgx,
                       label: block_catgx_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cathd; else goto cathc;
       cathd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cathc: // global
           I64[Hp - 16] = sat_sasMD_info;
           P64[Hp] = P64[Sp + 40];
           _sasMu::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_catgG_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _sasMu::P64;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_v_info;
           Sp = Sp + 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _catgG() //  [R1]
         { info_tbl: [(catgG,
                       label: block_catgG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catgG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cathg; else goto cathf;
       cathg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cathf: // global
           I64[Hp - 48] = sat_sasMN_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 40];
           R1 = Hp - 48;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.364452516 UTC

[section ""data" . GHC.Event.TimerManager.newWith_closure" {
     GHC.Event.TimerManager.newWith_closure:
         const GHC.Event.TimerManager.newWith_info;
         const 0;
 },
 GHC.Event.TimerManager.newWith_entry() //  [R2]
         { info_tbl: [(cathm,
                       label: GHC.Event.TimerManager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cathm: // global
           R2 = R2;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.365301323 UTC

[section ""data" . GHC.Event.TimerManager.new1_closure" {
     GHC.Event.TimerManager.new1_closure:
         const GHC.Event.TimerManager.new1_info;
         const 0;
 },
 GHC.Event.TimerManager.new1_entry() //  []
         { info_tbl: [(cathv,
                       label: GHC.Event.TimerManager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cathv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cathw; else goto cathx;
       cathw: // global
           R1 = GHC.Event.TimerManager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cathx: // global
           I64[Sp - 8] = block_catht_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _catht() //  [R1]
         { info_tbl: [(catht,
                       label: block_catht_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catht: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.366289225 UTC

[section ""data" . GHC.Event.TimerManager.new_closure" {
     GHC.Event.TimerManager.new_closure:
         const GHC.Event.TimerManager.new_info;
         const 0;
 },
 GHC.Event.TimerManager.new_entry() //  []
         { info_tbl: [(cathD,
                       label: GHC.Event.TimerManager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cathD: // global
           call GHC.Event.TimerManager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.369948101 UTC

[section ""data" . GHC.Event.TimerManager.step1_closure" {
     GHC.Event.TimerManager.step1_closure:
         const GHC.Event.TimerManager.step1_info;
         const 0;
 },
 sat_sasNw_entry() //  [R1]
         { info_tbl: [(catik,
                       label: sat_sasNw_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catik: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catil; else goto catim;
       catil: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catim: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catic_info;
           _sasMX::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sasMX::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatiJ; else goto catid;
       uatiJ: // global
           call _catic(R1) args: 0, res: 0, upd: 0;
       catid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catic() //  [R1]
         { info_tbl: [(catic,
                       label: block_catic_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catic: // global
           _catij::P64 = R1 & 7;
           if (_catij::P64 < 3) goto uatiI; else goto catii;
       uatiI: // global
           _sasMX::I64 = I64[Sp + 8];
           if (_catij::P64 < 2) goto catig; else goto catih;
       catig: // global
           Hp = Hp + 16;
           _sasNk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto catiE; else goto catiu;
       catiu: // global
           _sasNr::I64 = I64[_sasNk::P64 + 39] - _sasMX::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _sasNr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catih: // global
           Hp = Hp + 16;
           _sasNk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto catiE; else goto catiD;
       catiE: // global
           HpAlloc = 16;
           R1 = _sasNk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       catiD: // global
           _sasNv::I64 = I64[_sasNk::P64 + 22] - _sasMX::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _sasNv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catii: // global
           R1 = GHC.Event.Internal.Forever_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasNy_entry() //  [R1, R2]
         { info_tbl: [(catiK,
                       label: sat_sasNy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catiK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catiN; else goto catiO;
       catiN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catiO: // global
           I64[Sp - 16] = block_cati1_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 15];
           Sp = Sp - 16;
           call GHC.Event.PSQ.$watMost_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cati1() //  [R1, R2]
         { info_tbl: [(cati1,
                       label: block_cati1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cati1: // global
           I64[Sp - 8] = block_cati3_info;
           _sasNh::P64 = R1;
           R1 = R2;
           P64[Sp] = _sasNh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatiT; else goto cati4;
       uatiT: // global
           call _cati3(R1) args: 0, res: 0, upd: 0;
       cati4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cati3() //  [R1]
         { info_tbl: [(cati3,
                       label: block_cati3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cati3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catiS; else goto catiR;
       catiS: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catiR: // global
           I64[Hp - 72] = sat_sasNw_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 39;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasNX_entry() //  [R1, R2, R3]
         { info_tbl: [(catje,
                       label: sat_sasNX_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catje: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catjf; else goto catjg;
       catjf: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catjg: // global
           I64[Sp - 32] = block_catjb_info;
           _sasN1::P64 = P64[R1 + 5];
           _sasN7::P64 = P64[R1 + 13];
           _sasN5::I64 = I64[R1 + 21];
           R1 = R2;
           P64[Sp - 24] = _sasN1::P64;
           I64[Sp - 16] = _sasN5::I64;
           P64[Sp - 8] = _sasN7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatjM; else goto catjc;
       uatjM: // global
           call _catjb(R1) args: 0, res: 0, upd: 0;
       catjc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catjb() //  [R1]
         { info_tbl: [(catjb,
                       label: block_catjb_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catjb: // global
           I64[Sp] = block_catjj_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = I64[Sp + 16];
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _catjj() //  [R1]
         { info_tbl: [(catjj,
                       label: block_catjj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catjj: // global
           I64[Sp] = block_catjl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatjN; else goto catjo;
       uatjN: // global
           call _catjl(R1) args: 0, res: 0, upd: 0;
       catjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catjl() //  [R1]
         { info_tbl: [(catjl,
                       label: block_catjl_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catjl: // global
           _catjH::P64 = R1 & 7;
           if (_catjH::P64 < 3) goto uatjL; else goto catjD;
       uatjL: // global
           if (_catjH::P64 < 2) goto catju; else goto catjy;
       catju: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catjy: // global
           _sasN1::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sasN1::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasN1::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catjD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto catjG; else goto catjF;
       catjG: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catjF: // global
           _sasNT::P64 = P64[R1 + 5];
           _sasNS::I64 = I64[R1 + 13];
           _sasNU::I64 = I64[R1 + 21];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _sasNU::I64;
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _sasNT::P64;
           I64[Hp] = _sasNS::I64;
           R3 = Hp - 31;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasO6_entry() //  [R1]
         { info_tbl: [(catk7,
                       label: sat_sasO6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catk7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catk8; else goto catk9;
       catk8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catk9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_catk0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatkg; else goto catk1;
       uatkg: // global
           call _catk0(R1) args: 0, res: 0, upd: 0;
       catk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catk0() //  [R1]
         { info_tbl: [(catk0,
                       label: block_catk0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catk0: // global
           if (R1 & 7 == 2) goto catk5; else goto catk4;
       catk5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catk4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.step1_entry() //  [R2]
         { info_tbl: [(catkh,
                       label: GHC.Event.TimerManager.step1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catkh: // global
           if ((Sp + -64) < SpLim) (likely: False) goto catki; else goto catkj;
       catki: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.step1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catkj: // global
           (_sasMX::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 16] = block_cathL_info;
           R1 = R2;
           I64[Sp - 8] = _sasMX::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatl5; else goto cathM;
       uatl5: // global
           call _cathL(R1) args: 0, res: 0, upd: 0;
       cathM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cathL() //  [R1]
         { info_tbl: [(cathL,
                       label: block_cathL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cathL: // global
           I64[Sp - 32] = block_cathQ_info;
           _sasN0::P64 = P64[R1 + 15];
           _sasN1::P64 = P64[R1 + 23];
           _sasN7::P64 = P64[R1 + 47];
           _sasN5::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sasN1::P64;
           I64[Sp - 16] = _sasN5::I64;
           P64[Sp - 8] = _sasN7::P64;
           P64[Sp] = _sasN0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatl1; else goto cathR;
       uatl1: // global
           call _cathQ(R1) args: 0, res: 0, upd: 0;
       cathR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cathQ() //  [R1]
         { info_tbl: [(cathQ,
                       label: block_cathQ_info
                       rep:StackRep [False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cathQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto catkn; else goto catkm;
       catkn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catkm: // global
           _sasN9::P64 = P64[R1 + 7];
           _sasNa::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           _sasMX::I64 = I64[Sp + 40];
           I64[Hp - 24] = _sasMX::I64;
           I64[Hp - 16] = sat_sasNy_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _sasMX::I64;
           I64[Sp] = block_catiU_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sasNa::P64;
           P64[Sp + 40] = _sasN9::P64;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catiU() //  [R1]
         { info_tbl: [(catiU,
                       label: block_catiU_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catiU: // global
           I64[Sp] = block_catiW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatl2; else goto catiX;
       uatl2: // global
           call _catiW(R1) args: 0, res: 0, upd: 0;
       catiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catiW() //  [R1]
         { info_tbl: [(catiW,
                       label: block_catiW_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catiW: // global
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call _catkA() args: 0, res: 0, upd: 0;
     }
 },
 _catkA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catkA: // global
           _sasO8::P64 = P64[Sp];
           I64[Sp] = block_catkC_info;
           R1 = _sasO8::P64;
           if (R1 & 7 != 0) goto uatl6; else goto catkE;
       uatl6: // global
           call _catkC(R1) args: 0, res: 0, upd: 0;
       catkE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catkC() //  [R1]
         { info_tbl: [(catkC,
                       label: block_catkC_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catkC: // global
           if (R1 & 7 == 1) goto uatl7; else goto catkP;
       uatl7: // global
           call _catj4() args: 0, res: 0, upd: 0;
       catkP: // global
           I64[Sp - 8] = block_catkN_info;
           _sasOc::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sasOc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatl8; else goto catkQ;
       uatl8: // global
           call _catkN(R1) args: 0, res: 0, upd: 0;
       catkQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catj4() //  []
         { info_tbl: [(catj4,
                       label: block_catj4_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catj4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto catks; else goto catkr;
       catks: // global
           HpAlloc = 48;
           I64[Sp] = block_catj4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       catkr: // global
           I64[Hp - 40] = sat_sasNX_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_catjP_info;
           R4 = Hp - 37;
           R3 = Hp - 6;
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catjP() //  []
         { info_tbl: [(catjP,
                       label: block_catjP_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catjP: // global
           _sasO3::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 40] = block_catjR_info;
           R1 = _sasO3::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uatl4; else goto catjS;
       uatl4: // global
           call _catjR(R1) args: 0, res: 0, upd: 0;
       catjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catjR() //  [R1]
         { info_tbl: [(catjR,
                       label: block_catjR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catjR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catkw; else goto catkv;
       catkw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catkv: // global
           I64[Hp - 16] = sat_sasO6_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catkN() //  [R1]
         { info_tbl: [(catkN,
                       label: block_catkN_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catkN: // global
           I64[Sp] = block_catkU_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catkU() //  []
         { info_tbl: [(catkU,
                       label: block_catkU_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catkU: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _catkA() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.376385169 UTC

[section ""data" . GHC.Event.TimerManager.step_closure" {
     GHC.Event.TimerManager.step_closure:
         const GHC.Event.TimerManager.step_info;
         const 0;
 },
 GHC.Event.TimerManager.step_entry() //  [R2]
         { info_tbl: [(catle,
                       label: GHC.Event.TimerManager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catle: // global
           R2 = R2;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.37713199 UTC

[section ""cstring" . lvl_rasDV_bytes" {
     lvl_rasDV_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.378174607 UTC

[section ""data" . lvl1_rasDW_closure" {
     lvl1_rasDW_closure:
         const lvl1_rasDW_info;
         const 0;
 },
 sat_sasOm_entry() //  [R1]
         { info_tbl: [(catlw,
                       label: sat_sasOm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catlw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catlx; else goto catly;
       catlx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_catlp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatlF; else goto catlq;
       uatlF: // global
           call _catlp(R1) args: 0, res: 0, upd: 0;
       catlq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catlp() //  [R1]
         { info_tbl: [(catlp,
                       label: block_catlp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catlp: // global
           if (R1 & 7 == 4) goto catlu; else goto catlt;
       catlu: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       catlt: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_rasDW_entry() //  [R2]
         { info_tbl: [(catlI,
                       label: lvl1_rasDW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catlI: // global
           _sasOk::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto catlJ; else goto catlK;
       catlK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catlM; else goto catlL;
       catlM: // global
           HpAlloc = 24;
           goto catlJ;
       catlJ: // global
           R2 = _sasOk::P64;
           R1 = lvl1_rasDW_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catlL: // global
           I64[Hp - 16] = sat_sasOm_info;
           P64[Hp] = _sasOk::P64;
           I64[Sp - 8] = block_catlG_info;
           R3 = Hp - 16;
           R2 = lvl_rasDV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _catlG() //  [R1]
         { info_tbl: [(catlG,
                       label: block_catlG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catlG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.379674289 UTC

[section ""data" . lvl2_rasDX_closure" {
     lvl2_rasDX_closure:
         const (,)_con_info;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.380581169 UTC

[section ""data" . lvl3_rasDY_closure" {
     lvl3_rasDY_closure:
         const lvl3_rasDY_info;
 },
 lvl3_rasDY_entry() //  [R2]
         { info_tbl: [(catm1,
                       label: lvl3_rasDY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catm1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catm2; else goto catm3;
       catm2: // global
           R2 = R2;
           R1 = lvl3_rasDY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catm3: // global
           I64[Sp - 8] = block_catlU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatmd; else goto catlV;
       uatmd: // global
           call _catlU(R1) args: 0, res: 0, upd: 0;
       catlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catlU() //  [R1]
         { info_tbl: [(catlU,
                       label: block_catlU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catlU: // global
           if (R1 & 7 == 1) goto catlZ; else goto catlY;
       catlZ: // global
           R1 = lvl2_rasDX_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catlY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catm9; else goto catm8;
       catm9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catm8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.387338771 UTC

[section ""data" . GHC.Event.TimerManager.$wloop_closure" {
     GHC.Event.TimerManager.$wloop_closure:
         const GHC.Event.TimerManager.$wloop_info;
         const 0;
 },
 GHC.Event.TimerManager.$wloop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmf: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 40, res: 0, upd: 8;
     }
 },
 go_sasPk_entry() //  [R1]
         { info_tbl: [(catmN,
                       label: go_sasPk_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto uatn0; else goto uatmZ;
       uatn0: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _catmO() args: 0, res: 0, upd: 0;
       uatmZ: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _catmA() args: 0, res: 0, upd: 0;
     }
 },
 _catmA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catmR; else goto catmQ;
       catmR: // global
           HpAlloc = 80;
           call _catmO() args: 0, res: 0, upd: 0;
       catmQ: // global
           _sasPk::P64 = P64[Sp];
           _sasOr::P64 = P64[_sasPk::P64 + 7];
           _sasOs::P64 = P64[_sasPk::P64 + 15];
           _sasOt::P64 = P64[_sasPk::P64 + 23];
           _sasOx::P64 = P64[_sasPk::P64 + 31];
           _sasOy::P64 = P64[_sasPk::P64 + 39];
           _sasOA::P64 = P64[_sasPk::P64 + 47];
           _sasOu::I64 = I64[_sasPk::P64 + 55];
           _sasOv::I64 = I64[_sasPk::P64 + 63];
           _sasOw::I64 = I64[_sasPk::P64 + 71];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = _sasOA::P64;
           P64[Hp - 56] = _sasOr::P64;
           P64[Hp - 48] = _sasOs::P64;
           P64[Hp - 40] = _sasOt::P64;
           P64[Hp - 32] = _sasOx::P64;
           P64[Hp - 24] = _sasOy::P64;
           I64[Hp - 16] = _sasOu::I64;
           I64[Hp - 8] = _sasOv::I64;
           I64[Hp] = _sasOw::I64;
           I64[Sp - 8] = block_catmE_info;
           R2 = Hp - 71;
           Sp = Sp - 8;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _catmO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmO: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catmE() //  [R1]
         { info_tbl: [(catmE,
                       label: block_catmE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmE: // global
           I64[Sp] = block_catmG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatn3; else goto catmH;
       uatn3: // global
           call _catmG(R1) args: 0, res: 0, upd: 0;
       catmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catmG() //  [R1]
         { info_tbl: [(catmG,
                       label: block_catmG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmG: // global
           if (R1 & 7 == 1) goto catmK; else goto uatn1;
       catmK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uatn1: // global
           Sp = Sp + 8;
           call _catmA() args: 0, res: 0, upd: 0;
     }
 },
 sat_sasQ0_entry() //  [R1, R2]
         { info_tbl: [(catnn,
                       label: sat_sasQ0_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catnn: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catno; else goto catnp;
       catno: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catnp: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_catnh_info;
           _sasPt::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasPt::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catnh() //  []
         { info_tbl: [(catnh,
                       label: block_catnh_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catnh: // global
           I64[Sp] = block_catnj_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catnj() //  []
         { info_tbl: [(catnj,
                       label: block_catnj_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catnj: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasPG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasPL::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_catnA_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatnZ; else goto catnB;
       uatnZ: // global
           call _catnA(R1) args: 0, res: 0, upd: 0;
       catnB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catnA() //  [R1]
         { info_tbl: [(catnA,
                       label: block_catnA_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catnA: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasPt::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto catnH; else goto catnL;
       catnH: // global
           (_sasPR::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasPt::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       catnL: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasPZ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasPt::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasPs_entry() //  [R1]
         { info_tbl: [(cato5,
                       label: sat_sasPs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cato5: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasR8_entry() //  [R1, R2]
         { info_tbl: [(catos,
                       label: sat_sasR8_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catos: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catot; else goto catou;
       catot: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catou: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_catom_info;
           _sasQB::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasQB::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catom() //  []
         { info_tbl: [(catom,
                       label: block_catom_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catom: // global
           I64[Sp] = block_catoo_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catoo() //  []
         { info_tbl: [(catoo,
                       label: block_catoo_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catoo: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasQO::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasQT::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_catoF_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatp4; else goto catoG;
       uatp4: // global
           call _catoF(R1) args: 0, res: 0, upd: 0;
       catoG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catoF() //  [R1]
         { info_tbl: [(catoF,
                       label: block_catoF_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catoF: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasQB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto catoM; else goto catoQ;
       catoM: // global
           (_sasQZ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQB::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       catoQ: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasR7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQB::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasQA_entry() //  [R1]
         { info_tbl: [(catpa,
                       label: sat_sasQA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catpa: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasRH_entry() //  [R1]
         { info_tbl: [(catpo,
                       label: sat_sasRH_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catpo: // global
           _sasRH::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto catpp; else goto catpq;
       catpq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto catps; else goto catpr;
       catps: // global
           HpAlloc = 88;
           goto catpp;
       catpp: // global
           R1 = _sasRH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       catpr: // global
           _sasOs::P64 = P64[_sasRH::P64 + 7];
           _sasOx::P64 = P64[_sasRH::P64 + 15];
           _sasOy::P64 = P64[_sasRH::P64 + 23];
           _sasOB::P64 = P64[_sasRH::P64 + 31];
           _sasOF::P64 = P64[_sasRH::P64 + 39];
           _sasPk::P64 = P64[_sasRH::P64 + 47];
           _sasOu::I64 = I64[_sasRH::P64 + 55];
           _sasOv::I64 = I64[_sasRH::P64 + 63];
           _sasOw::I64 = I64[_sasRH::P64 + 71];
           I64[Hp - 80] = sat_sasR8_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasQA_info;
           P64[Hp] = _sasPk::P64;
           I64[Sp - 72] = block_catpd_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           P64[Sp - 64] = _sasOs::P64;
           I64[Sp - 56] = _sasOu::I64;
           I64[Sp - 48] = _sasOv::I64;
           I64[Sp - 40] = _sasOw::I64;
           P64[Sp - 32] = _sasOx::P64;
           P64[Sp - 24] = _sasOy::P64;
           P64[Sp - 16] = _sasOB::P64;
           P64[Sp - 8] = _sasOF::P64;
           Sp = Sp - 72;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catpd() //  [R1]
         { info_tbl: [(catpd,
                       label: block_catpd_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catpd: // global
           _sasOs::P64 = P64[Sp + 8];
           _sasOB::P64 = P64[Sp + 56];
           _sasOF::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 8] = block_catpi_info;
           R2 = _sasOB::P64;
           _sasRb::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 64] = _sasRb::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catpi() //  []
         { info_tbl: [(catpi,
                       label: block_catpi_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catpi: // global
           I64[Sp] = block_catpk_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catpk() //  []
         { info_tbl: [(catpk,
                       label: block_catpk_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catpk: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasRn::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasRs::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_catpE_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatq3; else goto catpF;
       uatq3: // global
           call _catpE(R1) args: 0, res: 0, upd: 0;
       catpF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catpE() //  [R1]
         { info_tbl: [(catpE,
                       label: block_catpE_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catpE: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasRb::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto catpL; else goto catpP;
       catpL: // global
           (_sasRy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRb::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catpP: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasRG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRb::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasSg_entry() //  [R1, R2]
         { info_tbl: [(catqj,
                       label: sat_sasSg_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catqj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catqk; else goto catql;
       catqk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catql: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_catqd_info;
           _sasRJ::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasRJ::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catqd() //  []
         { info_tbl: [(catqd,
                       label: block_catqd_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catqd: // global
           I64[Sp] = block_catqf_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catqf() //  []
         { info_tbl: [(catqf,
                       label: block_catqf_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catqf: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasRW::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasS1::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_catqw_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatqV; else goto catqx;
       uatqV: // global
           call _catqw(R1) args: 0, res: 0, upd: 0;
       catqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catqw() //  [R1]
         { info_tbl: [(catqw,
                       label: block_catqw_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catqw: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasRJ::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto catqD; else goto catqH;
       catqD: // global
           (_sasS7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRJ::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       catqH: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasSf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRJ::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasRI_entry() //  [R1]
         { info_tbl: [(catr1,
                       label: sat_sasRI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catr1: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wloop_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(catr4,
                       label: GHC.Event.TimerManager.$wloop_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catr4: // global
           if ((Sp + -64) < SpLim) (likely: False) goto catr5; else goto catr6;
       catr5: // global
           R1 = GHC.Event.TimerManager.$wloop_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       catr6: // global
           I64[Sp - 40] = block_catmj_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uatuq; else goto catmk;
       uatuq: // global
           call _catmj(R1) args: 0, res: 0, upd: 0;
       catmk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catmj() //  [R1]
         { info_tbl: [(catmj,
                       label: block_catmj_info
                       rep:StackRep [False, False, False, True, True, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmj: // global
           I64[Sp - 24] = block_catmo_info;
           R2 = lvl3_rasDY_closure+1;
           _sasOA::P64 = R1;
           _sasOB::P64 = P64[R1 + 7];
           _sasOF::P64 = P64[R1 + 39];
           R1 = P64[Sp + 16];
           P64[Sp - 16] = _sasOB::P64;
           P64[Sp - 8] = _sasOF::P64;
           P64[Sp] = _sasOA::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catmo() //  [R1]
         { info_tbl: [(catmo,
                       label: block_catmo_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmo: // global
           I64[Sp] = block_catmq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatup; else goto catmr;
       uatup: // global
           call _catmq(R1) args: 0, res: 0, upd: 0;
       catmr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catmq() //  [R1]
         { info_tbl: [(catmq,
                       label: block_catmq_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmq: // global
           _cattw::P64 = R1 & 7;
           if (_cattw::P64 == 1) goto catrJ; else goto uatun;
       catrJ: // global
           I64[Sp] = block_catmw_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       uatun: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           if (_cattw::P64 == 3) goto catt6; else goto catri;
       catt6: // global
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 48] = block_catt2_info;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       catri: // global
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_catrd_info;
           R2 = _sasOB::P64;
           _sasOJ::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasOJ::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catmw() //  [R1]
         { info_tbl: [(catmw,
                       label: block_catmw_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catmw: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto catrM; else goto catrL;
       catrM: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       catrL: // global
           I64[Hp - 160] = go_sasPk_info;
           P64[Hp - 152] = P64[Sp + 32];
           _sasOs::P64 = P64[Sp + 40];
           P64[Hp - 144] = _sasOs::P64;
           P64[Hp - 136] = P64[Sp + 48];
           _sasOx::P64 = P64[Sp + 80];
           P64[Hp - 128] = _sasOx::P64;
           _sasOy::P64 = P64[Sp + 88];
           P64[Hp - 120] = _sasOy::P64;
           P64[Hp - 112] = P64[Sp + 24];
           _sasOu::I64 = I64[Sp + 56];
           I64[Hp - 104] = _sasOu::I64;
           _sasOv::I64 = I64[Sp + 64];
           I64[Hp - 96] = _sasOv::I64;
           _sasOw::I64 = I64[Sp + 72];
           I64[Hp - 88] = _sasOw::I64;
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           _catmy::P64 = Hp - 159;
           if (R1 == 0) goto catsn; else goto uatuo;
       catsn: // global
           I64[Hp - 80] = sat_sasRH_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           P64[Hp - 32] = _catmy::P64;
           I64[Hp - 24] = _sasOu::I64;
           I64[Hp - 16] = _sasOv::I64;
           I64[Hp - 8] = _sasOw::I64;
           _cato9::P64 = Hp - 79;
           Hp = Hp - 8;
           R1 = _cato9::P64;
           Sp = Sp + 96;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uatuo: // global
           if (R1 == 1) goto catsw; else goto catrW;
       catsw: // global
           I64[Hp - 80] = sat_sasSg_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasRI_info;
           P64[Hp] = _catmy::P64;
           I64[Sp] = block_catso_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       catrW: // global
           I64[Hp - 80] = sat_sasQ0_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasPs_info;
           P64[Hp] = _catmy::P64;
           I64[Sp] = block_catrN_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catso() //  [R1]
         { info_tbl: [(catso,
                       label: block_catso_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catso: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_catst_info;
           R2 = _sasOB::P64;
           _sasSj::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasSj::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catst() //  []
         { info_tbl: [(catst,
                       label: block_catst_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catst: // global
           I64[Sp] = block_catsv_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catsv() //  []
         { info_tbl: [(catsv,
                       label: block_catsv_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catsv: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasSv::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasSA::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_catsL_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uatut; else goto catsM;
       uatut: // global
           call _catsL(R1) args: 0, res: 0, upd: 0;
       catsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catsL() //  [R1]
         { info_tbl: [(catsL,
                       label: block_catsL_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catsL: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasSj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto catsS; else goto catsW;
       catsS: // global
           (_sasSG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasSj::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catsW: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasSO::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasSj::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catrN() //  [R1]
         { info_tbl: [(catrN,
                       label: block_catrN_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catrN: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_catrS_info;
           R2 = _sasOB::P64;
           _sasQ3::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasQ3::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catrS() //  []
         { info_tbl: [(catrS,
                       label: block_catrS_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catrS: // global
           I64[Sp] = block_catrU_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catrU() //  []
         { info_tbl: [(catrU,
                       label: block_catrU_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catrU: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasQf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasQk::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_catsb_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uatus; else goto catsc;
       uatus: // global
           call _catsb(R1) args: 0, res: 0, upd: 0;
       catsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catsb() //  [R1]
         { info_tbl: [(catsb,
                       label: block_catsb_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catsb: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasQ3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto catsi; else goto catsm;
       catsi: // global
           (_sasQq::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQ3::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catsm: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasQy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQ3::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catt2() //  []
         { info_tbl: [(catt2,
                       label: block_catt2_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catt2: // global
           I64[Sp] = block_catt4_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catt4() //  []
         { info_tbl: [(catt4,
                       label: block_catt4_info
                       rep:StackRep [True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catt4: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasT0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasT5::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cattk_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatuu; else goto cattl;
       uatuu: // global
           call _cattk(R1) args: 0, res: 0, upd: 0;
       cattl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cattk() //  [R1]
         { info_tbl: [(cattk,
                       label: block_cattk_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cattk: // global
           _sasOw::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cattr; else goto cattv;
       cattr: // global
           (_sasTb::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cattv: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasTj::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catrd() //  []
         { info_tbl: [(catrd,
                       label: block_catrd_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catrd: // global
           I64[Sp] = block_catrf_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catrf() //  []
         { info_tbl: [(catrf,
                       label: block_catrf_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catrf: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasOV::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasP0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_catrw_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uatur; else goto catrx;
       uatur: // global
           call _catrw(R1) args: 0, res: 0, upd: 0;
       catrx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catrw() //  [R1]
         { info_tbl: [(catrw,
                       label: block_catrw_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catrw: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasOJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto catrD; else goto catrH;
       catrD: // global
           (_sasP6::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R2 = _sasOJ::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
       catrH: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasPf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R2 = _sasOJ::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.401038557 UTC

[section ""data" . GHC.Event.TimerManager.loop1_closure" {
     GHC.Event.TimerManager.loop1_closure:
         const GHC.Event.TimerManager.loop1_info;
         const 0;
 },
 GHC.Event.TimerManager.loop1_entry() //  [R2]
         { info_tbl: [(catuC,
                       label: GHC.Event.TimerManager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catuC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catuD; else goto catuE;
       catuD: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catuE: // global
           I64[Sp - 8] = block_catuz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatuI; else goto catuA;
       uatuI: // global
           call _catuz(R1) args: 0, res: 0, upd: 0;
       catuA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catuz() //  [R1]
         { info_tbl: [(catuz,
                       label: block_catuz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catuz: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 63];
           I64[Sp - 16] = I64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 39];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 24;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.402315307 UTC

[section ""data" . GHC.Event.TimerManager.loop_closure" {
     GHC.Event.TimerManager.loop_closure:
         const GHC.Event.TimerManager.loop_info;
         const 0;
 },
 GHC.Event.TimerManager.loop_entry() //  [R2]
         { info_tbl: [(catuN,
                       label: GHC.Event.TimerManager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catuN: // global
           R2 = R2;
           call GHC.Event.TimerManager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.403432397 UTC

[section ""data" . GHC.Event.TimerManager.TimerManager_closure" {
     GHC.Event.TimerManager.TimerManager_closure:
         const GHC.Event.TimerManager.TimerManager_info;
 },
 GHC.Event.TimerManager.TimerManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catuR: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.TimerManager_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.TimerManager_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(catuW,
                       label: GHC.Event.TimerManager.TimerManager_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catuW: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catv0; else goto catuZ;
       catv0: // global
           HpAlloc = 80;
           R1 = GHC.Event.TimerManager.TimerManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       catuZ: // global
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = R6;
           I64[Hp - 8] = I64[Sp];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.404668415 UTC

[section ""data" . GHC.Event.TimerManager.Created_closure" {
     GHC.Event.TimerManager.Created_closure:
         const GHC.Event.TimerManager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.405234164 UTC

[section ""data" . GHC.Event.TimerManager.Running_closure" {
     GHC.Event.TimerManager.Running_closure:
         const GHC.Event.TimerManager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.405816285 UTC

[section ""data" . GHC.Event.TimerManager.Dying_closure" {
     GHC.Event.TimerManager.Dying_closure:
         const GHC.Event.TimerManager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.406375402 UTC

[section ""data" . GHC.Event.TimerManager.Finished_closure" {
     GHC.Event.TimerManager.Finished_closure:
         const GHC.Event.TimerManager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.406998278 UTC

[GHC.Event.TimerManager.TimerManager_con_entry() //  [R1]
         { info_tbl: [(catv1,
                       label: GHC.Event.TimerManager.TimerManager_con_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,84,105,109,101,114,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catv1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.407679323 UTC

[section ""relreadonly" . GHC.Event.TimerManager.State_closure_tbl" {
     GHC.Event.TimerManager.State_closure_tbl:
         const GHC.Event.TimerManager.Created_closure+1;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Dying_closure+3;
         const GHC.Event.TimerManager.Finished_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.408320184 UTC

[GHC.Event.TimerManager.Created_con_entry() //  [R1]
         { info_tbl: [(catv2,
                       label: GHC.Event.TimerManager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catv2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.409042976 UTC

[GHC.Event.TimerManager.Running_con_entry() //  [R1]
         { info_tbl: [(catv3,
                       label: GHC.Event.TimerManager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catv3: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.409798613 UTC

[GHC.Event.TimerManager.Dying_con_entry() //  [R1]
         { info_tbl: [(catv4,
                       label: GHC.Event.TimerManager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catv4: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.410526135 UTC

[GHC.Event.TimerManager.Finished_con_entry() //  [R1]
         { info_tbl: [(catv5,
                       label: GHC.Event.TimerManager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catv5: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.411143416 UTC

[section ""relreadonly" . SasVk_srt" {
     SasVk_srt:
         const GHC.Event.TimerManager.$w$cshowsPrec_closure;
         const GHC.Event.TimerManager.$fShowState1_closure;
         const GHC.Event.TimerManager.$fShowState3_closure;
         const GHC.Event.TimerManager.$fShowState5_closure;
         const GHC.Event.TimerManager.$fShowState7_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.TimerManager.wakeManager1_closure;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure;
         const GHC.Event.TimerManager.$weditTimeouts_closure;
         const GHC.Event.TimerManager.unregisterTimeout2_closure;
         const GHC.Event.TimerManager.unregisterTimeout1_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const GHC.Event.TimerManager.$wregisterTimeout_closure;
         const GHC.Event.TimerManager.registerTimeout1_closure;
         const GHC.Event.TimerManager.updateTimeout1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.TimerManager.shutdown1_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.TimerManager.new1_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.TimerManager.step1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl1_rasDW_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.TimerManager.loop1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.411906619 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:27.413042266 UTC

[section ""data" . GHC.Event.TimerManager.$WTimerManager_closure" {
     GHC.Event.TimerManager.$WTimerManager_closure:
         const GHC.Event.TimerManager.$WTimerManager_info;
 },
 GHC.Event.TimerManager.$WTimerManager_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(catvd,
                       label: GHC.Event.TimerManager.$WTimerManager_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catvd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto catvB; else goto catvC;
       catvB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$WTimerManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       catvC: // global
           I64[Sp - 40] = block_catva_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uatvL; else goto catvb;
       uatvL: // global
           call _catva(R1) args: 0, res: 0, upd: 0;
       catvb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catva() //  [R1]
         { info_tbl: [(catva,
                       label: block_catva_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catva: // global
           I64[Sp] = block_catvg_info;
           _sasE5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sasE5::P64;
           if (R1 & 7 != 0) goto uatvK; else goto catvh;
       uatvK: // global
           call _catvg(R1) args: 0, res: 0, upd: 0;
       catvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catvg() //  [R1]
         { info_tbl: [(catvg,
                       label: block_catvg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catvg: // global
           I64[Sp] = block_catvl_info;
           _sasE7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sasE7::P64;
           if (R1 & 7 != 0) goto uatvM; else goto catvm;
       uatvM: // global
           call _catvl(R1) args: 0, res: 0, upd: 0;
       catvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catvl() //  [R1]
         { info_tbl: [(catvl,
                       label: block_catvl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catvl: // global
           I64[Sp] = block_catvq_info;
           _sasE9::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sasE9::P64;
           if (R1 & 7 != 0) goto uatvN; else goto catvr;
       uatvN: // global
           call _catvq(R1) args: 0, res: 0, upd: 0;
       catvr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catvq() //  [R1]
         { info_tbl: [(catvq,
                       label: block_catvq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catvq: // global
           I64[Sp] = block_catvv_info;
           _sasEb::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sasEb::P64;
           if (R1 & 7 != 0) goto uatvO; else goto catvw;
       uatvO: // global
           call _catvv(R1) args: 0, res: 0, upd: 0;
       catvw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catvv() //  [R1]
         { info_tbl: [(catvv,
                       label: block_catvv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catvv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catvJ; else goto catvI;
       catvJ: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catvI: // global
           _sasEg::P64 = P64[R1 + 7];
           _sasEh::P64 = P64[R1 + 15];
           _sasEd::I64 = I64[R1 + 23];
           _sasEe::I64 = I64[R1 + 31];
           _sasEf::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sasEg::P64;
           P64[Hp - 24] = _sasEh::P64;
           I64[Hp - 16] = _sasEd::I64;
           I64[Hp - 8] = _sasEe::I64;
           I64[Hp] = _sasEf::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.41514229 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState8_bytes" {
     GHC.Event.TimerManager.$fShowState8_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.415843052 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState7_closure" {
     GHC.Event.TimerManager.$fShowState7_closure:
         const GHC.Event.TimerManager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState7_entry() //  [R1]
         { info_tbl: [(catvV,
                       label: GHC.Event.TimerManager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catvV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catvW; else goto catvX;
       catvW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catvX: // global
           (_catvS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_catvS::I64 == 0) goto catvU; else goto catvT;
       catvU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       catvT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _catvS::I64;
           R2 = GHC.Event.TimerManager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.416685097 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState6_bytes" {
     GHC.Event.TimerManager.$fShowState6_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.417443838 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState5_closure" {
     GHC.Event.TimerManager.$fShowState5_closure:
         const GHC.Event.TimerManager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState5_entry() //  [R1]
         { info_tbl: [(catw4,
                       label: GHC.Event.TimerManager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catw4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catw5; else goto catw6;
       catw5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catw6: // global
           (_catw1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_catw1::I64 == 0) goto catw3; else goto catw2;
       catw3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       catw2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _catw1::I64;
           R2 = GHC.Event.TimerManager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.418315998 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState4_bytes" {
     GHC.Event.TimerManager.$fShowState4_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.419025592 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState3_closure" {
     GHC.Event.TimerManager.$fShowState3_closure:
         const GHC.Event.TimerManager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState3_entry() //  [R1]
         { info_tbl: [(catwd,
                       label: GHC.Event.TimerManager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catwd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catwe; else goto catwf;
       catwe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catwf: // global
           (_catwa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_catwa::I64 == 0) goto catwc; else goto catwb;
       catwc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       catwb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _catwa::I64;
           R2 = GHC.Event.TimerManager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.419916723 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState2_bytes" {
     GHC.Event.TimerManager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.42065483 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState1_closure" {
     GHC.Event.TimerManager.$fShowState1_closure:
         const GHC.Event.TimerManager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState1_entry() //  [R1]
         { info_tbl: [(catwm,
                       label: GHC.Event.TimerManager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catwm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catwn; else goto catwo;
       catwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catwo: // global
           (_catwj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_catwj::I64 == 0) goto catwl; else goto catwk;
       catwl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       catwk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _catwj::I64;
           R2 = GHC.Event.TimerManager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.422156768 UTC

[section ""data" . GHC.Event.TimerManager.$w$cshowsPrec_closure" {
     GHC.Event.TimerManager.$w$cshowsPrec_closure:
         const GHC.Event.TimerManager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(catwC,
                       label: GHC.Event.TimerManager.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catwC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catwD; else goto catwE;
       catwD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catwE: // global
           I64[Sp - 16] = block_catwt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatwT; else goto catwu;
       uatwT: // global
           call _catwt(R1) args: 0, res: 0, upd: 0;
       catwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catwt() //  [R1]
         { info_tbl: [(catwt,
                       label: block_catwt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catwt: // global
           _sasEj::P64 = P64[Sp + 8];
           _catwB::P64 = R1 & 7;
           if (_catwB::P64 < 3) goto uatwR; else goto uatwS;
       uatwR: // global
           if (_catwB::P64 < 2) goto catwx; else goto catwy;
       catwx: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       catwy: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uatwS: // global
           if (_catwB::P64 < 4) goto catwz; else goto catwA;
       catwz: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       catwA: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.423540465 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(catwY,
                       label: GHC.Event.TimerManager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catwY: // global
           _sasEm::P64 = R3;
           R3 = R4;
           R2 = _sasEm::P64;
           call GHC.Event.TimerManager.$w$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.427460088 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c==_closure" {
     GHC.Event.TimerManager.$fEqState_$c==_closure:
         const GHC.Event.TimerManager.$fEqState_$c==_info;
 },
 GHC.Event.TimerManager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(catxe,
                       label: GHC.Event.TimerManager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catxf; else goto catxg;
       catxf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catxg: // global
           I64[Sp - 16] = block_catx5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatyx; else goto catx6;
       uatyx: // global
           call _catx5(R1) args: 0, res: 0, upd: 0;
       catx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catx5() //  [R1]
         { info_tbl: [(catx5,
                       label: block_catx5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catx5: // global
           _sasEp::P64 = P64[Sp + 8];
           _catxd::P64 = R1 & 7;
           if (_catxd::P64 < 3) goto uatyj; else goto uatyk;
       uatyj: // global
           if (_catxd::P64 < 2) goto catx9; else goto catxa;
       catx9: // global
           I64[Sp + 8] = block_catxj_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatyt; else goto catxl;
       uatyt: // global
           call _catxj(R1) args: 0, res: 0, upd: 0;
       catxl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       catxa: // global
           I64[Sp + 8] = block_catxy_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatyu; else goto catxA;
       uatyu: // global
           call _catxy(R1) args: 0, res: 0, upd: 0;
       catxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uatyk: // global
           if (_catxd::P64 < 4) goto catxb; else goto catxc;
       catxb: // global
           I64[Sp + 8] = block_catxN_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatyv; else goto catxP;
       uatyv: // global
           call _catxN(R1) args: 0, res: 0, upd: 0;
       catxP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       catxc: // global
           I64[Sp + 8] = block_caty2_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatyw; else goto caty4;
       uatyw: // global
           call _caty2(R1) args: 0, res: 0, upd: 0;
       caty4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catxj() //  [R1]
         { info_tbl: [(catxj,
                       label: block_catxj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catxj: // global
           if (R1 & 7 == 1) goto uatyl; else goto uatym;
       uatyl: // global
           Sp = Sp + 8;
           call _catye() args: 0, res: 0, upd: 0;
       uatym: // global
           Sp = Sp + 8;
           call _catya() args: 0, res: 0, upd: 0;
     }
 },
 _catxy() //  [R1]
         { info_tbl: [(catxy,
                       label: block_catxy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catxy: // global
           if (R1 & 7 == 2) goto uatyn; else goto uatyo;
       uatyn: // global
           Sp = Sp + 8;
           call _catye() args: 0, res: 0, upd: 0;
       uatyo: // global
           Sp = Sp + 8;
           call _catya() args: 0, res: 0, upd: 0;
     }
 },
 _catxN() //  [R1]
         { info_tbl: [(catxN,
                       label: block_catxN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catxN: // global
           if (R1 & 7 == 3) goto uatyp; else goto uatyq;
       uatyp: // global
           Sp = Sp + 8;
           call _catye() args: 0, res: 0, upd: 0;
       uatyq: // global
           Sp = Sp + 8;
           call _catya() args: 0, res: 0, upd: 0;
     }
 },
 _caty2() //  [R1]
         { info_tbl: [(caty2,
                       label: block_caty2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caty2: // global
           if (R1 & 7 == 4) goto uatyr; else goto uatys;
       uatyr: // global
           Sp = Sp + 8;
           call _catye() args: 0, res: 0, upd: 0;
       uatys: // global
           Sp = Sp + 8;
           call _catya() args: 0, res: 0, upd: 0;
     }
 },
 _catye() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catye: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catya() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catya: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.429569292 UTC

[section ""data" . GHC.Event.TimerManager.$fEqTimeoutKey_closure" {
     GHC.Event.TimerManager.$fEqTimeoutKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.eqInt_closure+2;
         const GHC.Classes.neInt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.430385685 UTC

[section ""data" . GHC.Event.TimerManager.emControl_closure" {
     GHC.Event.TimerManager.emControl_closure:
         const GHC.Event.TimerManager.emControl_info;
 },
 GHC.Event.TimerManager.emControl_entry() //  [R2]
         { info_tbl: [(catyN,
                       label: GHC.Event.TimerManager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catyN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catyR; else goto catyS;
       catyR: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catyS: // global
           I64[Sp - 8] = block_catyK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatyW; else goto catyL;
       uatyW: // global
           call _catyK(R1) args: 0, res: 0, upd: 0;
       catyL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catyK() //  [R1]
         { info_tbl: [(catyK,
                       label: block_catyK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catyK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto catyV; else goto catyU;
       catyV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catyU: // global
           _sasEE::P64 = P64[R1 + 39];
           _sasEF::P64 = P64[R1 + 47];
           _sasEB::I64 = I64[R1 + 55];
           _sasEC::I64 = I64[R1 + 63];
           _sasED::I64 = I64[R1 + 71];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _sasEE::P64;
           P64[Hp - 24] = _sasEF::P64;
           I64[Hp - 16] = _sasEB::I64;
           I64[Hp - 8] = _sasEC::I64;
           I64[Hp] = _sasED::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.431774614 UTC

[section ""data" . GHC.Event.TimerManager.emUniqueSource_closure" {
     GHC.Event.TimerManager.emUniqueSource_closure:
         const GHC.Event.TimerManager.emUniqueSource_info;
 },
 GHC.Event.TimerManager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(catz4,
                       label: GHC.Event.TimerManager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catz4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catz8; else goto catz9;
       catz8: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catz9: // global
           I64[Sp - 8] = block_catz1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatzd; else goto catz2;
       uatzd: // global
           call _catz1(R1) args: 0, res: 0, upd: 0;
       catz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catz1() //  [R1]
         { info_tbl: [(catz1,
                       label: block_catz1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catz1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto catzc; else goto catzb;
       catzc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catzb: // global
           _sasEL::P64 = P64[R1 + 31];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _sasEL::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.433091483 UTC

[section ""data" . GHC.Event.TimerManager.emState_closure" {
     GHC.Event.TimerManager.emState_closure:
         const GHC.Event.TimerManager.emState_info;
 },
 GHC.Event.TimerManager.emState_entry() //  [R2]
         { info_tbl: [(catzl,
                       label: GHC.Event.TimerManager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catzl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catzp; else goto catzq;
       catzp: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catzq: // global
           I64[Sp - 8] = block_catzi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatzu; else goto catzj;
       uatzu: // global
           call _catzi(R1) args: 0, res: 0, upd: 0;
       catzj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catzi() //  [R1]
         { info_tbl: [(catzi,
                       label: block_catzi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catzi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto catzt; else goto catzs;
       catzt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catzs: // global
           _sasEV::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sasEV::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.434610677 UTC

[section ""data" . GHC.Event.TimerManager.emTimeouts_closure" {
     GHC.Event.TimerManager.emTimeouts_closure:
         const GHC.Event.TimerManager.emTimeouts_info;
 },
 GHC.Event.TimerManager.emTimeouts_entry() //  [R2]
         { info_tbl: [(catzC,
                       label: GHC.Event.TimerManager.emTimeouts_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catzC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catzG; else goto catzH;
       catzG: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emTimeouts_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catzH: // global
           I64[Sp - 8] = block_catzz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatzL; else goto catzA;
       uatzL: // global
           call _catzz(R1) args: 0, res: 0, upd: 0;
       catzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catzz() //  [R1]
         { info_tbl: [(catzz,
                       label: block_catzz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catzz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto catzK; else goto catzJ;
       catzK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catzJ: // global
           _sasF5::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sasF5::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.435857139 UTC

[section ""data" . GHC.Event.TimerManager.emBackend_closure" {
     GHC.Event.TimerManager.emBackend_closure:
         const GHC.Event.TimerManager.emBackend_info;
 },
 GHC.Event.TimerManager.emBackend_entry() //  [R2]
         { info_tbl: [(catzT,
                       label: GHC.Event.TimerManager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catzT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catzU; else goto catzV;
       catzU: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catzV: // global
           I64[Sp - 8] = block_catzQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatzZ; else goto catzR;
       uatzZ: // global
           call _catzQ(R1) args: 0, res: 0, upd: 0;
       catzR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catzQ() //  [R1]
         { info_tbl: [(catzQ,
                       label: block_catzQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catzQ: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.436906181 UTC

[section ""data" . GHC.Event.TimerManager.newDefaultBackend_closure" {
     GHC.Event.TimerManager.newDefaultBackend_closure:
         const GHC.Event.TimerManager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.TimerManager.newDefaultBackend_entry() //  []
         { info_tbl: [(catA4,
                       label: GHC.Event.TimerManager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catA4: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.437824076 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager1_closure" {
     GHC.Event.TimerManager.wakeManager1_closure:
         const GHC.Event.TimerManager.wakeManager1_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager1_entry() //  [R2]
         { info_tbl: [(catAe,
                       label: GHC.Event.TimerManager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catAe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catAf; else goto catAg;
       catAf: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.wakeManager1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catAg: // global
           I64[Sp - 8] = block_catAb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatAk; else goto catAc;
       uatAk: // global
           call _catAb(R1) args: 0, res: 0, upd: 0;
       catAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catAb() //  [R1]
         { info_tbl: [(catAb,
                       label: block_catAb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catAb: // global
           R3 = P64[R1 + 47];
           R2 = I64[R1 + 71];
           Sp = Sp + 8;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.438915172 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager_closure" {
     GHC.Event.TimerManager.wakeManager_closure:
         const GHC.Event.TimerManager.wakeManager_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager_entry() //  [R2]
         { info_tbl: [(catAp,
                       label: GHC.Event.TimerManager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catAp: // global
           R2 = R2;
           call GHC.Event.TimerManager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.439625287 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule4_bytes" {
     GHC.Event.TimerManager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.440222041 UTC

[section ""data" . GHC.Event.TimerManager.$trModule3_closure" {
     GHC.Event.TimerManager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.440798515 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule2_bytes" {
     GHC.Event.TimerManager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.441385607 UTC

[section ""data" . GHC.Event.TimerManager.$trModule1_closure" {
     GHC.Event.TimerManager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.44197314 UTC

[section ""data" . GHC.Event.TimerManager.$trModule_closure" {
     GHC.Event.TimerManager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.TimerManager.$trModule3_closure+1;
         const GHC.Event.TimerManager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.442553069 UTC

[section ""data" . $krep_rasDC_closure" {
     $krep_rasDC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.443129484 UTC

[section ""data" . $krep1_rasDD_closure" {
     $krep1_rasDD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.443709057 UTC

[section ""data" . $krep2_rasDE_closure" {
     $krep2_rasDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.444295001 UTC

[section ""data" . $krep3_rasDF_closure" {
     $krep3_rasDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.444874703 UTC

[section ""data" . $krep4_rasDG_closure" {
     $krep4_rasDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.445485346 UTC

[section ""data" . $krep5_rasDH_closure" {
     $krep5_rasDH_closure:
         const :_con_info;
         const $krep3_rasDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.446056056 UTC

[section ""data" . $krep6_rasDI_closure" {
     $krep6_rasDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep5_rasDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.44662976 UTC

[section ""data" . $krep7_rasDJ_closure" {
     $krep7_rasDJ_closure:
         const :_con_info;
         const $krep6_rasDI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.447184606 UTC

[section ""data" . $krep8_rasDK_closure" {
     $krep8_rasDK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.PSQ.$tcIntPSQ_closure;
         const $krep7_rasDJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.447777861 UTC

[section ""data" . $krep9_rasDL_closure" {
     $krep9_rasDL_closure:
         const :_con_info;
         const $krep8_rasDK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.448354911 UTC

[section ""data" . $krep10_rasDM_closure" {
     $krep10_rasDM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep9_rasDL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.448946141 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimeoutKey2_bytes" {
     GHC.Event.TimerManager.$tcTimeoutKey2_bytes:
         I8[] [84,105,109,101,111,117,116,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.44977176 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey1_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.450315752 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimeoutKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11465769786694886755;
         const 8841886228133799087;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.450965622 UTC

[section ""data" . $krep11_rasDN_closure" {
     $krep11_rasDN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.45154811 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK1_closure" {
     GHC.Event.TimerManager.$tc'TK1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rasDC_closure+1;
         const $krep11_rasDN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.452103724 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TK3_bytes" {
     GHC.Event.TimerManager.$tc'TK3_bytes:
         I8[] [39,84,75]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.452694863 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK2_closure" {
     GHC.Event.TimerManager.$tc'TK2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TK3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.453306353 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK_closure" {
     GHC.Event.TimerManager.$tc'TK_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TK2_closure+1;
         const GHC.Event.TimerManager.$tc'TK1_closure+4;
         const 4362213157428095811;
         const 13641506162182658721;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.453952539 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcState2_bytes" {
     GHC.Event.TimerManager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.454494972 UTC

[section ""data" . GHC.Event.TimerManager.$tcState1_closure" {
     GHC.Event.TimerManager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.455052516 UTC

[section ""data" . GHC.Event.TimerManager.$tcState_closure" {
     GHC.Event.TimerManager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10067362680685980057;
         const 6560547589611231606;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.455627625 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created1_closure" {
     GHC.Event.TimerManager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.456145743 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Created3_bytes" {
     GHC.Event.TimerManager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.456678525 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created2_closure" {
     GHC.Event.TimerManager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.457270557 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created_closure" {
     GHC.Event.TimerManager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Created2_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 7473777249114724674;
         const 2904627795268885228;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.457888641 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Running2_bytes" {
     GHC.Event.TimerManager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.459760517 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running1_closure" {
     GHC.Event.TimerManager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.460356699 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running_closure" {
     GHC.Event.TimerManager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Running1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 15425377252641674582;
         const 12404533232809671740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.460933931 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Dying2_bytes" {
     GHC.Event.TimerManager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.461780694 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying1_closure" {
     GHC.Event.TimerManager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.46238709 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying_closure" {
     GHC.Event.TimerManager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Dying1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 13405772281963838681;
         const 437803396301020926;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.462976187 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Finished2_bytes" {
     GHC.Event.TimerManager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.463512439 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished1_closure" {
     GHC.Event.TimerManager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.464103519 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished_closure" {
     GHC.Event.TimerManager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Finished1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 1288208730452846229;
         const 15347214930365004647;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.464711362 UTC

[section ""data" . $krep12_rasDO_closure" {
     $krep12_rasDO_closure:
         const :_con_info;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.465322474 UTC

[section ""data" . $krep13_rasDP_closure" {
     $krep13_rasDP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep12_rasDO_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.465888523 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimerManager2_bytes" {
     GHC.Event.TimerManager.$tcTimerManager2_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.4664526 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager1_closure" {
     GHC.Event.TimerManager.$tcTimerManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimerManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.466997909 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager_closure" {
     GHC.Event.TimerManager.$tcTimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimerManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 3987042711794726631;
         const 6993782799294290901;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.467620782 UTC

[section ""data" . $krep14_rasDQ_closure" {
     $krep14_rasDQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimerManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.468217918 UTC

[section ""data" . $krep15_rasDR_closure" {
     $krep15_rasDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rasDD_closure+1;
         const $krep14_rasDQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.468832899 UTC

[section ""data" . $krep16_rasDS_closure" {
     $krep16_rasDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rasDE_closure+1;
         const $krep15_rasDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.469429991 UTC

[section ""data" . $krep17_rasDT_closure" {
     $krep17_rasDT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_rasDP_closure+1;
         const $krep16_rasDS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.470007537 UTC

[section ""data" . $krep18_rasDU_closure" {
     $krep18_rasDU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rasDM_closure+1;
         const $krep17_rasDT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.470556315 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager1_closure" {
     GHC.Event.TimerManager.$tc'TimerManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rasDG_closure+1;
         const $krep18_rasDU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.471112319 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TimerManager3_bytes" {
     GHC.Event.TimerManager.$tc'TimerManager3_bytes:
         I8[] [39,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.471657907 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager2_closure" {
     GHC.Event.TimerManager.$tc'TimerManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TimerManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.472231041 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager_closure" {
     GHC.Event.TimerManager.$tc'TimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager2_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager1_closure+4;
         const 451007785877958328;
         const 8145550165147362681;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.473719904 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshow_closure" {
     GHC.Event.TimerManager.$fShowState_$cshow_closure:
         const GHC.Event.TimerManager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(catAF,
                       label: GHC.Event.TimerManager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catAF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catAG; else goto catAH;
       catAG: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catAH: // global
           I64[Sp - 8] = block_catAw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatAW; else goto catAx;
       uatAW: // global
           call _catAw(R1) args: 0, res: 0, upd: 0;
       catAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catAw() //  [R1]
         { info_tbl: [(catAw,
                       label: block_catAw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catAw: // global
           _catAE::P64 = R1 & 7;
           if (_catAE::P64 < 3) goto uatAU; else goto uatAV;
       uatAU: // global
           if (_catAE::P64 < 2) goto catAA; else goto catAB;
       catAA: // global
           R1 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       catAB: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uatAV: // global
           if (_catAE::P64 < 4) goto catAC; else goto catAD;
       catAC: // global
           R1 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       catAD: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.475036776 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowList_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowList_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(catB1,
                       label: GHC.Event.TimerManager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catB1: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.TimerManager.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.475755566 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_closure" {
     GHC.Event.TimerManager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure+1;
         const GHC.Event.TimerManager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.477122695 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c/=_closure" {
     GHC.Event.TimerManager.$fEqState_$c/=_closure:
         const GHC.Event.TimerManager.$fEqState_$c/=_info;
 },
 GHC.Event.TimerManager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(catBh,
                       label: GHC.Event.TimerManager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catBh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catBi; else goto catBj;
       catBi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catBj: // global
           I64[Sp - 16] = block_catB8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatCA; else goto catB9;
       uatCA: // global
           call _catB8(R1) args: 0, res: 0, upd: 0;
       catB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catB8() //  [R1]
         { info_tbl: [(catB8,
                       label: block_catB8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catB8: // global
           _sasFF::P64 = P64[Sp + 8];
           _catBg::P64 = R1 & 7;
           if (_catBg::P64 < 3) goto uatCm; else goto uatCn;
       uatCm: // global
           if (_catBg::P64 < 2) goto catBc; else goto catBd;
       catBc: // global
           I64[Sp + 8] = block_catBm_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatCw; else goto catBo;
       uatCw: // global
           call _catBm(R1) args: 0, res: 0, upd: 0;
       catBo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       catBd: // global
           I64[Sp + 8] = block_catBB_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatCx; else goto catBD;
       uatCx: // global
           call _catBB(R1) args: 0, res: 0, upd: 0;
       catBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uatCn: // global
           if (_catBg::P64 < 4) goto catBe; else goto catBf;
       catBe: // global
           I64[Sp + 8] = block_catBQ_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatCy; else goto catBS;
       uatCy: // global
           call _catBQ(R1) args: 0, res: 0, upd: 0;
       catBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       catBf: // global
           I64[Sp + 8] = block_catC5_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatCz; else goto catC7;
       uatCz: // global
           call _catC5(R1) args: 0, res: 0, upd: 0;
       catC7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catBm() //  [R1]
         { info_tbl: [(catBm,
                       label: block_catBm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catBm: // global
           if (R1 & 7 == 1) goto uatCo; else goto uatCp;
       uatCo: // global
           Sp = Sp + 8;
           call _catCh() args: 0, res: 0, upd: 0;
       uatCp: // global
           Sp = Sp + 8;
           call _catCd() args: 0, res: 0, upd: 0;
     }
 },
 _catBB() //  [R1]
         { info_tbl: [(catBB,
                       label: block_catBB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catBB: // global
           if (R1 & 7 == 2) goto uatCq; else goto uatCr;
       uatCq: // global
           Sp = Sp + 8;
           call _catCh() args: 0, res: 0, upd: 0;
       uatCr: // global
           Sp = Sp + 8;
           call _catCd() args: 0, res: 0, upd: 0;
     }
 },
 _catBQ() //  [R1]
         { info_tbl: [(catBQ,
                       label: block_catBQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catBQ: // global
           if (R1 & 7 == 3) goto uatCs; else goto uatCt;
       uatCs: // global
           Sp = Sp + 8;
           call _catCh() args: 0, res: 0, upd: 0;
       uatCt: // global
           Sp = Sp + 8;
           call _catCd() args: 0, res: 0, upd: 0;
     }
 },
 _catC5() //  [R1]
         { info_tbl: [(catC5,
                       label: block_catC5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catC5: // global
           if (R1 & 7 == 4) goto uatCu; else goto uatCv;
       uatCu: // global
           Sp = Sp + 8;
           call _catCh() args: 0, res: 0, upd: 0;
       uatCv: // global
           Sp = Sp + 8;
           call _catCd() args: 0, res: 0, upd: 0;
     }
 },
 _catCh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catCh: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catCd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catCd: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.479243405 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_closure" {
     GHC.Event.TimerManager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.TimerManager.$fEqState_$c==_closure+2;
         const GHC.Event.TimerManager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.48135255 UTC

[section ""data" . GHC.Event.TimerManager.$weditTimeouts_closure" {
     GHC.Event.TimerManager.$weditTimeouts_closure:
         const GHC.Event.TimerManager.$weditTimeouts_info;
         const 0;
 },
 GHC.Event.TimerManager.$weditTimeouts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catCK: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sasGs_entry() //  [R1]
         { info_tbl: [(catD9,
                       label: sat_sasGs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catD9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catDa; else goto catDb;
       catDa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catDb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catD1_info;
           _sasFT::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasFT::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatE6; else goto catD2;
       uatE6: // global
           call _catD1(R1) args: 0, res: 0, upd: 0;
       catD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catD1() //  [R1]
         { info_tbl: [(catD1,
                       label: block_catD1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catD1: // global
           _catD8::P64 = R1 & 7;
           if (_catD8::P64 < 3) goto uatDX; else goto uatE0;
       uatDX: // global
           _sasFT::P64 = P64[Sp + 8];
           if (_catD8::P64 < 2) goto catD5; else goto catD6;
       catD5: // global
           I64[Sp] = block_catDe_info;
           _sasFW::I64 = I64[R1 + 39];
           R1 = _sasFT::P64;
           I64[Sp + 8] = _sasFW::I64;
           if (R1 & 7 != 0) goto uatE3; else goto catDg;
       uatE3: // global
           call _catDe(R1) args: 0, res: 0, upd: 0;
       catDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       catD6: // global
           I64[Sp] = block_catDx_info;
           _sasGe::I64 = I64[R1 + 22];
           R1 = _sasFT::P64;
           I64[Sp + 8] = _sasGe::I64;
           if (R1 & 7 != 0) goto uatE4; else goto catDz;
       uatE4: // global
           call _catDx(R1) args: 0, res: 0, upd: 0;
       catDz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uatE0: // global
           Sp = Sp + 16;
           call _catD7() args: 0, res: 0, upd: 0;
     }
 },
 _catDe() //  [R1]
         { info_tbl: [(catDe,
                       label: block_catDe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catDe: // global
           _catDU::P64 = R1 & 7;
           if (_catDU::P64 < 3) goto uatDY; else goto uatE1;
       uatDY: // global
           _sasFW::I64 = I64[Sp + 8];
           if (_catDU::P64 < 2) goto catDm; else goto catDq;
       catDm: // global
           R1 = I64[((_sasFW::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catDq: // global
           R1 = I64[((_sasFW::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatE1: // global
           Sp = Sp + 16;
           call _catD7() args: 0, res: 0, upd: 0;
     }
 },
 _catDx() //  [R1]
         { info_tbl: [(catDx,
                       label: block_catDx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catDx: // global
           _catDR::P64 = R1 & 7;
           if (_catDR::P64 < 3) goto uatDZ; else goto uatE2;
       uatDZ: // global
           _sasGe::I64 = I64[Sp + 8];
           if (_catDR::P64 < 2) goto catDF; else goto catDJ;
       catDF: // global
           R1 = I64[((_sasGe::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catDJ: // global
           R1 = I64[((_sasGe::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatE2: // global
           Sp = Sp + 16;
           call _catD7() args: 0, res: 0, upd: 0;
     }
 },
 _catD7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catD7: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasGt_entry() //  [R1, R2]
         { info_tbl: [(catE9,
                       label: sat_sasGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catE9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catEb; else goto catEc;
       catEb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catEc: // global
           I64[Sp - 16] = block_catCT_info;
           _sasFS::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sasFS::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catCT() //  [R1]
         { info_tbl: [(catCT,
                       label: block_catCT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catCT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catEf; else goto catEe;
       catEf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catEe: // global
           I64[Hp - 48] = sat_sasGs_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$weditTimeouts_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(catEp,
                       label: GHC.Event.TimerManager.$weditTimeouts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catEp: // global
           _sasFP::P64 = R6;
           _sasFO::I64 = R5;
           _sasFN::P64 = R4;
           _sasFM::P64 = R3;
           _sasFL::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto catEq; else goto catEr;
       catEr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto catEt; else goto catEs;
       catEt: // global
           HpAlloc = 16;
           goto catEq;
       catEq: // global
           R1 = GHC.Event.TimerManager.$weditTimeouts_closure;
           P64[Sp - 40] = _sasFL::P64;
           P64[Sp - 32] = _sasFM::P64;
           P64[Sp - 24] = _sasFN::P64;
           I64[Sp - 16] = _sasFO::I64;
           P64[Sp - 8] = _sasFP::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       catEs: // global
           I64[Hp - 8] = sat_sasGt_info;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_catEg_info;
           R2 = Hp - 7;
           R1 = _sasFL::P64;
           P64[Sp - 8] = _sasFP::P64;
           I64[Sp] = _sasFO::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catEg() //  [R1]
         { info_tbl: [(catEg,
                       label: block_catEg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catEg: // global
           I64[Sp] = block_catEi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatEB; else goto catEj;
       uatEB: // global
           call _catEi(R1) args: 0, res: 0, upd: 0;
       catEj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catEi() //  [R1]
         { info_tbl: [(catEi,
                       label: block_catEi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catEi: // global
           if (R1 & 7 == 1) goto catEm; else goto catEn;
       catEm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catEn: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.485031917 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout2_closure" {
     GHC.Event.TimerManager.unregisterTimeout2_closure:
         const GHC.Event.TimerManager.unregisterTimeout2_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout2_entry() //  [R2, R3]
         { info_tbl: [(catEJ,
                       label: GHC.Event.TimerManager.unregisterTimeout2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catEJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catEK; else goto catEL;
       catEK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catEL: // global
           I64[Sp - 16] = block_catEG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatEP; else goto catEH;
       uatEP: // global
           call _catEG(R1) args: 0, res: 0, upd: 0;
       catEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catEG() //  [R1]
         { info_tbl: [(catEG,
                       label: block_catEG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catEG: // global
           R6 = P64[R1 + 47];
           R5 = I64[R1 + 71];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.487575077 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout1_closure" {
     GHC.Event.TimerManager.unregisterTimeout1_closure:
         const GHC.Event.TimerManager.unregisterTimeout1_info;
         const 0;
 },
 sat_sasHy_entry() //  [R1]
         { info_tbl: [(catFk,
                       label: sat_sasHy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catFk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catFl; else goto catFm;
       catFl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catFm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catFc_info;
           _sasGZ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasGZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatGh; else goto catFd;
       uatGh: // global
           call _catFc(R1) args: 0, res: 0, upd: 0;
       catFd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catFc() //  [R1]
         { info_tbl: [(catFc,
                       label: block_catFc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catFc: // global
           _catFj::P64 = R1 & 7;
           if (_catFj::P64 < 3) goto uatG8; else goto uatGb;
       uatG8: // global
           _sasGZ::P64 = P64[Sp + 8];
           if (_catFj::P64 < 2) goto catFg; else goto catFh;
       catFg: // global
           I64[Sp] = block_catFp_info;
           _sasH2::I64 = I64[R1 + 39];
           R1 = _sasGZ::P64;
           I64[Sp + 8] = _sasH2::I64;
           if (R1 & 7 != 0) goto uatGe; else goto catFr;
       uatGe: // global
           call _catFp(R1) args: 0, res: 0, upd: 0;
       catFr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       catFh: // global
           I64[Sp] = block_catFI_info;
           _sasHk::I64 = I64[R1 + 22];
           R1 = _sasGZ::P64;
           I64[Sp + 8] = _sasHk::I64;
           if (R1 & 7 != 0) goto uatGf; else goto catFK;
       uatGf: // global
           call _catFI(R1) args: 0, res: 0, upd: 0;
       catFK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uatGb: // global
           Sp = Sp + 16;
           call _catFi() args: 0, res: 0, upd: 0;
     }
 },
 _catFp() //  [R1]
         { info_tbl: [(catFp,
                       label: block_catFp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catFp: // global
           _catG5::P64 = R1 & 7;
           if (_catG5::P64 < 3) goto uatG9; else goto uatGc;
       uatG9: // global
           _sasH2::I64 = I64[Sp + 8];
           if (_catG5::P64 < 2) goto catFx; else goto catFB;
       catFx: // global
           R1 = I64[((_sasH2::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catFB: // global
           R1 = I64[((_sasH2::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatGc: // global
           Sp = Sp + 16;
           call _catFi() args: 0, res: 0, upd: 0;
     }
 },
 _catFI() //  [R1]
         { info_tbl: [(catFI,
                       label: block_catFI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catFI: // global
           _catG2::P64 = R1 & 7;
           if (_catG2::P64 < 3) goto uatGa; else goto uatGd;
       uatGa: // global
           _sasHk::I64 = I64[Sp + 8];
           if (_catG2::P64 < 2) goto catFQ; else goto catFU;
       catFQ: // global
           R1 = I64[((_sasHk::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catFU: // global
           R1 = I64[((_sasHk::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatGd: // global
           Sp = Sp + 16;
           call _catFi() args: 0, res: 0, upd: 0;
     }
 },
 _catFi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catFi: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasHz_entry() //  [R1, R2]
         { info_tbl: [(catGk,
                       label: sat_sasHz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catGk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catGm; else goto catGn;
       catGm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catGn: // global
           I64[Sp - 16] = block_catF4_info;
           R3 = R2;
           _sasGY::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sasGY::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _catF4() //  [R1]
         { info_tbl: [(catF4,
                       label: block_catF4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catF4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catGq; else goto catGp;
       catGq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catGp: // global
           I64[Hp - 48] = sat_sasHy_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.unregisterTimeout1_entry() //  [R2, R3]
         { info_tbl: [(catGr,
                       label: GHC.Event.TimerManager.unregisterTimeout1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catGr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catGs; else goto catGt;
       catGs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catGt: // global
           I64[Sp - 16] = block_catEU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatGN; else goto catEV;
       uatGN: // global
           call _catEU(R1) args: 0, res: 0, upd: 0;
       catEV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catEU() //  [R1]
         { info_tbl: [(catEU,
                       label: block_catEU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catEU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto catGz; else goto catGy;
       catGz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catGy: // global
           _sasGQ::P64 = P64[R1 + 15];
           _sasGX::P64 = P64[R1 + 47];
           _sasGV::I64 = I64[R1 + 71];
           I64[Hp - 8] = sat_sasHz_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_catGu_info;
           R2 = Hp - 7;
           R1 = _sasGQ::P64;
           P64[Sp] = _sasGX::P64;
           I64[Sp + 8] = _sasGV::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catGu() //  [R1]
         { info_tbl: [(catGu,
                       label: block_catGu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catGu: // global
           I64[Sp] = block_catGw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatGO; else goto catGB;
       uatGO: // global
           call _catGw(R1) args: 0, res: 0, upd: 0;
       catGB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catGw() //  [R1]
         { info_tbl: [(catGw,
                       label: block_catGw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catGw: // global
           if (R1 & 7 == 1) goto catGH; else goto catGL;
       catGH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catGL: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.491581587 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout_closure" {
     GHC.Event.TimerManager.unregisterTimeout_closure:
         const GHC.Event.TimerManager.unregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout_entry() //  [R2, R3]
         { info_tbl: [(catGT,
                       label: GHC.Event.TimerManager.unregisterTimeout_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catGT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.unregisterTimeout1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.49452699 UTC

[section ""data" . GHC.Event.TimerManager.$wregisterTimeout_closure" {
     GHC.Event.TimerManager.$wregisterTimeout_closure:
         const GHC.Event.TimerManager.$wregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.$wregisterTimeout_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catGX: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2,
                                                               R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sasIz_entry() //  [R1]
         { info_tbl: [(catHG,
                       label: sat_sasIz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catHG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catHH; else goto catHI;
       catHH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catHI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catHy_info;
           _sasI0::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasI0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatID; else goto catHz;
       uatID: // global
           call _catHy(R1) args: 0, res: 0, upd: 0;
       catHz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catHy() //  [R1]
         { info_tbl: [(catHy,
                       label: block_catHy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catHy: // global
           _catHF::P64 = R1 & 7;
           if (_catHF::P64 < 3) goto uatIu; else goto uatIx;
       uatIu: // global
           _sasI0::P64 = P64[Sp + 8];
           if (_catHF::P64 < 2) goto catHC; else goto catHD;
       catHC: // global
           I64[Sp] = block_catHL_info;
           _sasI3::I64 = I64[R1 + 39];
           R1 = _sasI0::P64;
           I64[Sp + 8] = _sasI3::I64;
           if (R1 & 7 != 0) goto uatIA; else goto catHN;
       uatIA: // global
           call _catHL(R1) args: 0, res: 0, upd: 0;
       catHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       catHD: // global
           I64[Sp] = block_catI4_info;
           _sasIl::I64 = I64[R1 + 22];
           R1 = _sasI0::P64;
           I64[Sp + 8] = _sasIl::I64;
           if (R1 & 7 != 0) goto uatIB; else goto catI6;
       uatIB: // global
           call _catI4(R1) args: 0, res: 0, upd: 0;
       catI6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uatIx: // global
           Sp = Sp + 16;
           call _catHE() args: 0, res: 0, upd: 0;
     }
 },
 _catHL() //  [R1]
         { info_tbl: [(catHL,
                       label: block_catHL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catHL: // global
           _catIr::P64 = R1 & 7;
           if (_catIr::P64 < 3) goto uatIv; else goto uatIy;
       uatIv: // global
           _sasI3::I64 = I64[Sp + 8];
           if (_catIr::P64 < 2) goto catHT; else goto catHX;
       catHT: // global
           R1 = I64[((_sasI3::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catHX: // global
           R1 = I64[((_sasI3::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatIy: // global
           Sp = Sp + 16;
           call _catHE() args: 0, res: 0, upd: 0;
     }
 },
 _catI4() //  [R1]
         { info_tbl: [(catI4,
                       label: block_catI4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catI4: // global
           _catIo::P64 = R1 & 7;
           if (_catIo::P64 < 3) goto uatIw; else goto uatIz;
       uatIw: // global
           _sasIl::I64 = I64[Sp + 8];
           if (_catIo::P64 < 2) goto catIc; else goto catIg;
       catIc: // global
           R1 = I64[((_sasIl::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catIg: // global
           R1 = I64[((_sasIl::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatIz: // global
           Sp = Sp + 16;
           call _catHE() args: 0, res: 0, upd: 0;
     }
 },
 _catHE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catHE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasIA_entry() //  [R1, R2]
         { info_tbl: [(catIG,
                       label: sat_sasIA_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catIG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto catII; else goto catIJ;
       catII: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catIJ: // global
           I64[Sp - 40] = block_catHm_info;
           R3 = R2;
           _sasHY::P64 = R2;
           R2 = P64[R1 + 15];
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 23];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _sasHY::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _catHm() //  [R1]
         { info_tbl: [(catHm,
                       label: block_catHm_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catHm: // global
           _sasHV::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_catHq_info;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _sasHV::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _catHq() //  [R1]
         { info_tbl: [(catHq,
                       label: block_catHq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catHq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catIN; else goto catIM;
       catIN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catIM: // global
           I64[Hp - 48] = sat_sasIz_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wregisterTimeout_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(catIR,
                       label: GHC.Event.TimerManager.$wregisterTimeout_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catIR: // global
           _sasHI::P64 = R6;
           _sasHH::I64 = R5;
           _sasHG::P64 = R4;
           _sasHF::P64 = R3;
           _sasHE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto catIS; else goto catIT;
       catIT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catIV; else goto catIU;
       catIV: // global
           HpAlloc = 56;
           goto catIS;
       catIS: // global
           R1 = GHC.Event.TimerManager.$wregisterTimeout_closure;
           P64[Sp - 40] = _sasHE::P64;
           P64[Sp - 32] = _sasHF::P64;
           P64[Sp - 24] = _sasHG::P64;
           I64[Sp - 16] = _sasHH::I64;
           P64[Sp - 8] = _sasHI::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       catIU: // global
           _sasHJ::I64 = I64[Sp];
           _sasHK::P64 = P64[Sp + 8];
           (_sasHO::I64) = call MO_AtomicRMW W64 AMO_Add(_sasHG::P64 + 16, 1);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sasHO::I64;
           _catH3::P64 = Hp - 47;
           if (%MO_S_Gt_W64(_sasHJ::I64, 0)) goto catIP; else goto catIQ;
       catIP: // global
           (_sasHU::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 32] = sat_sasIA_info;
           P64[Hp - 24] = _sasHK::P64;
           P64[Hp - 16] = _catH3::P64;
           I64[Hp - 8] = _sasHO::I64;
           I64[Hp] = _sasHJ::I64 * 1000 + _sasHU::I64;
           I64[Sp - 16] = block_catIW_info;
           R2 = Hp - 31;
           R1 = _sasHE::P64;
           P64[Sp - 8] = _sasHI::P64;
           I64[Sp] = _sasHH::I64;
           P64[Sp + 8] = _catH3::P64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       catIQ: // global
           Hp = Hp - 40;
           I64[Sp] = block_catK5_info;
           R1 = _sasHK::P64;
           P64[Sp + 8] = _catH3::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catIW() //  [R1]
         { info_tbl: [(catIW,
                       label: block_catIW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catIW: // global
           I64[Sp] = block_catIY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatKd; else goto catJ0;
       uatKd: // global
           call _catIY(R1) args: 0, res: 0, upd: 0;
       catJ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catIY() //  [R1]
         { info_tbl: [(catIY,
                       label: block_catIY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catIY: // global
           if (R1 & 7 == 1) goto uatKa; else goto catK3;
       uatKa: // global
           Sp = Sp + 24;
           goto uatKg;
       catK3: // global
           _sasHI::P64 = P64[Sp + 8];
           (_sasIJ::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])), 1);
           if (%MO_SS_Conv_W64_W32(_sasIJ::I64) == 0 :: W32) goto uatKb; else goto catJp;
       uatKb: // global
           Sp = Sp + 24;
           goto uatKg;
       uatKg: // global
           call _catJZ() args: 0, res: 0, upd: 0;
       catJp: // global
           (_sasIO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_catJn_info;
           R1 = P64[_sasHI::P64 + 8];
           I64[Sp + 16] = _sasIO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatKe; else goto catJr;
       uatKe: // global
           call _catJn(R1) args: 0, res: 0, upd: 0;
       catJr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catJn() //  [R1]
         { info_tbl: [(catJn,
                       label: block_catJn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catJn: // global
           if (R1 & 7 == 1) goto catJy; else goto catJW;
       catJy: // global
           I64[Sp + 8] = block_catJv_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       catJW: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uatKc; else goto catJM;
       uatKc: // global
           Sp = Sp + 16;
           call _catJZ() args: 0, res: 0, upd: 0;
       catJM: // global
           I64[Sp + 8] = block_catJK_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _catJv() //  []
         { info_tbl: [(catJv,
                       label: block_catJv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catJv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catJZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catJZ: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catJK() //  []
         { info_tbl: [(catJK,
                       label: block_catJK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catJK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catK5() //  []
         { info_tbl: [(catK5,
                       label: block_catK5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catK5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.49968946 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout1_closure" {
     GHC.Event.TimerManager.registerTimeout1_closure:
         const GHC.Event.TimerManager.registerTimeout1_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(catKp,
                       label: GHC.Event.TimerManager.registerTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catKp: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catKt; else goto catKu;
       catKt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.registerTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       catKu: // global
           I64[Sp - 24] = block_catKm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatKC; else goto catKn;
       uatKC: // global
           call _catKm(R1) args: 0, res: 0, upd: 0;
       catKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catKm() //  [R1]
         { info_tbl: [(catKm,
                       label: block_catKm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catKm: // global
           I64[Sp - 32] = block_catKs_info;
           _sasJ9::P64 = P64[R1 + 15];
           _sasJa::P64 = P64[R1 + 23];
           _sasJb::P64 = P64[R1 + 31];
           _sasJg::P64 = P64[R1 + 47];
           _sasJe::I64 = I64[R1 + 71];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sasJb::P64;
           I64[Sp - 16] = _sasJe::I64;
           P64[Sp - 8] = _sasJg::P64;
           P64[Sp] = _sasJa::P64;
           P64[Sp + 8] = _sasJ9::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatKB; else goto catKw;
       uatKB: // global
           call _catKs(R1) args: 0, res: 0, upd: 0;
       catKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catKs() //  [R1]
         { info_tbl: [(catKs,
                       label: block_catKs_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catKs: // global
           R6 = P64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.501179173 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout_closure" {
     GHC.Event.TimerManager.registerTimeout_closure:
         const GHC.Event.TimerManager.registerTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(catKH,
                       label: GHC.Event.TimerManager.registerTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catKH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.registerTimeout1_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.504612061 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout1_closure" {
     GHC.Event.TimerManager.updateTimeout1_closure:
         const GHC.Event.TimerManager.updateTimeout1_info;
         const 0;
 },
 x_sasJB_entry() //  [R1]
         { info_tbl: [(catL1,
                       label: x_sasJB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catL1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catLe; else goto catLf;
       catLe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catLf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catKY_info;
           _sasJq::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sasJq::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatLj; else goto catKZ;
       uatLj: // global
           call _catKY(R1) args: 0, res: 0, upd: 0;
       catKZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catKY() //  [R1]
         { info_tbl: [(catKY,
                       label: block_catKY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catKY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto catLi; else goto catLh;
       catLi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       catLh: // global
           _sasJG::I64 = I64[R1 + 7] * 1000 + I64[Sp + 8];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sasJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasJL_entry() //  [R1]
         { info_tbl: [(catLJ,
                       label: sat_sasJL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catLJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catLK; else goto catLL;
       catLK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catLL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_catLC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatLS; else goto catLD;
       uatLS: // global
           call _catLC(R1) args: 0, res: 0, upd: 0;
       catLD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catLC() //  [R1]
         { info_tbl: [(catLC,
                       label: block_catLC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catLC: // global
           if (R1 & 7 == 3) goto catLH; else goto catLG;
       catLH: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catLG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasKu_entry() //  [R1]
         { info_tbl: [(catMq,
                       label: sat_sasKu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catMq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catMr; else goto catMs;
       catMr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catMs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catMi_info;
           _sasJV::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasJV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatNn; else goto catMj;
       uatNn: // global
           call _catMi(R1) args: 0, res: 0, upd: 0;
       catMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catMi() //  [R1]
         { info_tbl: [(catMi,
                       label: block_catMi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catMi: // global
           _catMp::P64 = R1 & 7;
           if (_catMp::P64 < 3) goto uatNe; else goto uatNh;
       uatNe: // global
           _sasJV::P64 = P64[Sp + 8];
           if (_catMp::P64 < 2) goto catMm; else goto catMn;
       catMm: // global
           I64[Sp] = block_catMv_info;
           _sasJY::I64 = I64[R1 + 39];
           R1 = _sasJV::P64;
           I64[Sp + 8] = _sasJY::I64;
           if (R1 & 7 != 0) goto uatNk; else goto catMx;
       uatNk: // global
           call _catMv(R1) args: 0, res: 0, upd: 0;
       catMx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       catMn: // global
           I64[Sp] = block_catMO_info;
           _sasKg::I64 = I64[R1 + 22];
           R1 = _sasJV::P64;
           I64[Sp + 8] = _sasKg::I64;
           if (R1 & 7 != 0) goto uatNl; else goto catMQ;
       uatNl: // global
           call _catMO(R1) args: 0, res: 0, upd: 0;
       catMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uatNh: // global
           Sp = Sp + 16;
           call _catMo() args: 0, res: 0, upd: 0;
     }
 },
 _catMv() //  [R1]
         { info_tbl: [(catMv,
                       label: block_catMv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catMv: // global
           _catNb::P64 = R1 & 7;
           if (_catNb::P64 < 3) goto uatNf; else goto uatNi;
       uatNf: // global
           _sasJY::I64 = I64[Sp + 8];
           if (_catNb::P64 < 2) goto catMD; else goto catMH;
       catMD: // global
           R1 = I64[((_sasJY::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catMH: // global
           R1 = I64[((_sasJY::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatNi: // global
           Sp = Sp + 16;
           call _catMo() args: 0, res: 0, upd: 0;
     }
 },
 _catMO() //  [R1]
         { info_tbl: [(catMO,
                       label: block_catMO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catMO: // global
           _catN8::P64 = R1 & 7;
           if (_catN8::P64 < 3) goto uatNg; else goto uatNj;
       uatNg: // global
           _sasKg::I64 = I64[Sp + 8];
           if (_catN8::P64 < 2) goto catMW; else goto catN0;
       catMW: // global
           R1 = I64[((_sasKg::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catN0: // global
           R1 = I64[((_sasKg::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uatNj: // global
           Sp = Sp + 16;
           call _catMo() args: 0, res: 0, upd: 0;
     }
 },
 _catMo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catMo: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasKv_entry() //  [R1, R2]
         { info_tbl: [(catNu,
                       label: sat_sasKv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catNu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto catNv; else goto catNw;
       catNv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catNw: // global
           I64[Sp - 32] = block_catLp_info;
           R3 = R2;
           _sasJH::P64 = R2;
           _sasJk::P64 = P64[R1 + 7];
           R2 = _sasJk::P64;
           P64[Sp - 24] = _sasJk::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sasJH::P64;
           Sp = Sp - 32;
           call GHC.Event.PSQ.deleteView_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _catLp() //  [R1]
         { info_tbl: [(catLp,
                       label: block_catLp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catLp: // global
           if (R1 & 7 == 1) goto catNr; else goto catNs;
       catNr: // global
           _sasJH::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_catLt_info;
           R1 = _sasJH::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uatNK; else goto catLu;
       uatNK: // global
           call _catLt(R1) args: 0, res: 0, upd: 0;
       catLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       catNs: // global
           I64[Sp] = block_catLV_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uatNL; else goto catLW;
       uatNL: // global
           call _catLV(R1) args: 0, res: 0, upd: 0;
       catLW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catLt() //  [R1]
         { info_tbl: [(catLt,
                       label: block_catLt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catLt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto catNB; else goto catNA;
       catNB: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catNA: // global
           I64[Hp - 40] = sat_sasJL_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catLV() //  [R1]
         { info_tbl: [(catLV,
                       label: block_catLV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catLV: // global
           I64[Sp - 8] = block_catM0_info;
           _sasJP::P64 = P64[R1 + 15];
           _sasJQ::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp] = _sasJQ::P64;
           P64[Sp + 8] = _sasJP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatNM; else goto catM1;
       uatNM: // global
           call _catM0(R1) args: 0, res: 0, upd: 0;
       catM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catM0() //  [R1]
         { info_tbl: [(catM0,
                       label: block_catM0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catM0: // global
           I64[Sp] = block_catM5_info;
           _sasJS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sasJS::I64;
           if (R1 & 7 != 0) goto uatNN; else goto catM6;
       uatNN: // global
           call _catM5(R1) args: 0, res: 0, upd: 0;
       catM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catM5() //  [R1]
         { info_tbl: [(catM5,
                       label: block_catM5_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catM5: // global
           _sasJS::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_catMa_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = _sasJS::I64;
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _catMa() //  [R1]
         { info_tbl: [(catMa,
                       label: block_catMa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catMa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catNJ; else goto catNI;
       catNJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catNI: // global
           I64[Hp - 48] = sat_sasKu_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.updateTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(catNO,
                       label: GHC.Event.TimerManager.updateTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catNO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catNP; else goto catNQ;
       catNP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.updateTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       catNQ: // global
           _sasJl::P64 = R4;
           _sasJk::P64 = R3;
           (_sasJq::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 32] = block_catKP_info;
           R1 = R2;
           P64[Sp - 24] = _sasJk::P64;
           P64[Sp - 16] = _sasJl::P64;
           I64[Sp - 8] = _sasJq::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatOa; else goto catKQ;
       uatOa: // global
           call _catKP(R1) args: 0, res: 0, upd: 0;
       catKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catKP() //  [R1]
         { info_tbl: [(catKP,
                       label: block_catKP_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catKP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catNW; else goto catNV;
       catNW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catNV: // global
           _sasJt::P64 = P64[R1 + 15];
           _sasJA::P64 = P64[R1 + 47];
           _sasJy::I64 = I64[R1 + 71];
           I64[Hp - 48] = x_sasJB_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = sat_sasKv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           I64[Sp + 8] = block_catNR_info;
           R2 = Hp - 15;
           R1 = _sasJt::P64;
           P64[Sp + 16] = _sasJA::P64;
           I64[Sp + 24] = _sasJy::I64;
           Sp = Sp + 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catNR() //  [R1]
         { info_tbl: [(catNR,
                       label: block_catNR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catNR: // global
           I64[Sp] = block_catNT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatOb; else goto catNY;
       uatOb: // global
           call _catNT(R1) args: 0, res: 0, upd: 0;
       catNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catNT() //  [R1]
         { info_tbl: [(catNT,
                       label: block_catNT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catNT: // global
           if (R1 & 7 == 1) goto catO4; else goto catO8;
       catO4: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catO8: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.510490378 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout_closure" {
     GHC.Event.TimerManager.updateTimeout_closure:
         const GHC.Event.TimerManager.updateTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.updateTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(catOg,
                       label: GHC.Event.TimerManager.updateTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.updateTimeout1_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.511917199 UTC

[section ""data" . GHC.Event.TimerManager.cleanup1_closure" {
     GHC.Event.TimerManager.cleanup1_closure:
         const GHC.Event.TimerManager.cleanup1_info;
 },
 GHC.Event.TimerManager.cleanup1_entry() //  [R2]
         { info_tbl: [(catOq,
                       label: GHC.Event.TimerManager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOq: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catOu; else goto catOv;
       catOu: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catOv: // global
           I64[Sp - 8] = block_catOn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatPl; else goto catOo;
       uatPl: // global
           call _catOn(R1) args: 0, res: 0, upd: 0;
       catOo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catOn() //  [R1]
         { info_tbl: [(catOn,
                       label: block_catOn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOn: // global
           I64[Sp - 48] = block_catOt_info;
           _sasKF::P64 = P64[R1 + 23];
           _sasKK::P64 = P64[R1 + 39];
           _sasKL::P64 = P64[R1 + 47];
           _sasKH::I64 = I64[R1 + 55];
           _sasKI::I64 = I64[R1 + 63];
           _sasKJ::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _sasKH::I64;
           I64[Sp - 32] = _sasKI::I64;
           I64[Sp - 24] = _sasKJ::I64;
           P64[Sp - 16] = _sasKK::P64;
           P64[Sp - 8] = _sasKL::P64;
           P64[Sp] = _sasKF::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uatPk; else goto catOx;
       uatPk: // global
           call _catOt(R1) args: 0, res: 0, upd: 0;
       catOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catOt() //  [R1]
         { info_tbl: [(catOt,
                       label: block_catOt_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOt: // global
           _sasKF::P64 = P64[Sp + 48];
           _sasKN::P64 = P64[R1 + 7];
           _sasKR::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_sasKF::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasKF::P64);
           I64[Sp] = block_catOE_info;
           R2 = _sasKN::P64;
           R1 = _sasKR::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catOE() //  []
         { info_tbl: [(catOE,
                       label: block_catOE_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOE: // global
           I64[Sp] = block_catOG_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catOG() //  []
         { info_tbl: [(catOG,
                       label: block_catOG_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOG: // global
           _sasKI::I64 = I64[Sp + 16];
           _sasKK::P64 = P64[Sp + 32];
           (_sasL3::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasL8::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKI::I64)));
           I64[Sp + 16] = block_catOV_info;
           R1 = _sasKK::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatPm; else goto catOW;
       uatPm: // global
           call _catOV(R1) args: 0, res: 0, upd: 0;
       catOW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catOV() //  [R1]
         { info_tbl: [(catOV,
                       label: block_catOV_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catOV: // global
           _sasKJ::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto catP2; else goto catP6;
       catP2: // global
           (_sasLe::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKJ::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catP6: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasLm::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKJ::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.514270302 UTC

[section ""data" . GHC.Event.TimerManager.cleanup_closure" {
     GHC.Event.TimerManager.cleanup_closure:
         const GHC.Event.TimerManager.cleanup_info;
 },
 GHC.Event.TimerManager.cleanup_entry() //  [R2]
         { info_tbl: [(catPr,
                       label: GHC.Event.TimerManager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catPr: // global
           R2 = R2;
           call GHC.Event.TimerManager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.51544815 UTC

[section ""data" . GHC.Event.TimerManager.finished1_closure" {
     GHC.Event.TimerManager.finished1_closure:
         const GHC.Event.TimerManager.finished1_info;
 },
 sat_sasLD_entry() //  [R1]
         { info_tbl: [(catPO,
                       label: sat_sasLD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catPO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catPP; else goto catPQ;
       catPP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catPQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_catPH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatPX; else goto catPI;
       uatPX: // global
           call _catPH(R1) args: 0, res: 0, upd: 0;
       catPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catPH() //  [R1]
         { info_tbl: [(catPH,
                       label: block_catPH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catPH: // global
           if (R1 & 7 == 4) goto catPM; else goto catPL;
       catPM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catPL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.finished1_entry() //  [R2]
         { info_tbl: [(catPY,
                       label: GHC.Event.TimerManager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catPY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catPZ; else goto catQ0;
       catPZ: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catQ0: // global
           I64[Sp - 8] = block_catPy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatQ4; else goto catPz;
       uatQ4: // global
           call _catPy(R1) args: 0, res: 0, upd: 0;
       catPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catPy() //  [R1]
         { info_tbl: [(catPy,
                       label: block_catPy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catPy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catQ3; else goto catQ2;
       catQ3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catQ2: // global
           _sasLB::P64 = P64[P64[R1 + 23] + 8];
           I64[Hp - 16] = sat_sasLD_info;
           P64[Hp] = _sasLB::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.517055273 UTC

[section ""data" . GHC.Event.TimerManager.finished_closure" {
     GHC.Event.TimerManager.finished_closure:
         const GHC.Event.TimerManager.finished_info;
 },
 GHC.Event.TimerManager.finished_entry() //  [R2]
         { info_tbl: [(catQ9,
                       label: GHC.Event.TimerManager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQ9: // global
           R2 = R2;
           call GHC.Event.TimerManager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.5179424 UTC

[section ""data" . GHC.Event.TimerManager.shutdown2_closure" {
     GHC.Event.TimerManager.shutdown2_closure:
         const GHC.Event.TimerManager.shutdown2_info;
 },
 GHC.Event.TimerManager.shutdown2_entry() //  [R2]
         { info_tbl: [(catQh,
                       label: GHC.Event.TimerManager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catQl; else goto catQk;
       catQl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catQk: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.519109078 UTC

[section ""data" . GHC.Event.TimerManager.shutdown1_closure" {
     GHC.Event.TimerManager.shutdown1_closure:
         const GHC.Event.TimerManager.shutdown1_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown1_entry() //  [R2]
         { info_tbl: [(catQt,
                       label: GHC.Event.TimerManager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catQu; else goto catQv;
       catQu: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catQv: // global
           I64[Sp - 8] = block_catQq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatQP; else goto catQr;
       uatQP: // global
           call _catQq(R1) args: 0, res: 0, upd: 0;
       catQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catQq() //  [R1]
         { info_tbl: [(catQq,
                       label: block_catQq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQq: // global
           I64[Sp - 16] = block_catQy_info;
           R2 = GHC.Event.TimerManager.shutdown2_closure+1;
           _sasLQ::P64 = P64[R1 + 47];
           _sasLN::I64 = I64[R1 + 63];
           R1 = P64[R1 + 23];
           P64[Sp - 8] = _sasLQ::P64;
           I64[Sp] = _sasLN::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catQy() //  [R1]
         { info_tbl: [(catQy,
                       label: block_catQy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQy: // global
           I64[Sp] = block_catQA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatQQ; else goto catQD;
       uatQQ: // global
           call _catQA(R1) args: 0, res: 0, upd: 0;
       catQD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catQA() //  [R1]
         { info_tbl: [(catQA,
                       label: block_catQA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQA: // global
           if (R1 & 7 == 2) goto catQN; else goto catQJ;
       catQN: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       catQJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.520668671 UTC

[section ""data" . GHC.Event.TimerManager.shutdown_closure" {
     GHC.Event.TimerManager.shutdown_closure:
         const GHC.Event.TimerManager.shutdown_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown_entry() //  [R2]
         { info_tbl: [(catQV,
                       label: GHC.Event.TimerManager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catQV: // global
           R2 = R2;
           call GHC.Event.TimerManager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.523406507 UTC

[section ""data" . GHC.Event.TimerManager.new3_closure" {
     GHC.Event.TimerManager.new3_closure:
         const GHC.Event.TimerManager.new3_info;
 },
 GHC.Event.TimerManager.new3_entry() //  [R2]
         { info_tbl: [(catR3,
                       label: GHC.Event.TimerManager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catR3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catR7; else goto catR6;
       catR7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.new3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catR6: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Finished_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.526036103 UTC

[section ""data" . GHC.Event.TimerManager.new2_closure" {
     GHC.Event.TimerManager.new2_closure:
         const GHC.Event.TimerManager.new2_info;
         const 0;
 },
 sat_sasMp_entry() //  [R1]
         { info_tbl: [(catRw,
                       label: sat_sasMp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catRx; else goto catRy;
       catRx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       catRy: // global
           I64[Sp - 24] = block_catRn_info;
           R2 = GHC.Event.TimerManager.new3_closure+1;
           _sasLW::P64 = P64[R1 + 7];
           _sasM3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sasLW::P64;
           P64[Sp - 8] = _sasM3::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRn() //  [R1]
         { info_tbl: [(catRn,
                       label: block_catRn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRn: // global
           I64[Sp] = block_catRp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatRP; else goto catRq;
       uatRP: // global
           call _catRp(R1) args: 0, res: 0, upd: 0;
       catRq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRp() //  [R1]
         { info_tbl: [(catRp,
                       label: block_catRp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRp: // global
           if (R1 & 7 == 4) goto catRu; else goto catRt;
       catRu: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catRt: // global
           _sasLW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_catRC_info;
           R1 = _sasLW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uatRQ; else goto catRD;
       uatRQ: // global
           call _catRC(R1) args: 0, res: 0, upd: 0;
       catRD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRC() //  [R1]
         { info_tbl: [(catRC,
                       label: block_catRC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRC: // global
           I64[Sp] = block_catRH_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRH() //  []
         { info_tbl: [(catRH,
                       label: block_catRH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRH: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasMz_entry() //  [R1]
         { info_tbl: [(catS3,
                       label: sat_sasMz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catS3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catS4; else goto catS5;
       catS4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catS5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlReadFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasMD_entry() //  [R1]
         { info_tbl: [(catSc,
                       label: sat_sasMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catSc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catSd; else goto catSe;
       catSd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catSe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlEventFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasMN_entry() //  [R1]
         { info_tbl: [(catSo,
                       label: sat_sasMN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catSo: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catSs; else goto catSt;
       catSs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catSt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_catSl_info;
           _sasM0::P64 = P64[R1 + 16];
           _sasM6::P64 = P64[R1 + 32];
           _sasM9::P64 = P64[R1 + 40];
           _sasMt::P64 = P64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sasM0::P64;
           P64[Sp - 40] = _sasM6::P64;
           P64[Sp - 32] = _sasM9::P64;
           P64[Sp - 24] = _sasMt::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uatSx; else goto catSm;
       uatSx: // global
           call _catSl(R1) args: 0, res: 0, upd: 0;
       catSm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catSl() //  [R1]
         { info_tbl: [(catSl,
                       label: block_catSl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catSl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catSw; else goto catSv;
       catSw: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       catSv: // global
           _sasML::P64 = P64[R1 + 7];
           _sasMM::P64 = P64[R1 + 15];
           _sasMI::I64 = I64[R1 + 23];
           _sasMJ::I64 = I64[R1 + 31];
           _sasMK::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sasML::P64;
           P64[Hp - 24] = _sasMM::P64;
           I64[Hp - 16] = _sasMI::I64;
           I64[Hp - 8] = _sasMJ::I64;
           I64[Hp] = _sasMK::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.new2_entry() //  [R2]
         { info_tbl: [(catSy,
                       label: GHC.Event.TimerManager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catSy: // global
           if ((Sp + -72) < SpLim) (likely: False) goto catSz; else goto catSA;
       catSz: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catSA: // global
           I64[Sp - 16] = block_catRc_info;
           R1 = GHC.Event.PSQ.Nil_closure+3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRc() //  [R1]
         { info_tbl: [(catRc,
                       label: block_catRc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRc: // global
           I64[Sp - 8] = block_catRe_info;
           R2 = GHC.Types.True_closure+2;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _catRe() //  [R1]
         { info_tbl: [(catRe,
                       label: block_catRe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRe: // global
           I64[Sp - 8] = block_catRg_info;
           _sasM3::P64 = R1;
           R1 = GHC.Event.TimerManager.Created_closure+1;
           P64[Sp] = _sasM3::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRg() //  [R1]
         { info_tbl: [(catRg,
                       label: block_catRg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto catSF; else goto catSE;
       catSF: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catSE: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_sasMp_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_catRS_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _sasM6::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _sasM6::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRS() //  []
         { info_tbl: [(catRS,
                       label: block_catRS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRS: // global
           I64[Sp] = block_catRU_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uatSQ; else goto catRV;
       uatSQ: // global
           call _catRU(R1) args: 0, res: 0, upd: 0;
       catRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catRU() //  [R1]
         { info_tbl: [(catRU,
                       label: block_catRU_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catRU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catSJ; else goto catSI;
       catSJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catSI: // global
           _sasMu::P64 = P64[R1 + 7];
           _sasMw::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sasMz_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp - 16] = block_catS6_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _sasMu::P64;
           _sasMt::P64 = R1;
           R1 = _sasMw::P64;
           I64[Sp - 24] = stg_ap_v_info;
           P64[Sp - 8] = _sasMw::P64;
           P64[Sp] = _sasMu::P64;
           P64[Sp + 40] = _sasMt::P64;
           Sp = Sp - 24;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _catS6() //  [R1]
         { info_tbl: [(catS6,
                       label: block_catS6_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catS6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catSM; else goto catSL;
       catSM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catSL: // global
           I64[Hp - 16] = sat_sasMD_info;
           P64[Hp] = P64[Sp + 40];
           _sasMu::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_catSf_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _sasMu::P64;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_v_info;
           Sp = Sp + 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _catSf() //  [R1]
         { info_tbl: [(catSf,
                       label: block_catSf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catSf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto catSP; else goto catSO;
       catSP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catSO: // global
           I64[Hp - 48] = sat_sasMN_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 40];
           R1 = Hp - 48;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.53066543 UTC

[section ""data" . GHC.Event.TimerManager.newWith_closure" {
     GHC.Event.TimerManager.newWith_closure:
         const GHC.Event.TimerManager.newWith_info;
         const 0;
 },
 GHC.Event.TimerManager.newWith_entry() //  [R2]
         { info_tbl: [(catSV,
                       label: GHC.Event.TimerManager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catSV: // global
           R2 = R2;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.531524994 UTC

[section ""data" . GHC.Event.TimerManager.new1_closure" {
     GHC.Event.TimerManager.new1_closure:
         const GHC.Event.TimerManager.new1_info;
         const 0;
 },
 GHC.Event.TimerManager.new1_entry() //  []
         { info_tbl: [(catT4,
                       label: GHC.Event.TimerManager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catT4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catT5; else goto catT6;
       catT5: // global
           R1 = GHC.Event.TimerManager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       catT6: // global
           I64[Sp - 8] = block_catT2_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _catT2() //  [R1]
         { info_tbl: [(catT2,
                       label: block_catT2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catT2: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.532497777 UTC

[section ""data" . GHC.Event.TimerManager.new_closure" {
     GHC.Event.TimerManager.new_closure:
         const GHC.Event.TimerManager.new_info;
         const 0;
 },
 GHC.Event.TimerManager.new_entry() //  []
         { info_tbl: [(catTc,
                       label: GHC.Event.TimerManager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTc: // global
           call GHC.Event.TimerManager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.536088624 UTC

[section ""data" . GHC.Event.TimerManager.step1_closure" {
     GHC.Event.TimerManager.step1_closure:
         const GHC.Event.TimerManager.step1_info;
         const 0;
 },
 sat_sasNw_entry() //  [R1]
         { info_tbl: [(catTT,
                       label: sat_sasNw_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catTU; else goto catTV;
       catTU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catTV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_catTL_info;
           _sasMX::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sasMX::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatUi; else goto catTM;
       uatUi: // global
           call _catTL(R1) args: 0, res: 0, upd: 0;
       catTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catTL() //  [R1]
         { info_tbl: [(catTL,
                       label: block_catTL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTL: // global
           _catTS::P64 = R1 & 7;
           if (_catTS::P64 < 3) goto uatUh; else goto catTR;
       uatUh: // global
           _sasMX::I64 = I64[Sp + 8];
           if (_catTS::P64 < 2) goto catTP; else goto catTQ;
       catTP: // global
           Hp = Hp + 16;
           _sasNk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto catUd; else goto catU3;
       catU3: // global
           _sasNr::I64 = I64[_sasNk::P64 + 39] - _sasMX::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _sasNr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catTQ: // global
           Hp = Hp + 16;
           _sasNk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto catUd; else goto catUc;
       catUd: // global
           HpAlloc = 16;
           R1 = _sasNk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       catUc: // global
           _sasNv::I64 = I64[_sasNk::P64 + 22] - _sasMX::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _sasNv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catTR: // global
           R1 = GHC.Event.Internal.Forever_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasNy_entry() //  [R1, R2]
         { info_tbl: [(catUj,
                       label: sat_sasNy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catUm; else goto catUn;
       catUm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catUn: // global
           I64[Sp - 16] = block_catTA_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 15];
           Sp = Sp - 16;
           call GHC.Event.PSQ.$watMost_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _catTA() //  [R1, R2]
         { info_tbl: [(catTA,
                       label: block_catTA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTA: // global
           I64[Sp - 8] = block_catTC_info;
           _sasNh::P64 = R1;
           R1 = R2;
           P64[Sp] = _sasNh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatUs; else goto catTD;
       uatUs: // global
           call _catTC(R1) args: 0, res: 0, upd: 0;
       catTD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catTC() //  [R1]
         { info_tbl: [(catTC,
                       label: block_catTC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTC: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catUr; else goto catUq;
       catUr: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catUq: // global
           I64[Hp - 72] = sat_sasNw_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 39;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasNX_entry() //  [R1, R2, R3]
         { info_tbl: [(catUN,
                       label: sat_sasNX_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto catUO; else goto catUP;
       catUO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catUP: // global
           I64[Sp - 32] = block_catUK_info;
           _sasN1::P64 = P64[R1 + 5];
           _sasN7::P64 = P64[R1 + 13];
           _sasN5::I64 = I64[R1 + 21];
           R1 = R2;
           P64[Sp - 24] = _sasN1::P64;
           I64[Sp - 16] = _sasN5::I64;
           P64[Sp - 8] = _sasN7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatVl; else goto catUL;
       uatVl: // global
           call _catUK(R1) args: 0, res: 0, upd: 0;
       catUL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catUK() //  [R1]
         { info_tbl: [(catUK,
                       label: block_catUK_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUK: // global
           I64[Sp] = block_catUS_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = I64[Sp + 16];
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _catUS() //  [R1]
         { info_tbl: [(catUS,
                       label: block_catUS_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUS: // global
           I64[Sp] = block_catUU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatVm; else goto catUX;
       uatVm: // global
           call _catUU(R1) args: 0, res: 0, upd: 0;
       catUX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catUU() //  [R1]
         { info_tbl: [(catUU,
                       label: block_catUU_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUU: // global
           _catVg::P64 = R1 & 7;
           if (_catVg::P64 < 3) goto uatVk; else goto catVc;
       uatVk: // global
           if (_catVg::P64 < 2) goto catV3; else goto catV7;
       catV3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catV7: // global
           _sasN1::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sasN1::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasN1::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catVc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto catVf; else goto catVe;
       catVf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catVe: // global
           _sasNT::P64 = P64[R1 + 5];
           _sasNS::I64 = I64[R1 + 13];
           _sasNU::I64 = I64[R1 + 21];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _sasNU::I64;
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _sasNT::P64;
           I64[Hp] = _sasNS::I64;
           R3 = Hp - 31;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasO6_entry() //  [R1]
         { info_tbl: [(catVG,
                       label: sat_sasO6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catVG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catVH; else goto catVI;
       catVH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catVI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_catVz_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatVP; else goto catVA;
       uatVP: // global
           call _catVz(R1) args: 0, res: 0, upd: 0;
       catVA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catVz() //  [R1]
         { info_tbl: [(catVz,
                       label: block_catVz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catVz: // global
           if (R1 & 7 == 2) goto catVE; else goto catVD;
       catVE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       catVD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.step1_entry() //  [R2]
         { info_tbl: [(catVQ,
                       label: GHC.Event.TimerManager.step1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catVQ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto catVR; else goto catVS;
       catVR: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.step1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catVS: // global
           (_sasMX::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 16] = block_catTk_info;
           R1 = R2;
           I64[Sp - 8] = _sasMX::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uatWE; else goto catTl;
       uatWE: // global
           call _catTk(R1) args: 0, res: 0, upd: 0;
       catTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catTk() //  [R1]
         { info_tbl: [(catTk,
                       label: block_catTk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTk: // global
           I64[Sp - 32] = block_catTp_info;
           _sasN0::P64 = P64[R1 + 15];
           _sasN1::P64 = P64[R1 + 23];
           _sasN7::P64 = P64[R1 + 47];
           _sasN5::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sasN1::P64;
           I64[Sp - 16] = _sasN5::I64;
           P64[Sp - 8] = _sasN7::P64;
           P64[Sp] = _sasN0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uatWA; else goto catTq;
       uatWA: // global
           call _catTp(R1) args: 0, res: 0, upd: 0;
       catTq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catTp() //  [R1]
         { info_tbl: [(catTp,
                       label: block_catTp_info
                       rep:StackRep [False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catTp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto catVW; else goto catVV;
       catVW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catVV: // global
           _sasN9::P64 = P64[R1 + 7];
           _sasNa::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           _sasMX::I64 = I64[Sp + 40];
           I64[Hp - 24] = _sasMX::I64;
           I64[Hp - 16] = sat_sasNy_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _sasMX::I64;
           I64[Sp] = block_catUt_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sasNa::P64;
           P64[Sp + 40] = _sasN9::P64;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catUt() //  [R1]
         { info_tbl: [(catUt,
                       label: block_catUt_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUt: // global
           I64[Sp] = block_catUv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatWB; else goto catUw;
       uatWB: // global
           call _catUv(R1) args: 0, res: 0, upd: 0;
       catUw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catUv() //  [R1]
         { info_tbl: [(catUv,
                       label: block_catUv_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUv: // global
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call _catW9() args: 0, res: 0, upd: 0;
     }
 },
 _catW9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catW9: // global
           _sasO8::P64 = P64[Sp];
           I64[Sp] = block_catWb_info;
           R1 = _sasO8::P64;
           if (R1 & 7 != 0) goto uatWF; else goto catWd;
       uatWF: // global
           call _catWb(R1) args: 0, res: 0, upd: 0;
       catWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catWb() //  [R1]
         { info_tbl: [(catWb,
                       label: block_catWb_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catWb: // global
           if (R1 & 7 == 1) goto uatWG; else goto catWo;
       uatWG: // global
           call _catUD() args: 0, res: 0, upd: 0;
       catWo: // global
           I64[Sp - 8] = block_catWm_info;
           _sasOc::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sasOc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatWH; else goto catWp;
       uatWH: // global
           call _catWm(R1) args: 0, res: 0, upd: 0;
       catWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catUD() //  []
         { info_tbl: [(catUD,
                       label: block_catUD_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catUD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto catW1; else goto catW0;
       catW1: // global
           HpAlloc = 48;
           I64[Sp] = block_catUD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       catW0: // global
           I64[Hp - 40] = sat_sasNX_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_catVo_info;
           R4 = Hp - 37;
           R3 = Hp - 6;
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catVo() //  []
         { info_tbl: [(catVo,
                       label: block_catVo_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catVo: // global
           _sasO3::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 40] = block_catVq_info;
           R1 = _sasO3::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uatWD; else goto catVr;
       uatWD: // global
           call _catVq(R1) args: 0, res: 0, upd: 0;
       catVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catVq() //  [R1]
         { info_tbl: [(catVq,
                       label: block_catVq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catVq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catW5; else goto catW4;
       catW5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catW4: // global
           I64[Hp - 16] = sat_sasO6_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catWm() //  [R1]
         { info_tbl: [(catWm,
                       label: block_catWm_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catWm: // global
           I64[Sp] = block_catWt_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catWt() //  []
         { info_tbl: [(catWt,
                       label: block_catWt_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catWt: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _catW9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.542449458 UTC

[section ""data" . GHC.Event.TimerManager.step_closure" {
     GHC.Event.TimerManager.step_closure:
         const GHC.Event.TimerManager.step_info;
         const 0;
 },
 GHC.Event.TimerManager.step_entry() //  [R2]
         { info_tbl: [(catWN,
                       label: GHC.Event.TimerManager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catWN: // global
           R2 = R2;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.543197543 UTC

[section ""cstring" . lvl_rasDV_bytes" {
     lvl_rasDV_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.544246586 UTC

[section ""data" . lvl1_rasDW_closure" {
     lvl1_rasDW_closure:
         const lvl1_rasDW_info;
         const 0;
 },
 sat_sasOm_entry() //  [R1]
         { info_tbl: [(catX5,
                       label: sat_sasOm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catX5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto catX6; else goto catX7;
       catX6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       catX7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_catWY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uatXe; else goto catWZ;
       uatXe: // global
           call _catWY(R1) args: 0, res: 0, upd: 0;
       catWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _catWY() //  [R1]
         { info_tbl: [(catWY,
                       label: block_catWY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catWY: // global
           if (R1 & 7 == 4) goto catX3; else goto catX2;
       catX3: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       catX2: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_rasDW_entry() //  [R2]
         { info_tbl: [(catXh,
                       label: lvl1_rasDW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXh: // global
           _sasOk::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto catXi; else goto catXj;
       catXj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catXl; else goto catXk;
       catXl: // global
           HpAlloc = 24;
           goto catXi;
       catXi: // global
           R2 = _sasOk::P64;
           R1 = lvl1_rasDW_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catXk: // global
           I64[Hp - 16] = sat_sasOm_info;
           P64[Hp] = _sasOk::P64;
           I64[Sp - 8] = block_catXf_info;
           R3 = Hp - 16;
           R2 = lvl_rasDV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _catXf() //  [R1]
         { info_tbl: [(catXf,
                       label: block_catXf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.545855693 UTC

[section ""data" . lvl2_rasDX_closure" {
     lvl2_rasDX_closure:
         const (,)_con_info;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.54678786 UTC

[section ""data" . lvl3_rasDY_closure" {
     lvl3_rasDY_closure:
         const lvl3_rasDY_info;
 },
 lvl3_rasDY_entry() //  [R2]
         { info_tbl: [(catXA,
                       label: lvl3_rasDY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto catXB; else goto catXC;
       catXB: // global
           R2 = R2;
           R1 = lvl3_rasDY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catXC: // global
           I64[Sp - 8] = block_catXt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uatXM; else goto catXu;
       uatXM: // global
           call _catXt(R1) args: 0, res: 0, upd: 0;
       catXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catXt() //  [R1]
         { info_tbl: [(catXt,
                       label: block_catXt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXt: // global
           if (R1 & 7 == 1) goto catXy; else goto catXx;
       catXy: // global
           R1 = lvl2_rasDX_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       catXx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto catXI; else goto catXH;
       catXI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catXH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.553449012 UTC

[section ""data" . GHC.Event.TimerManager.$wloop_closure" {
     GHC.Event.TimerManager.$wloop_closure:
         const GHC.Event.TimerManager.$wloop_info;
         const 0;
 },
 GHC.Event.TimerManager.$wloop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXO: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 40, res: 0, upd: 8;
     }
 },
 go_sasPk_entry() //  [R1]
         { info_tbl: [(catYm,
                       label: go_sasPk_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto uatYz; else goto uatYy;
       uatYz: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _catYn() args: 0, res: 0, upd: 0;
       uatYy: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _catY9() args: 0, res: 0, upd: 0;
     }
 },
 _catY9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catY9: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto catYq; else goto catYp;
       catYq: // global
           HpAlloc = 80;
           call _catYn() args: 0, res: 0, upd: 0;
       catYp: // global
           _sasPk::P64 = P64[Sp];
           _sasOr::P64 = P64[_sasPk::P64 + 7];
           _sasOs::P64 = P64[_sasPk::P64 + 15];
           _sasOt::P64 = P64[_sasPk::P64 + 23];
           _sasOx::P64 = P64[_sasPk::P64 + 31];
           _sasOy::P64 = P64[_sasPk::P64 + 39];
           _sasOA::P64 = P64[_sasPk::P64 + 47];
           _sasOu::I64 = I64[_sasPk::P64 + 55];
           _sasOv::I64 = I64[_sasPk::P64 + 63];
           _sasOw::I64 = I64[_sasPk::P64 + 71];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = _sasOA::P64;
           P64[Hp - 56] = _sasOr::P64;
           P64[Hp - 48] = _sasOs::P64;
           P64[Hp - 40] = _sasOt::P64;
           P64[Hp - 32] = _sasOx::P64;
           P64[Hp - 24] = _sasOy::P64;
           I64[Hp - 16] = _sasOu::I64;
           I64[Hp - 8] = _sasOv::I64;
           I64[Hp] = _sasOw::I64;
           I64[Sp - 8] = block_catYd_info;
           R2 = Hp - 71;
           Sp = Sp - 8;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _catYn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYn: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
     }
 },
 _catYd() //  [R1]
         { info_tbl: [(catYd,
                       label: block_catYd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYd: // global
           I64[Sp] = block_catYf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uatYC; else goto catYg;
       uatYC: // global
           call _catYf(R1) args: 0, res: 0, upd: 0;
       catYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catYf() //  [R1]
         { info_tbl: [(catYf,
                       label: block_catYf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYf: // global
           if (R1 & 7 == 1) goto catYj; else goto uatYA;
       catYj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uatYA: // global
           Sp = Sp + 8;
           call _catY9() args: 0, res: 0, upd: 0;
     }
 },
 sat_sasQ0_entry() //  [R1, R2]
         { info_tbl: [(catYW,
                       label: sat_sasQ0_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYW: // global
           if ((Sp + -56) < SpLim) (likely: False) goto catYX; else goto catYY;
       catYX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       catYY: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_catYQ_info;
           _sasPt::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasPt::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catYQ() //  []
         { info_tbl: [(catYQ,
                       label: block_catYQ_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYQ: // global
           I64[Sp] = block_catYS_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catYS() //  []
         { info_tbl: [(catYS,
                       label: block_catYS_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catYS: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasPG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasPL::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_catZ9_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uatZy; else goto catZa;
       uatZy: // global
           call _catZ9(R1) args: 0, res: 0, upd: 0;
       catZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catZ9() //  [R1]
         { info_tbl: [(catZ9,
                       label: block_catZ9_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catZ9: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasPt::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto catZg; else goto catZk;
       catZg: // global
           (_sasPR::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasPt::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       catZk: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasPZ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasPt::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasPs_entry() //  [R1]
         { info_tbl: [(catZE,
                       label: sat_sasPs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catZE: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasR8_entry() //  [R1, R2]
         { info_tbl: [(cau01,
                       label: sat_sasR8_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau01: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cau02; else goto cau03;
       cau02: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cau03: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_catZV_info;
           _sasQB::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasQB::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catZV() //  []
         { info_tbl: [(catZV,
                       label: block_catZV_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catZV: // global
           I64[Sp] = block_catZX_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catZX() //  []
         { info_tbl: [(catZX,
                       label: block_catZX_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catZX: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasQO::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasQT::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cau0e_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uau0D; else goto cau0f;
       uau0D: // global
           call _cau0e(R1) args: 0, res: 0, upd: 0;
       cau0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau0e() //  [R1]
         { info_tbl: [(cau0e,
                       label: block_cau0e_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau0e: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasQB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cau0l; else goto cau0p;
       cau0l: // global
           (_sasQZ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQB::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cau0p: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasR7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQB::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasQA_entry() //  [R1]
         { info_tbl: [(cau0J,
                       label: sat_sasQA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau0J: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasRH_entry() //  [R1]
         { info_tbl: [(cau0X,
                       label: sat_sasRH_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau0X: // global
           _sasRH::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto cau0Y; else goto cau0Z;
       cau0Z: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cau11; else goto cau10;
       cau11: // global
           HpAlloc = 88;
           goto cau0Y;
       cau0Y: // global
           R1 = _sasRH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cau10: // global
           _sasOs::P64 = P64[_sasRH::P64 + 7];
           _sasOx::P64 = P64[_sasRH::P64 + 15];
           _sasOy::P64 = P64[_sasRH::P64 + 23];
           _sasOB::P64 = P64[_sasRH::P64 + 31];
           _sasOF::P64 = P64[_sasRH::P64 + 39];
           _sasPk::P64 = P64[_sasRH::P64 + 47];
           _sasOu::I64 = I64[_sasRH::P64 + 55];
           _sasOv::I64 = I64[_sasRH::P64 + 63];
           _sasOw::I64 = I64[_sasRH::P64 + 71];
           I64[Hp - 80] = sat_sasR8_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasQA_info;
           P64[Hp] = _sasPk::P64;
           I64[Sp - 72] = block_cau0M_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           P64[Sp - 64] = _sasOs::P64;
           I64[Sp - 56] = _sasOu::I64;
           I64[Sp - 48] = _sasOv::I64;
           I64[Sp - 40] = _sasOw::I64;
           P64[Sp - 32] = _sasOx::P64;
           P64[Sp - 24] = _sasOy::P64;
           P64[Sp - 16] = _sasOB::P64;
           P64[Sp - 8] = _sasOF::P64;
           Sp = Sp - 72;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau0M() //  [R1]
         { info_tbl: [(cau0M,
                       label: block_cau0M_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau0M: // global
           _sasOs::P64 = P64[Sp + 8];
           _sasOB::P64 = P64[Sp + 56];
           _sasOF::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 8] = block_cau0R_info;
           R2 = _sasOB::P64;
           _sasRb::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 64] = _sasRb::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau0R() //  []
         { info_tbl: [(cau0R,
                       label: block_cau0R_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau0R: // global
           I64[Sp] = block_cau0T_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau0T() //  []
         { info_tbl: [(cau0T,
                       label: block_cau0T_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau0T: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasRn::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasRs::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cau1d_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uau1C; else goto cau1e;
       uau1C: // global
           call _cau1d(R1) args: 0, res: 0, upd: 0;
       cau1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau1d() //  [R1]
         { info_tbl: [(cau1d,
                       label: block_cau1d_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau1d: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasRb::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cau1k; else goto cau1o;
       cau1k: // global
           (_sasRy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRb::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cau1o: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasRG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRb::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasSg_entry() //  [R1, R2]
         { info_tbl: [(cau1S,
                       label: sat_sasSg_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau1S: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cau1T; else goto cau1U;
       cau1T: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cau1U: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_cau1M_info;
           _sasRJ::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasRJ::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau1M() //  []
         { info_tbl: [(cau1M,
                       label: block_cau1M_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau1M: // global
           I64[Sp] = block_cau1O_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau1O() //  []
         { info_tbl: [(cau1O,
                       label: block_cau1O_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau1O: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasRW::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasS1::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cau25_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uau2u; else goto cau26;
       uau2u: // global
           call _cau25(R1) args: 0, res: 0, upd: 0;
       cau26: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau25() //  [R1]
         { info_tbl: [(cau25,
                       label: block_cau25_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau25: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasRJ::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cau2c; else goto cau2g;
       cau2c: // global
           (_sasS7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRJ::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cau2g: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasSf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRJ::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasRI_entry() //  [R1]
         { info_tbl: [(cau2A,
                       label: sat_sasRI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau2A: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wloop_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cau2D,
                       label: GHC.Event.TimerManager.$wloop_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau2D: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cau2E; else goto cau2F;
       cau2E: // global
           R1 = GHC.Event.TimerManager.$wloop_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cau2F: // global
           I64[Sp - 40] = block_catXS_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uau5Z; else goto catXT;
       uau5Z: // global
           call _catXS(R1) args: 0, res: 0, upd: 0;
       catXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catXS() //  [R1]
         { info_tbl: [(catXS,
                       label: block_catXS_info
                       rep:StackRep [False, False, False, True, True, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXS: // global
           I64[Sp - 24] = block_catXX_info;
           R2 = lvl3_rasDY_closure+1;
           _sasOA::P64 = R1;
           _sasOB::P64 = P64[R1 + 7];
           _sasOF::P64 = P64[R1 + 39];
           R1 = P64[Sp + 16];
           P64[Sp - 16] = _sasOB::P64;
           P64[Sp - 8] = _sasOF::P64;
           P64[Sp] = _sasOA::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catXX() //  [R1]
         { info_tbl: [(catXX,
                       label: block_catXX_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXX: // global
           I64[Sp] = block_catXZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uau5Y; else goto catY0;
       uau5Y: // global
           call _catXZ(R1) args: 0, res: 0, upd: 0;
       catY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _catXZ() //  [R1]
         { info_tbl: [(catXZ,
                       label: block_catXZ_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catXZ: // global
           _cau55::P64 = R1 & 7;
           if (_cau55::P64 == 1) goto cau3i; else goto uau5W;
       cau3i: // global
           I64[Sp] = block_catY5_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       uau5W: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           if (_cau55::P64 == 3) goto cau4F; else goto cau2R;
       cau4F: // global
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 48] = block_cau4B_info;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cau2R: // global
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_cau2M_info;
           R2 = _sasOB::P64;
           _sasOJ::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasOJ::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _catY5() //  [R1]
         { info_tbl: [(catY5,
                       label: block_catY5_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catY5: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cau3l; else goto cau3k;
       cau3l: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cau3k: // global
           I64[Hp - 160] = go_sasPk_info;
           P64[Hp - 152] = P64[Sp + 32];
           _sasOs::P64 = P64[Sp + 40];
           P64[Hp - 144] = _sasOs::P64;
           P64[Hp - 136] = P64[Sp + 48];
           _sasOx::P64 = P64[Sp + 80];
           P64[Hp - 128] = _sasOx::P64;
           _sasOy::P64 = P64[Sp + 88];
           P64[Hp - 120] = _sasOy::P64;
           P64[Hp - 112] = P64[Sp + 24];
           _sasOu::I64 = I64[Sp + 56];
           I64[Hp - 104] = _sasOu::I64;
           _sasOv::I64 = I64[Sp + 64];
           I64[Hp - 96] = _sasOv::I64;
           _sasOw::I64 = I64[Sp + 72];
           I64[Hp - 88] = _sasOw::I64;
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           _catY7::P64 = Hp - 159;
           if (R1 == 0) goto cau3W; else goto uau5X;
       cau3W: // global
           I64[Hp - 80] = sat_sasRH_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           P64[Hp - 32] = _catY7::P64;
           I64[Hp - 24] = _sasOu::I64;
           I64[Hp - 16] = _sasOv::I64;
           I64[Hp - 8] = _sasOw::I64;
           _catZI::P64 = Hp - 79;
           Hp = Hp - 8;
           R1 = _catZI::P64;
           Sp = Sp + 96;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uau5X: // global
           if (R1 == 1) goto cau45; else goto cau3v;
       cau45: // global
           I64[Hp - 80] = sat_sasSg_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasRI_info;
           P64[Hp] = _catY7::P64;
           I64[Sp] = block_cau3X_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cau3v: // global
           I64[Hp - 80] = sat_sasQ0_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasPs_info;
           P64[Hp] = _catY7::P64;
           I64[Sp] = block_cau3m_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau3X() //  [R1]
         { info_tbl: [(cau3X,
                       label: block_cau3X_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau3X: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_cau42_info;
           R2 = _sasOB::P64;
           _sasSj::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasSj::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau42() //  []
         { info_tbl: [(cau42,
                       label: block_cau42_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau42: // global
           I64[Sp] = block_cau44_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau44() //  []
         { info_tbl: [(cau44,
                       label: block_cau44_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau44: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasSv::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasSA::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_cau4k_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uau62; else goto cau4l;
       uau62: // global
           call _cau4k(R1) args: 0, res: 0, upd: 0;
       cau4l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau4k() //  [R1]
         { info_tbl: [(cau4k,
                       label: block_cau4k_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau4k: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasSj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cau4r; else goto cau4v;
       cau4r: // global
           (_sasSG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasSj::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cau4v: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasSO::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasSj::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cau3m() //  [R1]
         { info_tbl: [(cau3m,
                       label: block_cau3m_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau3m: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_cau3r_info;
           R2 = _sasOB::P64;
           _sasQ3::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasQ3::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau3r() //  []
         { info_tbl: [(cau3r,
                       label: block_cau3r_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau3r: // global
           I64[Sp] = block_cau3t_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau3t() //  []
         { info_tbl: [(cau3t,
                       label: block_cau3t_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau3t: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasQf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasQk::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_cau3K_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uau61; else goto cau3L;
       uau61: // global
           call _cau3K(R1) args: 0, res: 0, upd: 0;
       cau3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau3K() //  [R1]
         { info_tbl: [(cau3K,
                       label: block_cau3K_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau3K: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasQ3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cau3R; else goto cau3V;
       cau3R: // global
           (_sasQq::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQ3::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cau3V: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasQy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQ3::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cau4B() //  []
         { info_tbl: [(cau4B,
                       label: block_cau4B_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau4B: // global
           I64[Sp] = block_cau4D_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau4D() //  []
         { info_tbl: [(cau4D,
                       label: block_cau4D_info
                       rep:StackRep [True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau4D: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasT0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasT5::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cau4T_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uau63; else goto cau4U;
       uau63: // global
           call _cau4T(R1) args: 0, res: 0, upd: 0;
       cau4U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau4T() //  [R1]
         { info_tbl: [(cau4T,
                       label: block_cau4T_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau4T: // global
           _sasOw::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cau50; else goto cau54;
       cau50: // global
           (_sasTb::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cau54: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasTj::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cau2M() //  []
         { info_tbl: [(cau2M,
                       label: block_cau2M_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau2M: // global
           I64[Sp] = block_cau2O_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau2O() //  []
         { info_tbl: [(cau2O,
                       label: block_cau2O_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau2O: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasOV::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasP0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_cau35_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uau60; else goto cau36;
       uau60: // global
           call _cau35(R1) args: 0, res: 0, upd: 0;
       cau36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau35() //  [R1]
         { info_tbl: [(cau35,
                       label: block_cau35_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau35: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasOJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cau3c; else goto cau3g;
       cau3c: // global
           (_sasP6::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R2 = _sasOJ::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
       cau3g: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasPf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R2 = _sasOJ::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.5695341 UTC

[section ""data" . GHC.Event.TimerManager.loop1_closure" {
     GHC.Event.TimerManager.loop1_closure:
         const GHC.Event.TimerManager.loop1_info;
         const 0;
 },
 GHC.Event.TimerManager.loop1_entry() //  [R2]
         { info_tbl: [(cau6b,
                       label: GHC.Event.TimerManager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cau6c; else goto cau6d;
       cau6c: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cau6d: // global
           I64[Sp - 8] = block_cau68_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uau6h; else goto cau69;
       uau6h: // global
           call _cau68(R1) args: 0, res: 0, upd: 0;
       cau69: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau68() //  [R1]
         { info_tbl: [(cau68,
                       label: block_cau68_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau68: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 63];
           I64[Sp - 16] = I64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 39];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 24;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.570780372 UTC

[section ""data" . GHC.Event.TimerManager.loop_closure" {
     GHC.Event.TimerManager.loop_closure:
         const GHC.Event.TimerManager.loop_info;
         const 0;
 },
 GHC.Event.TimerManager.loop_entry() //  [R2]
         { info_tbl: [(cau6m,
                       label: GHC.Event.TimerManager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6m: // global
           R2 = R2;
           call GHC.Event.TimerManager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.571850106 UTC

[section ""data" . GHC.Event.TimerManager.TimerManager_closure" {
     GHC.Event.TimerManager.TimerManager_closure:
         const GHC.Event.TimerManager.TimerManager_info;
 },
 GHC.Event.TimerManager.TimerManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6q: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.TimerManager_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.TimerManager_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cau6v,
                       label: GHC.Event.TimerManager.TimerManager_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6v: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cau6z; else goto cau6y;
       cau6z: // global
           HpAlloc = 80;
           R1 = GHC.Event.TimerManager.TimerManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cau6y: // global
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = R6;
           I64[Hp - 8] = I64[Sp];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.573027542 UTC

[section ""data" . GHC.Event.TimerManager.Created_closure" {
     GHC.Event.TimerManager.Created_closure:
         const GHC.Event.TimerManager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.573634043 UTC

[section ""data" . GHC.Event.TimerManager.Running_closure" {
     GHC.Event.TimerManager.Running_closure:
         const GHC.Event.TimerManager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.574200906 UTC

[section ""data" . GHC.Event.TimerManager.Dying_closure" {
     GHC.Event.TimerManager.Dying_closure:
         const GHC.Event.TimerManager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.574744706 UTC

[section ""data" . GHC.Event.TimerManager.Finished_closure" {
     GHC.Event.TimerManager.Finished_closure:
         const GHC.Event.TimerManager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.575349285 UTC

[GHC.Event.TimerManager.TimerManager_con_entry() //  [R1]
         { info_tbl: [(cau6A,
                       label: GHC.Event.TimerManager.TimerManager_con_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,84,105,109,101,114,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6A: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.576041939 UTC

[section ""relreadonly" . GHC.Event.TimerManager.State_closure_tbl" {
     GHC.Event.TimerManager.State_closure_tbl:
         const GHC.Event.TimerManager.Created_closure+1;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Dying_closure+3;
         const GHC.Event.TimerManager.Finished_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.576680048 UTC

[GHC.Event.TimerManager.Created_con_entry() //  [R1]
         { info_tbl: [(cau6C,
                       label: GHC.Event.TimerManager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6C: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.57739489 UTC

[GHC.Event.TimerManager.Running_con_entry() //  [R1]
         { info_tbl: [(cau6E,
                       label: GHC.Event.TimerManager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6E: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.578124359 UTC

[GHC.Event.TimerManager.Dying_con_entry() //  [R1]
         { info_tbl: [(cau6G,
                       label: GHC.Event.TimerManager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6G: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.578856891 UTC

[GHC.Event.TimerManager.Finished_con_entry() //  [R1]
         { info_tbl: [(cau6I,
                       label: GHC.Event.TimerManager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6I: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.579505965 UTC

[section ""relreadonly" . SasVk_srt" {
     SasVk_srt:
         const GHC.Event.TimerManager.$w$cshowsPrec_closure;
         const GHC.Event.TimerManager.$fShowState1_closure;
         const GHC.Event.TimerManager.$fShowState3_closure;
         const GHC.Event.TimerManager.$fShowState5_closure;
         const GHC.Event.TimerManager.$fShowState7_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.TimerManager.wakeManager1_closure;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure;
         const GHC.Event.TimerManager.$weditTimeouts_closure;
         const GHC.Event.TimerManager.unregisterTimeout2_closure;
         const GHC.Event.TimerManager.unregisterTimeout1_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const GHC.Event.TimerManager.$wregisterTimeout_closure;
         const GHC.Event.TimerManager.registerTimeout1_closure;
         const GHC.Event.TimerManager.updateTimeout1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.TimerManager.shutdown1_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.TimerManager.new1_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.TimerManager.step1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl1_rasDW_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.TimerManager.loop1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.580508209 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:27.58238577 UTC

[section ""data" . GHC.Event.TimerManager.$WTimerManager_closure" {
     GHC.Event.TimerManager.$WTimerManager_closure:
         const GHC.Event.TimerManager.$WTimerManager_info;
 },
 GHC.Event.TimerManager.$WTimerManager_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cau6R,
                       label: GHC.Event.TimerManager.$WTimerManager_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cau7f; else goto cau7g;
       cau7f: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$WTimerManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cau7g: // global
           I64[Sp - 40] = block_cau6O_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uau7p; else goto cau6P;
       uau7p: // global
           call _cau6O(R1) args: 0, res: 0, upd: 0;
       cau6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau6O() //  [R1]
         { info_tbl: [(cau6O,
                       label: block_cau6O_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6O: // global
           I64[Sp] = block_cau6U_info;
           _sasE5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sasE5::P64;
           if (R1 & 7 != 0) goto uau7o; else goto cau6V;
       uau7o: // global
           call _cau6U(R1) args: 0, res: 0, upd: 0;
       cau6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau6U() //  [R1]
         { info_tbl: [(cau6U,
                       label: block_cau6U_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6U: // global
           I64[Sp] = block_cau6Z_info;
           _sasE7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sasE7::P64;
           if (R1 & 7 != 0) goto uau7q; else goto cau70;
       uau7q: // global
           call _cau6Z(R1) args: 0, res: 0, upd: 0;
       cau70: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau6Z() //  [R1]
         { info_tbl: [(cau6Z,
                       label: block_cau6Z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau6Z: // global
           I64[Sp] = block_cau74_info;
           _sasE9::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sasE9::P64;
           if (R1 & 7 != 0) goto uau7r; else goto cau75;
       uau7r: // global
           call _cau74(R1) args: 0, res: 0, upd: 0;
       cau75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau74() //  [R1]
         { info_tbl: [(cau74,
                       label: block_cau74_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau74: // global
           I64[Sp] = block_cau79_info;
           _sasEb::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sasEb::P64;
           if (R1 & 7 != 0) goto uau7s; else goto cau7a;
       uau7s: // global
           call _cau79(R1) args: 0, res: 0, upd: 0;
       cau7a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau79() //  [R1]
         { info_tbl: [(cau79,
                       label: block_cau79_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau79: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cau7n; else goto cau7m;
       cau7n: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cau7m: // global
           _sasEg::P64 = P64[R1 + 7];
           _sasEh::P64 = P64[R1 + 15];
           _sasEd::I64 = I64[R1 + 23];
           _sasEe::I64 = I64[R1 + 31];
           _sasEf::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sasEg::P64;
           P64[Hp - 24] = _sasEh::P64;
           I64[Hp - 16] = _sasEd::I64;
           I64[Hp - 8] = _sasEe::I64;
           I64[Hp] = _sasEf::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.598315188 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState8_bytes" {
     GHC.Event.TimerManager.$fShowState8_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.600255142 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState7_closure" {
     GHC.Event.TimerManager.$fShowState7_closure:
         const GHC.Event.TimerManager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState7_entry() //  [R1]
         { info_tbl: [(cau84,
                       label: GHC.Event.TimerManager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau84: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cau85; else goto cau86;
       cau85: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cau86: // global
           (_cau81::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cau81::I64 == 0) goto cau83; else goto cau82;
       cau83: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cau82: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cau81::I64;
           R2 = GHC.Event.TimerManager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.604731766 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState6_bytes" {
     GHC.Event.TimerManager.$fShowState6_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.606681708 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState5_closure" {
     GHC.Event.TimerManager.$fShowState5_closure:
         const GHC.Event.TimerManager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState5_entry() //  [R1]
         { info_tbl: [(cau8l,
                       label: GHC.Event.TimerManager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau8l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cau8m; else goto cau8n;
       cau8m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cau8n: // global
           (_cau8i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cau8i::I64 == 0) goto cau8k; else goto cau8j;
       cau8k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cau8j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cau8i::I64;
           R2 = GHC.Event.TimerManager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.611144305 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState4_bytes" {
     GHC.Event.TimerManager.$fShowState4_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.6131001 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState3_closure" {
     GHC.Event.TimerManager.$fShowState3_closure:
         const GHC.Event.TimerManager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState3_entry() //  [R1]
         { info_tbl: [(cau8C,
                       label: GHC.Event.TimerManager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cau8D; else goto cau8E;
       cau8D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cau8E: // global
           (_cau8z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cau8z::I64 == 0) goto cau8B; else goto cau8A;
       cau8B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cau8A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cau8z::I64;
           R2 = GHC.Event.TimerManager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.617142298 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState2_bytes" {
     GHC.Event.TimerManager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.619176847 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState1_closure" {
     GHC.Event.TimerManager.$fShowState1_closure:
         const GHC.Event.TimerManager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState1_entry() //  [R1]
         { info_tbl: [(cau8T,
                       label: GHC.Event.TimerManager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau8T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cau8U; else goto cau8V;
       cau8U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cau8V: // global
           (_cau8Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cau8Q::I64 == 0) goto cau8S; else goto cau8R;
       cau8S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cau8R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cau8Q::I64;
           R2 = GHC.Event.TimerManager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.623466744 UTC

[section ""data" . GHC.Event.TimerManager.$w$cshowsPrec_closure" {
     GHC.Event.TimerManager.$w$cshowsPrec_closure:
         const GHC.Event.TimerManager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(cau9g,
                       label: GHC.Event.TimerManager.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau9g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cau9h; else goto cau9i;
       cau9h: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cau9i: // global
           I64[Sp - 16] = block_cau97_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uau9x; else goto cau98;
       uau9x: // global
           call _cau97(R1) args: 0, res: 0, upd: 0;
       cau98: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau97() //  [R1]
         { info_tbl: [(cau97,
                       label: block_cau97_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau97: // global
           _sasEj::P64 = P64[Sp + 8];
           _cau9f::P64 = R1 & 7;
           if (_cau9f::P64 < 3) goto uau9v; else goto uau9w;
       uau9v: // global
           if (_cau9f::P64 < 2) goto cau9b; else goto cau9c;
       cau9b: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cau9c: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uau9w: // global
           if (_cau9f::P64 < 4) goto cau9d; else goto cau9e;
       cau9d: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cau9e: // global
           R3 = _sasEj::P64;
           R2 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.629725668 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(cau9M,
                       label: GHC.Event.TimerManager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau9M: // global
           _sasEm::P64 = R3;
           R3 = R4;
           R2 = _sasEm::P64;
           call GHC.Event.TimerManager.$w$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.635190634 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c==_closure" {
     GHC.Event.TimerManager.$fEqState_$c==_closure:
         const GHC.Event.TimerManager.$fEqState_$c==_info;
 },
 GHC.Event.TimerManager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(caua6,
                       label: GHC.Event.TimerManager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caua6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caua7; else goto caua8;
       caua7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caua8: // global
           I64[Sp - 16] = block_cau9X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaubp; else goto cau9Y;
       uaubp: // global
           call _cau9X(R1) args: 0, res: 0, upd: 0;
       cau9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cau9X() //  [R1]
         { info_tbl: [(cau9X,
                       label: block_cau9X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau9X: // global
           _sasEp::P64 = P64[Sp + 8];
           _caua5::P64 = R1 & 7;
           if (_caua5::P64 < 3) goto uaubb; else goto uaubc;
       uaubb: // global
           if (_caua5::P64 < 2) goto caua1; else goto caua2;
       caua1: // global
           I64[Sp + 8] = block_cauab_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaubl; else goto cauad;
       uaubl: // global
           call _cauab(R1) args: 0, res: 0, upd: 0;
       cauad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caua2: // global
           I64[Sp + 8] = block_cauaq_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaubm; else goto cauas;
       uaubm: // global
           call _cauaq(R1) args: 0, res: 0, upd: 0;
       cauas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaubc: // global
           if (_caua5::P64 < 4) goto caua3; else goto caua4;
       caua3: // global
           I64[Sp + 8] = block_cauaF_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaubn; else goto cauaH;
       uaubn: // global
           call _cauaF(R1) args: 0, res: 0, upd: 0;
       cauaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caua4: // global
           I64[Sp + 8] = block_cauaU_info;
           R1 = _sasEp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaubo; else goto cauaW;
       uaubo: // global
           call _cauaU(R1) args: 0, res: 0, upd: 0;
       cauaW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauab() //  [R1]
         { info_tbl: [(cauab,
                       label: block_cauab_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauab: // global
           if (R1 & 7 == 1) goto uaubd; else goto uaube;
       uaubd: // global
           Sp = Sp + 8;
           call _caub6() args: 0, res: 0, upd: 0;
       uaube: // global
           Sp = Sp + 8;
           call _caub2() args: 0, res: 0, upd: 0;
     }
 },
 _cauaq() //  [R1]
         { info_tbl: [(cauaq,
                       label: block_cauaq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauaq: // global
           if (R1 & 7 == 2) goto uaubf; else goto uaubg;
       uaubf: // global
           Sp = Sp + 8;
           call _caub6() args: 0, res: 0, upd: 0;
       uaubg: // global
           Sp = Sp + 8;
           call _caub2() args: 0, res: 0, upd: 0;
     }
 },
 _cauaF() //  [R1]
         { info_tbl: [(cauaF,
                       label: block_cauaF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauaF: // global
           if (R1 & 7 == 3) goto uaubh; else goto uaubi;
       uaubh: // global
           Sp = Sp + 8;
           call _caub6() args: 0, res: 0, upd: 0;
       uaubi: // global
           Sp = Sp + 8;
           call _caub2() args: 0, res: 0, upd: 0;
     }
 },
 _cauaU() //  [R1]
         { info_tbl: [(cauaU,
                       label: block_cauaU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauaU: // global
           if (R1 & 7 == 4) goto uaubj; else goto uaubk;
       uaubj: // global
           Sp = Sp + 8;
           call _caub6() args: 0, res: 0, upd: 0;
       uaubk: // global
           Sp = Sp + 8;
           call _caub2() args: 0, res: 0, upd: 0;
     }
 },
 _caub6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caub6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caub2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caub2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.649882143 UTC

[section ""data" . GHC.Event.TimerManager.$fEqTimeoutKey_closure" {
     GHC.Event.TimerManager.$fEqTimeoutKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.eqInt_closure+2;
         const GHC.Classes.neInt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.652109603 UTC

[section ""data" . GHC.Event.TimerManager.emControl_closure" {
     GHC.Event.TimerManager.emControl_closure:
         const GHC.Event.TimerManager.emControl_info;
 },
 GHC.Event.TimerManager.emControl_entry() //  [R2]
         { info_tbl: [(cauck,
                       label: GHC.Event.TimerManager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauck: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cauco; else goto caucp;
       cauco: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caucp: // global
           I64[Sp - 8] = block_cauch_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauct; else goto cauci;
       uauct: // global
           call _cauch(R1) args: 0, res: 0, upd: 0;
       cauci: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauch() //  [R1]
         { info_tbl: [(cauch,
                       label: block_cauch_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauch: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caucs; else goto caucr;
       caucs: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caucr: // global
           _sasEE::P64 = P64[R1 + 39];
           _sasEF::P64 = P64[R1 + 47];
           _sasEB::I64 = I64[R1 + 55];
           _sasEC::I64 = I64[R1 + 63];
           _sasED::I64 = I64[R1 + 71];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _sasEE::P64;
           P64[Hp - 24] = _sasEF::P64;
           I64[Hp - 16] = _sasEB::I64;
           I64[Hp - 8] = _sasEC::I64;
           I64[Hp] = _sasED::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.658572799 UTC

[section ""data" . GHC.Event.TimerManager.emUniqueSource_closure" {
     GHC.Event.TimerManager.emUniqueSource_closure:
         const GHC.Event.TimerManager.emUniqueSource_info;
 },
 GHC.Event.TimerManager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(caucL,
                       label: GHC.Event.TimerManager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caucL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caucP; else goto caucQ;
       caucP: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caucQ: // global
           I64[Sp - 8] = block_caucI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaucU; else goto caucJ;
       uaucU: // global
           call _caucI(R1) args: 0, res: 0, upd: 0;
       caucJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caucI() //  [R1]
         { info_tbl: [(caucI,
                       label: block_caucI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caucI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caucT; else goto caucS;
       caucT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caucS: // global
           _sasEL::P64 = P64[R1 + 31];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _sasEL::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.664133841 UTC

[section ""data" . GHC.Event.TimerManager.emState_closure" {
     GHC.Event.TimerManager.emState_closure:
         const GHC.Event.TimerManager.emState_info;
 },
 GHC.Event.TimerManager.emState_entry() //  [R2]
         { info_tbl: [(caudc,
                       label: GHC.Event.TimerManager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caudc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caudg; else goto caudh;
       caudg: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caudh: // global
           I64[Sp - 8] = block_caud9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaudl; else goto cauda;
       uaudl: // global
           call _caud9(R1) args: 0, res: 0, upd: 0;
       cauda: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caud9() //  [R1]
         { info_tbl: [(caud9,
                       label: block_caud9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caud9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caudk; else goto caudj;
       caudk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caudj: // global
           _sasEV::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sasEV::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.670506001 UTC

[section ""data" . GHC.Event.TimerManager.emTimeouts_closure" {
     GHC.Event.TimerManager.emTimeouts_closure:
         const GHC.Event.TimerManager.emTimeouts_info;
 },
 GHC.Event.TimerManager.emTimeouts_entry() //  [R2]
         { info_tbl: [(caudD,
                       label: GHC.Event.TimerManager.emTimeouts_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caudD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caudH; else goto caudI;
       caudH: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emTimeouts_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caudI: // global
           I64[Sp - 8] = block_caudA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaudM; else goto caudB;
       uaudM: // global
           call _caudA(R1) args: 0, res: 0, upd: 0;
       caudB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caudA() //  [R1]
         { info_tbl: [(caudA,
                       label: block_caudA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caudA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caudL; else goto caudK;
       caudL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caudK: // global
           _sasF5::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sasF5::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.67629835 UTC

[section ""data" . GHC.Event.TimerManager.emBackend_closure" {
     GHC.Event.TimerManager.emBackend_closure:
         const GHC.Event.TimerManager.emBackend_info;
 },
 GHC.Event.TimerManager.emBackend_entry() //  [R2]
         { info_tbl: [(caue4,
                       label: GHC.Event.TimerManager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caue4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caue5; else goto caue6;
       caue5: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caue6: // global
           I64[Sp - 8] = block_caue1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauea; else goto caue2;
       uauea: // global
           call _caue1(R1) args: 0, res: 0, upd: 0;
       caue2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caue1() //  [R1]
         { info_tbl: [(caue1,
                       label: block_caue1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caue1: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.681496595 UTC

[section ""data" . GHC.Event.TimerManager.newDefaultBackend_closure" {
     GHC.Event.TimerManager.newDefaultBackend_closure:
         const GHC.Event.TimerManager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.TimerManager.newDefaultBackend_entry() //  []
         { info_tbl: [(caueq,
                       label: GHC.Event.TimerManager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caueq: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.684896898 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager1_closure" {
     GHC.Event.TimerManager.wakeManager1_closure:
         const GHC.Event.TimerManager.wakeManager1_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager1_entry() //  [R2]
         { info_tbl: [(caueE,
                       label: GHC.Event.TimerManager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caueE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caueF; else goto caueG;
       caueF: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.wakeManager1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caueG: // global
           I64[Sp - 8] = block_caueB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaueK; else goto caueC;
       uaueK: // global
           call _caueB(R1) args: 0, res: 0, upd: 0;
       caueC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caueB() //  [R1]
         { info_tbl: [(caueB,
                       label: block_caueB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caueB: // global
           R3 = P64[R1 + 47];
           R2 = I64[R1 + 71];
           Sp = Sp + 8;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.690304281 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager_closure" {
     GHC.Event.TimerManager.wakeManager_closure:
         const GHC.Event.TimerManager.wakeManager_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager_entry() //  [R2]
         { info_tbl: [(caueY,
                       label: GHC.Event.TimerManager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caueY: // global
           R2 = R2;
           call GHC.Event.TimerManager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.693388954 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule4_bytes" {
     GHC.Event.TimerManager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.695071438 UTC

[section ""data" . GHC.Event.TimerManager.$trModule3_closure" {
     GHC.Event.TimerManager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.696724326 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule2_bytes" {
     GHC.Event.TimerManager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.698726976 UTC

[section ""data" . GHC.Event.TimerManager.$trModule1_closure" {
     GHC.Event.TimerManager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.70080381 UTC

[section ""data" . GHC.Event.TimerManager.$trModule_closure" {
     GHC.Event.TimerManager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.TimerManager.$trModule3_closure+1;
         const GHC.Event.TimerManager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.702579553 UTC

[section ""data" . $krep_rasDC_closure" {
     $krep_rasDC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.704332328 UTC

[section ""data" . $krep1_rasDD_closure" {
     $krep1_rasDD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.706083967 UTC

[section ""data" . $krep2_rasDE_closure" {
     $krep2_rasDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.707744103 UTC

[section ""data" . $krep3_rasDF_closure" {
     $krep3_rasDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.709871942 UTC

[section ""data" . $krep4_rasDG_closure" {
     $krep4_rasDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.711580443 UTC

[section ""data" . $krep5_rasDH_closure" {
     $krep5_rasDH_closure:
         const :_con_info;
         const $krep3_rasDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.713325549 UTC

[section ""data" . $krep6_rasDI_closure" {
     $krep6_rasDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep5_rasDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.715044216 UTC

[section ""data" . $krep7_rasDJ_closure" {
     $krep7_rasDJ_closure:
         const :_con_info;
         const $krep6_rasDI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.716694711 UTC

[section ""data" . $krep8_rasDK_closure" {
     $krep8_rasDK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.PSQ.$tcIntPSQ_closure;
         const $krep7_rasDJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.718462076 UTC

[section ""data" . $krep9_rasDL_closure" {
     $krep9_rasDL_closure:
         const :_con_info;
         const $krep8_rasDK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.720192407 UTC

[section ""data" . $krep10_rasDM_closure" {
     $krep10_rasDM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep9_rasDL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.721955649 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimeoutKey2_bytes" {
     GHC.Event.TimerManager.$tcTimeoutKey2_bytes:
         I8[] [84,105,109,101,111,117,116,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.723635148 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey1_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.725801765 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimeoutKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11465769786694886755;
         const 8841886228133799087;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.727668687 UTC

[section ""data" . $krep11_rasDN_closure" {
     $krep11_rasDN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.729832446 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK1_closure" {
     GHC.Event.TimerManager.$tc'TK1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rasDC_closure+1;
         const $krep11_rasDN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.731585796 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TK3_bytes" {
     GHC.Event.TimerManager.$tc'TK3_bytes:
         I8[] [39,84,75]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.733276756 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK2_closure" {
     GHC.Event.TimerManager.$tc'TK2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TK3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.73495122 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK_closure" {
     GHC.Event.TimerManager.$tc'TK_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TK2_closure+1;
         const GHC.Event.TimerManager.$tc'TK1_closure+4;
         const 4362213157428095811;
         const 13641506162182658721;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.736735358 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcState2_bytes" {
     GHC.Event.TimerManager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.738406682 UTC

[section ""data" . GHC.Event.TimerManager.$tcState1_closure" {
     GHC.Event.TimerManager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.740127588 UTC

[section ""data" . GHC.Event.TimerManager.$tcState_closure" {
     GHC.Event.TimerManager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10067362680685980057;
         const 6560547589611231606;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.742565578 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created1_closure" {
     GHC.Event.TimerManager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.744300551 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Created3_bytes" {
     GHC.Event.TimerManager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.746016364 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created2_closure" {
     GHC.Event.TimerManager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.747675451 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created_closure" {
     GHC.Event.TimerManager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Created2_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 7473777249114724674;
         const 2904627795268885228;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.749526261 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Running2_bytes" {
     GHC.Event.TimerManager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.751623211 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running1_closure" {
     GHC.Event.TimerManager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.753717044 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running_closure" {
     GHC.Event.TimerManager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Running1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 15425377252641674582;
         const 12404533232809671740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.755538242 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Dying2_bytes" {
     GHC.Event.TimerManager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.757128806 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying1_closure" {
     GHC.Event.TimerManager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.758782055 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying_closure" {
     GHC.Event.TimerManager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Dying1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 13405772281963838681;
         const 437803396301020926;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.760504069 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Finished2_bytes" {
     GHC.Event.TimerManager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.762159368 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished1_closure" {
     GHC.Event.TimerManager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.76384924 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished_closure" {
     GHC.Event.TimerManager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Finished1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 1288208730452846229;
         const 15347214930365004647;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.765650149 UTC

[section ""data" . $krep12_rasDO_closure" {
     $krep12_rasDO_closure:
         const :_con_info;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.767387167 UTC

[section ""data" . $krep13_rasDP_closure" {
     $krep13_rasDP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep12_rasDO_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.769071884 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimerManager2_bytes" {
     GHC.Event.TimerManager.$tcTimerManager2_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.771128181 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager1_closure" {
     GHC.Event.TimerManager.$tcTimerManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimerManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.772912566 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager_closure" {
     GHC.Event.TimerManager.$tcTimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimerManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 3987042711794726631;
         const 6993782799294290901;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.774848895 UTC

[section ""data" . $krep14_rasDQ_closure" {
     $krep14_rasDQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimerManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.776611557 UTC

[section ""data" . $krep15_rasDR_closure" {
     $krep15_rasDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rasDD_closure+1;
         const $krep14_rasDQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.778778764 UTC

[section ""data" . $krep16_rasDS_closure" {
     $krep16_rasDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rasDE_closure+1;
         const $krep15_rasDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.780516077 UTC

[section ""data" . $krep17_rasDT_closure" {
     $krep17_rasDT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_rasDP_closure+1;
         const $krep16_rasDS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.782207845 UTC

[section ""data" . $krep18_rasDU_closure" {
     $krep18_rasDU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rasDM_closure+1;
         const $krep17_rasDT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.783891832 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager1_closure" {
     GHC.Event.TimerManager.$tc'TimerManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rasDG_closure+1;
         const $krep18_rasDU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.786209255 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TimerManager3_bytes" {
     GHC.Event.TimerManager.$tc'TimerManager3_bytes:
         I8[] [39,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.787884784 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager2_closure" {
     GHC.Event.TimerManager.$tc'TimerManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TimerManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.789581311 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager_closure" {
     GHC.Event.TimerManager.$tc'TimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager2_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager1_closure+4;
         const 451007785877958328;
         const 8145550165147362681;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.791796725 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshow_closure" {
     GHC.Event.TimerManager.$fShowState_$cshow_closure:
         const GHC.Event.TimerManager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(cauga,
                       label: GHC.Event.TimerManager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauga: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caugb; else goto caugc;
       caugb: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caugc: // global
           I64[Sp - 8] = block_caug1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaugr; else goto caug2;
       uaugr: // global
           call _caug1(R1) args: 0, res: 0, upd: 0;
       caug2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caug1() //  [R1]
         { info_tbl: [(caug1,
                       label: block_caug1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caug1: // global
           _caug9::P64 = R1 & 7;
           if (_caug9::P64 < 3) goto uaugp; else goto uaugq;
       uaugp: // global
           if (_caug9::P64 < 2) goto caug5; else goto caug6;
       caug5: // global
           R1 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caug6: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uaugq: // global
           if (_caug9::P64 < 4) goto caug7; else goto caug8;
       caug7: // global
           R1 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caug8: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.798355062 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowList_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowList_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caugK,
                       label: GHC.Event.TimerManager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caugK: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.TimerManager.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.801563474 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_closure" {
     GHC.Event.TimerManager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure+1;
         const GHC.Event.TimerManager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.804123749 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c/=_closure" {
     GHC.Event.TimerManager.$fEqState_$c/=_closure:
         const GHC.Event.TimerManager.$fEqState_$c/=_info;
 },
 GHC.Event.TimerManager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cauh5,
                       label: GHC.Event.TimerManager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauh5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cauh6; else goto cauh7;
       cauh6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cauh7: // global
           I64[Sp - 16] = block_caugW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uauio; else goto caugX;
       uauio: // global
           call _caugW(R1) args: 0, res: 0, upd: 0;
       caugX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caugW() //  [R1]
         { info_tbl: [(caugW,
                       label: block_caugW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caugW: // global
           _sasFF::P64 = P64[Sp + 8];
           _cauh4::P64 = R1 & 7;
           if (_cauh4::P64 < 3) goto uauia; else goto uauib;
       uauia: // global
           if (_cauh4::P64 < 2) goto cauh0; else goto cauh1;
       cauh0: // global
           I64[Sp + 8] = block_cauha_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uauik; else goto cauhc;
       uauik: // global
           call _cauha(R1) args: 0, res: 0, upd: 0;
       cauhc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cauh1: // global
           I64[Sp + 8] = block_cauhp_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uauil; else goto cauhr;
       uauil: // global
           call _cauhp(R1) args: 0, res: 0, upd: 0;
       cauhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uauib: // global
           if (_cauh4::P64 < 4) goto cauh2; else goto cauh3;
       cauh2: // global
           I64[Sp + 8] = block_cauhE_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uauim; else goto cauhG;
       uauim: // global
           call _cauhE(R1) args: 0, res: 0, upd: 0;
       cauhG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cauh3: // global
           I64[Sp + 8] = block_cauhT_info;
           R1 = _sasFF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uauin; else goto cauhV;
       uauin: // global
           call _cauhT(R1) args: 0, res: 0, upd: 0;
       cauhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauha() //  [R1]
         { info_tbl: [(cauha,
                       label: block_cauha_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauha: // global
           if (R1 & 7 == 1) goto uauic; else goto uauid;
       uauic: // global
           Sp = Sp + 8;
           call _caui5() args: 0, res: 0, upd: 0;
       uauid: // global
           Sp = Sp + 8;
           call _caui1() args: 0, res: 0, upd: 0;
     }
 },
 _cauhp() //  [R1]
         { info_tbl: [(cauhp,
                       label: block_cauhp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauhp: // global
           if (R1 & 7 == 2) goto uauie; else goto uauif;
       uauie: // global
           Sp = Sp + 8;
           call _caui5() args: 0, res: 0, upd: 0;
       uauif: // global
           Sp = Sp + 8;
           call _caui1() args: 0, res: 0, upd: 0;
     }
 },
 _cauhE() //  [R1]
         { info_tbl: [(cauhE,
                       label: block_cauhE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauhE: // global
           if (R1 & 7 == 3) goto uauig; else goto uauih;
       uauig: // global
           Sp = Sp + 8;
           call _caui5() args: 0, res: 0, upd: 0;
       uauih: // global
           Sp = Sp + 8;
           call _caui1() args: 0, res: 0, upd: 0;
     }
 },
 _cauhT() //  [R1]
         { info_tbl: [(cauhT,
                       label: block_cauhT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauhT: // global
           if (R1 & 7 == 4) goto uauii; else goto uauij;
       uauii: // global
           Sp = Sp + 8;
           call _caui5() args: 0, res: 0, upd: 0;
       uauij: // global
           Sp = Sp + 8;
           call _caui1() args: 0, res: 0, upd: 0;
     }
 },
 _caui5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caui5: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caui1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caui1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.819001238 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_closure" {
     GHC.Event.TimerManager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.TimerManager.$fEqState_$c==_closure+2;
         const GHC.Event.TimerManager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.822548156 UTC

[section ""data" . GHC.Event.TimerManager.$weditTimeouts_closure" {
     GHC.Event.TimerManager.$weditTimeouts_closure:
         const GHC.Event.TimerManager.$weditTimeouts_info;
         const 0;
 },
 GHC.Event.TimerManager.$weditTimeouts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caujd: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sasGs_entry() //  [R1]
         { info_tbl: [(caujC,
                       label: sat_sasGs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caujC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caujD; else goto caujE;
       caujD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caujE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cauju_info;
           _sasFT::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasFT::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaukz; else goto caujv;
       uaukz: // global
           call _cauju(R1) args: 0, res: 0, upd: 0;
       caujv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauju() //  [R1]
         { info_tbl: [(cauju,
                       label: block_cauju_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauju: // global
           _caujB::P64 = R1 & 7;
           if (_caujB::P64 < 3) goto uaukq; else goto uaukt;
       uaukq: // global
           _sasFT::P64 = P64[Sp + 8];
           if (_caujB::P64 < 2) goto caujy; else goto caujz;
       caujy: // global
           I64[Sp] = block_caujH_info;
           _sasFW::I64 = I64[R1 + 39];
           R1 = _sasFT::P64;
           I64[Sp + 8] = _sasFW::I64;
           if (R1 & 7 != 0) goto uaukw; else goto caujJ;
       uaukw: // global
           call _caujH(R1) args: 0, res: 0, upd: 0;
       caujJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caujz: // global
           I64[Sp] = block_cauk0_info;
           _sasGe::I64 = I64[R1 + 22];
           R1 = _sasFT::P64;
           I64[Sp + 8] = _sasGe::I64;
           if (R1 & 7 != 0) goto uaukx; else goto cauk2;
       uaukx: // global
           call _cauk0(R1) args: 0, res: 0, upd: 0;
       cauk2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaukt: // global
           Sp = Sp + 16;
           call _caujA() args: 0, res: 0, upd: 0;
     }
 },
 _caujH() //  [R1]
         { info_tbl: [(caujH,
                       label: block_caujH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caujH: // global
           _caukn::P64 = R1 & 7;
           if (_caukn::P64 < 3) goto uaukr; else goto uauku;
       uaukr: // global
           _sasFW::I64 = I64[Sp + 8];
           if (_caukn::P64 < 2) goto caujP; else goto caujT;
       caujP: // global
           R1 = I64[((_sasFW::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caujT: // global
           R1 = I64[((_sasFW::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uauku: // global
           Sp = Sp + 16;
           call _caujA() args: 0, res: 0, upd: 0;
     }
 },
 _cauk0() //  [R1]
         { info_tbl: [(cauk0,
                       label: block_cauk0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauk0: // global
           _caukk::P64 = R1 & 7;
           if (_caukk::P64 < 3) goto uauks; else goto uaukv;
       uauks: // global
           _sasGe::I64 = I64[Sp + 8];
           if (_caukk::P64 < 2) goto cauk8; else goto caukc;
       cauk8: // global
           R1 = I64[((_sasGe::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caukc: // global
           R1 = I64[((_sasGe::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaukv: // global
           Sp = Sp + 16;
           call _caujA() args: 0, res: 0, upd: 0;
     }
 },
 _caujA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caujA: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasGt_entry() //  [R1, R2]
         { info_tbl: [(caukC,
                       label: sat_sasGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caukC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caukE; else goto caukF;
       caukE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caukF: // global
           I64[Sp - 16] = block_caujm_info;
           _sasFS::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sasFS::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caujm() //  [R1]
         { info_tbl: [(caujm,
                       label: block_caujm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caujm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caukI; else goto caukH;
       caukI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caukH: // global
           I64[Hp - 48] = sat_sasGs_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$weditTimeouts_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(caukS,
                       label: GHC.Event.TimerManager.$weditTimeouts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caukS: // global
           _sasFP::P64 = R6;
           _sasFO::I64 = R5;
           _sasFN::P64 = R4;
           _sasFM::P64 = R3;
           _sasFL::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto caukT; else goto caukU;
       caukU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caukW; else goto caukV;
       caukW: // global
           HpAlloc = 16;
           goto caukT;
       caukT: // global
           R1 = GHC.Event.TimerManager.$weditTimeouts_closure;
           P64[Sp - 40] = _sasFL::P64;
           P64[Sp - 32] = _sasFM::P64;
           P64[Sp - 24] = _sasFN::P64;
           I64[Sp - 16] = _sasFO::I64;
           P64[Sp - 8] = _sasFP::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       caukV: // global
           I64[Hp - 8] = sat_sasGt_info;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_caukJ_info;
           R2 = Hp - 7;
           R1 = _sasFL::P64;
           P64[Sp - 8] = _sasFP::P64;
           I64[Sp] = _sasFO::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caukJ() //  [R1]
         { info_tbl: [(caukJ,
                       label: block_caukJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caukJ: // global
           I64[Sp] = block_caukL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaul4; else goto caukM;
       uaul4: // global
           call _caukL(R1) args: 0, res: 0, upd: 0;
       caukM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caukL() //  [R1]
         { info_tbl: [(caukL,
                       label: block_caukL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caukL: // global
           if (R1 & 7 == 1) goto caukP; else goto caukQ;
       caukP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caukQ: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.844962198 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout2_closure" {
     GHC.Event.TimerManager.unregisterTimeout2_closure:
         const GHC.Event.TimerManager.unregisterTimeout2_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout2_entry() //  [R2, R3]
         { info_tbl: [(caumc,
                       label: GHC.Event.TimerManager.unregisterTimeout2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caumc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caumd; else goto caume;
       caumd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caume: // global
           I64[Sp - 16] = block_caum9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaumi; else goto cauma;
       uaumi: // global
           call _caum9(R1) args: 0, res: 0, upd: 0;
       cauma: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caum9() //  [R1]
         { info_tbl: [(caum9,
                       label: block_caum9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caum9: // global
           R6 = P64[R1 + 47];
           R5 = I64[R1 + 71];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.852509877 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout1_closure" {
     GHC.Event.TimerManager.unregisterTimeout1_closure:
         const GHC.Event.TimerManager.unregisterTimeout1_info;
         const 0;
 },
 sat_sasHy_entry() //  [R1]
         { info_tbl: [(caumW,
                       label: sat_sasHy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caumW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caumX; else goto caumY;
       caumX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caumY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caumO_info;
           _sasGZ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasGZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaunT; else goto caumP;
       uaunT: // global
           call _caumO(R1) args: 0, res: 0, upd: 0;
       caumP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caumO() //  [R1]
         { info_tbl: [(caumO,
                       label: block_caumO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caumO: // global
           _caumV::P64 = R1 & 7;
           if (_caumV::P64 < 3) goto uaunK; else goto uaunN;
       uaunK: // global
           _sasGZ::P64 = P64[Sp + 8];
           if (_caumV::P64 < 2) goto caumS; else goto caumT;
       caumS: // global
           I64[Sp] = block_caun1_info;
           _sasH2::I64 = I64[R1 + 39];
           R1 = _sasGZ::P64;
           I64[Sp + 8] = _sasH2::I64;
           if (R1 & 7 != 0) goto uaunQ; else goto caun3;
       uaunQ: // global
           call _caun1(R1) args: 0, res: 0, upd: 0;
       caun3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caumT: // global
           I64[Sp] = block_caunk_info;
           _sasHk::I64 = I64[R1 + 22];
           R1 = _sasGZ::P64;
           I64[Sp + 8] = _sasHk::I64;
           if (R1 & 7 != 0) goto uaunR; else goto caunm;
       uaunR: // global
           call _caunk(R1) args: 0, res: 0, upd: 0;
       caunm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaunN: // global
           Sp = Sp + 16;
           call _caumU() args: 0, res: 0, upd: 0;
     }
 },
 _caun1() //  [R1]
         { info_tbl: [(caun1,
                       label: block_caun1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caun1: // global
           _caunH::P64 = R1 & 7;
           if (_caunH::P64 < 3) goto uaunL; else goto uaunO;
       uaunL: // global
           _sasH2::I64 = I64[Sp + 8];
           if (_caunH::P64 < 2) goto caun9; else goto caund;
       caun9: // global
           R1 = I64[((_sasH2::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caund: // global
           R1 = I64[((_sasH2::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaunO: // global
           Sp = Sp + 16;
           call _caumU() args: 0, res: 0, upd: 0;
     }
 },
 _caunk() //  [R1]
         { info_tbl: [(caunk,
                       label: block_caunk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caunk: // global
           _caunE::P64 = R1 & 7;
           if (_caunE::P64 < 3) goto uaunM; else goto uaunP;
       uaunM: // global
           _sasHk::I64 = I64[Sp + 8];
           if (_caunE::P64 < 2) goto cauns; else goto caunw;
       cauns: // global
           R1 = I64[((_sasHk::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caunw: // global
           R1 = I64[((_sasHk::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaunP: // global
           Sp = Sp + 16;
           call _caumU() args: 0, res: 0, upd: 0;
     }
 },
 _caumU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caumU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasHz_entry() //  [R1, R2]
         { info_tbl: [(caunW,
                       label: sat_sasHz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caunW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caunY; else goto caunZ;
       caunY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caunZ: // global
           I64[Sp - 16] = block_caumG_info;
           R3 = R2;
           _sasGY::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sasGY::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caumG() //  [R1]
         { info_tbl: [(caumG,
                       label: block_caumG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caumG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cauo2; else goto cauo1;
       cauo2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauo1: // global
           I64[Hp - 48] = sat_sasHy_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.unregisterTimeout1_entry() //  [R2, R3]
         { info_tbl: [(cauo3,
                       label: GHC.Event.TimerManager.unregisterTimeout1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauo3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauo4; else goto cauo5;
       cauo4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cauo5: // global
           I64[Sp - 16] = block_caumw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uauop; else goto caumx;
       uauop: // global
           call _caumw(R1) args: 0, res: 0, upd: 0;
       caumx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caumw() //  [R1]
         { info_tbl: [(caumw,
                       label: block_caumw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caumw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cauob; else goto cauoa;
       cauob: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauoa: // global
           _sasGQ::P64 = P64[R1 + 15];
           _sasGX::P64 = P64[R1 + 47];
           _sasGV::I64 = I64[R1 + 71];
           I64[Hp - 8] = sat_sasHz_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cauo6_info;
           R2 = Hp - 7;
           R1 = _sasGQ::P64;
           P64[Sp] = _sasGX::P64;
           I64[Sp + 8] = _sasGV::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauo6() //  [R1]
         { info_tbl: [(cauo6,
                       label: block_cauo6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauo6: // global
           I64[Sp] = block_cauo8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauoq; else goto cauod;
       uauoq: // global
           call _cauo8(R1) args: 0, res: 0, upd: 0;
       cauod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauo8() //  [R1]
         { info_tbl: [(cauo8,
                       label: block_cauo8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauo8: // global
           if (R1 & 7 == 1) goto cauoj; else goto cauon;
       cauoj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauon: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.875262024 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout_closure" {
     GHC.Event.TimerManager.unregisterTimeout_closure:
         const GHC.Event.TimerManager.unregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout_entry() //  [R2, R3]
         { info_tbl: [(caupx,
                       label: GHC.Event.TimerManager.unregisterTimeout_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caupx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.unregisterTimeout1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.881159605 UTC

[section ""data" . GHC.Event.TimerManager.$wregisterTimeout_closure" {
     GHC.Event.TimerManager.$wregisterTimeout_closure:
         const GHC.Event.TimerManager.$wregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.$wregisterTimeout_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caupF: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2,
                                                               R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sasIz_entry() //  [R1]
         { info_tbl: [(cauqo,
                       label: sat_sasIz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauqo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cauqp; else goto cauqq;
       cauqp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauqq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cauqg_info;
           _sasI0::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasI0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaurl; else goto cauqh;
       uaurl: // global
           call _cauqg(R1) args: 0, res: 0, upd: 0;
       cauqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauqg() //  [R1]
         { info_tbl: [(cauqg,
                       label: block_cauqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauqg: // global
           _cauqn::P64 = R1 & 7;
           if (_cauqn::P64 < 3) goto uaurc; else goto uaurf;
       uaurc: // global
           _sasI0::P64 = P64[Sp + 8];
           if (_cauqn::P64 < 2) goto cauqk; else goto cauql;
       cauqk: // global
           I64[Sp] = block_cauqt_info;
           _sasI3::I64 = I64[R1 + 39];
           R1 = _sasI0::P64;
           I64[Sp + 8] = _sasI3::I64;
           if (R1 & 7 != 0) goto uauri; else goto cauqv;
       uauri: // global
           call _cauqt(R1) args: 0, res: 0, upd: 0;
       cauqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cauql: // global
           I64[Sp] = block_cauqM_info;
           _sasIl::I64 = I64[R1 + 22];
           R1 = _sasI0::P64;
           I64[Sp + 8] = _sasIl::I64;
           if (R1 & 7 != 0) goto uaurj; else goto cauqO;
       uaurj: // global
           call _cauqM(R1) args: 0, res: 0, upd: 0;
       cauqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uaurf: // global
           Sp = Sp + 16;
           call _cauqm() args: 0, res: 0, upd: 0;
     }
 },
 _cauqt() //  [R1]
         { info_tbl: [(cauqt,
                       label: block_cauqt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauqt: // global
           _caur9::P64 = R1 & 7;
           if (_caur9::P64 < 3) goto uaurd; else goto uaurg;
       uaurd: // global
           _sasI3::I64 = I64[Sp + 8];
           if (_caur9::P64 < 2) goto cauqB; else goto cauqF;
       cauqB: // global
           R1 = I64[((_sasI3::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauqF: // global
           R1 = I64[((_sasI3::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaurg: // global
           Sp = Sp + 16;
           call _cauqm() args: 0, res: 0, upd: 0;
     }
 },
 _cauqM() //  [R1]
         { info_tbl: [(cauqM,
                       label: block_cauqM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauqM: // global
           _caur6::P64 = R1 & 7;
           if (_caur6::P64 < 3) goto uaure; else goto uaurh;
       uaure: // global
           _sasIl::I64 = I64[Sp + 8];
           if (_caur6::P64 < 2) goto cauqU; else goto cauqY;
       cauqU: // global
           R1 = I64[((_sasIl::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauqY: // global
           R1 = I64[((_sasIl::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaurh: // global
           Sp = Sp + 16;
           call _cauqm() args: 0, res: 0, upd: 0;
     }
 },
 _cauqm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauqm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasIA_entry() //  [R1, R2]
         { info_tbl: [(cauro,
                       label: sat_sasIA_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauro: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caurq; else goto caurr;
       caurq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caurr: // global
           I64[Sp - 40] = block_cauq4_info;
           R3 = R2;
           _sasHY::P64 = R2;
           R2 = P64[R1 + 15];
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 23];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _sasHY::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauq4() //  [R1]
         { info_tbl: [(cauq4,
                       label: block_cauq4_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauq4: // global
           _sasHV::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cauq8_info;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _sasHV::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauq8() //  [R1]
         { info_tbl: [(cauq8,
                       label: block_cauq8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauq8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caurv; else goto cauru;
       caurv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauru: // global
           I64[Hp - 48] = sat_sasIz_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wregisterTimeout_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(caurz,
                       label: GHC.Event.TimerManager.$wregisterTimeout_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caurz: // global
           _sasHI::P64 = R6;
           _sasHH::I64 = R5;
           _sasHG::P64 = R4;
           _sasHF::P64 = R3;
           _sasHE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto caurA; else goto caurB;
       caurB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caurD; else goto caurC;
       caurD: // global
           HpAlloc = 56;
           goto caurA;
       caurA: // global
           R1 = GHC.Event.TimerManager.$wregisterTimeout_closure;
           P64[Sp - 40] = _sasHE::P64;
           P64[Sp - 32] = _sasHF::P64;
           P64[Sp - 24] = _sasHG::P64;
           I64[Sp - 16] = _sasHH::I64;
           P64[Sp - 8] = _sasHI::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       caurC: // global
           _sasHJ::I64 = I64[Sp];
           _sasHK::P64 = P64[Sp + 8];
           (_sasHO::I64) = call MO_AtomicRMW W64 AMO_Add(_sasHG::P64 + 16, 1);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sasHO::I64;
           _caupL::P64 = Hp - 47;
           if (%MO_S_Gt_W64(_sasHJ::I64, 0)) goto caurx; else goto caury;
       caurx: // global
           (_sasHU::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 32] = sat_sasIA_info;
           P64[Hp - 24] = _sasHK::P64;
           P64[Hp - 16] = _caupL::P64;
           I64[Hp - 8] = _sasHO::I64;
           I64[Hp] = _sasHJ::I64 * 1000 + _sasHU::I64;
           I64[Sp - 16] = block_caurE_info;
           R2 = Hp - 31;
           R1 = _sasHE::P64;
           P64[Sp - 8] = _sasHI::P64;
           I64[Sp] = _sasHH::I64;
           P64[Sp + 8] = _caupL::P64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       caury: // global
           Hp = Hp - 40;
           I64[Sp] = block_causN_info;
           R1 = _sasHK::P64;
           P64[Sp + 8] = _caupL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caurE() //  [R1]
         { info_tbl: [(caurE,
                       label: block_caurE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caurE: // global
           I64[Sp] = block_caurG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uausV; else goto caurI;
       uausV: // global
           call _caurG(R1) args: 0, res: 0, upd: 0;
       caurI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caurG() //  [R1]
         { info_tbl: [(caurG,
                       label: block_caurG_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caurG: // global
           if (R1 & 7 == 1) goto uausS; else goto causL;
       uausS: // global
           Sp = Sp + 24;
           goto uausY;
       causL: // global
           _sasHI::P64 = P64[Sp + 8];
           (_sasIJ::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])), 1);
           if (%MO_SS_Conv_W64_W32(_sasIJ::I64) == 0 :: W32) goto uausT; else goto caus7;
       uausT: // global
           Sp = Sp + 24;
           goto uausY;
       uausY: // global
           call _causH() args: 0, res: 0, upd: 0;
       caus7: // global
           (_sasIO::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_caus5_info;
           R1 = P64[_sasHI::P64 + 8];
           I64[Sp + 16] = _sasIO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uausW; else goto caus9;
       uausW: // global
           call _caus5(R1) args: 0, res: 0, upd: 0;
       caus9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caus5() //  [R1]
         { info_tbl: [(caus5,
                       label: block_caus5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caus5: // global
           if (R1 & 7 == 1) goto causg; else goto causE;
       causg: // global
           I64[Sp + 8] = block_causd_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       causE: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uausU; else goto causu;
       uausU: // global
           Sp = Sp + 16;
           call _causH() args: 0, res: 0, upd: 0;
       causu: // global
           I64[Sp + 8] = block_causs_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _causd() //  []
         { info_tbl: [(causd,
                       label: block_causd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       causd: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _causH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       causH: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _causs() //  []
         { info_tbl: [(causs,
                       label: block_causs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       causs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _causN() //  []
         { info_tbl: [(causN,
                       label: block_causN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       causN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.914652153 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout1_closure" {
     GHC.Event.TimerManager.registerTimeout1_closure:
         const GHC.Event.TimerManager.registerTimeout1_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(cauuC,
                       label: GHC.Event.TimerManager.registerTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauuC: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cauuG; else goto cauuH;
       cauuG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.registerTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cauuH: // global
           I64[Sp - 24] = block_cauuz_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uauuP; else goto cauuA;
       uauuP: // global
           call _cauuz(R1) args: 0, res: 0, upd: 0;
       cauuA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauuz() //  [R1]
         { info_tbl: [(cauuz,
                       label: block_cauuz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauuz: // global
           I64[Sp - 32] = block_cauuF_info;
           _sasJ9::P64 = P64[R1 + 15];
           _sasJa::P64 = P64[R1 + 23];
           _sasJb::P64 = P64[R1 + 31];
           _sasJg::P64 = P64[R1 + 47];
           _sasJe::I64 = I64[R1 + 71];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sasJb::P64;
           I64[Sp - 16] = _sasJe::I64;
           P64[Sp - 8] = _sasJg::P64;
           P64[Sp] = _sasJa::P64;
           P64[Sp + 8] = _sasJ9::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauuO; else goto cauuJ;
       uauuO: // global
           call _cauuF(R1) args: 0, res: 0, upd: 0;
       cauuJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauuF() //  [R1]
         { info_tbl: [(cauuF,
                       label: block_cauuF_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauuF: // global
           R6 = P64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.922347037 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout_closure" {
     GHC.Event.TimerManager.registerTimeout_closure:
         const GHC.Event.TimerManager.registerTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(cauv8,
                       label: GHC.Event.TimerManager.registerTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauv8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.registerTimeout1_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.928560371 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout1_closure" {
     GHC.Event.TimerManager.updateTimeout1_closure:
         const GHC.Event.TimerManager.updateTimeout1_info;
         const 0;
 },
 x_sasJB_entry() //  [R1]
         { info_tbl: [(cauvw,
                       label: x_sasJB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauvw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cauvJ; else goto cauvK;
       cauvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauvK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cauvt_info;
           _sasJq::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sasJq::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauvO; else goto cauvu;
       uauvO: // global
           call _cauvt(R1) args: 0, res: 0, upd: 0;
       cauvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauvt() //  [R1]
         { info_tbl: [(cauvt,
                       label: block_cauvt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauvt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cauvN; else goto cauvM;
       cauvN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cauvM: // global
           _sasJG::I64 = I64[R1 + 7] * 1000 + I64[Sp + 8];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sasJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasJL_entry() //  [R1]
         { info_tbl: [(cauwe,
                       label: sat_sasJL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauwf; else goto cauwg;
       cauwf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauwg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cauw7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uauwn; else goto cauw8;
       uauwn: // global
           call _cauw7(R1) args: 0, res: 0, upd: 0;
       cauw8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauw7() //  [R1]
         { info_tbl: [(cauw7,
                       label: block_cauw7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauw7: // global
           if (R1 & 7 == 3) goto cauwc; else goto cauwb;
       cauwc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauwb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasKu_entry() //  [R1]
         { info_tbl: [(cauwV,
                       label: sat_sasKu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cauwW; else goto cauwX;
       cauwW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauwX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cauwN_info;
           _sasJV::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sasJV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauxS; else goto cauwO;
       uauxS: // global
           call _cauwN(R1) args: 0, res: 0, upd: 0;
       cauwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauwN() //  [R1]
         { info_tbl: [(cauwN,
                       label: block_cauwN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwN: // global
           _cauwU::P64 = R1 & 7;
           if (_cauwU::P64 < 3) goto uauxJ; else goto uauxM;
       uauxJ: // global
           _sasJV::P64 = P64[Sp + 8];
           if (_cauwU::P64 < 2) goto cauwR; else goto cauwS;
       cauwR: // global
           I64[Sp] = block_caux0_info;
           _sasJY::I64 = I64[R1 + 39];
           R1 = _sasJV::P64;
           I64[Sp + 8] = _sasJY::I64;
           if (R1 & 7 != 0) goto uauxP; else goto caux2;
       uauxP: // global
           call _caux0(R1) args: 0, res: 0, upd: 0;
       caux2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cauwS: // global
           I64[Sp] = block_cauxj_info;
           _sasKg::I64 = I64[R1 + 22];
           R1 = _sasJV::P64;
           I64[Sp + 8] = _sasKg::I64;
           if (R1 & 7 != 0) goto uauxQ; else goto cauxl;
       uauxQ: // global
           call _cauxj(R1) args: 0, res: 0, upd: 0;
       cauxl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uauxM: // global
           Sp = Sp + 16;
           call _cauwT() args: 0, res: 0, upd: 0;
     }
 },
 _caux0() //  [R1]
         { info_tbl: [(caux0,
                       label: block_caux0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caux0: // global
           _cauxG::P64 = R1 & 7;
           if (_cauxG::P64 < 3) goto uauxK; else goto uauxN;
       uauxK: // global
           _sasJY::I64 = I64[Sp + 8];
           if (_cauxG::P64 < 2) goto caux8; else goto cauxc;
       caux8: // global
           R1 = I64[((_sasJY::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauxc: // global
           R1 = I64[((_sasJY::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uauxN: // global
           Sp = Sp + 16;
           call _cauwT() args: 0, res: 0, upd: 0;
     }
 },
 _cauxj() //  [R1]
         { info_tbl: [(cauxj,
                       label: block_cauxj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauxj: // global
           _cauxD::P64 = R1 & 7;
           if (_cauxD::P64 < 3) goto uauxL; else goto uauxO;
       uauxL: // global
           _sasKg::I64 = I64[Sp + 8];
           if (_cauxD::P64 < 2) goto cauxr; else goto cauxv;
       cauxr: // global
           R1 = I64[((_sasKg::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauxv: // global
           R1 = I64[((_sasKg::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uauxO: // global
           Sp = Sp + 16;
           call _cauwT() args: 0, res: 0, upd: 0;
     }
 },
 _cauwT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwT: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasKv_entry() //  [R1, R2]
         { info_tbl: [(cauxZ,
                       label: sat_sasKv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauxZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cauy0; else goto cauy1;
       cauy0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauy1: // global
           I64[Sp - 32] = block_cauvU_info;
           R3 = R2;
           _sasJH::P64 = R2;
           _sasJk::P64 = P64[R1 + 7];
           R2 = _sasJk::P64;
           P64[Sp - 24] = _sasJk::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sasJH::P64;
           Sp = Sp - 32;
           call GHC.Event.PSQ.deleteView_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauvU() //  [R1]
         { info_tbl: [(cauvU,
                       label: block_cauvU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauvU: // global
           if (R1 & 7 == 1) goto cauxW; else goto cauxX;
       cauxW: // global
           _sasJH::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cauvY_info;
           R1 = _sasJH::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uauyf; else goto cauvZ;
       uauyf: // global
           call _cauvY(R1) args: 0, res: 0, upd: 0;
       cauvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cauxX: // global
           I64[Sp] = block_cauwq_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uauyg; else goto cauwr;
       uauyg: // global
           call _cauwq(R1) args: 0, res: 0, upd: 0;
       cauwr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauvY() //  [R1]
         { info_tbl: [(cauvY,
                       label: block_cauvY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauvY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cauy6; else goto cauy5;
       cauy6: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauy5: // global
           I64[Hp - 40] = sat_sasJL_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cauwq() //  [R1]
         { info_tbl: [(cauwq,
                       label: block_cauwq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwq: // global
           I64[Sp - 8] = block_cauwv_info;
           _sasJP::P64 = P64[R1 + 15];
           _sasJQ::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp] = _sasJQ::P64;
           P64[Sp + 8] = _sasJP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauyh; else goto cauww;
       uauyh: // global
           call _cauwv(R1) args: 0, res: 0, upd: 0;
       cauww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauwv() //  [R1]
         { info_tbl: [(cauwv,
                       label: block_cauwv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwv: // global
           I64[Sp] = block_cauwA_info;
           _sasJS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sasJS::I64;
           if (R1 & 7 != 0) goto uauyi; else goto cauwB;
       uauyi: // global
           call _cauwA(R1) args: 0, res: 0, upd: 0;
       cauwB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauwA() //  [R1]
         { info_tbl: [(cauwA,
                       label: block_cauwA_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwA: // global
           _sasJS::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cauwF_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = _sasJS::I64;
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauwF() //  [R1]
         { info_tbl: [(cauwF,
                       label: block_cauwF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauwF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cauye; else goto cauyd;
       cauye: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauyd: // global
           I64[Hp - 48] = sat_sasKu_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.updateTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(cauyj,
                       label: GHC.Event.TimerManager.updateTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauyj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cauyk; else goto cauyl;
       cauyk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.updateTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cauyl: // global
           _sasJl::P64 = R4;
           _sasJk::P64 = R3;
           (_sasJq::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 32] = block_cauvk_info;
           R1 = R2;
           P64[Sp - 24] = _sasJk::P64;
           P64[Sp - 16] = _sasJl::P64;
           I64[Sp - 8] = _sasJq::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauyF; else goto cauvl;
       uauyF: // global
           call _cauvk(R1) args: 0, res: 0, upd: 0;
       cauvl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauvk() //  [R1]
         { info_tbl: [(cauvk,
                       label: block_cauvk_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauvk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cauyr; else goto cauyq;
       cauyr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauyq: // global
           _sasJt::P64 = P64[R1 + 15];
           _sasJA::P64 = P64[R1 + 47];
           _sasJy::I64 = I64[R1 + 71];
           I64[Hp - 48] = x_sasJB_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = sat_sasKv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           I64[Sp + 8] = block_cauym_info;
           R2 = Hp - 15;
           R1 = _sasJt::P64;
           P64[Sp + 16] = _sasJA::P64;
           I64[Sp + 24] = _sasJy::I64;
           Sp = Sp + 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauym() //  [R1]
         { info_tbl: [(cauym,
                       label: block_cauym_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauym: // global
           I64[Sp] = block_cauyo_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauyG; else goto cauyt;
       uauyG: // global
           call _cauyo(R1) args: 0, res: 0, upd: 0;
       cauyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauyo() //  [R1]
         { info_tbl: [(cauyo,
                       label: block_cauyo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauyo: // global
           if (R1 & 7 == 1) goto cauyz; else goto cauyD;
       cauyz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauyD: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.968520051 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout_closure" {
     GHC.Event.TimerManager.updateTimeout_closure:
         const GHC.Event.TimerManager.updateTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.updateTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(cauAB,
                       label: GHC.Event.TimerManager.updateTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauAB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.updateTimeout1_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.972652369 UTC

[section ""data" . GHC.Event.TimerManager.cleanup1_closure" {
     GHC.Event.TimerManager.cleanup1_closure:
         const GHC.Event.TimerManager.cleanup1_info;
 },
 GHC.Event.TimerManager.cleanup1_entry() //  [R2]
         { info_tbl: [(cauAP,
                       label: GHC.Event.TimerManager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauAP: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cauAT; else goto cauAU;
       cauAT: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauAU: // global
           I64[Sp - 8] = block_cauAM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauBK; else goto cauAN;
       uauBK: // global
           call _cauAM(R1) args: 0, res: 0, upd: 0;
       cauAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauAM() //  [R1]
         { info_tbl: [(cauAM,
                       label: block_cauAM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauAM: // global
           I64[Sp - 48] = block_cauAS_info;
           _sasKF::P64 = P64[R1 + 23];
           _sasKK::P64 = P64[R1 + 39];
           _sasKL::P64 = P64[R1 + 47];
           _sasKH::I64 = I64[R1 + 55];
           _sasKI::I64 = I64[R1 + 63];
           _sasKJ::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _sasKH::I64;
           I64[Sp - 32] = _sasKI::I64;
           I64[Sp - 24] = _sasKJ::I64;
           P64[Sp - 16] = _sasKK::P64;
           P64[Sp - 8] = _sasKL::P64;
           P64[Sp] = _sasKF::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uauBJ; else goto cauAW;
       uauBJ: // global
           call _cauAS(R1) args: 0, res: 0, upd: 0;
       cauAW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauAS() //  [R1]
         { info_tbl: [(cauAS,
                       label: block_cauAS_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauAS: // global
           _sasKF::P64 = P64[Sp + 48];
           _sasKN::P64 = P64[R1 + 7];
           _sasKR::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_sasKF::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasKF::P64);
           I64[Sp] = block_cauB3_info;
           R2 = _sasKN::P64;
           R1 = _sasKR::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauB3() //  []
         { info_tbl: [(cauB3,
                       label: block_cauB3_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauB3: // global
           I64[Sp] = block_cauB5_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauB5() //  []
         { info_tbl: [(cauB5,
                       label: block_cauB5_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauB5: // global
           _sasKI::I64 = I64[Sp + 16];
           _sasKK::P64 = P64[Sp + 32];
           (_sasL3::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasL8::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKI::I64)));
           I64[Sp + 16] = block_cauBk_info;
           R1 = _sasKK::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uauBL; else goto cauBl;
       uauBL: // global
           call _cauBk(R1) args: 0, res: 0, upd: 0;
       cauBl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauBk() //  [R1]
         { info_tbl: [(cauBk,
                       label: block_cauBk_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauBk: // global
           _sasKJ::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cauBr; else goto cauBv;
       cauBr: // global
           (_sasLe::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKJ::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauBv: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasLm::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasKJ::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.987026591 UTC

[section ""data" . GHC.Event.TimerManager.cleanup_closure" {
     GHC.Event.TimerManager.cleanup_closure:
         const GHC.Event.TimerManager.cleanup_info;
 },
 GHC.Event.TimerManager.cleanup_entry() //  [R2]
         { info_tbl: [(cauCj,
                       label: GHC.Event.TimerManager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauCj: // global
           R2 = R2;
           call GHC.Event.TimerManager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.990700096 UTC

[section ""data" . GHC.Event.TimerManager.finished1_closure" {
     GHC.Event.TimerManager.finished1_closure:
         const GHC.Event.TimerManager.finished1_info;
 },
 sat_sasLD_entry() //  [R1]
         { info_tbl: [(cauCK,
                       label: sat_sasLD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauCK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauCL; else goto cauCM;
       cauCL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauCM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cauCD_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uauCT; else goto cauCE;
       uauCT: // global
           call _cauCD(R1) args: 0, res: 0, upd: 0;
       cauCE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauCD() //  [R1]
         { info_tbl: [(cauCD,
                       label: block_cauCD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauCD: // global
           if (R1 & 7 == 4) goto cauCI; else goto cauCH;
       cauCI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauCH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.finished1_entry() //  [R2]
         { info_tbl: [(cauCU,
                       label: GHC.Event.TimerManager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauCU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cauCV; else goto cauCW;
       cauCV: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauCW: // global
           I64[Sp - 8] = block_cauCu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauD0; else goto cauCv;
       uauD0: // global
           call _cauCu(R1) args: 0, res: 0, upd: 0;
       cauCv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauCu() //  [R1]
         { info_tbl: [(cauCu,
                       label: block_cauCu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauCu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauCZ; else goto cauCY;
       cauCZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauCY: // global
           _sasLB::P64 = P64[P64[R1 + 23] + 8];
           I64[Hp - 16] = sat_sasLD_info;
           P64[Hp] = _sasLB::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:27.999863735 UTC

[section ""data" . GHC.Event.TimerManager.finished_closure" {
     GHC.Event.TimerManager.finished_closure:
         const GHC.Event.TimerManager.finished_info;
 },
 GHC.Event.TimerManager.finished_entry() //  [R2]
         { info_tbl: [(cauDs,
                       label: GHC.Event.TimerManager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauDs: // global
           R2 = R2;
           call GHC.Event.TimerManager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.002937079 UTC

[section ""data" . GHC.Event.TimerManager.shutdown2_closure" {
     GHC.Event.TimerManager.shutdown2_closure:
         const GHC.Event.TimerManager.shutdown2_info;
 },
 GHC.Event.TimerManager.shutdown2_entry() //  [R2]
         { info_tbl: [(cauDE,
                       label: GHC.Event.TimerManager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauDE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauDI; else goto cauDH;
       cauDI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauDH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.006863194 UTC

[section ""data" . GHC.Event.TimerManager.shutdown1_closure" {
     GHC.Event.TimerManager.shutdown1_closure:
         const GHC.Event.TimerManager.shutdown1_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown1_entry() //  [R2]
         { info_tbl: [(cauDV,
                       label: GHC.Event.TimerManager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauDV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauDW; else goto cauDX;
       cauDW: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauDX: // global
           I64[Sp - 8] = block_cauDS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauEh; else goto cauDT;
       uauEh: // global
           call _cauDS(R1) args: 0, res: 0, upd: 0;
       cauDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauDS() //  [R1]
         { info_tbl: [(cauDS,
                       label: block_cauDS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauDS: // global
           I64[Sp - 16] = block_cauE0_info;
           R2 = GHC.Event.TimerManager.shutdown2_closure+1;
           _sasLQ::P64 = P64[R1 + 47];
           _sasLN::I64 = I64[R1 + 63];
           R1 = P64[R1 + 23];
           P64[Sp - 8] = _sasLQ::P64;
           I64[Sp] = _sasLN::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauE0() //  [R1]
         { info_tbl: [(cauE0,
                       label: block_cauE0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauE0: // global
           I64[Sp] = block_cauE2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauEi; else goto cauE5;
       uauEi: // global
           call _cauE2(R1) args: 0, res: 0, upd: 0;
       cauE5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauE2() //  [R1]
         { info_tbl: [(cauE2,
                       label: block_cauE2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauE2: // global
           if (R1 & 7 == 2) goto cauEf; else goto cauEb;
       cauEf: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cauEb: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.016323301 UTC

[section ""data" . GHC.Event.TimerManager.shutdown_closure" {
     GHC.Event.TimerManager.shutdown_closure:
         const GHC.Event.TimerManager.shutdown_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown_entry() //  [R2]
         { info_tbl: [(cauEG,
                       label: GHC.Event.TimerManager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauEG: // global
           R2 = R2;
           call GHC.Event.TimerManager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.019567225 UTC

[section ""data" . GHC.Event.TimerManager.new3_closure" {
     GHC.Event.TimerManager.new3_closure:
         const GHC.Event.TimerManager.new3_info;
 },
 GHC.Event.TimerManager.new3_entry() //  [R2]
         { info_tbl: [(cauES,
                       label: GHC.Event.TimerManager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauES: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauEW; else goto cauEV;
       cauEW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.new3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauEV: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Finished_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.025136066 UTC

[section ""data" . GHC.Event.TimerManager.new2_closure" {
     GHC.Event.TimerManager.new2_closure:
         const GHC.Event.TimerManager.new2_info;
         const 0;
 },
 sat_sasMp_entry() //  [R1]
         { info_tbl: [(cauFq,
                       label: sat_sasMp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauFr; else goto cauFs;
       cauFr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cauFs: // global
           I64[Sp - 24] = block_cauFh_info;
           R2 = GHC.Event.TimerManager.new3_closure+1;
           _sasLW::P64 = P64[R1 + 7];
           _sasM3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sasLW::P64;
           P64[Sp - 8] = _sasM3::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFh() //  [R1]
         { info_tbl: [(cauFh,
                       label: block_cauFh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFh: // global
           I64[Sp] = block_cauFj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauFJ; else goto cauFk;
       uauFJ: // global
           call _cauFj(R1) args: 0, res: 0, upd: 0;
       cauFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFj() //  [R1]
         { info_tbl: [(cauFj,
                       label: block_cauFj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFj: // global
           if (R1 & 7 == 4) goto cauFo; else goto cauFn;
       cauFo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauFn: // global
           _sasLW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cauFw_info;
           R1 = _sasLW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uauFK; else goto cauFx;
       uauFK: // global
           call _cauFw(R1) args: 0, res: 0, upd: 0;
       cauFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFw() //  [R1]
         { info_tbl: [(cauFw,
                       label: block_cauFw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFw: // global
           I64[Sp] = block_cauFB_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFB() //  []
         { info_tbl: [(cauFB,
                       label: block_cauFB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFB: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasMz_entry() //  [R1]
         { info_tbl: [(cauFX,
                       label: sat_sasMz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cauFY; else goto cauFZ;
       cauFY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauFZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlReadFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasMD_entry() //  [R1]
         { info_tbl: [(cauG6,
                       label: sat_sasMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauG6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cauG7; else goto cauG8;
       cauG7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauG8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlEventFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasMN_entry() //  [R1]
         { info_tbl: [(cauGi,
                       label: sat_sasMN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauGi: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cauGm; else goto cauGn;
       cauGm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cauGf_info;
           _sasM0::P64 = P64[R1 + 16];
           _sasM6::P64 = P64[R1 + 32];
           _sasM9::P64 = P64[R1 + 40];
           _sasMt::P64 = P64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sasM0::P64;
           P64[Sp - 40] = _sasM6::P64;
           P64[Sp - 32] = _sasM9::P64;
           P64[Sp - 24] = _sasMt::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uauGr; else goto cauGg;
       uauGr: // global
           call _cauGf(R1) args: 0, res: 0, upd: 0;
       cauGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauGf() //  [R1]
         { info_tbl: [(cauGf,
                       label: block_cauGf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauGf: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cauGq; else goto cauGp;
       cauGq: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cauGp: // global
           _sasML::P64 = P64[R1 + 7];
           _sasMM::P64 = P64[R1 + 15];
           _sasMI::I64 = I64[R1 + 23];
           _sasMJ::I64 = I64[R1 + 31];
           _sasMK::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sasML::P64;
           P64[Hp - 24] = _sasMM::P64;
           I64[Hp - 16] = _sasMI::I64;
           I64[Hp - 8] = _sasMJ::I64;
           I64[Hp] = _sasMK::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.new2_entry() //  [R2]
         { info_tbl: [(cauGs,
                       label: GHC.Event.TimerManager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauGs: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cauGt; else goto cauGu;
       cauGt: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauGu: // global
           I64[Sp - 16] = block_cauF6_info;
           R1 = GHC.Event.PSQ.Nil_closure+3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauF6() //  [R1]
         { info_tbl: [(cauF6,
                       label: block_cauF6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauF6: // global
           I64[Sp - 8] = block_cauF8_info;
           R2 = GHC.Types.True_closure+2;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauF8() //  [R1]
         { info_tbl: [(cauF8,
                       label: block_cauF8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauF8: // global
           I64[Sp - 8] = block_cauFa_info;
           _sasM3::P64 = R1;
           R1 = GHC.Event.TimerManager.Created_closure+1;
           P64[Sp] = _sasM3::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFa() //  [R1]
         { info_tbl: [(cauFa,
                       label: block_cauFa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cauGz; else goto cauGy;
       cauGz: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauGy: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_sasMp_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_cauFM_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _sasM6::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _sasM6::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFM() //  []
         { info_tbl: [(cauFM,
                       label: block_cauFM_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFM: // global
           I64[Sp] = block_cauFO_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uauGK; else goto cauFP;
       uauGK: // global
           call _cauFO(R1) args: 0, res: 0, upd: 0;
       cauFP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauFO() //  [R1]
         { info_tbl: [(cauFO,
                       label: block_cauFO_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauFO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauGD; else goto cauGC;
       cauGD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauGC: // global
           _sasMu::P64 = P64[R1 + 7];
           _sasMw::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sasMz_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp - 16] = block_cauG0_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _sasMu::P64;
           _sasMt::P64 = R1;
           R1 = _sasMw::P64;
           I64[Sp - 24] = stg_ap_v_info;
           P64[Sp - 8] = _sasMw::P64;
           P64[Sp] = _sasMu::P64;
           P64[Sp + 40] = _sasMt::P64;
           Sp = Sp - 24;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _cauG0() //  [R1]
         { info_tbl: [(cauG0,
                       label: block_cauG0_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauG0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauGG; else goto cauGF;
       cauGG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauGF: // global
           I64[Hp - 16] = sat_sasMD_info;
           P64[Hp] = P64[Sp + 40];
           _sasMu::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cauG9_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _sasMu::P64;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_v_info;
           Sp = Sp + 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _cauG9() //  [R1]
         { info_tbl: [(cauG9,
                       label: block_cauG9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauG9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cauGJ; else goto cauGI;
       cauGJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauGI: // global
           I64[Hp - 48] = sat_sasMN_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 40];
           R1 = Hp - 48;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.058440064 UTC

[section ""data" . GHC.Event.TimerManager.newWith_closure" {
     GHC.Event.TimerManager.newWith_closure:
         const GHC.Event.TimerManager.newWith_info;
         const 0;
 },
 GHC.Event.TimerManager.newWith_entry() //  [R2]
         { info_tbl: [(cauI7,
                       label: GHC.Event.TimerManager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauI7: // global
           R2 = R2;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.062171101 UTC

[section ""data" . GHC.Event.TimerManager.new1_closure" {
     GHC.Event.TimerManager.new1_closure:
         const GHC.Event.TimerManager.new1_info;
         const 0;
 },
 GHC.Event.TimerManager.new1_entry() //  []
         { info_tbl: [(cauIk,
                       label: GHC.Event.TimerManager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauIk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cauIl; else goto cauIm;
       cauIl: // global
           R1 = GHC.Event.TimerManager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cauIm: // global
           I64[Sp - 8] = block_cauIi_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _cauIi() //  [R1]
         { info_tbl: [(cauIi,
                       label: block_cauIi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauIi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.067170846 UTC

[section ""data" . GHC.Event.TimerManager.new_closure" {
     GHC.Event.TimerManager.new_closure:
         const GHC.Event.TimerManager.new_info;
         const 0;
 },
 GHC.Event.TimerManager.new_entry() //  []
         { info_tbl: [(cauIA,
                       label: GHC.Event.TimerManager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauIA: // global
           call GHC.Event.TimerManager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.07334342 UTC

[section ""data" . GHC.Event.TimerManager.step1_closure" {
     GHC.Event.TimerManager.step1_closure:
         const GHC.Event.TimerManager.step1_info;
         const 0;
 },
 sat_sasNw_entry() //  [R1]
         { info_tbl: [(cauJl,
                       label: sat_sasNw_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cauJm; else goto cauJn;
       cauJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauJn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cauJd_info;
           _sasMX::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sasMX::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauJK; else goto cauJe;
       uauJK: // global
           call _cauJd(R1) args: 0, res: 0, upd: 0;
       cauJe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauJd() //  [R1]
         { info_tbl: [(cauJd,
                       label: block_cauJd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJd: // global
           _cauJk::P64 = R1 & 7;
           if (_cauJk::P64 < 3) goto uauJJ; else goto cauJj;
       uauJJ: // global
           _sasMX::I64 = I64[Sp + 8];
           if (_cauJk::P64 < 2) goto cauJh; else goto cauJi;
       cauJh: // global
           Hp = Hp + 16;
           _sasNk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cauJF; else goto cauJv;
       cauJv: // global
           _sasNr::I64 = I64[_sasNk::P64 + 39] - _sasMX::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _sasNr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauJi: // global
           Hp = Hp + 16;
           _sasNk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cauJF; else goto cauJE;
       cauJF: // global
           HpAlloc = 16;
           R1 = _sasNk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cauJE: // global
           _sasNv::I64 = I64[_sasNk::P64 + 22] - _sasMX::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _sasNv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauJj: // global
           R1 = GHC.Event.Internal.Forever_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sasNy_entry() //  [R1, R2]
         { info_tbl: [(cauJL,
                       label: sat_sasNy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauJO; else goto cauJP;
       cauJO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauJP: // global
           I64[Sp - 16] = block_cauJ2_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 15];
           Sp = Sp - 16;
           call GHC.Event.PSQ.$watMost_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauJ2() //  [R1, R2]
         { info_tbl: [(cauJ2,
                       label: block_cauJ2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJ2: // global
           I64[Sp - 8] = block_cauJ4_info;
           _sasNh::P64 = R1;
           R1 = R2;
           P64[Sp] = _sasNh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauJU; else goto cauJ5;
       uauJU: // global
           call _cauJ4(R1) args: 0, res: 0, upd: 0;
       cauJ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauJ4() //  [R1]
         { info_tbl: [(cauJ4,
                       label: block_cauJ4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJ4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cauJT; else goto cauJS;
       cauJT: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauJS: // global
           I64[Hp - 72] = sat_sasNw_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 39;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasNX_entry() //  [R1, R2, R3]
         { info_tbl: [(cauKf,
                       label: sat_sasNX_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauKf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cauKg; else goto cauKh;
       cauKg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cauKh: // global
           I64[Sp - 32] = block_cauKc_info;
           _sasN1::P64 = P64[R1 + 5];
           _sasN7::P64 = P64[R1 + 13];
           _sasN5::I64 = I64[R1 + 21];
           R1 = R2;
           P64[Sp - 24] = _sasN1::P64;
           I64[Sp - 16] = _sasN5::I64;
           P64[Sp - 8] = _sasN7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauKN; else goto cauKd;
       uauKN: // global
           call _cauKc(R1) args: 0, res: 0, upd: 0;
       cauKd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauKc() //  [R1]
         { info_tbl: [(cauKc,
                       label: block_cauKc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauKc: // global
           I64[Sp] = block_cauKk_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = I64[Sp + 16];
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauKk() //  [R1]
         { info_tbl: [(cauKk,
                       label: block_cauKk_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauKk: // global
           I64[Sp] = block_cauKm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauKO; else goto cauKp;
       uauKO: // global
           call _cauKm(R1) args: 0, res: 0, upd: 0;
       cauKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauKm() //  [R1]
         { info_tbl: [(cauKm,
                       label: block_cauKm_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauKm: // global
           _cauKI::P64 = R1 & 7;
           if (_cauKI::P64 < 3) goto uauKM; else goto cauKE;
       uauKM: // global
           if (_cauKI::P64 < 2) goto cauKv; else goto cauKz;
       cauKv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauKz: // global
           _sasN1::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sasN1::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasN1::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauKE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cauKH; else goto cauKG;
       cauKH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauKG: // global
           _sasNT::P64 = P64[R1 + 5];
           _sasNS::I64 = I64[R1 + 13];
           _sasNU::I64 = I64[R1 + 21];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _sasNU::I64;
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _sasNT::P64;
           I64[Hp] = _sasNS::I64;
           R3 = Hp - 31;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasO6_entry() //  [R1]
         { info_tbl: [(cauL8,
                       label: sat_sasO6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauL8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauL9; else goto cauLa;
       cauL9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauLa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cauL1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uauLh; else goto cauL2;
       uauLh: // global
           call _cauL1(R1) args: 0, res: 0, upd: 0;
       cauL2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauL1() //  [R1]
         { info_tbl: [(cauL1,
                       label: block_cauL1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauL1: // global
           if (R1 & 7 == 2) goto cauL6; else goto cauL5;
       cauL6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cauL5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.step1_entry() //  [R2]
         { info_tbl: [(cauLi,
                       label: GHC.Event.TimerManager.step1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauLi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cauLj; else goto cauLk;
       cauLj: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.step1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauLk: // global
           (_sasMX::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 16] = block_cauIM_info;
           R1 = R2;
           I64[Sp - 8] = _sasMX::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uauM6; else goto cauIN;
       uauM6: // global
           call _cauIM(R1) args: 0, res: 0, upd: 0;
       cauIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauIM() //  [R1]
         { info_tbl: [(cauIM,
                       label: block_cauIM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauIM: // global
           I64[Sp - 32] = block_cauIR_info;
           _sasN0::P64 = P64[R1 + 15];
           _sasN1::P64 = P64[R1 + 23];
           _sasN7::P64 = P64[R1 + 47];
           _sasN5::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sasN1::P64;
           I64[Sp - 16] = _sasN5::I64;
           P64[Sp - 8] = _sasN7::P64;
           P64[Sp] = _sasN0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uauM2; else goto cauIS;
       uauM2: // global
           call _cauIR(R1) args: 0, res: 0, upd: 0;
       cauIS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauIR() //  [R1]
         { info_tbl: [(cauIR,
                       label: block_cauIR_info
                       rep:StackRep [False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauIR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cauLo; else goto cauLn;
       cauLo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauLn: // global
           _sasN9::P64 = P64[R1 + 7];
           _sasNa::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           _sasMX::I64 = I64[Sp + 40];
           I64[Hp - 24] = _sasMX::I64;
           I64[Hp - 16] = sat_sasNy_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _sasMX::I64;
           I64[Sp] = block_cauJV_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sasNa::P64;
           P64[Sp + 40] = _sasN9::P64;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauJV() //  [R1]
         { info_tbl: [(cauJV,
                       label: block_cauJV_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJV: // global
           I64[Sp] = block_cauJX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauM3; else goto cauJY;
       uauM3: // global
           call _cauJX(R1) args: 0, res: 0, upd: 0;
       cauJY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauJX() //  [R1]
         { info_tbl: [(cauJX,
                       label: block_cauJX_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauJX: // global
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call _cauLB() args: 0, res: 0, upd: 0;
     }
 },
 _cauLB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauLB: // global
           _sasO8::P64 = P64[Sp];
           I64[Sp] = block_cauLD_info;
           R1 = _sasO8::P64;
           if (R1 & 7 != 0) goto uauM7; else goto cauLF;
       uauM7: // global
           call _cauLD(R1) args: 0, res: 0, upd: 0;
       cauLF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauLD() //  [R1]
         { info_tbl: [(cauLD,
                       label: block_cauLD_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauLD: // global
           if (R1 & 7 == 1) goto uauM8; else goto cauLQ;
       uauM8: // global
           call _cauK5() args: 0, res: 0, upd: 0;
       cauLQ: // global
           I64[Sp - 8] = block_cauLO_info;
           _sasOc::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sasOc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauM9; else goto cauLR;
       uauM9: // global
           call _cauLO(R1) args: 0, res: 0, upd: 0;
       cauLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauK5() //  []
         { info_tbl: [(cauK5,
                       label: block_cauK5_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauK5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cauLt; else goto cauLs;
       cauLt: // global
           HpAlloc = 48;
           I64[Sp] = block_cauK5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cauLs: // global
           I64[Hp - 40] = sat_sasNX_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cauKQ_info;
           R4 = Hp - 37;
           R3 = Hp - 6;
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauKQ() //  []
         { info_tbl: [(cauKQ,
                       label: block_cauKQ_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauKQ: // global
           _sasO3::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 40] = block_cauKS_info;
           R1 = _sasO3::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uauM5; else goto cauKT;
       uauM5: // global
           call _cauKS(R1) args: 0, res: 0, upd: 0;
       cauKT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauKS() //  [R1]
         { info_tbl: [(cauKS,
                       label: block_cauKS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauKS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauLx; else goto cauLw;
       cauLx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauLw: // global
           I64[Hp - 16] = sat_sasO6_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cauLO() //  [R1]
         { info_tbl: [(cauLO,
                       label: block_cauLO_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauLO: // global
           I64[Sp] = block_cauLV_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauLV() //  []
         { info_tbl: [(cauLV,
                       label: block_cauLV_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauLV: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cauLB() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.119071626 UTC

[section ""data" . GHC.Event.TimerManager.step_closure" {
     GHC.Event.TimerManager.step_closure:
         const GHC.Event.TimerManager.step_info;
         const 0;
 },
 GHC.Event.TimerManager.step_entry() //  [R2]
         { info_tbl: [(cauO8,
                       label: GHC.Event.TimerManager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauO8: // global
           R2 = R2;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.122240621 UTC

[section ""cstring" . lvl_rasDV_bytes" {
     lvl_rasDV_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.124838905 UTC

[section ""data" . lvl1_rasDW_closure" {
     lvl1_rasDW_closure:
         const lvl1_rasDW_info;
         const 0;
 },
 sat_sasOm_entry() //  [R1]
         { info_tbl: [(cauOv,
                       label: sat_sasOm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauOv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cauOw; else goto cauOx;
       cauOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cauOo_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uauOE; else goto cauOp;
       uauOE: // global
           call _cauOo(R1) args: 0, res: 0, upd: 0;
       cauOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cauOo() //  [R1]
         { info_tbl: [(cauOo,
                       label: block_cauOo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauOo: // global
           if (R1 & 7 == 4) goto cauOt; else goto cauOs;
       cauOt: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cauOs: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_rasDW_entry() //  [R2]
         { info_tbl: [(cauOH,
                       label: lvl1_rasDW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauOH: // global
           _sasOk::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cauOI; else goto cauOJ;
       cauOJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauOL; else goto cauOK;
       cauOL: // global
           HpAlloc = 24;
           goto cauOI;
       cauOI: // global
           R2 = _sasOk::P64;
           R1 = lvl1_rasDW_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauOK: // global
           I64[Hp - 16] = sat_sasOm_info;
           P64[Hp] = _sasOk::P64;
           I64[Sp - 8] = block_cauOF_info;
           R3 = Hp - 16;
           R2 = lvl_rasDV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauOF() //  [R1]
         { info_tbl: [(cauOF,
                       label: block_cauOF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauOF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.13401197 UTC

[section ""data" . lvl2_rasDX_closure" {
     lvl2_rasDX_closure:
         const (,)_con_info;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.13608868 UTC

[section ""data" . lvl3_rasDY_closure" {
     lvl3_rasDY_closure:
         const lvl3_rasDY_info;
 },
 lvl3_rasDY_entry() //  [R2]
         { info_tbl: [(cauPl,
                       label: lvl3_rasDY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauPl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cauPm; else goto cauPn;
       cauPm: // global
           R2 = R2;
           R1 = lvl3_rasDY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauPn: // global
           I64[Sp - 8] = block_cauPe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uauPx; else goto cauPf;
       uauPx: // global
           call _cauPe(R1) args: 0, res: 0, upd: 0;
       cauPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauPe() //  [R1]
         { info_tbl: [(cauPe,
                       label: block_cauPe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauPe: // global
           if (R1 & 7 == 1) goto cauPj; else goto cauPi;
       cauPj: // global
           R1 = lvl2_rasDX_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauPi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cauPt; else goto cauPs;
       cauPt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cauPs: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.147506412 UTC

[section ""data" . GHC.Event.TimerManager.$wloop_closure" {
     GHC.Event.TimerManager.$wloop_closure:
         const GHC.Event.TimerManager.$wloop_info;
         const 0;
 },
 GHC.Event.TimerManager.$wloop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauPM: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 40, res: 0, upd: 8;
     }
 },
 go_sasPk_entry() //  [R1]
         { info_tbl: [(cauQk,
                       label: go_sasPk_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto uauQx; else goto uauQw;
       uauQx: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _cauQl() args: 0, res: 0, upd: 0;
       uauQw: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _cauQ7() args: 0, res: 0, upd: 0;
     }
 },
 _cauQ7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQ7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cauQo; else goto cauQn;
       cauQo: // global
           HpAlloc = 80;
           call _cauQl() args: 0, res: 0, upd: 0;
       cauQn: // global
           _sasPk::P64 = P64[Sp];
           _sasOr::P64 = P64[_sasPk::P64 + 7];
           _sasOs::P64 = P64[_sasPk::P64 + 15];
           _sasOt::P64 = P64[_sasPk::P64 + 23];
           _sasOx::P64 = P64[_sasPk::P64 + 31];
           _sasOy::P64 = P64[_sasPk::P64 + 39];
           _sasOA::P64 = P64[_sasPk::P64 + 47];
           _sasOu::I64 = I64[_sasPk::P64 + 55];
           _sasOv::I64 = I64[_sasPk::P64 + 63];
           _sasOw::I64 = I64[_sasPk::P64 + 71];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = _sasOA::P64;
           P64[Hp - 56] = _sasOr::P64;
           P64[Hp - 48] = _sasOs::P64;
           P64[Hp - 40] = _sasOt::P64;
           P64[Hp - 32] = _sasOx::P64;
           P64[Hp - 24] = _sasOy::P64;
           I64[Hp - 16] = _sasOu::I64;
           I64[Hp - 8] = _sasOv::I64;
           I64[Hp] = _sasOw::I64;
           I64[Sp - 8] = block_cauQb_info;
           R2 = Hp - 71;
           Sp = Sp - 8;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cauQl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQl: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cauQb() //  [R1]
         { info_tbl: [(cauQb,
                       label: block_cauQb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQb: // global
           I64[Sp] = block_cauQd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauQA; else goto cauQe;
       uauQA: // global
           call _cauQd(R1) args: 0, res: 0, upd: 0;
       cauQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauQd() //  [R1]
         { info_tbl: [(cauQd,
                       label: block_cauQd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQd: // global
           if (R1 & 7 == 1) goto cauQh; else goto uauQy;
       cauQh: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uauQy: // global
           Sp = Sp + 8;
           call _cauQ7() args: 0, res: 0, upd: 0;
     }
 },
 sat_sasQ0_entry() //  [R1, R2]
         { info_tbl: [(cauQU,
                       label: sat_sasQ0_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQU: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cauQV; else goto cauQW;
       cauQV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauQW: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_cauQO_info;
           _sasPt::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasPt::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauQO() //  []
         { info_tbl: [(cauQO,
                       label: block_cauQO_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQO: // global
           I64[Sp] = block_cauQQ_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauQQ() //  []
         { info_tbl: [(cauQQ,
                       label: block_cauQQ_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQQ: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasPG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasPL::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cauR7_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uauRw; else goto cauR8;
       uauRw: // global
           call _cauR7(R1) args: 0, res: 0, upd: 0;
       cauR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauR7() //  [R1]
         { info_tbl: [(cauR7,
                       label: block_cauR7_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauR7: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasPt::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cauRe; else goto cauRi;
       cauRe: // global
           (_sasPR::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasPt::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cauRi: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasPZ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasPt::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasPs_entry() //  [R1]
         { info_tbl: [(cauRC,
                       label: sat_sasPs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauRC: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasR8_entry() //  [R1, R2]
         { info_tbl: [(cauRZ,
                       label: sat_sasR8_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauRZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cauS0; else goto cauS1;
       cauS0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauS1: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_cauRT_info;
           _sasQB::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasQB::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauRT() //  []
         { info_tbl: [(cauRT,
                       label: block_cauRT_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauRT: // global
           I64[Sp] = block_cauRV_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauRV() //  []
         { info_tbl: [(cauRV,
                       label: block_cauRV_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauRV: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasQO::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasQT::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cauSc_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uauSB; else goto cauSd;
       uauSB: // global
           call _cauSc(R1) args: 0, res: 0, upd: 0;
       cauSd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauSc() //  [R1]
         { info_tbl: [(cauSc,
                       label: block_cauSc_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauSc: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasQB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cauSj; else goto cauSn;
       cauSj: // global
           (_sasQZ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQB::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cauSn: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasR7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQB::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasQA_entry() //  [R1]
         { info_tbl: [(cauSH,
                       label: sat_sasQA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauSH: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasRH_entry() //  [R1]
         { info_tbl: [(cauSV,
                       label: sat_sasRH_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauSV: // global
           _sasRH::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto cauSW; else goto cauSX;
       cauSX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cauSZ; else goto cauSY;
       cauSZ: // global
           HpAlloc = 88;
           goto cauSW;
       cauSW: // global
           R1 = _sasRH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cauSY: // global
           _sasOs::P64 = P64[_sasRH::P64 + 7];
           _sasOx::P64 = P64[_sasRH::P64 + 15];
           _sasOy::P64 = P64[_sasRH::P64 + 23];
           _sasOB::P64 = P64[_sasRH::P64 + 31];
           _sasOF::P64 = P64[_sasRH::P64 + 39];
           _sasPk::P64 = P64[_sasRH::P64 + 47];
           _sasOu::I64 = I64[_sasRH::P64 + 55];
           _sasOv::I64 = I64[_sasRH::P64 + 63];
           _sasOw::I64 = I64[_sasRH::P64 + 71];
           I64[Hp - 80] = sat_sasR8_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasQA_info;
           P64[Hp] = _sasPk::P64;
           I64[Sp - 72] = block_cauSK_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           P64[Sp - 64] = _sasOs::P64;
           I64[Sp - 56] = _sasOu::I64;
           I64[Sp - 48] = _sasOv::I64;
           I64[Sp - 40] = _sasOw::I64;
           P64[Sp - 32] = _sasOx::P64;
           P64[Sp - 24] = _sasOy::P64;
           P64[Sp - 16] = _sasOB::P64;
           P64[Sp - 8] = _sasOF::P64;
           Sp = Sp - 72;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauSK() //  [R1]
         { info_tbl: [(cauSK,
                       label: block_cauSK_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauSK: // global
           _sasOs::P64 = P64[Sp + 8];
           _sasOB::P64 = P64[Sp + 56];
           _sasOF::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 8] = block_cauSP_info;
           R2 = _sasOB::P64;
           _sasRb::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 64] = _sasRb::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauSP() //  []
         { info_tbl: [(cauSP,
                       label: block_cauSP_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauSP: // global
           I64[Sp] = block_cauSR_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauSR() //  []
         { info_tbl: [(cauSR,
                       label: block_cauSR_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauSR: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasRn::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasRs::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cauTb_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uauTA; else goto cauTc;
       uauTA: // global
           call _cauTb(R1) args: 0, res: 0, upd: 0;
       cauTc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauTb() //  [R1]
         { info_tbl: [(cauTb,
                       label: block_cauTb_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauTb: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasRb::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cauTi; else goto cauTm;
       cauTi: // global
           (_sasRy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRb::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauTm: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasRG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRb::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasSg_entry() //  [R1, R2]
         { info_tbl: [(cauTQ,
                       label: sat_sasSg_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauTQ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cauTR; else goto cauTS;
       cauTR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cauTS: // global
           _sasOs::P64 = P64[R1 + 6];
           _sasOx::P64 = P64[R1 + 14];
           _sasOy::P64 = P64[R1 + 22];
           _sasOB::P64 = P64[R1 + 30];
           _sasOF::P64 = P64[R1 + 38];
           _sasOu::I64 = I64[R1 + 46];
           _sasOv::I64 = I64[R1 + 54];
           _sasOw::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp - 56] = block_cauTK_info;
           _sasRJ::P64 = R2;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           I64[Sp - 48] = _sasOu::I64;
           I64[Sp - 40] = _sasOv::I64;
           I64[Sp - 32] = _sasOw::I64;
           P64[Sp - 24] = _sasOx::P64;
           P64[Sp - 16] = _sasOy::P64;
           P64[Sp - 8] = _sasRJ::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauTK() //  []
         { info_tbl: [(cauTK,
                       label: block_cauTK_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauTK: // global
           I64[Sp] = block_cauTM_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauTM() //  []
         { info_tbl: [(cauTM,
                       label: block_cauTM_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauTM: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasRW::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasS1::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cauU3_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uauUs; else goto cauU4;
       uauUs: // global
           call _cauU3(R1) args: 0, res: 0, upd: 0;
       cauU4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauU3() //  [R1]
         { info_tbl: [(cauU3,
                       label: block_cauU3_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauU3: // global
           _sasOw::I64 = I64[Sp + 8];
           _sasRJ::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cauUa; else goto cauUe;
       cauUa: // global
           (_sasS7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRJ::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cauUe: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasSf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasRJ::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sasRI_entry() //  [R1]
         { info_tbl: [(cauUy,
                       label: sat_sasRI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauUy: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wloop_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cauUB,
                       label: GHC.Event.TimerManager.$wloop_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauUB: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cauUC; else goto cauUD;
       cauUC: // global
           R1 = GHC.Event.TimerManager.$wloop_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cauUD: // global
           I64[Sp - 40] = block_cauPQ_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uauXX; else goto cauPR;
       uauXX: // global
           call _cauPQ(R1) args: 0, res: 0, upd: 0;
       cauPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauPQ() //  [R1]
         { info_tbl: [(cauPQ,
                       label: block_cauPQ_info
                       rep:StackRep [False, False, False, True, True, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauPQ: // global
           I64[Sp - 24] = block_cauPV_info;
           R2 = lvl3_rasDY_closure+1;
           _sasOA::P64 = R1;
           _sasOB::P64 = P64[R1 + 7];
           _sasOF::P64 = P64[R1 + 39];
           R1 = P64[Sp + 16];
           P64[Sp - 16] = _sasOB::P64;
           P64[Sp - 8] = _sasOF::P64;
           P64[Sp] = _sasOA::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauPV() //  [R1]
         { info_tbl: [(cauPV,
                       label: block_cauPV_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauPV: // global
           I64[Sp] = block_cauPX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uauXW; else goto cauPY;
       uauXW: // global
           call _cauPX(R1) args: 0, res: 0, upd: 0;
       cauPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauPX() //  [R1]
         { info_tbl: [(cauPX,
                       label: block_cauPX_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauPX: // global
           _cauX3::P64 = R1 & 7;
           if (_cauX3::P64 == 1) goto cauVg; else goto uauXU;
       cauVg: // global
           I64[Sp] = block_cauQ3_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       uauXU: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           if (_cauX3::P64 == 3) goto cauWD; else goto cauUP;
       cauWD: // global
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 48] = block_cauWz_info;
           R2 = _sasOB::P64;
           R1 = _sasOF::P64;
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cauUP: // global
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_cauUK_info;
           R2 = _sasOB::P64;
           _sasOJ::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasOJ::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauQ3() //  [R1]
         { info_tbl: [(cauQ3,
                       label: block_cauQ3_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauQ3: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cauVj; else goto cauVi;
       cauVj: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cauVi: // global
           I64[Hp - 160] = go_sasPk_info;
           P64[Hp - 152] = P64[Sp + 32];
           _sasOs::P64 = P64[Sp + 40];
           P64[Hp - 144] = _sasOs::P64;
           P64[Hp - 136] = P64[Sp + 48];
           _sasOx::P64 = P64[Sp + 80];
           P64[Hp - 128] = _sasOx::P64;
           _sasOy::P64 = P64[Sp + 88];
           P64[Hp - 120] = _sasOy::P64;
           P64[Hp - 112] = P64[Sp + 24];
           _sasOu::I64 = I64[Sp + 56];
           I64[Hp - 104] = _sasOu::I64;
           _sasOv::I64 = I64[Sp + 64];
           I64[Hp - 96] = _sasOv::I64;
           _sasOw::I64 = I64[Sp + 72];
           I64[Hp - 88] = _sasOw::I64;
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           _cauQ5::P64 = Hp - 159;
           if (R1 == 0) goto cauVU; else goto uauXV;
       cauVU: // global
           I64[Hp - 80] = sat_sasRH_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           P64[Hp - 32] = _cauQ5::P64;
           I64[Hp - 24] = _sasOu::I64;
           I64[Hp - 16] = _sasOv::I64;
           I64[Hp - 8] = _sasOw::I64;
           _cauRG::P64 = Hp - 79;
           Hp = Hp - 8;
           R1 = _cauRG::P64;
           Sp = Sp + 96;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uauXV: // global
           if (R1 == 1) goto cauW3; else goto cauVt;
       cauW3: // global
           I64[Hp - 80] = sat_sasSg_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasRI_info;
           P64[Hp] = _cauQ5::P64;
           I64[Sp] = block_cauVV_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cauVt: // global
           I64[Hp - 80] = sat_sasQ0_info;
           P64[Hp - 72] = _sasOs::P64;
           P64[Hp - 64] = _sasOx::P64;
           P64[Hp - 56] = _sasOy::P64;
           P64[Hp - 48] = _sasOB::P64;
           P64[Hp - 40] = _sasOF::P64;
           I64[Hp - 32] = _sasOu::I64;
           I64[Hp - 24] = _sasOv::I64;
           I64[Hp - 16] = _sasOw::I64;
           I64[Hp - 8] = sat_sasPs_info;
           P64[Hp] = _cauQ5::P64;
           I64[Sp] = block_cauVk_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauVV() //  [R1]
         { info_tbl: [(cauVV,
                       label: block_cauVV_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauVV: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_cauW0_info;
           R2 = _sasOB::P64;
           _sasSj::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasSj::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauW0() //  []
         { info_tbl: [(cauW0,
                       label: block_cauW0_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauW0: // global
           I64[Sp] = block_cauW2_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauW2() //  []
         { info_tbl: [(cauW2,
                       label: block_cauW2_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauW2: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasSv::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasSA::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_cauWi_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uauY0; else goto cauWj;
       uauY0: // global
           call _cauWi(R1) args: 0, res: 0, upd: 0;
       cauWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauWi() //  [R1]
         { info_tbl: [(cauWi,
                       label: block_cauWi_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauWi: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasSj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cauWp; else goto cauWt;
       cauWp: // global
           (_sasSG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasSj::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauWt: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasSO::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasSj::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cauVk() //  [R1]
         { info_tbl: [(cauVk,
                       label: block_cauVk_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauVk: // global
           _sasOs::P64 = P64[Sp + 40];
           _sasOB::P64 = P64[Sp + 8];
           _sasOF::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sasOs::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sasOs::P64);
           I64[Sp + 40] = block_cauVp_info;
           R2 = _sasOB::P64;
           _sasQ3::P64 = R1;
           R1 = _sasOF::P64;
           P64[Sp + 48] = _sasQ3::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauVp() //  []
         { info_tbl: [(cauVp,
                       label: block_cauVp_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauVp: // global
           I64[Sp] = block_cauVr_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauVr() //  []
         { info_tbl: [(cauVr,
                       label: block_cauVr_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauVr: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasQf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasQk::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_cauVI_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uauXZ; else goto cauVJ;
       uauXZ: // global
           call _cauVI(R1) args: 0, res: 0, upd: 0;
       cauVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauVI() //  [R1]
         { info_tbl: [(cauVI,
                       label: block_cauVI_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauVI: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasQ3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cauVP; else goto cauVT;
       cauVP: // global
           (_sasQq::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQ3::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauVT: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasQy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = _sasQ3::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cauWz() //  []
         { info_tbl: [(cauWz,
                       label: block_cauWz_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauWz: // global
           I64[Sp] = block_cauWB_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauWB() //  []
         { info_tbl: [(cauWB,
                       label: block_cauWB_info
                       rep:StackRep [True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauWB: // global
           _sasOv::I64 = I64[Sp + 16];
           _sasOx::P64 = P64[Sp + 32];
           (_sasT0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sasT5::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp + 16] = block_cauWR_info;
           R1 = _sasOx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uauY1; else goto cauWS;
       uauY1: // global
           call _cauWR(R1) args: 0, res: 0, upd: 0;
       cauWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauWR() //  [R1]
         { info_tbl: [(cauWR,
                       label: block_cauWR_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauWR: // global
           _sasOw::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cauWY; else goto cauX2;
       cauWY: // global
           (_sasTb::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cauX2: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasTj::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cauUK() //  []
         { info_tbl: [(cauUK,
                       label: block_cauUK_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauUK: // global
           I64[Sp] = block_cauUM_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauUM() //  []
         { info_tbl: [(cauUM,
                       label: block_cauUM_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauUM: // global
           _sasOv::I64 = I64[Sp + 24];
           _sasOx::P64 = P64[Sp + 40];
           (_sasOV::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_sasP0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOv::I64)));
           I64[Sp] = block_cauV3_info;
           R1 = _sasOx::P64;
           if (R1 & 7 != 0) goto uauXY; else goto cauV4;
       uauXY: // global
           call _cauV3(R1) args: 0, res: 0, upd: 0;
       cauV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cauV3() //  [R1]
         { info_tbl: [(cauV3,
                       label: block_cauV3_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauV3: // global
           _sasOw::I64 = I64[Sp + 32];
           _sasOJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cauVa; else goto cauVe;
       cauVa: // global
           (_sasP6::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R2 = _sasOJ::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
       cauVe: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sasPf::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sasOw::I64)));
           R2 = _sasOJ::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.239040607 UTC

[section ""data" . GHC.Event.TimerManager.loop1_closure" {
     GHC.Event.TimerManager.loop1_closure:
         const GHC.Event.TimerManager.loop1_info;
         const 0;
 },
 GHC.Event.TimerManager.loop1_entry() //  [R2]
         { info_tbl: [(cav1k,
                       label: GHC.Event.TimerManager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav1k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cav1l; else goto cav1m;
       cav1l: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cav1m: // global
           I64[Sp - 8] = block_cav1h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uav1q; else goto cav1i;
       uav1q: // global
           call _cav1h(R1) args: 0, res: 0, upd: 0;
       cav1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cav1h() //  [R1]
         { info_tbl: [(cav1h,
                       label: block_cav1h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav1h: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 63];
           I64[Sp - 16] = I64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 39];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 24;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.244644012 UTC

[section ""data" . GHC.Event.TimerManager.loop_closure" {
     GHC.Event.TimerManager.loop_closure:
         const GHC.Event.TimerManager.loop_info;
         const 0;
 },
 GHC.Event.TimerManager.loop_entry() //  [R2]
         { info_tbl: [(cav1I,
                       label: GHC.Event.TimerManager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav1I: // global
           R2 = R2;
           call GHC.Event.TimerManager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.248116468 UTC

[section ""data" . GHC.Event.TimerManager.TimerManager_closure" {
     GHC.Event.TimerManager.TimerManager_closure:
         const GHC.Event.TimerManager.TimerManager_info;
 },
 GHC.Event.TimerManager.TimerManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav1Q: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.TimerManager_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.TimerManager_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cav1V,
                       label: GHC.Event.TimerManager.TimerManager_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav1V: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cav1Z; else goto cav1Y;
       cav1Z: // global
           HpAlloc = 80;
           R1 = GHC.Event.TimerManager.TimerManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cav1Y: // global
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = R6;
           I64[Hp - 8] = I64[Sp];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.254228708 UTC

[section ""data" . GHC.Event.TimerManager.Created_closure" {
     GHC.Event.TimerManager.Created_closure:
         const GHC.Event.TimerManager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.255897139 UTC

[section ""data" . GHC.Event.TimerManager.Running_closure" {
     GHC.Event.TimerManager.Running_closure:
         const GHC.Event.TimerManager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.257521349 UTC

[section ""data" . GHC.Event.TimerManager.Dying_closure" {
     GHC.Event.TimerManager.Dying_closure:
         const GHC.Event.TimerManager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.259241032 UTC

[section ""data" . GHC.Event.TimerManager.Finished_closure" {
     GHC.Event.TimerManager.Finished_closure:
         const GHC.Event.TimerManager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.260963808 UTC

[GHC.Event.TimerManager.TimerManager_con_entry() //  [R1]
         { info_tbl: [(cav2f,
                       label: GHC.Event.TimerManager.TimerManager_con_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,84,105,109,101,114,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav2f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.264215789 UTC

[section ""relreadonly" . GHC.Event.TimerManager.State_closure_tbl" {
     GHC.Event.TimerManager.State_closure_tbl:
         const GHC.Event.TimerManager.Created_closure+1;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Dying_closure+3;
         const GHC.Event.TimerManager.Finished_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.266082112 UTC

[GHC.Event.TimerManager.Created_con_entry() //  [R1]
         { info_tbl: [(cav2m,
                       label: GHC.Event.TimerManager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav2m: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.26919553 UTC

[GHC.Event.TimerManager.Running_con_entry() //  [R1]
         { info_tbl: [(cav2s,
                       label: GHC.Event.TimerManager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav2s: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.272633288 UTC

[GHC.Event.TimerManager.Dying_con_entry() //  [R1]
         { info_tbl: [(cav2y,
                       label: GHC.Event.TimerManager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav2y: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.275811542 UTC

[GHC.Event.TimerManager.Finished_con_entry() //  [R1]
         { info_tbl: [(cav2E,
                       label: GHC.Event.TimerManager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav2E: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:28.278925274 UTC

[section ""relreadonly" . SasVk_srt" {
     SasVk_srt:
         const GHC.Event.TimerManager.$w$cshowsPrec_closure;
         const GHC.Event.TimerManager.$fShowState1_closure;
         const GHC.Event.TimerManager.$fShowState3_closure;
         const GHC.Event.TimerManager.$fShowState5_closure;
         const GHC.Event.TimerManager.$fShowState7_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.TimerManager.wakeManager1_closure;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure;
         const GHC.Event.TimerManager.$weditTimeouts_closure;
         const GHC.Event.TimerManager.unregisterTimeout2_closure;
         const GHC.Event.TimerManager.unregisterTimeout1_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const GHC.Event.TimerManager.$wregisterTimeout_closure;
         const GHC.Event.TimerManager.registerTimeout1_closure;
         const GHC.Event.TimerManager.updateTimeout1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.TimerManager.shutdown1_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.TimerManager.new1_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.TimerManager.step1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl1_rasDW_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.TimerManager.loop1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.428562273 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:30.430411064 UTC

[section ""data" . GHC.Event.TimerManager.$WTimerManager_closure" {
     GHC.Event.TimerManager.$WTimerManager_closure:
         const GHC.Event.TimerManager.$WTimerManager_info;
 },
 GHC.Event.TimerManager.$WTimerManager_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cavio,
                       label: GHC.Event.TimerManager.$WTimerManager_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavio: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caviM; else goto caviN;
       caviM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$WTimerManager_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caviN: // global
           I64[Sp - 40] = block_cavil_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaviW; else goto cavim;
       uaviW: // global
           call _cavil(R1) args: 0, res: 0, upd: 0;
       cavim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavil() //  [R1]
         { info_tbl: [(cavil,
                       label: block_cavil_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavil: // global
           I64[Sp] = block_cavir_info;
           _sav2Q::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sav2Q::P64;
           if (R1 & 7 != 0) goto uaviV; else goto cavis;
       uaviV: // global
           call _cavir(R1) args: 0, res: 0, upd: 0;
       cavis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavir() //  [R1]
         { info_tbl: [(cavir,
                       label: block_cavir_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavir: // global
           I64[Sp] = block_caviw_info;
           _sav2S::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sav2S::P64;
           if (R1 & 7 != 0) goto uaviX; else goto cavix;
       uaviX: // global
           call _caviw(R1) args: 0, res: 0, upd: 0;
       cavix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caviw() //  [R1]
         { info_tbl: [(caviw,
                       label: block_caviw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caviw: // global
           I64[Sp] = block_caviB_info;
           _sav2U::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sav2U::P64;
           if (R1 & 7 != 0) goto uaviY; else goto caviC;
       uaviY: // global
           call _caviB(R1) args: 0, res: 0, upd: 0;
       caviC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caviB() //  [R1]
         { info_tbl: [(caviB,
                       label: block_caviB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caviB: // global
           I64[Sp] = block_caviG_info;
           _sav2W::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sav2W::P64;
           if (R1 & 7 != 0) goto uaviZ; else goto caviH;
       uaviZ: // global
           call _caviG(R1) args: 0, res: 0, upd: 0;
       caviH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caviG() //  [R1]
         { info_tbl: [(caviG,
                       label: block_caviG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caviG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caviU; else goto caviT;
       caviU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caviT: // global
           _sav31::P64 = P64[R1 + 7];
           _sav32::P64 = P64[R1 + 15];
           _sav2Y::I64 = I64[R1 + 23];
           _sav2Z::I64 = I64[R1 + 31];
           _sav30::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sav31::P64;
           P64[Hp - 24] = _sav32::P64;
           I64[Hp - 16] = _sav2Y::I64;
           I64[Hp - 8] = _sav2Z::I64;
           I64[Hp] = _sav30::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.443328755 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState8_bytes" {
     GHC.Event.TimerManager.$fShowState8_bytes:
         I8[] [67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.445221109 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState7_closure" {
     GHC.Event.TimerManager.$fShowState7_closure:
         const GHC.Event.TimerManager.$fShowState7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState7_entry() //  [R1]
         { info_tbl: [(cavjH,
                       label: GHC.Event.TimerManager.$fShowState7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavjH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavjI; else goto cavjJ;
       cavjI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavjJ: // global
           (_cavjE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cavjE::I64 == 0) goto cavjG; else goto cavjF;
       cavjG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cavjF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cavjE::I64;
           R2 = GHC.Event.TimerManager.$fShowState8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.449098999 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState6_bytes" {
     GHC.Event.TimerManager.$fShowState6_bytes:
         I8[] [82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.450997379 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState5_closure" {
     GHC.Event.TimerManager.$fShowState5_closure:
         const GHC.Event.TimerManager.$fShowState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState5_entry() //  [R1]
         { info_tbl: [(cavjZ,
                       label: GHC.Event.TimerManager.$fShowState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavjZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavk0; else goto cavk1;
       cavk0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavk1: // global
           (_cavjW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cavjW::I64 == 0) goto cavjY; else goto cavjX;
       cavjY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cavjX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cavjW::I64;
           R2 = GHC.Event.TimerManager.$fShowState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.454930747 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState4_bytes" {
     GHC.Event.TimerManager.$fShowState4_bytes:
         I8[] [68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.456720752 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState3_closure" {
     GHC.Event.TimerManager.$fShowState3_closure:
         const GHC.Event.TimerManager.$fShowState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState3_entry() //  [R1]
         { info_tbl: [(cavkh,
                       label: GHC.Event.TimerManager.$fShowState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavkh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavki; else goto cavkj;
       cavki: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavkj: // global
           (_cavke::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cavke::I64 == 0) goto cavkg; else goto cavkf;
       cavkg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cavkf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cavke::I64;
           R2 = GHC.Event.TimerManager.$fShowState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.460623943 UTC

[section ""cstring" . GHC.Event.TimerManager.$fShowState2_bytes" {
     GHC.Event.TimerManager.$fShowState2_bytes:
         I8[] [70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.464162205 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState1_closure" {
     GHC.Event.TimerManager.$fShowState1_closure:
         const GHC.Event.TimerManager.$fShowState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState1_entry() //  [R1]
         { info_tbl: [(cavkz,
                       label: GHC.Event.TimerManager.$fShowState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavkz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavkA; else goto cavkB;
       cavkA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavkB: // global
           (_cavkw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cavkw::I64 == 0) goto cavky; else goto cavkx;
       cavky: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cavkx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cavkw::I64;
           R2 = GHC.Event.TimerManager.$fShowState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.468363447 UTC

[section ""data" . GHC.Event.TimerManager.$w$cshowsPrec_closure" {
     GHC.Event.TimerManager.$w$cshowsPrec_closure:
         const GHC.Event.TimerManager.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(cavkX,
                       label: GHC.Event.TimerManager.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavkX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavkY; else goto cavkZ;
       cavkY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cavkZ: // global
           I64[Sp - 16] = block_cavkO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uavle; else goto cavkP;
       uavle: // global
           call _cavkO(R1) args: 0, res: 0, upd: 0;
       cavkP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavkO() //  [R1]
         { info_tbl: [(cavkO,
                       label: block_cavkO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavkO: // global
           _sav34::P64 = P64[Sp + 8];
           _cavkW::P64 = R1 & 7;
           if (_cavkW::P64 < 3) goto uavlc; else goto uavld;
       uavlc: // global
           if (_cavkW::P64 < 2) goto cavkS; else goto cavkT;
       cavkS: // global
           R3 = _sav34::P64;
           R2 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cavkT: // global
           R3 = _sav34::P64;
           R2 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uavld: // global
           if (_cavkW::P64 < 4) goto cavkU; else goto cavkV;
       cavkU: // global
           R3 = _sav34::P64;
           R2 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cavkV: // global
           R3 = _sav34::P64;
           R2 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.474835616 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(cavlv,
                       label: GHC.Event.TimerManager.$fShowState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavlv: // global
           _sav37::P64 = R3;
           R3 = R4;
           R2 = _sav37::P64;
           call GHC.Event.TimerManager.$w$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.478822472 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c==_closure" {
     GHC.Event.TimerManager.$fEqState_$c==_closure:
         const GHC.Event.TimerManager.$fEqState_$c==_info;
 },
 GHC.Event.TimerManager.$fEqState_$c==_entry() //  [R2, R3]
         { info_tbl: [(cavlP,
                       label: GHC.Event.TimerManager.$fEqState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavlP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavlQ; else goto cavlR;
       cavlQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cavlR: // global
           I64[Sp - 16] = block_cavlG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uavn8; else goto cavlH;
       uavn8: // global
           call _cavlG(R1) args: 0, res: 0, upd: 0;
       cavlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavlG() //  [R1]
         { info_tbl: [(cavlG,
                       label: block_cavlG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavlG: // global
           _sav3a::P64 = P64[Sp + 8];
           _cavlO::P64 = R1 & 7;
           if (_cavlO::P64 < 3) goto uavmU; else goto uavmV;
       uavmU: // global
           if (_cavlO::P64 < 2) goto cavlK; else goto cavlL;
       cavlK: // global
           I64[Sp + 8] = block_cavlU_info;
           R1 = _sav3a::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavn4; else goto cavlW;
       uavn4: // global
           call _cavlU(R1) args: 0, res: 0, upd: 0;
       cavlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cavlL: // global
           I64[Sp + 8] = block_cavm9_info;
           R1 = _sav3a::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavn5; else goto cavmb;
       uavn5: // global
           call _cavm9(R1) args: 0, res: 0, upd: 0;
       cavmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uavmV: // global
           if (_cavlO::P64 < 4) goto cavlM; else goto cavlN;
       cavlM: // global
           I64[Sp + 8] = block_cavmo_info;
           R1 = _sav3a::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavn6; else goto cavmq;
       uavn6: // global
           call _cavmo(R1) args: 0, res: 0, upd: 0;
       cavmq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cavlN: // global
           I64[Sp + 8] = block_cavmD_info;
           R1 = _sav3a::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavn7; else goto cavmF;
       uavn7: // global
           call _cavmD(R1) args: 0, res: 0, upd: 0;
       cavmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavlU() //  [R1]
         { info_tbl: [(cavlU,
                       label: block_cavlU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavlU: // global
           if (R1 & 7 == 1) goto uavmW; else goto uavmX;
       uavmW: // global
           Sp = Sp + 8;
           call _cavmP() args: 0, res: 0, upd: 0;
       uavmX: // global
           Sp = Sp + 8;
           call _cavmL() args: 0, res: 0, upd: 0;
     }
 },
 _cavm9() //  [R1]
         { info_tbl: [(cavm9,
                       label: block_cavm9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavm9: // global
           if (R1 & 7 == 2) goto uavmY; else goto uavmZ;
       uavmY: // global
           Sp = Sp + 8;
           call _cavmP() args: 0, res: 0, upd: 0;
       uavmZ: // global
           Sp = Sp + 8;
           call _cavmL() args: 0, res: 0, upd: 0;
     }
 },
 _cavmo() //  [R1]
         { info_tbl: [(cavmo,
                       label: block_cavmo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavmo: // global
           if (R1 & 7 == 3) goto uavn0; else goto uavn1;
       uavn0: // global
           Sp = Sp + 8;
           call _cavmP() args: 0, res: 0, upd: 0;
       uavn1: // global
           Sp = Sp + 8;
           call _cavmL() args: 0, res: 0, upd: 0;
     }
 },
 _cavmD() //  [R1]
         { info_tbl: [(cavmD,
                       label: block_cavmD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavmD: // global
           if (R1 & 7 == 4) goto uavn2; else goto uavn3;
       uavn2: // global
           Sp = Sp + 8;
           call _cavmP() args: 0, res: 0, upd: 0;
       uavn3: // global
           Sp = Sp + 8;
           call _cavmL() args: 0, res: 0, upd: 0;
     }
 },
 _cavmP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavmP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cavmL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavmL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.493006545 UTC

[section ""data" . GHC.Event.TimerManager.$fEqTimeoutKey_closure" {
     GHC.Event.TimerManager.$fEqTimeoutKey_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.eqInt_closure+2;
         const GHC.Classes.neInt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.495421779 UTC

[section ""data" . GHC.Event.TimerManager.emControl_closure" {
     GHC.Event.TimerManager.emControl_closure:
         const GHC.Event.TimerManager.emControl_info;
 },
 GHC.Event.TimerManager.emControl_entry() //  [R2]
         { info_tbl: [(cavoa,
                       label: GHC.Event.TimerManager.emControl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavoa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavoe; else goto cavof;
       cavoe: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emControl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavof: // global
           I64[Sp - 8] = block_cavo7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavoj; else goto cavo8;
       uavoj: // global
           call _cavo7(R1) args: 0, res: 0, upd: 0;
       cavo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavo7() //  [R1]
         { info_tbl: [(cavo7,
                       label: block_cavo7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavo7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cavoi; else goto cavoh;
       cavoi: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavoh: // global
           _sav3p::P64 = P64[R1 + 39];
           _sav3q::P64 = P64[R1 + 47];
           _sav3m::I64 = I64[R1 + 55];
           _sav3n::I64 = I64[R1 + 63];
           _sav3o::I64 = I64[R1 + 71];
           I64[Hp - 40] = GHC.Event.Control.W_con_info;
           P64[Hp - 32] = _sav3p::P64;
           P64[Hp - 24] = _sav3q::P64;
           I64[Hp - 16] = _sav3m::I64;
           I64[Hp - 8] = _sav3n::I64;
           I64[Hp] = _sav3o::I64;
           R1 = Hp - 39;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.501880232 UTC

[section ""data" . GHC.Event.TimerManager.emUniqueSource_closure" {
     GHC.Event.TimerManager.emUniqueSource_closure:
         const GHC.Event.TimerManager.emUniqueSource_info;
 },
 GHC.Event.TimerManager.emUniqueSource_entry() //  [R2]
         { info_tbl: [(cavoD,
                       label: GHC.Event.TimerManager.emUniqueSource_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavoD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavoH; else goto cavoI;
       cavoH: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emUniqueSource_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavoI: // global
           I64[Sp - 8] = block_cavoA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavoM; else goto cavoB;
       uavoM: // global
           call _cavoA(R1) args: 0, res: 0, upd: 0;
       cavoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavoA() //  [R1]
         { info_tbl: [(cavoA,
                       label: block_cavoA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavoA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cavoL; else goto cavoK;
       cavoL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavoK: // global
           _sav3w::P64 = P64[R1 + 31];
           I64[Hp - 8] = GHC.Event.Unique.US_con_info;
           P64[Hp] = _sav3w::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.507844132 UTC

[section ""data" . GHC.Event.TimerManager.emState_closure" {
     GHC.Event.TimerManager.emState_closure:
         const GHC.Event.TimerManager.emState_info;
 },
 GHC.Event.TimerManager.emState_entry() //  [R2]
         { info_tbl: [(cavp6,
                       label: GHC.Event.TimerManager.emState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavp6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavpa; else goto cavpb;
       cavpa: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavpb: // global
           I64[Sp - 8] = block_cavp3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavpf; else goto cavp4;
       uavpf: // global
           call _cavp3(R1) args: 0, res: 0, upd: 0;
       cavp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavp3() //  [R1]
         { info_tbl: [(cavp3,
                       label: block_cavp3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavp3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cavpe; else goto cavpd;
       cavpe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavpd: // global
           _sav3G::P64 = P64[R1 + 23];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sav3G::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.51348744 UTC

[section ""data" . GHC.Event.TimerManager.emTimeouts_closure" {
     GHC.Event.TimerManager.emTimeouts_closure:
         const GHC.Event.TimerManager.emTimeouts_info;
 },
 GHC.Event.TimerManager.emTimeouts_entry() //  [R2]
         { info_tbl: [(cavpz,
                       label: GHC.Event.TimerManager.emTimeouts_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavpz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavpD; else goto cavpE;
       cavpD: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emTimeouts_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavpE: // global
           I64[Sp - 8] = block_cavpw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavpI; else goto cavpx;
       uavpI: // global
           call _cavpw(R1) args: 0, res: 0, upd: 0;
       cavpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavpw() //  [R1]
         { info_tbl: [(cavpw,
                       label: block_cavpw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavpw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cavpH; else goto cavpG;
       cavpH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavpG: // global
           _sav3Q::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sav3Q::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.519287582 UTC

[section ""data" . GHC.Event.TimerManager.emBackend_closure" {
     GHC.Event.TimerManager.emBackend_closure:
         const GHC.Event.TimerManager.emBackend_info;
 },
 GHC.Event.TimerManager.emBackend_entry() //  [R2]
         { info_tbl: [(cavq2,
                       label: GHC.Event.TimerManager.emBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavq2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavq3; else goto cavq4;
       cavq3: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.emBackend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavq4: // global
           I64[Sp - 8] = block_cavpZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavq8; else goto cavq0;
       uavq8: // global
           call _cavpZ(R1) args: 0, res: 0, upd: 0;
       cavq0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavpZ() //  [R1]
         { info_tbl: [(cavpZ,
                       label: block_cavpZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavpZ: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.524418197 UTC

[section ""data" . GHC.Event.TimerManager.newDefaultBackend_closure" {
     GHC.Event.TimerManager.newDefaultBackend_closure:
         const GHC.Event.TimerManager.newDefaultBackend_info;
         const 0;
 },
 GHC.Event.TimerManager.newDefaultBackend_entry() //  []
         { info_tbl: [(cavqp,
                       label: GHC.Event.TimerManager.newDefaultBackend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavqp: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.527770462 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager1_closure" {
     GHC.Event.TimerManager.wakeManager1_closure:
         const GHC.Event.TimerManager.wakeManager1_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager1_entry() //  [R2]
         { info_tbl: [(cavqD,
                       label: GHC.Event.TimerManager.wakeManager1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavqD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavqE; else goto cavqF;
       cavqE: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.wakeManager1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavqF: // global
           I64[Sp - 8] = block_cavqA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavqJ; else goto cavqB;
       uavqJ: // global
           call _cavqA(R1) args: 0, res: 0, upd: 0;
       cavqB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavqA() //  [R1]
         { info_tbl: [(cavqA,
                       label: block_cavqA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavqA: // global
           R3 = P64[R1 + 47];
           R2 = I64[R1 + 71];
           Sp = Sp + 8;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.534104161 UTC

[section ""data" . GHC.Event.TimerManager.wakeManager_closure" {
     GHC.Event.TimerManager.wakeManager_closure:
         const GHC.Event.TimerManager.wakeManager_info;
         const 0;
 },
 GHC.Event.TimerManager.wakeManager_entry() //  [R2]
         { info_tbl: [(cavqY,
                       label: GHC.Event.TimerManager.wakeManager_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavqY: // global
           R2 = R2;
           call GHC.Event.TimerManager.wakeManager1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.537335352 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule4_bytes" {
     GHC.Event.TimerManager.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.538901421 UTC

[section ""data" . GHC.Event.TimerManager.$trModule3_closure" {
     GHC.Event.TimerManager.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.540566938 UTC

[section ""cstring" . GHC.Event.TimerManager.$trModule2_bytes" {
     GHC.Event.TimerManager.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.542288852 UTC

[section ""data" . GHC.Event.TimerManager.$trModule1_closure" {
     GHC.Event.TimerManager.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.543937041 UTC

[section ""data" . GHC.Event.TimerManager.$trModule_closure" {
     GHC.Event.TimerManager.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.TimerManager.$trModule3_closure+1;
         const GHC.Event.TimerManager.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.546055386 UTC

[section ""data" . $krep_rasDC_closure" {
     $krep_rasDC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUnique_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.547774078 UTC

[section ""data" . $krep1_rasDD_closure" {
     $krep1_rasDD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Control.$tcControl_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.549510983 UTC

[section ""data" . $krep2_rasDE_closure" {
     $krep2_rasDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Unique.$tcUniqueSource_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.551296701 UTC

[section ""data" . $krep3_rasDF_closure" {
     $krep3_rasDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.55299422 UTC

[section ""data" . $krep4_rasDG_closure" {
     $krep4_rasDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Internal.$tcBackend_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.55470817 UTC

[section ""data" . $krep5_rasDH_closure" {
     $krep5_rasDH_closure:
         const :_con_info;
         const $krep3_rasDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.556423754 UTC

[section ""data" . $krep6_rasDI_closure" {
     $krep6_rasDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcIO_closure;
         const $krep5_rasDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.558719863 UTC

[section ""data" . $krep7_rasDJ_closure" {
     $krep7_rasDJ_closure:
         const :_con_info;
         const $krep6_rasDI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.560920042 UTC

[section ""data" . $krep8_rasDK_closure" {
     $krep8_rasDK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.PSQ.$tcIntPSQ_closure;
         const $krep7_rasDJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.562640406 UTC

[section ""data" . $krep9_rasDL_closure" {
     $krep9_rasDL_closure:
         const :_con_info;
         const $krep8_rasDK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.564274127 UTC

[section ""data" . $krep10_rasDM_closure" {
     $krep10_rasDM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep9_rasDL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.565959571 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimeoutKey2_bytes" {
     GHC.Event.TimerManager.$tcTimeoutKey2_bytes:
         I8[] [84,105,109,101,111,117,116,75,101,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.567558173 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey1_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.56972646 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimeoutKey_closure" {
     GHC.Event.TimerManager.$tcTimeoutKey_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimeoutKey1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11465769786694886755;
         const 8841886228133799087;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.571514423 UTC

[section ""data" . $krep11_rasDN_closure" {
     $krep11_rasDN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimeoutKey_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.573130474 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK1_closure" {
     GHC.Event.TimerManager.$tc'TK1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rasDC_closure+1;
         const $krep11_rasDN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.574871431 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TK3_bytes" {
     GHC.Event.TimerManager.$tc'TK3_bytes:
         I8[] [39,84,75]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.576589431 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK2_closure" {
     GHC.Event.TimerManager.$tc'TK2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TK3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.578314161 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TK_closure" {
     GHC.Event.TimerManager.$tc'TK_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TK2_closure+1;
         const GHC.Event.TimerManager.$tc'TK1_closure+4;
         const 4362213157428095811;
         const 13641506162182658721;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.580106831 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcState2_bytes" {
     GHC.Event.TimerManager.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.582212744 UTC

[section ""data" . GHC.Event.TimerManager.$tcState1_closure" {
     GHC.Event.TimerManager.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.583926425 UTC

[section ""data" . GHC.Event.TimerManager.$tcState_closure" {
     GHC.Event.TimerManager.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10067362680685980057;
         const 6560547589611231606;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.586213052 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created1_closure" {
     GHC.Event.TimerManager.$tc'Created1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.58786842 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Created3_bytes" {
     GHC.Event.TimerManager.$tc'Created3_bytes:
         I8[] [39,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.589479038 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created2_closure" {
     GHC.Event.TimerManager.$tc'Created2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Created3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.59107061 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Created_closure" {
     GHC.Event.TimerManager.$tc'Created_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Created2_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 7473777249114724674;
         const 2904627795268885228;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.592887687 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Running2_bytes" {
     GHC.Event.TimerManager.$tc'Running2_bytes:
         I8[] [39,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.595013546 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running1_closure" {
     GHC.Event.TimerManager.$tc'Running1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Running2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.596687418 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Running_closure" {
     GHC.Event.TimerManager.$tc'Running_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Running1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 15425377252641674582;
         const 12404533232809671740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.598516326 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Dying2_bytes" {
     GHC.Event.TimerManager.$tc'Dying2_bytes:
         I8[] [39,68,121,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.600123932 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying1_closure" {
     GHC.Event.TimerManager.$tc'Dying1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Dying2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.601793602 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Dying_closure" {
     GHC.Event.TimerManager.$tc'Dying_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Dying1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 13405772281963838681;
         const 437803396301020926;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.603573312 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'Finished2_bytes" {
     GHC.Event.TimerManager.$tc'Finished2_bytes:
         I8[] [39,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.605157821 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished1_closure" {
     GHC.Event.TimerManager.$tc'Finished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'Finished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.606886377 UTC

[section ""data" . GHC.Event.TimerManager.$tc'Finished_closure" {
     GHC.Event.TimerManager.$tc'Finished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'Finished1_closure+1;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const 1288208730452846229;
         const 15347214930365004647;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.608663686 UTC

[section ""data" . $krep12_rasDO_closure" {
     $krep12_rasDO_closure:
         const :_con_info;
         const GHC.Event.TimerManager.$tc'Created1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.611329954 UTC

[section ""data" . $krep13_rasDP_closure" {
     $krep13_rasDP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep12_rasDO_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.613050448 UTC

[section ""cstring" . GHC.Event.TimerManager.$tcTimerManager2_bytes" {
     GHC.Event.TimerManager.$tcTimerManager2_bytes:
         I8[] [84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.614716409 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager1_closure" {
     GHC.Event.TimerManager.$tcTimerManager1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tcTimerManager2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.616415214 UTC

[section ""data" . GHC.Event.TimerManager.$tcTimerManager_closure" {
     GHC.Event.TimerManager.$tcTimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tcTimerManager1_closure+1;
         const GHC.Types.krep$*_closure;
         const 3987042711794726631;
         const 6993782799294290901;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.618239155 UTC

[section ""data" . $krep14_rasDQ_closure" {
     $krep14_rasDQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.TimerManager.$tcTimerManager_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.619939875 UTC

[section ""data" . $krep15_rasDR_closure" {
     $krep15_rasDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rasDD_closure+1;
         const $krep14_rasDQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.622320008 UTC

[section ""data" . $krep16_rasDS_closure" {
     $krep16_rasDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rasDE_closure+1;
         const $krep15_rasDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.62404094 UTC

[section ""data" . $krep17_rasDT_closure" {
     $krep17_rasDT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_rasDP_closure+1;
         const $krep16_rasDS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.625735788 UTC

[section ""data" . $krep18_rasDU_closure" {
     $krep18_rasDU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rasDM_closure+1;
         const $krep17_rasDT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.627438514 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager1_closure" {
     GHC.Event.TimerManager.$tc'TimerManager1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rasDG_closure+1;
         const $krep18_rasDU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.62917486 UTC

[section ""cstring" . GHC.Event.TimerManager.$tc'TimerManager3_bytes" {
     GHC.Event.TimerManager.$tc'TimerManager3_bytes:
         I8[] [39,84,105,109,101,114,77,97,110,97,103,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.63082503 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager2_closure" {
     GHC.Event.TimerManager.$tc'TimerManager2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.TimerManager.$tc'TimerManager3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.632566941 UTC

[section ""data" . GHC.Event.TimerManager.$tc'TimerManager_closure" {
     GHC.Event.TimerManager.$tc'TimerManager_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.TimerManager.$trModule_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager2_closure+1;
         const GHC.Event.TimerManager.$tc'TimerManager1_closure+4;
         const 451007785877958328;
         const 8145550165147362681;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.635272701 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshow_closure" {
     GHC.Event.TimerManager.$fShowState_$cshow_closure:
         const GHC.Event.TimerManager.$fShowState_$cshow_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshow_entry() //  [R2]
         { info_tbl: [(cavsa,
                       label: GHC.Event.TimerManager.$fShowState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavsa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavsb; else goto cavsc;
       cavsb: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fShowState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavsc: // global
           I64[Sp - 8] = block_cavs1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavsr; else goto cavs2;
       uavsr: // global
           call _cavs1(R1) args: 0, res: 0, upd: 0;
       cavs2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavs1() //  [R1]
         { info_tbl: [(cavs1,
                       label: block_cavs1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavs1: // global
           _cavs9::P64 = R1 & 7;
           if (_cavs9::P64 < 3) goto uavsp; else goto uavsq;
       uavsp: // global
           if (_cavs9::P64 < 2) goto cavs5; else goto cavs6;
       cavs5: // global
           R1 = GHC.Event.TimerManager.$fShowState7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cavs6: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       uavsq: // global
           if (_cavs9::P64 < 4) goto cavs7; else goto cavs8;
       cavs7: // global
           R1 = GHC.Event.TimerManager.$fShowState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cavs8: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.641874704 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_$cshowList_closure" {
     GHC.Event.TimerManager.$fShowState_$cshowList_closure:
         const GHC.Event.TimerManager.$fShowState_$cshowList_info;
         const 0;
 },
 GHC.Event.TimerManager.$fShowState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cavsL,
                       label: GHC.Event.TimerManager.$fShowState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavsL: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.TimerManager.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.645227684 UTC

[section ""data" . GHC.Event.TimerManager.$fShowState_closure" {
     GHC.Event.TimerManager.$fShowState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.TimerManager.$fShowState_$cshowsPrec_closure+3;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure+1;
         const GHC.Event.TimerManager.$fShowState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.647766066 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_$c/=_closure" {
     GHC.Event.TimerManager.$fEqState_$c/=_closure:
         const GHC.Event.TimerManager.$fEqState_$c/=_info;
 },
 GHC.Event.TimerManager.$fEqState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cavt6,
                       label: GHC.Event.TimerManager.$fEqState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavt6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavt7; else goto cavt8;
       cavt7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.$fEqState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cavt8: // global
           I64[Sp - 16] = block_cavsX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uavup; else goto cavsY;
       uavup: // global
           call _cavsX(R1) args: 0, res: 0, upd: 0;
       cavsY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavsX() //  [R1]
         { info_tbl: [(cavsX,
                       label: block_cavsX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavsX: // global
           _sav4q::P64 = P64[Sp + 8];
           _cavt5::P64 = R1 & 7;
           if (_cavt5::P64 < 3) goto uavub; else goto uavuc;
       uavub: // global
           if (_cavt5::P64 < 2) goto cavt1; else goto cavt2;
       cavt1: // global
           I64[Sp + 8] = block_cavtb_info;
           R1 = _sav4q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavul; else goto cavtd;
       uavul: // global
           call _cavtb(R1) args: 0, res: 0, upd: 0;
       cavtd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cavt2: // global
           I64[Sp + 8] = block_cavtq_info;
           R1 = _sav4q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavum; else goto cavts;
       uavum: // global
           call _cavtq(R1) args: 0, res: 0, upd: 0;
       cavts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uavuc: // global
           if (_cavt5::P64 < 4) goto cavt3; else goto cavt4;
       cavt3: // global
           I64[Sp + 8] = block_cavtF_info;
           R1 = _sav4q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavun; else goto cavtH;
       uavun: // global
           call _cavtF(R1) args: 0, res: 0, upd: 0;
       cavtH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cavt4: // global
           I64[Sp + 8] = block_cavtU_info;
           R1 = _sav4q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavuo; else goto cavtW;
       uavuo: // global
           call _cavtU(R1) args: 0, res: 0, upd: 0;
       cavtW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavtb() //  [R1]
         { info_tbl: [(cavtb,
                       label: block_cavtb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavtb: // global
           if (R1 & 7 == 1) goto uavud; else goto uavue;
       uavud: // global
           Sp = Sp + 8;
           call _cavu6() args: 0, res: 0, upd: 0;
       uavue: // global
           Sp = Sp + 8;
           call _cavu2() args: 0, res: 0, upd: 0;
     }
 },
 _cavtq() //  [R1]
         { info_tbl: [(cavtq,
                       label: block_cavtq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavtq: // global
           if (R1 & 7 == 2) goto uavuf; else goto uavug;
       uavuf: // global
           Sp = Sp + 8;
           call _cavu6() args: 0, res: 0, upd: 0;
       uavug: // global
           Sp = Sp + 8;
           call _cavu2() args: 0, res: 0, upd: 0;
     }
 },
 _cavtF() //  [R1]
         { info_tbl: [(cavtF,
                       label: block_cavtF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavtF: // global
           if (R1 & 7 == 3) goto uavuh; else goto uavui;
       uavuh: // global
           Sp = Sp + 8;
           call _cavu6() args: 0, res: 0, upd: 0;
       uavui: // global
           Sp = Sp + 8;
           call _cavu2() args: 0, res: 0, upd: 0;
     }
 },
 _cavtU() //  [R1]
         { info_tbl: [(cavtU,
                       label: block_cavtU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavtU: // global
           if (R1 & 7 == 4) goto uavuj; else goto uavuk;
       uavuj: // global
           Sp = Sp + 8;
           call _cavu6() args: 0, res: 0, upd: 0;
       uavuk: // global
           Sp = Sp + 8;
           call _cavu2() args: 0, res: 0, upd: 0;
     }
 },
 _cavu6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavu6: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cavu2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavu2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.662948225 UTC

[section ""data" . GHC.Event.TimerManager.$fEqState_closure" {
     GHC.Event.TimerManager.$fEqState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Event.TimerManager.$fEqState_$c==_closure+2;
         const GHC.Event.TimerManager.$fEqState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.666373625 UTC

[section ""data" . GHC.Event.TimerManager.$weditTimeouts_closure" {
     GHC.Event.TimerManager.$weditTimeouts_closure:
         const GHC.Event.TimerManager.$weditTimeouts_info;
         const 0;
 },
 GHC.Event.TimerManager.$weditTimeouts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavvl: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sav5d_entry() //  [R1]
         { info_tbl: [(cavvK,
                       label: sat_sav5d_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavvK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavvL; else goto cavvM;
       cavvL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavvM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cavvC_info;
           _sav4E::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sav4E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavwH; else goto cavvD;
       uavwH: // global
           call _cavvC(R1) args: 0, res: 0, upd: 0;
       cavvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavvC() //  [R1]
         { info_tbl: [(cavvC,
                       label: block_cavvC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavvC: // global
           _cavvJ::P64 = R1 & 7;
           if (_cavvJ::P64 < 3) goto uavwy; else goto uavwB;
       uavwy: // global
           _sav4E::P64 = P64[Sp + 8];
           if (_cavvJ::P64 < 2) goto cavvG; else goto cavvH;
       cavvG: // global
           I64[Sp] = block_cavvP_info;
           _sav4H::I64 = I64[R1 + 39];
           R1 = _sav4E::P64;
           I64[Sp + 8] = _sav4H::I64;
           if (R1 & 7 != 0) goto uavwE; else goto cavvR;
       uavwE: // global
           call _cavvP(R1) args: 0, res: 0, upd: 0;
       cavvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cavvH: // global
           I64[Sp] = block_cavw8_info;
           _sav4Z::I64 = I64[R1 + 22];
           R1 = _sav4E::P64;
           I64[Sp + 8] = _sav4Z::I64;
           if (R1 & 7 != 0) goto uavwF; else goto cavwa;
       uavwF: // global
           call _cavw8(R1) args: 0, res: 0, upd: 0;
       cavwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uavwB: // global
           Sp = Sp + 16;
           call _cavvI() args: 0, res: 0, upd: 0;
     }
 },
 _cavvP() //  [R1]
         { info_tbl: [(cavvP,
                       label: block_cavvP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavvP: // global
           _cavwv::P64 = R1 & 7;
           if (_cavwv::P64 < 3) goto uavwz; else goto uavwC;
       uavwz: // global
           _sav4H::I64 = I64[Sp + 8];
           if (_cavwv::P64 < 2) goto cavvX; else goto cavw1;
       cavvX: // global
           R1 = I64[((_sav4H::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavw1: // global
           R1 = I64[((_sav4H::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavwC: // global
           Sp = Sp + 16;
           call _cavvI() args: 0, res: 0, upd: 0;
     }
 },
 _cavw8() //  [R1]
         { info_tbl: [(cavw8,
                       label: block_cavw8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavw8: // global
           _cavws::P64 = R1 & 7;
           if (_cavws::P64 < 3) goto uavwA; else goto uavwD;
       uavwA: // global
           _sav4Z::I64 = I64[Sp + 8];
           if (_cavws::P64 < 2) goto cavwg; else goto cavwk;
       cavwg: // global
           R1 = I64[((_sav4Z::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavwk: // global
           R1 = I64[((_sav4Z::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavwD: // global
           Sp = Sp + 16;
           call _cavvI() args: 0, res: 0, upd: 0;
     }
 },
 _cavvI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavvI: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sav5e_entry() //  [R1, R2]
         { info_tbl: [(cavwK,
                       label: sat_sav5e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavwK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavwM; else goto cavwN;
       cavwM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavwN: // global
           I64[Sp - 16] = block_cavvu_info;
           _sav4D::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sav4D::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavvu() //  [R1]
         { info_tbl: [(cavvu,
                       label: block_cavvu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavvu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavwQ; else goto cavwP;
       cavwQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavwP: // global
           I64[Hp - 48] = sat_sav5d_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$weditTimeouts_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cavx0,
                       label: GHC.Event.TimerManager.$weditTimeouts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavx0: // global
           _sav4A::P64 = R6;
           _sav4z::I64 = R5;
           _sav4y::P64 = R4;
           _sav4x::P64 = R3;
           _sav4w::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cavx1; else goto cavx2;
       cavx2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cavx4; else goto cavx3;
       cavx4: // global
           HpAlloc = 16;
           goto cavx1;
       cavx1: // global
           R1 = GHC.Event.TimerManager.$weditTimeouts_closure;
           P64[Sp - 40] = _sav4w::P64;
           P64[Sp - 32] = _sav4x::P64;
           P64[Sp - 24] = _sav4y::P64;
           I64[Sp - 16] = _sav4z::I64;
           P64[Sp - 8] = _sav4A::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cavx3: // global
           I64[Hp - 8] = sat_sav5e_info;
           P64[Hp] = P64[Sp];
           I64[Sp - 16] = block_cavwR_info;
           R2 = Hp - 7;
           R1 = _sav4w::P64;
           P64[Sp - 8] = _sav4A::P64;
           I64[Sp] = _sav4z::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavwR() //  [R1]
         { info_tbl: [(cavwR,
                       label: block_cavwR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavwR: // global
           I64[Sp] = block_cavwT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavxc; else goto cavwU;
       uavxc: // global
           call _cavwT(R1) args: 0, res: 0, upd: 0;
       cavwU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavwT() //  [R1]
         { info_tbl: [(cavwT,
                       label: block_cavwT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavwT: // global
           if (R1 & 7 == 1) goto cavwX; else goto cavwY;
       cavwX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavwY: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.68932565 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout2_closure" {
     GHC.Event.TimerManager.unregisterTimeout2_closure:
         const GHC.Event.TimerManager.unregisterTimeout2_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout2_entry() //  [R2, R3]
         { info_tbl: [(cavyA,
                       label: GHC.Event.TimerManager.unregisterTimeout2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavyA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavyB; else goto cavyC;
       cavyB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cavyC: // global
           I64[Sp - 16] = block_cavyx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uavyG; else goto cavyy;
       uavyG: // global
           call _cavyx(R1) args: 0, res: 0, upd: 0;
       cavyy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavyx() //  [R1]
         { info_tbl: [(cavyx,
                       label: block_cavyx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavyx: // global
           R6 = P64[R1 + 47];
           R5 = I64[R1 + 71];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.Event.TimerManager.$weditTimeouts_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.696439079 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout1_closure" {
     GHC.Event.TimerManager.unregisterTimeout1_closure:
         const GHC.Event.TimerManager.unregisterTimeout1_info;
         const 0;
 },
 sat_sav6j_entry() //  [R1]
         { info_tbl: [(cavzl,
                       label: sat_sav6j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavzl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavzm; else goto cavzn;
       cavzm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavzn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cavzd_info;
           _sav5K::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sav5K::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavAi; else goto cavze;
       uavAi: // global
           call _cavzd(R1) args: 0, res: 0, upd: 0;
       cavze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavzd() //  [R1]
         { info_tbl: [(cavzd,
                       label: block_cavzd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavzd: // global
           _cavzk::P64 = R1 & 7;
           if (_cavzk::P64 < 3) goto uavA9; else goto uavAc;
       uavA9: // global
           _sav5K::P64 = P64[Sp + 8];
           if (_cavzk::P64 < 2) goto cavzh; else goto cavzi;
       cavzh: // global
           I64[Sp] = block_cavzq_info;
           _sav5N::I64 = I64[R1 + 39];
           R1 = _sav5K::P64;
           I64[Sp + 8] = _sav5N::I64;
           if (R1 & 7 != 0) goto uavAf; else goto cavzs;
       uavAf: // global
           call _cavzq(R1) args: 0, res: 0, upd: 0;
       cavzs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cavzi: // global
           I64[Sp] = block_cavzJ_info;
           _sav65::I64 = I64[R1 + 22];
           R1 = _sav5K::P64;
           I64[Sp + 8] = _sav65::I64;
           if (R1 & 7 != 0) goto uavAg; else goto cavzL;
       uavAg: // global
           call _cavzJ(R1) args: 0, res: 0, upd: 0;
       cavzL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uavAc: // global
           Sp = Sp + 16;
           call _cavzj() args: 0, res: 0, upd: 0;
     }
 },
 _cavzq() //  [R1]
         { info_tbl: [(cavzq,
                       label: block_cavzq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavzq: // global
           _cavA6::P64 = R1 & 7;
           if (_cavA6::P64 < 3) goto uavAa; else goto uavAd;
       uavAa: // global
           _sav5N::I64 = I64[Sp + 8];
           if (_cavA6::P64 < 2) goto cavzy; else goto cavzC;
       cavzy: // global
           R1 = I64[((_sav5N::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavzC: // global
           R1 = I64[((_sav5N::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavAd: // global
           Sp = Sp + 16;
           call _cavzj() args: 0, res: 0, upd: 0;
     }
 },
 _cavzJ() //  [R1]
         { info_tbl: [(cavzJ,
                       label: block_cavzJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavzJ: // global
           _cavA3::P64 = R1 & 7;
           if (_cavA3::P64 < 3) goto uavAb; else goto uavAe;
       uavAb: // global
           _sav65::I64 = I64[Sp + 8];
           if (_cavA3::P64 < 2) goto cavzR; else goto cavzV;
       cavzR: // global
           R1 = I64[((_sav65::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavzV: // global
           R1 = I64[((_sav65::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavAe: // global
           Sp = Sp + 16;
           call _cavzj() args: 0, res: 0, upd: 0;
     }
 },
 _cavzj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavzj: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sav6k_entry() //  [R1, R2]
         { info_tbl: [(cavAl,
                       label: sat_sav6k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavAl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavAn; else goto cavAo;
       cavAn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavAo: // global
           I64[Sp - 16] = block_cavz5_info;
           R3 = R2;
           _sav5J::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sav5J::P64;
           Sp = Sp - 16;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavz5() //  [R1]
         { info_tbl: [(cavz5,
                       label: block_cavz5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavz5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavAr; else goto cavAq;
       cavAr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavAq: // global
           I64[Hp - 48] = sat_sav6j_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.unregisterTimeout1_entry() //  [R2, R3]
         { info_tbl: [(cavAs,
                       label: GHC.Event.TimerManager.unregisterTimeout1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavAs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavAt; else goto cavAu;
       cavAt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.unregisterTimeout1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cavAu: // global
           I64[Sp - 16] = block_cavyV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uavAO; else goto cavyW;
       uavAO: // global
           call _cavyV(R1) args: 0, res: 0, upd: 0;
       cavyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavyV() //  [R1]
         { info_tbl: [(cavyV,
                       label: block_cavyV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavyV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cavAA; else goto cavAz;
       cavAA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavAz: // global
           _sav5B::P64 = P64[R1 + 15];
           _sav5I::P64 = P64[R1 + 47];
           _sav5G::I64 = I64[R1 + 71];
           I64[Hp - 8] = sat_sav6k_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cavAv_info;
           R2 = Hp - 7;
           R1 = _sav5B::P64;
           P64[Sp] = _sav5I::P64;
           I64[Sp + 8] = _sav5G::I64;
           Sp = Sp - 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavAv() //  [R1]
         { info_tbl: [(cavAv,
                       label: block_cavAv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavAv: // global
           I64[Sp] = block_cavAx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavAP; else goto cavAC;
       uavAP: // global
           call _cavAx(R1) args: 0, res: 0, upd: 0;
       cavAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavAx() //  [R1]
         { info_tbl: [(cavAx,
                       label: block_cavAx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavAx: // global
           if (R1 & 7 == 1) goto cavAI; else goto cavAM;
       cavAI: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavAM: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.720395976 UTC

[section ""data" . GHC.Event.TimerManager.unregisterTimeout_closure" {
     GHC.Event.TimerManager.unregisterTimeout_closure:
         const GHC.Event.TimerManager.unregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.unregisterTimeout_entry() //  [R2, R3]
         { info_tbl: [(cavCd,
                       label: GHC.Event.TimerManager.unregisterTimeout_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavCd: // global
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.unregisterTimeout1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.726254048 UTC

[section ""data" . GHC.Event.TimerManager.$wregisterTimeout_closure" {
     GHC.Event.TimerManager.$wregisterTimeout_closure:
         const GHC.Event.TimerManager.$wregisterTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.$wregisterTimeout_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavCl: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2,
                                                               R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sav7k_entry() //  [R1]
         { info_tbl: [(cavD4,
                       label: sat_sav7k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavD4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavD5; else goto cavD6;
       cavD5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavD6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cavCW_info;
           _sav6L::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sav6L::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavE1; else goto cavCX;
       uavE1: // global
           call _cavCW(R1) args: 0, res: 0, upd: 0;
       cavCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavCW() //  [R1]
         { info_tbl: [(cavCW,
                       label: block_cavCW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavCW: // global
           _cavD3::P64 = R1 & 7;
           if (_cavD3::P64 < 3) goto uavDS; else goto uavDV;
       uavDS: // global
           _sav6L::P64 = P64[Sp + 8];
           if (_cavD3::P64 < 2) goto cavD0; else goto cavD1;
       cavD0: // global
           I64[Sp] = block_cavD9_info;
           _sav6O::I64 = I64[R1 + 39];
           R1 = _sav6L::P64;
           I64[Sp + 8] = _sav6O::I64;
           if (R1 & 7 != 0) goto uavDY; else goto cavDb;
       uavDY: // global
           call _cavD9(R1) args: 0, res: 0, upd: 0;
       cavDb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cavD1: // global
           I64[Sp] = block_cavDs_info;
           _sav76::I64 = I64[R1 + 22];
           R1 = _sav6L::P64;
           I64[Sp + 8] = _sav76::I64;
           if (R1 & 7 != 0) goto uavDZ; else goto cavDu;
       uavDZ: // global
           call _cavDs(R1) args: 0, res: 0, upd: 0;
       cavDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uavDV: // global
           Sp = Sp + 16;
           call _cavD2() args: 0, res: 0, upd: 0;
     }
 },
 _cavD9() //  [R1]
         { info_tbl: [(cavD9,
                       label: block_cavD9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavD9: // global
           _cavDP::P64 = R1 & 7;
           if (_cavDP::P64 < 3) goto uavDT; else goto uavDW;
       uavDT: // global
           _sav6O::I64 = I64[Sp + 8];
           if (_cavDP::P64 < 2) goto cavDh; else goto cavDl;
       cavDh: // global
           R1 = I64[((_sav6O::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavDl: // global
           R1 = I64[((_sav6O::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavDW: // global
           Sp = Sp + 16;
           call _cavD2() args: 0, res: 0, upd: 0;
     }
 },
 _cavDs() //  [R1]
         { info_tbl: [(cavDs,
                       label: block_cavDs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavDs: // global
           _cavDM::P64 = R1 & 7;
           if (_cavDM::P64 < 3) goto uavDU; else goto uavDX;
       uavDU: // global
           _sav76::I64 = I64[Sp + 8];
           if (_cavDM::P64 < 2) goto cavDA; else goto cavDE;
       cavDA: // global
           R1 = I64[((_sav76::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavDE: // global
           R1 = I64[((_sav76::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavDX: // global
           Sp = Sp + 16;
           call _cavD2() args: 0, res: 0, upd: 0;
     }
 },
 _cavD2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavD2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sav7l_entry() //  [R1, R2]
         { info_tbl: [(cavE4,
                       label: sat_sav7l_info
                       rep:HeapRep 2 ptrs 2 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavE4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cavE6; else goto cavE7;
       cavE6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavE7: // global
           I64[Sp - 40] = block_cavCK_info;
           R3 = R2;
           _sav6J::P64 = R2;
           R2 = P64[R1 + 15];
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 23];
           I64[Sp - 16] = I64[R1 + 31];
           P64[Sp - 8] = _sav6J::P64;
           Sp = Sp - 40;
           call GHC.Event.PSQ.delete_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavCK() //  [R1]
         { info_tbl: [(cavCK,
                       label: block_cavCK_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavCK: // global
           _sav6G::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cavCO_info;
           R5 = R1;
           R4 = P64[Sp + 8];
           R3 = _sav6G::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavCO() //  [R1]
         { info_tbl: [(cavCO,
                       label: block_cavCO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavCO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavEb; else goto cavEa;
       cavEb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavEa: // global
           I64[Hp - 48] = sat_sav7k_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wregisterTimeout_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cavEf,
                       label: GHC.Event.TimerManager.$wregisterTimeout_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavEf: // global
           _sav6t::P64 = R6;
           _sav6s::I64 = R5;
           _sav6r::P64 = R4;
           _sav6q::P64 = R3;
           _sav6p::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cavEg; else goto cavEh;
       cavEh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavEj; else goto cavEi;
       cavEj: // global
           HpAlloc = 56;
           goto cavEg;
       cavEg: // global
           R1 = GHC.Event.TimerManager.$wregisterTimeout_closure;
           P64[Sp - 40] = _sav6p::P64;
           P64[Sp - 32] = _sav6q::P64;
           P64[Sp - 24] = _sav6r::P64;
           I64[Sp - 16] = _sav6s::I64;
           P64[Sp - 8] = _sav6t::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cavEi: // global
           _sav6u::I64 = I64[Sp];
           _sav6v::P64 = P64[Sp + 8];
           (_sav6z::I64) = call MO_AtomicRMW W64 AMO_Add(_sav6r::P64 + 16, 1);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sav6z::I64;
           _cavCr::P64 = Hp - 47;
           if (%MO_S_Gt_W64(_sav6u::I64, 0)) goto cavEd; else goto cavEe;
       cavEd: // global
           (_sav6F::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 32] = sat_sav7l_info;
           P64[Hp - 24] = _sav6v::P64;
           P64[Hp - 16] = _cavCr::P64;
           I64[Hp - 8] = _sav6z::I64;
           I64[Hp] = _sav6u::I64 * 1000 + _sav6F::I64;
           I64[Sp - 16] = block_cavEk_info;
           R2 = Hp - 31;
           R1 = _sav6p::P64;
           P64[Sp - 8] = _sav6t::P64;
           I64[Sp] = _sav6s::I64;
           P64[Sp + 8] = _cavCr::P64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
       cavEe: // global
           Hp = Hp - 40;
           I64[Sp] = block_cavFt_info;
           R1 = _sav6v::P64;
           P64[Sp + 8] = _cavCr::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavEk() //  [R1]
         { info_tbl: [(cavEk,
                       label: block_cavEk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavEk: // global
           I64[Sp] = block_cavEm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavFB; else goto cavEo;
       uavFB: // global
           call _cavEm(R1) args: 0, res: 0, upd: 0;
       cavEo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavEm() //  [R1]
         { info_tbl: [(cavEm,
                       label: block_cavEm_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavEm: // global
           if (R1 & 7 == 1) goto uavFy; else goto cavFr;
       uavFy: // global
           Sp = Sp + 24;
           goto uavFE;
       cavFr: // global
           _sav6t::P64 = P64[Sp + 8];
           (_sav7u::I64) = call "ccall" arg hints:  [‘signed’,]  result hints:  [‘signed’] eventfd_write(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])), 1);
           if (%MO_SS_Conv_W64_W32(_sav7u::I64) == 0 :: W32) goto uavFz; else goto cavEN;
       uavFz: // global
           Sp = Sp + 24;
           goto uavFE;
       uavFE: // global
           call _cavFn() args: 0, res: 0, upd: 0;
       cavEN: // global
           (_sav7z::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp + 8] = block_cavEL_info;
           R1 = P64[_sav6t::P64 + 8];
           I64[Sp + 16] = _sav7z::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavFC; else goto cavEP;
       uavFC: // global
           call _cavEL(R1) args: 0, res: 0, upd: 0;
       cavEP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavEL() //  [R1]
         { info_tbl: [(cavEL,
                       label: block_cavEL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavEL: // global
           if (R1 & 7 == 1) goto cavEW; else goto cavFk;
       cavEW: // global
           I64[Sp + 8] = block_cavET_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
       cavFk: // global
           if (%MO_SS_Conv_W64_W32(I64[Sp + 8]) == 9 :: W32) goto uavFA; else goto cavFa;
       uavFA: // global
           Sp = Sp + 16;
           call _cavFn() args: 0, res: 0, upd: 0;
       cavFa: // global
           I64[Sp + 8] = block_cavF8_info;
           R2 = GHC.Event.Control.sendWakeup2_closure;
           Sp = Sp + 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavET() //  []
         { info_tbl: [(cavET,
                       label: block_cavET_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavET: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cavFn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavFn: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cavF8() //  []
         { info_tbl: [(cavF8,
                       label: block_cavF8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavF8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cavFt() //  []
         { info_tbl: [(cavFt,
                       label: block_cavFt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavFt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.759533694 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout1_closure" {
     GHC.Event.TimerManager.registerTimeout1_closure:
         const GHC.Event.TimerManager.registerTimeout1_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(cavHD,
                       label: GHC.Event.TimerManager.registerTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavHD: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cavHH; else goto cavHI;
       cavHH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.registerTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cavHI: // global
           I64[Sp - 24] = block_cavHA_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uavHQ; else goto cavHB;
       uavHQ: // global
           call _cavHA(R1) args: 0, res: 0, upd: 0;
       cavHB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavHA() //  [R1]
         { info_tbl: [(cavHA,
                       label: block_cavHA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavHA: // global
           I64[Sp - 32] = block_cavHG_info;
           _sav7U::P64 = P64[R1 + 15];
           _sav7V::P64 = P64[R1 + 23];
           _sav7W::P64 = P64[R1 + 31];
           _sav81::P64 = P64[R1 + 47];
           _sav7Z::I64 = I64[R1 + 71];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sav7W::P64;
           I64[Sp - 16] = _sav7Z::I64;
           P64[Sp - 8] = _sav81::P64;
           P64[Sp] = _sav7V::P64;
           P64[Sp + 8] = _sav7U::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavHP; else goto cavHK;
       uavHP: // global
           call _cavHG(R1) args: 0, res: 0, upd: 0;
       cavHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavHG() //  [R1]
         { info_tbl: [(cavHG,
                       label: block_cavHG_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavHG: // global
           R6 = P64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wregisterTimeout_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.768044058 UTC

[section ""data" . GHC.Event.TimerManager.registerTimeout_closure" {
     GHC.Event.TimerManager.registerTimeout_closure:
         const GHC.Event.TimerManager.registerTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.registerTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(cavIb,
                       label: GHC.Event.TimerManager.registerTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavIb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.registerTimeout1_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.774068404 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout1_closure" {
     GHC.Event.TimerManager.updateTimeout1_closure:
         const GHC.Event.TimerManager.updateTimeout1_info;
         const 0;
 },
 x_sav8m_entry() //  [R1]
         { info_tbl: [(cavIz,
                       label: x_sav8m_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavIz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavIM; else goto cavIN;
       cavIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavIN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cavIw_info;
           _sav8b::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sav8b::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavIR; else goto cavIx;
       uavIR: // global
           call _cavIw(R1) args: 0, res: 0, upd: 0;
       cavIx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavIw() //  [R1]
         { info_tbl: [(cavIw,
                       label: block_cavIw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavIw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cavIQ; else goto cavIP;
       cavIQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cavIP: // global
           _sav8r::I64 = I64[R1 + 7] * 1000 + I64[Sp + 8];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sav8r::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sav8w_entry() //  [R1]
         { info_tbl: [(cavJh,
                       label: sat_sav8w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavJi; else goto cavJj;
       cavJi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavJj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cavJa_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uavJq; else goto cavJb;
       uavJq: // global
           call _cavJa(R1) args: 0, res: 0, upd: 0;
       cavJb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavJa() //  [R1]
         { info_tbl: [(cavJa,
                       label: block_cavJa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJa: // global
           if (R1 & 7 == 3) goto cavJf; else goto cavJe;
       cavJf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavJe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sav9f_entry() //  [R1]
         { info_tbl: [(cavJY,
                       label: sat_sav9f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavJZ; else goto cavK0;
       cavJZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavK0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cavJQ_info;
           _sav8G::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sav8G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavKV; else goto cavJR;
       uavKV: // global
           call _cavJQ(R1) args: 0, res: 0, upd: 0;
       cavJR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavJQ() //  [R1]
         { info_tbl: [(cavJQ,
                       label: block_cavJQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJQ: // global
           _cavJX::P64 = R1 & 7;
           if (_cavJX::P64 < 3) goto uavKM; else goto uavKP;
       uavKM: // global
           _sav8G::P64 = P64[Sp + 8];
           if (_cavJX::P64 < 2) goto cavJU; else goto cavJV;
       cavJU: // global
           I64[Sp] = block_cavK3_info;
           _sav8J::I64 = I64[R1 + 39];
           R1 = _sav8G::P64;
           I64[Sp + 8] = _sav8J::I64;
           if (R1 & 7 != 0) goto uavKS; else goto cavK5;
       uavKS: // global
           call _cavK3(R1) args: 0, res: 0, upd: 0;
       cavK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cavJV: // global
           I64[Sp] = block_cavKm_info;
           _sav91::I64 = I64[R1 + 22];
           R1 = _sav8G::P64;
           I64[Sp + 8] = _sav91::I64;
           if (R1 & 7 != 0) goto uavKT; else goto cavKo;
       uavKT: // global
           call _cavKm(R1) args: 0, res: 0, upd: 0;
       cavKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uavKP: // global
           Sp = Sp + 16;
           call _cavJW() args: 0, res: 0, upd: 0;
     }
 },
 _cavK3() //  [R1]
         { info_tbl: [(cavK3,
                       label: block_cavK3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavK3: // global
           _cavKJ::P64 = R1 & 7;
           if (_cavKJ::P64 < 3) goto uavKN; else goto uavKQ;
       uavKN: // global
           _sav8J::I64 = I64[Sp + 8];
           if (_cavKJ::P64 < 2) goto cavKb; else goto cavKf;
       cavKb: // global
           R1 = I64[((_sav8J::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavKf: // global
           R1 = I64[((_sav8J::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavKQ: // global
           Sp = Sp + 16;
           call _cavJW() args: 0, res: 0, upd: 0;
     }
 },
 _cavKm() //  [R1]
         { info_tbl: [(cavKm,
                       label: block_cavKm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavKm: // global
           _cavKG::P64 = R1 & 7;
           if (_cavKG::P64 < 3) goto uavKO; else goto uavKR;
       uavKO: // global
           _sav91::I64 = I64[Sp + 8];
           if (_cavKG::P64 < 2) goto cavKu; else goto cavKy;
       cavKu: // global
           R1 = I64[((_sav91::I64 != I64[R1 + 39]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavKy: // global
           R1 = I64[((_sav91::I64 != I64[R1 + 22]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uavKR: // global
           Sp = Sp + 16;
           call _cavJW() args: 0, res: 0, upd: 0;
     }
 },
 _cavJW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJW: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sav9g_entry() //  [R1, R2]
         { info_tbl: [(cavL2,
                       label: sat_sav9g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavL2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cavL3; else goto cavL4;
       cavL3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavL4: // global
           I64[Sp - 32] = block_cavIX_info;
           R3 = R2;
           _sav8s::P64 = R2;
           _sav85::P64 = P64[R1 + 7];
           R2 = _sav85::P64;
           P64[Sp - 24] = _sav85::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sav8s::P64;
           Sp = Sp - 32;
           call GHC.Event.PSQ.deleteView_entry(R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavIX() //  [R1]
         { info_tbl: [(cavIX,
                       label: block_cavIX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavIX: // global
           if (R1 & 7 == 1) goto cavKZ; else goto cavL0;
       cavKZ: // global
           _sav8s::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cavJ1_info;
           R1 = _sav8s::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uavLi; else goto cavJ2;
       uavLi: // global
           call _cavJ1(R1) args: 0, res: 0, upd: 0;
       cavJ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cavL0: // global
           I64[Sp] = block_cavJt_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uavLj; else goto cavJu;
       uavLj: // global
           call _cavJt(R1) args: 0, res: 0, upd: 0;
       cavJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavJ1() //  [R1]
         { info_tbl: [(cavJ1,
                       label: block_cavJ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJ1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cavL9; else goto cavL8;
       cavL9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavL8: // global
           I64[Hp - 40] = sat_sav8w_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cavJt() //  [R1]
         { info_tbl: [(cavJt,
                       label: block_cavJt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJt: // global
           I64[Sp - 8] = block_cavJy_info;
           _sav8A::P64 = P64[R1 + 15];
           _sav8B::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp] = _sav8B::P64;
           P64[Sp + 8] = _sav8A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavLk; else goto cavJz;
       uavLk: // global
           call _cavJy(R1) args: 0, res: 0, upd: 0;
       cavJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavJy() //  [R1]
         { info_tbl: [(cavJy,
                       label: block_cavJy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJy: // global
           I64[Sp] = block_cavJD_info;
           _sav8D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sav8D::I64;
           if (R1 & 7 != 0) goto uavLl; else goto cavJE;
       uavLl: // global
           call _cavJD(R1) args: 0, res: 0, upd: 0;
       cavJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavJD() //  [R1]
         { info_tbl: [(cavJD,
                       label: block_cavJD_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJD: // global
           _sav8D::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cavJI_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = _sav8D::I64;
           Sp = Sp + 24;
           call GHC.Event.PSQ.$wunsafeInsertNew_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavJI() //  [R1]
         { info_tbl: [(cavJI,
                       label: block_cavJI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavJI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavLh; else goto cavLg;
       cavLh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavLg: // global
           I64[Hp - 48] = sat_sav9f_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.updateTimeout1_entry() //  [R2, R3, R4]
         { info_tbl: [(cavLm,
                       label: GHC.Event.TimerManager.updateTimeout1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavLm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavLn; else goto cavLo;
       cavLn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.TimerManager.updateTimeout1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cavLo: // global
           _sav86::P64 = R4;
           _sav85::P64 = R3;
           (_sav8b::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 32] = block_cavIn_info;
           R1 = R2;
           P64[Sp - 24] = _sav85::P64;
           P64[Sp - 16] = _sav86::P64;
           I64[Sp - 8] = _sav8b::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavLI; else goto cavIo;
       uavLI: // global
           call _cavIn(R1) args: 0, res: 0, upd: 0;
       cavIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavIn() //  [R1]
         { info_tbl: [(cavIn,
                       label: block_cavIn_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavIn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavLu; else goto cavLt;
       cavLu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavLt: // global
           _sav8e::P64 = P64[R1 + 15];
           _sav8l::P64 = P64[R1 + 47];
           _sav8j::I64 = I64[R1 + 71];
           I64[Hp - 48] = x_sav8m_info;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = sat_sav9g_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           I64[Sp + 8] = block_cavLp_info;
           R2 = Hp - 15;
           R1 = _sav8e::P64;
           P64[Sp + 16] = _sav8l::P64;
           I64[Sp + 24] = _sav8j::I64;
           Sp = Sp + 8;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavLp() //  [R1]
         { info_tbl: [(cavLp,
                       label: block_cavLp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavLp: // global
           I64[Sp] = block_cavLr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavLJ; else goto cavLw;
       uavLJ: // global
           call _cavLr(R1) args: 0, res: 0, upd: 0;
       cavLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavLr() //  [R1]
         { info_tbl: [(cavLr,
                       label: block_cavLr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavLr: // global
           if (R1 & 7 == 1) goto cavLC; else goto cavLG;
       cavLC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavLG: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendWakeup_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.814728243 UTC

[section ""data" . GHC.Event.TimerManager.updateTimeout_closure" {
     GHC.Event.TimerManager.updateTimeout_closure:
         const GHC.Event.TimerManager.updateTimeout_info;
         const 0;
 },
 GHC.Event.TimerManager.updateTimeout_entry() //  [R2, R3, R4]
         { info_tbl: [(cavOa,
                       label: GHC.Event.TimerManager.updateTimeout_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Event.TimerManager.updateTimeout1_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.818807369 UTC

[section ""data" . GHC.Event.TimerManager.cleanup1_closure" {
     GHC.Event.TimerManager.cleanup1_closure:
         const GHC.Event.TimerManager.cleanup1_info;
 },
 GHC.Event.TimerManager.cleanup1_entry() //  [R2]
         { info_tbl: [(cavOo,
                       label: GHC.Event.TimerManager.cleanup1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOo: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cavOs; else goto cavOt;
       cavOs: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.cleanup1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavOt: // global
           I64[Sp - 8] = block_cavOl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavPj; else goto cavOm;
       uavPj: // global
           call _cavOl(R1) args: 0, res: 0, upd: 0;
       cavOm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavOl() //  [R1]
         { info_tbl: [(cavOl,
                       label: block_cavOl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOl: // global
           I64[Sp - 48] = block_cavOr_info;
           _sav9q::P64 = P64[R1 + 23];
           _sav9v::P64 = P64[R1 + 39];
           _sav9w::P64 = P64[R1 + 47];
           _sav9s::I64 = I64[R1 + 55];
           _sav9t::I64 = I64[R1 + 63];
           _sav9u::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           I64[Sp - 40] = _sav9s::I64;
           I64[Sp - 32] = _sav9t::I64;
           I64[Sp - 24] = _sav9u::I64;
           P64[Sp - 16] = _sav9v::P64;
           P64[Sp - 8] = _sav9w::P64;
           P64[Sp] = _sav9q::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uavPi; else goto cavOv;
       uavPi: // global
           call _cavOr(R1) args: 0, res: 0, upd: 0;
       cavOv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavOr() //  [R1]
         { info_tbl: [(cavOr,
                       label: block_cavOr_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOr: // global
           _sav9q::P64 = P64[Sp + 48];
           _sav9y::P64 = P64[R1 + 7];
           _sav9C::P64 = P64[R1 + 39];
           call MO_WriteBarrier();
           P64[_sav9q::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sav9q::P64);
           I64[Sp] = block_cavOC_info;
           R2 = _sav9y::P64;
           R1 = _sav9C::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavOC() //  []
         { info_tbl: [(cavOC,
                       label: block_cavOC_info
                       rep:StackRep [True, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOC: // global
           I64[Sp] = block_cavOE_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavOE() //  []
         { info_tbl: [(cavOE,
                       label: block_cavOE_info
                       rep:StackRep [True, True, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOE: // global
           _sav9t::I64 = I64[Sp + 16];
           _sav9v::P64 = P64[Sp + 32];
           (_sav9O::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_sav9T::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sav9t::I64)));
           I64[Sp + 16] = block_cavOT_info;
           R1 = _sav9v::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uavPk; else goto cavOU;
       uavPk: // global
           call _cavOT(R1) args: 0, res: 0, upd: 0;
       cavOU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavOT() //  [R1]
         { info_tbl: [(cavOT,
                       label: block_cavOT_info
                       rep:StackRep [True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavOT: // global
           _sav9u::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cavP0; else goto cavP4;
       cavP0: // global
           (_sav9Z::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sav9u::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavP4: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_sava7::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sav9u::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.832535898 UTC

[section ""data" . GHC.Event.TimerManager.cleanup_closure" {
     GHC.Event.TimerManager.cleanup_closure:
         const GHC.Event.TimerManager.cleanup_info;
 },
 GHC.Event.TimerManager.cleanup_entry() //  [R2]
         { info_tbl: [(cavQ1,
                       label: GHC.Event.TimerManager.cleanup_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavQ1: // global
           R2 = R2;
           call GHC.Event.TimerManager.cleanup1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.836140578 UTC

[section ""data" . GHC.Event.TimerManager.finished1_closure" {
     GHC.Event.TimerManager.finished1_closure:
         const GHC.Event.TimerManager.finished1_info;
 },
 sat_savao_entry() //  [R1]
         { info_tbl: [(cavQs,
                       label: sat_savao_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavQs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavQt; else goto cavQu;
       cavQt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cavQl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uavQB; else goto cavQm;
       uavQB: // global
           call _cavQl(R1) args: 0, res: 0, upd: 0;
       cavQm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavQl() //  [R1]
         { info_tbl: [(cavQl,
                       label: block_cavQl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavQl: // global
           if (R1 & 7 == 4) goto cavQq; else goto cavQp;
       cavQq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavQp: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.finished1_entry() //  [R2]
         { info_tbl: [(cavQC,
                       label: GHC.Event.TimerManager.finished1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavQC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavQD; else goto cavQE;
       cavQD: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.finished1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavQE: // global
           I64[Sp - 8] = block_cavQc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavQI; else goto cavQd;
       uavQI: // global
           call _cavQc(R1) args: 0, res: 0, upd: 0;
       cavQd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavQc() //  [R1]
         { info_tbl: [(cavQc,
                       label: block_cavQc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavQc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cavQH; else goto cavQG;
       cavQH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavQG: // global
           _savam::P64 = P64[P64[R1 + 23] + 8];
           I64[Hp - 16] = sat_savao_info;
           P64[Hp] = _savam::P64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.846568175 UTC

[section ""data" . GHC.Event.TimerManager.finished_closure" {
     GHC.Event.TimerManager.finished_closure:
         const GHC.Event.TimerManager.finished_info;
 },
 GHC.Event.TimerManager.finished_entry() //  [R2]
         { info_tbl: [(cavRg,
                       label: GHC.Event.TimerManager.finished_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavRg: // global
           R2 = R2;
           call GHC.Event.TimerManager.finished1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.849846754 UTC

[section ""data" . GHC.Event.TimerManager.shutdown2_closure" {
     GHC.Event.TimerManager.shutdown2_closure:
         const GHC.Event.TimerManager.shutdown2_info;
 },
 GHC.Event.TimerManager.shutdown2_entry() //  [R2]
         { info_tbl: [(cavRs,
                       label: GHC.Event.TimerManager.shutdown2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavRs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cavRw; else goto cavRv;
       cavRw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavRv: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Dying_closure+3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.853844069 UTC

[section ""data" . GHC.Event.TimerManager.shutdown1_closure" {
     GHC.Event.TimerManager.shutdown1_closure:
         const GHC.Event.TimerManager.shutdown1_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown1_entry() //  [R2]
         { info_tbl: [(cavRL,
                       label: GHC.Event.TimerManager.shutdown1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavRL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavRM; else goto cavRN;
       cavRM: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.shutdown1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavRN: // global
           I64[Sp - 8] = block_cavRI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavS7; else goto cavRJ;
       uavS7: // global
           call _cavRI(R1) args: 0, res: 0, upd: 0;
       cavRJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavRI() //  [R1]
         { info_tbl: [(cavRI,
                       label: block_cavRI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavRI: // global
           I64[Sp - 16] = block_cavRQ_info;
           R2 = GHC.Event.TimerManager.shutdown2_closure+1;
           _savaB::P64 = P64[R1 + 47];
           _savay::I64 = I64[R1 + 63];
           R1 = P64[R1 + 23];
           P64[Sp - 8] = _savaB::P64;
           I64[Sp] = _savay::I64;
           Sp = Sp - 16;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavRQ() //  [R1]
         { info_tbl: [(cavRQ,
                       label: block_cavRQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavRQ: // global
           I64[Sp] = block_cavRS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavS8; else goto cavRV;
       uavS8: // global
           call _cavRS(R1) args: 0, res: 0, upd: 0;
       cavRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavRS() //  [R1]
         { info_tbl: [(cavRS,
                       label: block_cavRS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavRS: // global
           if (R1 & 7 == 2) goto cavS5; else goto cavS1;
       cavS5: // global
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Event.Control.$wsendDie_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cavS1: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.862767387 UTC

[section ""data" . GHC.Event.TimerManager.shutdown_closure" {
     GHC.Event.TimerManager.shutdown_closure:
         const GHC.Event.TimerManager.shutdown_info;
         const 0;
 },
 GHC.Event.TimerManager.shutdown_entry() //  [R2]
         { info_tbl: [(cavSA,
                       label: GHC.Event.TimerManager.shutdown_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavSA: // global
           R2 = R2;
           call GHC.Event.TimerManager.shutdown1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.866067264 UTC

[section ""data" . GHC.Event.TimerManager.new3_closure" {
     GHC.Event.TimerManager.new3_closure:
         const GHC.Event.TimerManager.new3_info;
 },
 GHC.Event.TimerManager.new3_entry() //  [R2]
         { info_tbl: [(cavSM,
                       label: GHC.Event.TimerManager.new3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavSM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cavSQ; else goto cavSP;
       cavSQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.TimerManager.new3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavSP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Event.TimerManager.Finished_closure+4;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.871538649 UTC

[section ""data" . GHC.Event.TimerManager.new2_closure" {
     GHC.Event.TimerManager.new2_closure:
         const GHC.Event.TimerManager.new2_info;
         const 0;
 },
 sat_savba_entry() //  [R1]
         { info_tbl: [(cavTm,
                       label: sat_savba_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavTn; else goto cavTo;
       cavTn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cavTo: // global
           I64[Sp - 24] = block_cavTd_info;
           R2 = GHC.Event.TimerManager.new3_closure+1;
           _savaH::P64 = P64[R1 + 7];
           _savaO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _savaH::P64;
           P64[Sp - 8] = _savaO::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavTd() //  [R1]
         { info_tbl: [(cavTd,
                       label: block_cavTd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTd: // global
           I64[Sp] = block_cavTf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavTF; else goto cavTg;
       uavTF: // global
           call _cavTf(R1) args: 0, res: 0, upd: 0;
       cavTg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavTf() //  [R1]
         { info_tbl: [(cavTf,
                       label: block_cavTf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTf: // global
           if (R1 & 7 == 4) goto cavTk; else goto cavTj;
       cavTk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavTj: // global
           _savaH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cavTs_info;
           R1 = _savaH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uavTG; else goto cavTt;
       uavTG: // global
           call _cavTs(R1) args: 0, res: 0, upd: 0;
       cavTt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavTs() //  [R1]
         { info_tbl: [(cavTs,
                       label: block_cavTs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTs: // global
           I64[Sp] = block_cavTx_info;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavTx() //  []
         { info_tbl: [(cavTx,
                       label: block_cavTx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTx: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Event.Control.closeControl1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_savbk_entry() //  [R1]
         { info_tbl: [(cavTT,
                       label: sat_savbk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavTU; else goto cavTV;
       cavTU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavTV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlReadFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_savbo_entry() //  [R1]
         { info_tbl: [(cavU2,
                       label: sat_savbo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavU2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cavU3; else goto cavU4;
       cavU3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavU4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Event.Control.controlEventFd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_savby_entry() //  [R1]
         { info_tbl: [(cavUe,
                       label: sat_savby_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavUe: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cavUi; else goto cavUj;
       cavUi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavUj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cavUb_info;
           _savaL::P64 = P64[R1 + 16];
           _savaR::P64 = P64[R1 + 32];
           _savaU::P64 = P64[R1 + 40];
           _savbe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _savaL::P64;
           P64[Sp - 40] = _savaR::P64;
           P64[Sp - 32] = _savaU::P64;
           P64[Sp - 24] = _savbe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uavUn; else goto cavUc;
       uavUn: // global
           call _cavUb(R1) args: 0, res: 0, upd: 0;
       cavUc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavUb() //  [R1]
         { info_tbl: [(cavUb,
                       label: block_cavUb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavUb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cavUm; else goto cavUl;
       cavUm: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cavUl: // global
           _savbw::P64 = P64[R1 + 7];
           _savbx::P64 = P64[R1 + 15];
           _savbt::I64 = I64[R1 + 23];
           _savbu::I64 = I64[R1 + 31];
           _savbv::I64 = I64[R1 + 39];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _savbw::P64;
           P64[Hp - 24] = _savbx::P64;
           I64[Hp - 16] = _savbt::I64;
           I64[Hp - 8] = _savbu::I64;
           I64[Hp] = _savbv::I64;
           R1 = Hp - 71;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.new2_entry() //  [R2]
         { info_tbl: [(cavUo,
                       label: GHC.Event.TimerManager.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavUo: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cavUp; else goto cavUq;
       cavUp: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.new2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavUq: // global
           I64[Sp - 16] = block_cavT2_info;
           R1 = GHC.Event.PSQ.Nil_closure+3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavT2() //  [R1]
         { info_tbl: [(cavT2,
                       label: block_cavT2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavT2: // global
           I64[Sp - 8] = block_cavT4_info;
           R2 = GHC.Types.True_closure+2;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Event.Control.newControl1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavT4() //  [R1]
         { info_tbl: [(cavT4,
                       label: block_cavT4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavT4: // global
           I64[Sp - 8] = block_cavT6_info;
           _savaO::P64 = R1;
           R1 = GHC.Event.TimerManager.Created_closure+1;
           P64[Sp] = _savaO::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavT6() //  [R1]
         { info_tbl: [(cavT6,
                       label: block_cavT6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavT6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cavUv; else goto cavUu;
       cavUv: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavUu: // global
           I64[Hp - 64] = stg_ARR_WORDS_info;
           I64[Hp - 56] = 8;
           I64[Hp - 40] = sat_savba_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_cavTI_info;
           R3 = Hp - 39;
           R2 = Hp - 7;
           _savaR::P64 = R1;
           R1 = R1;
           P64[Sp - 8] = Hp - 64;
           P64[Sp] = _savaR::P64;
           Sp = Sp - 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavTI() //  []
         { info_tbl: [(cavTI,
                       label: block_cavTI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTI: // global
           I64[Sp] = block_cavTK_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uavUG; else goto cavTL;
       uavUG: // global
           call _cavTK(R1) args: 0, res: 0, upd: 0;
       cavTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavTK() //  [R1]
         { info_tbl: [(cavTK,
                       label: block_cavTK_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cavUz; else goto cavUy;
       cavUz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavUy: // global
           _savbf::P64 = P64[R1 + 7];
           _savbh::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_savbk_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp - 16] = block_cavTW_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _savbf::P64;
           _savbe::P64 = R1;
           R1 = _savbh::P64;
           I64[Sp - 24] = stg_ap_v_info;
           P64[Sp - 8] = _savbh::P64;
           P64[Sp] = _savbf::P64;
           P64[Sp + 40] = _savbe::P64;
           Sp = Sp - 24;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _cavTW() //  [R1]
         { info_tbl: [(cavTW,
                       label: block_cavTW_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavTW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cavUC; else goto cavUB;
       cavUC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavUB: // global
           I64[Hp - 16] = sat_savbo_info;
           P64[Hp] = P64[Sp + 40];
           _savbf::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cavU5_info;
           R5 = GHC.Event.Internal.evtRead_closure;
           R4 = GHC.Event.Internal.evtNothing_closure;
           R3 = Hp - 16;
           R2 = _savbf::P64;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_v_info;
           Sp = Sp + 8;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 16, res: 8, upd: 8;
     }
 },
 _cavU5() //  [R1]
         { info_tbl: [(cavU5,
                       label: block_cavU5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavU5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cavUF; else goto cavUE;
       cavUF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavUE: // global
           I64[Hp - 48] = sat_savby_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 40];
           R1 = Hp - 48;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.906030176 UTC

[section ""data" . GHC.Event.TimerManager.newWith_closure" {
     GHC.Event.TimerManager.newWith_closure:
         const GHC.Event.TimerManager.newWith_info;
         const 0;
 },
 GHC.Event.TimerManager.newWith_entry() //  [R2]
         { info_tbl: [(cavWu,
                       label: GHC.Event.TimerManager.newWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavWu: // global
           R2 = R2;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.90928996 UTC

[section ""data" . GHC.Event.TimerManager.new1_closure" {
     GHC.Event.TimerManager.new1_closure:
         const GHC.Event.TimerManager.new1_info;
         const 0;
 },
 GHC.Event.TimerManager.new1_entry() //  []
         { info_tbl: [(cavWH,
                       label: GHC.Event.TimerManager.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavWH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cavWI; else goto cavWJ;
       cavWI: // global
           R1 = GHC.Event.TimerManager.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cavWJ: // global
           I64[Sp - 8] = block_cavWF_info;
           Sp = Sp - 8;
           call GHC.Event.Poll.new1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _cavWF() //  [R1]
         { info_tbl: [(cavWF,
                       label: block_cavWF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavWF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Event.TimerManager.new2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.914627674 UTC

[section ""data" . GHC.Event.TimerManager.new_closure" {
     GHC.Event.TimerManager.new_closure:
         const GHC.Event.TimerManager.new_info;
         const 0;
 },
 GHC.Event.TimerManager.new_entry() //  []
         { info_tbl: [(cavWY,
                       label: GHC.Event.TimerManager.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavWY: // global
           call GHC.Event.TimerManager.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.921065769 UTC

[section ""data" . GHC.Event.TimerManager.step1_closure" {
     GHC.Event.TimerManager.step1_closure:
         const GHC.Event.TimerManager.step1_info;
         const 0;
 },
 sat_savch_entry() //  [R1]
         { info_tbl: [(cavXJ,
                       label: sat_savch_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavXJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavXK; else goto cavXL;
       cavXK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavXL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cavXB_info;
           _savbI::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _savbI::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavY8; else goto cavXC;
       uavY8: // global
           call _cavXB(R1) args: 0, res: 0, upd: 0;
       cavXC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavXB() //  [R1]
         { info_tbl: [(cavXB,
                       label: block_cavXB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavXB: // global
           _cavXI::P64 = R1 & 7;
           if (_cavXI::P64 < 3) goto uavY7; else goto cavXH;
       uavY7: // global
           _savbI::I64 = I64[Sp + 8];
           if (_cavXI::P64 < 2) goto cavXF; else goto cavXG;
       cavXF: // global
           Hp = Hp + 16;
           _savc5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cavY3; else goto cavXT;
       cavXT: // global
           _savcc::I64 = I64[_savc5::P64 + 39] - _savbI::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _savcc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavXG: // global
           Hp = Hp + 16;
           _savc5::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cavY3; else goto cavY2;
       cavY3: // global
           HpAlloc = 16;
           R1 = _savc5::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cavY2: // global
           _savcg::I64 = I64[_savc5::P64 + 22] - _savbI::I64;
           I64[Hp - 8] = GHC.Event.Internal.Timeout_con_info;
           I64[Hp] = _savcg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavXH: // global
           R1 = GHC.Event.Internal.Forever_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_savcj_entry() //  [R1, R2]
         { info_tbl: [(cavY9,
                       label: sat_savcj_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavY9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavYc; else goto cavYd;
       cavYc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavYd: // global
           I64[Sp - 16] = block_cavXq_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 15];
           Sp = Sp - 16;
           call GHC.Event.PSQ.$watMost_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavXq() //  [R1, R2]
         { info_tbl: [(cavXq,
                       label: block_cavXq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavXq: // global
           I64[Sp - 8] = block_cavXs_info;
           _savc2::P64 = R1;
           R1 = R2;
           P64[Sp] = _savc2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uavYi; else goto cavXt;
       uavYi: // global
           call _cavXs(R1) args: 0, res: 0, upd: 0;
       cavXt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavXs() //  [R1]
         { info_tbl: [(cavXs,
                       label: block_cavXs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavXs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cavYh; else goto cavYg;
       cavYh: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavYg: // global
           I64[Hp - 72] = sat_savch_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = I64[Sp + 16];
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 39;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_savcI_entry() //  [R1, R2, R3]
         { info_tbl: [(cavYD,
                       label: sat_savcI_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cavYE; else goto cavYF;
       cavYE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cavYF: // global
           I64[Sp - 32] = block_cavYA_info;
           _savbM::P64 = P64[R1 + 5];
           _savbS::P64 = P64[R1 + 13];
           _savbQ::I64 = I64[R1 + 21];
           R1 = R2;
           P64[Sp - 24] = _savbM::P64;
           I64[Sp - 16] = _savbQ::I64;
           P64[Sp - 8] = _savbS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uavZb; else goto cavYB;
       uavZb: // global
           call _cavYA(R1) args: 0, res: 0, upd: 0;
       cavYB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavYA() //  [R1]
         { info_tbl: [(cavYA,
                       label: block_cavYA_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYA: // global
           I64[Sp] = block_cavYI_info;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 24];
           R2 = I64[Sp + 16];
           call GHC.Event.Control.$wreadControlMessage_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cavYI() //  [R1]
         { info_tbl: [(cavYI,
                       label: block_cavYI_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYI: // global
           I64[Sp] = block_cavYK_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uavZc; else goto cavYN;
       uavZc: // global
           call _cavYK(R1) args: 0, res: 0, upd: 0;
       cavYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavYK() //  [R1]
         { info_tbl: [(cavYK,
                       label: block_cavYK_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYK: // global
           _cavZ6::P64 = R1 & 7;
           if (_cavZ6::P64 < 3) goto uavZa; else goto cavZ2;
       uavZa: // global
           if (_cavZ6::P64 < 2) goto cavYT; else goto cavYX;
       cavYT: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavYX: // global
           _savbM::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_savbM::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savbM::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cavZ2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cavZ5; else goto cavZ4;
       cavZ5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavZ4: // global
           _savcE::P64 = P64[R1 + 5];
           _savcD::I64 = I64[R1 + 13];
           _savcF::I64 = I64[R1 + 21];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _savcF::I64;
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _savcE::P64;
           I64[Hp] = _savcD::I64;
           R3 = Hp - 31;
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_savcR_entry() //  [R1]
         { info_tbl: [(cavZw,
                       label: sat_savcR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavZw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cavZx; else goto cavZy;
       cavZx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cavZy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cavZp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uavZF; else goto cavZq;
       uavZF: // global
           call _cavZp(R1) args: 0, res: 0, upd: 0;
       cavZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cavZp() //  [R1]
         { info_tbl: [(cavZp,
                       label: block_cavZp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavZp: // global
           if (R1 & 7 == 2) goto cavZu; else goto cavZt;
       cavZu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cavZt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.TimerManager.step1_entry() //  [R2]
         { info_tbl: [(cavZG,
                       label: GHC.Event.TimerManager.step1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavZG: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cavZH; else goto cavZI;
       cavZH: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.step1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cavZI: // global
           (_savbI::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Sp - 16] = block_cavXa_info;
           R1 = R2;
           I64[Sp - 8] = _savbI::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaw0u; else goto cavXb;
       uaw0u: // global
           call _cavXa(R1) args: 0, res: 0, upd: 0;
       cavXb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavXa() //  [R1]
         { info_tbl: [(cavXa,
                       label: block_cavXa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavXa: // global
           I64[Sp - 32] = block_cavXf_info;
           _savbL::P64 = P64[R1 + 15];
           _savbM::P64 = P64[R1 + 23];
           _savbS::P64 = P64[R1 + 47];
           _savbQ::I64 = I64[R1 + 71];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _savbM::P64;
           I64[Sp - 16] = _savbQ::I64;
           P64[Sp - 8] = _savbS::P64;
           P64[Sp] = _savbL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaw0q; else goto cavXg;
       uaw0q: // global
           call _cavXf(R1) args: 0, res: 0, upd: 0;
       cavXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavXf() //  [R1]
         { info_tbl: [(cavXf,
                       label: block_cavXf_info
                       rep:StackRep [False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavXf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cavZM; else goto cavZL;
       cavZM: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavZL: // global
           _savbU::P64 = P64[R1 + 7];
           _savbV::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           _savbI::I64 = I64[Sp + 40];
           I64[Hp - 24] = _savbI::I64;
           I64[Hp - 16] = sat_savcj_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = _savbI::I64;
           I64[Sp] = block_cavYj_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _savbV::P64;
           P64[Sp + 40] = _savbU::P64;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavYj() //  [R1]
         { info_tbl: [(cavYj,
                       label: block_cavYj_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYj: // global
           I64[Sp] = block_cavYl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaw0r; else goto cavYm;
       uaw0r: // global
           call _cavYl(R1) args: 0, res: 0, upd: 0;
       cavYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavYl() //  [R1]
         { info_tbl: [(cavYl,
                       label: block_cavYl_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYl: // global
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call _cavZZ() args: 0, res: 0, upd: 0;
     }
 },
 _cavZZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavZZ: // global
           _savcT::P64 = P64[Sp];
           I64[Sp] = block_caw01_info;
           R1 = _savcT::P64;
           if (R1 & 7 != 0) goto uaw0v; else goto caw03;
       uaw0v: // global
           call _caw01(R1) args: 0, res: 0, upd: 0;
       caw03: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw01() //  [R1]
         { info_tbl: [(caw01,
                       label: block_caw01_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw01: // global
           if (R1 & 7 == 1) goto uaw0w; else goto caw0e;
       uaw0w: // global
           call _cavYt() args: 0, res: 0, upd: 0;
       caw0e: // global
           I64[Sp - 8] = block_caw0c_info;
           _savcX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _savcX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaw0x; else goto caw0f;
       uaw0x: // global
           call _caw0c(R1) args: 0, res: 0, upd: 0;
       caw0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavYt() //  []
         { info_tbl: [(cavYt,
                       label: block_cavYt_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavYt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cavZR; else goto cavZQ;
       cavZR: // global
           HpAlloc = 48;
           I64[Sp] = block_cavYt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cavZQ: // global
           I64[Hp - 40] = sat_savcI_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cavZe_info;
           R4 = Hp - 37;
           R3 = Hp - 6;
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavZe() //  []
         { info_tbl: [(cavZe,
                       label: block_cavZe_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavZe: // global
           _savcO::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 40] = block_cavZg_info;
           R1 = _savcO::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto uaw0t; else goto cavZh;
       uaw0t: // global
           call _cavZg(R1) args: 0, res: 0, upd: 0;
       cavZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cavZg() //  [R1]
         { info_tbl: [(cavZg,
                       label: block_cavZg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavZg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cavZV; else goto cavZU;
       cavZV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cavZU: // global
           I64[Hp - 16] = sat_savcR_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caw0c() //  [R1]
         { info_tbl: [(caw0c,
                       label: block_caw0c_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw0c: // global
           I64[Sp] = block_caw0j_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw0j() //  []
         { info_tbl: [(caw0j,
                       label: block_caw0j_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw0j: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cavZZ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.967348059 UTC

[section ""data" . GHC.Event.TimerManager.step_closure" {
     GHC.Event.TimerManager.step_closure:
         const GHC.Event.TimerManager.step_info;
         const 0;
 },
 GHC.Event.TimerManager.step_entry() //  [R2]
         { info_tbl: [(caw37,
                       label: GHC.Event.TimerManager.step_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw37: // global
           R2 = R2;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.970416986 UTC

[section ""cstring" . lvl_rasDV_bytes" {
     lvl_rasDV_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,77,97,110,97,103,101,114,46,108,111,111,112,58,32,115,116,97,116,101,32,105,115,32,97,108,114,101,97,100,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.972498293 UTC

[section ""data" . lvl1_rasDW_closure" {
     lvl1_rasDW_closure:
         const lvl1_rasDW_info;
         const 0;
 },
 sat_savd7_entry() //  [R1]
         { info_tbl: [(caw3u,
                       label: sat_savd7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw3u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caw3v; else goto caw3w;
       caw3v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caw3w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caw3n_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaw3D; else goto caw3o;
       uaw3D: // global
           call _caw3n(R1) args: 0, res: 0, upd: 0;
       caw3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caw3n() //  [R1]
         { info_tbl: [(caw3n,
                       label: block_caw3n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw3n: // global
           if (R1 & 7 == 4) goto caw3s; else goto caw3r;
       caw3s: // global
           R1 = GHC.Event.TimerManager.$fShowState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caw3r: // global
           R1 = GHC.Event.TimerManager.$fShowState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_rasDW_entry() //  [R2]
         { info_tbl: [(caw3G,
                       label: lvl1_rasDW_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw3G: // global
           _savd5::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caw3H; else goto caw3I;
       caw3I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caw3K; else goto caw3J;
       caw3K: // global
           HpAlloc = 24;
           goto caw3H;
       caw3H: // global
           R2 = _savd5::P64;
           R1 = lvl1_rasDW_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caw3J: // global
           I64[Hp - 16] = sat_savd7_info;
           P64[Hp] = _savd5::P64;
           I64[Sp - 8] = block_caw3E_info;
           R3 = Hp - 16;
           R2 = lvl_rasDV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _caw3E() //  [R1]
         { info_tbl: [(caw3E,
                       label: block_caw3E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw3E: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.98123133 UTC

[section ""data" . lvl2_rasDX_closure" {
     lvl2_rasDX_closure:
         const (,)_con_info;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Created_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.983273287 UTC

[section ""data" . lvl3_rasDY_closure" {
     lvl3_rasDY_closure:
         const lvl3_rasDY_info;
 },
 lvl3_rasDY_entry() //  [R2]
         { info_tbl: [(caw4o,
                       label: lvl3_rasDY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw4o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caw4p; else goto caw4q;
       caw4p: // global
           R2 = R2;
           R1 = lvl3_rasDY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caw4q: // global
           I64[Sp - 8] = block_caw4h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaw4A; else goto caw4i;
       uaw4A: // global
           call _caw4h(R1) args: 0, res: 0, upd: 0;
       caw4i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw4h() //  [R1]
         { info_tbl: [(caw4h,
                       label: block_caw4h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw4h: // global
           if (R1 & 7 == 1) goto caw4m; else goto caw4l;
       caw4m: // global
           R1 = lvl2_rasDX_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caw4l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caw4w; else goto caw4v;
       caw4w: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caw4v: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:30.994587564 UTC

[section ""data" . GHC.Event.TimerManager.$wloop_closure" {
     GHC.Event.TimerManager.$wloop_closure:
         const GHC.Event.TimerManager.$wloop_info;
         const 0;
 },
 GHC.Event.TimerManager.$wloop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw4R: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 40, res: 0, upd: 8;
     }
 },
 go_save5_entry() //  [R1]
         { info_tbl: [(caw5p,
                       label: go_save5_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto uaw5C; else goto uaw5B;
       uaw5C: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _caw5q() args: 0, res: 0, upd: 0;
       uaw5B: // global
           P64[Sp - 8] = R1;
           Sp = Sp - 8;
           call _caw5c() args: 0, res: 0, upd: 0;
     }
 },
 _caw5c() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caw5t; else goto caw5s;
       caw5t: // global
           HpAlloc = 80;
           call _caw5q() args: 0, res: 0, upd: 0;
       caw5s: // global
           _save5::P64 = P64[Sp];
           _savdc::P64 = P64[_save5::P64 + 7];
           _savdd::P64 = P64[_save5::P64 + 15];
           _savde::P64 = P64[_save5::P64 + 23];
           _savdi::P64 = P64[_save5::P64 + 31];
           _savdj::P64 = P64[_save5::P64 + 39];
           _savdl::P64 = P64[_save5::P64 + 47];
           _savdf::I64 = I64[_save5::P64 + 55];
           _savdg::I64 = I64[_save5::P64 + 63];
           _savdh::I64 = I64[_save5::P64 + 71];
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = _savdl::P64;
           P64[Hp - 56] = _savdc::P64;
           P64[Hp - 48] = _savdd::P64;
           P64[Hp - 40] = _savde::P64;
           P64[Hp - 32] = _savdi::P64;
           P64[Hp - 24] = _savdj::P64;
           I64[Hp - 16] = _savdf::I64;
           I64[Hp - 8] = _savdg::I64;
           I64[Hp] = _savdh::I64;
           I64[Sp - 8] = block_caw5g_info;
           R2 = Hp - 71;
           Sp = Sp - 8;
           call GHC.Event.TimerManager.step1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caw5q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5q: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caw5g() //  [R1]
         { info_tbl: [(caw5g,
                       label: block_caw5g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5g: // global
           I64[Sp] = block_caw5i_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaw5F; else goto caw5j;
       uaw5F: // global
           call _caw5i(R1) args: 0, res: 0, upd: 0;
       caw5j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw5i() //  [R1]
         { info_tbl: [(caw5i,
                       label: block_caw5i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5i: // global
           if (R1 & 7 == 1) goto caw5m; else goto uaw5D;
       caw5m: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaw5D: // global
           Sp = Sp + 8;
           call _caw5c() args: 0, res: 0, upd: 0;
     }
 },
 sat_saveL_entry() //  [R1, R2]
         { info_tbl: [(caw5Z,
                       label: sat_saveL_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5Z: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caw60; else goto caw61;
       caw60: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caw61: // global
           _savdd::P64 = P64[R1 + 6];
           _savdi::P64 = P64[R1 + 14];
           _savdj::P64 = P64[R1 + 22];
           _savdm::P64 = P64[R1 + 30];
           _savdq::P64 = P64[R1 + 38];
           _savdf::I64 = I64[R1 + 46];
           _savdg::I64 = I64[R1 + 54];
           _savdh::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp - 56] = block_caw5T_info;
           _savee::P64 = R2;
           R2 = _savdm::P64;
           R1 = _savdq::P64;
           I64[Sp - 48] = _savdf::I64;
           I64[Sp - 40] = _savdg::I64;
           I64[Sp - 32] = _savdh::I64;
           P64[Sp - 24] = _savdi::P64;
           P64[Sp - 16] = _savdj::P64;
           P64[Sp - 8] = _savee::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw5T() //  []
         { info_tbl: [(caw5T,
                       label: block_caw5T_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5T: // global
           I64[Sp] = block_caw5V_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw5V() //  []
         { info_tbl: [(caw5V,
                       label: block_caw5V_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw5V: // global
           _savdg::I64 = I64[Sp + 16];
           _savdi::P64 = P64[Sp + 32];
           (_saver::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_savew::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp + 16] = block_caw6c_info;
           R1 = _savdi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaw6B; else goto caw6d;
       uaw6B: // global
           call _caw6c(R1) args: 0, res: 0, upd: 0;
       caw6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw6c() //  [R1]
         { info_tbl: [(caw6c,
                       label: block_caw6c_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw6c: // global
           _savdh::I64 = I64[Sp + 8];
           _savee::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caw6j; else goto caw6n;
       caw6j: // global
           (_saveC::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savee::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caw6n: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_saveK::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savee::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saved_entry() //  [R1]
         { info_tbl: [(caw6H,
                       label: sat_saved_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw6H: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_savfT_entry() //  [R1, R2]
         { info_tbl: [(caw74,
                       label: sat_savfT_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw74: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caw75; else goto caw76;
       caw75: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caw76: // global
           _savdd::P64 = P64[R1 + 6];
           _savdi::P64 = P64[R1 + 14];
           _savdj::P64 = P64[R1 + 22];
           _savdm::P64 = P64[R1 + 30];
           _savdq::P64 = P64[R1 + 38];
           _savdf::I64 = I64[R1 + 46];
           _savdg::I64 = I64[R1 + 54];
           _savdh::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp - 56] = block_caw6Y_info;
           _savfm::P64 = R2;
           R2 = _savdm::P64;
           R1 = _savdq::P64;
           I64[Sp - 48] = _savdf::I64;
           I64[Sp - 40] = _savdg::I64;
           I64[Sp - 32] = _savdh::I64;
           P64[Sp - 24] = _savdi::P64;
           P64[Sp - 16] = _savdj::P64;
           P64[Sp - 8] = _savfm::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw6Y() //  []
         { info_tbl: [(caw6Y,
                       label: block_caw6Y_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw6Y: // global
           I64[Sp] = block_caw70_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw70() //  []
         { info_tbl: [(caw70,
                       label: block_caw70_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw70: // global
           _savdg::I64 = I64[Sp + 16];
           _savdi::P64 = P64[Sp + 32];
           (_savfz::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_savfE::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp + 16] = block_caw7h_info;
           R1 = _savdi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaw7G; else goto caw7i;
       uaw7G: // global
           call _caw7h(R1) args: 0, res: 0, upd: 0;
       caw7i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw7h() //  [R1]
         { info_tbl: [(caw7h,
                       label: block_caw7h_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw7h: // global
           _savdh::I64 = I64[Sp + 8];
           _savfm::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caw7o; else goto caw7s;
       caw7o: // global
           (_savfK::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savfm::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caw7s: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_savfS::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savfm::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_savfl_entry() //  [R1]
         { info_tbl: [(caw7M,
                       label: sat_savfl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw7M: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_savgs_entry() //  [R1]
         { info_tbl: [(caw80,
                       label: sat_savgs_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw80: // global
           _savgs::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto caw81; else goto caw82;
       caw82: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto caw84; else goto caw83;
       caw84: // global
           HpAlloc = 88;
           goto caw81;
       caw81: // global
           R1 = _savgs::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caw83: // global
           _savdd::P64 = P64[_savgs::P64 + 7];
           _savdi::P64 = P64[_savgs::P64 + 15];
           _savdj::P64 = P64[_savgs::P64 + 23];
           _savdm::P64 = P64[_savgs::P64 + 31];
           _savdq::P64 = P64[_savgs::P64 + 39];
           _save5::P64 = P64[_savgs::P64 + 47];
           _savdf::I64 = I64[_savgs::P64 + 55];
           _savdg::I64 = I64[_savgs::P64 + 63];
           _savdh::I64 = I64[_savgs::P64 + 71];
           I64[Hp - 80] = sat_savfT_info;
           P64[Hp - 72] = _savdd::P64;
           P64[Hp - 64] = _savdi::P64;
           P64[Hp - 56] = _savdj::P64;
           P64[Hp - 48] = _savdm::P64;
           P64[Hp - 40] = _savdq::P64;
           I64[Hp - 32] = _savdf::I64;
           I64[Hp - 24] = _savdg::I64;
           I64[Hp - 16] = _savdh::I64;
           I64[Hp - 8] = sat_savfl_info;
           P64[Hp] = _save5::P64;
           I64[Sp - 72] = block_caw7P_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           P64[Sp - 64] = _savdd::P64;
           I64[Sp - 56] = _savdf::I64;
           I64[Sp - 48] = _savdg::I64;
           I64[Sp - 40] = _savdh::I64;
           P64[Sp - 32] = _savdi::P64;
           P64[Sp - 24] = _savdj::P64;
           P64[Sp - 16] = _savdm::P64;
           P64[Sp - 8] = _savdq::P64;
           Sp = Sp - 72;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw7P() //  [R1]
         { info_tbl: [(caw7P,
                       label: block_caw7P_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw7P: // global
           _savdd::P64 = P64[Sp + 8];
           _savdm::P64 = P64[Sp + 56];
           _savdq::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp + 8] = block_caw7U_info;
           R2 = _savdm::P64;
           _savfW::P64 = R1;
           R1 = _savdq::P64;
           P64[Sp + 64] = _savfW::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw7U() //  []
         { info_tbl: [(caw7U,
                       label: block_caw7U_info
                       rep:StackRep [True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw7U: // global
           I64[Sp] = block_caw7W_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw7W() //  []
         { info_tbl: [(caw7W,
                       label: block_caw7W_info
                       rep:StackRep [True, True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw7W: // global
           _savdg::I64 = I64[Sp + 16];
           _savdi::P64 = P64[Sp + 32];
           (_savg8::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_savgd::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp + 16] = block_caw8g_info;
           R1 = _savdi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaw8F; else goto caw8h;
       uaw8F: // global
           call _caw8g(R1) args: 0, res: 0, upd: 0;
       caw8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw8g() //  [R1]
         { info_tbl: [(caw8g,
                       label: block_caw8g_info
                       rep:StackRep [True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw8g: // global
           _savdh::I64 = I64[Sp + 8];
           _savfW::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caw8n; else goto caw8r;
       caw8n: // global
           (_savgj::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savfW::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caw8r: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_savgr::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savfW::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_savh1_entry() //  [R1, R2]
         { info_tbl: [(caw8V,
                       label: sat_savh1_info
                       rep:HeapRep 5 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw8V: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caw8W; else goto caw8X;
       caw8W: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caw8X: // global
           _savdd::P64 = P64[R1 + 6];
           _savdi::P64 = P64[R1 + 14];
           _savdj::P64 = P64[R1 + 22];
           _savdm::P64 = P64[R1 + 30];
           _savdq::P64 = P64[R1 + 38];
           _savdf::I64 = I64[R1 + 46];
           _savdg::I64 = I64[R1 + 54];
           _savdh::I64 = I64[R1 + 62];
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp - 56] = block_caw8P_info;
           _savgu::P64 = R2;
           R2 = _savdm::P64;
           R1 = _savdq::P64;
           I64[Sp - 48] = _savdf::I64;
           I64[Sp - 40] = _savdg::I64;
           I64[Sp - 32] = _savdh::I64;
           P64[Sp - 24] = _savdi::P64;
           P64[Sp - 16] = _savdj::P64;
           P64[Sp - 8] = _savgu::P64;
           Sp = Sp - 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw8P() //  []
         { info_tbl: [(caw8P,
                       label: block_caw8P_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw8P: // global
           I64[Sp] = block_caw8R_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw8R() //  []
         { info_tbl: [(caw8R,
                       label: block_caw8R_info
                       rep:StackRep [True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw8R: // global
           _savdg::I64 = I64[Sp + 16];
           _savdi::P64 = P64[Sp + 32];
           (_savgH::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_savgM::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp + 16] = block_caw98_info;
           R1 = _savdi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaw9x; else goto caw99;
       uaw9x: // global
           call _caw98(R1) args: 0, res: 0, upd: 0;
       caw99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw98() //  [R1]
         { info_tbl: [(caw98,
                       label: block_caw98_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw98: // global
           _savdh::I64 = I64[Sp + 8];
           _savgu::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto caw9f; else goto caw9j;
       caw9f: // global
           (_savgS::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savgu::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caw9j: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_savh0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savgu::P64;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_savgt_entry() //  [R1]
         { info_tbl: [(caw9D,
                       label: sat_savgt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw9D: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.$wloop_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caw9G,
                       label: GHC.Event.TimerManager.$wloop_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw9G: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caw9H; else goto caw9I;
       caw9H: // global
           R1 = GHC.Event.TimerManager.$wloop_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       caw9I: // global
           I64[Sp - 40] = block_caw4V_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uawd2; else goto caw4W;
       uawd2: // global
           call _caw4V(R1) args: 0, res: 0, upd: 0;
       caw4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw4V() //  [R1]
         { info_tbl: [(caw4V,
                       label: block_caw4V_info
                       rep:StackRep [False, False, False, True, True, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw4V: // global
           I64[Sp - 24] = block_caw50_info;
           R2 = lvl3_rasDY_closure+1;
           _savdl::P64 = R1;
           _savdm::P64 = P64[R1 + 7];
           _savdq::P64 = P64[R1 + 39];
           R1 = P64[Sp + 16];
           P64[Sp - 16] = _savdm::P64;
           P64[Sp - 8] = _savdq::P64;
           P64[Sp] = _savdl::P64;
           Sp = Sp - 24;
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw50() //  [R1]
         { info_tbl: [(caw50,
                       label: block_caw50_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw50: // global
           I64[Sp] = block_caw52_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uawd1; else goto caw53;
       uawd1: // global
           call _caw52(R1) args: 0, res: 0, upd: 0;
       caw53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw52() //  [R1]
         { info_tbl: [(caw52,
                       label: block_caw52_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw52: // global
           _cawc8::P64 = R1 & 7;
           if (_cawc8::P64 == 1) goto cawal; else goto uawcZ;
       cawal: // global
           I64[Sp] = block_caw58_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       uawcZ: // global
           _savdd::P64 = P64[Sp + 40];
           _savdm::P64 = P64[Sp + 8];
           _savdq::P64 = P64[Sp + 16];
           if (_cawc8::P64 == 3) goto cawbI; else goto caw9U;
       cawbI: // global
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp + 48] = block_cawbE_info;
           R2 = _savdm::P64;
           R1 = _savdq::P64;
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caw9U: // global
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp + 40] = block_caw9P_info;
           R2 = _savdm::P64;
           _savdu::P64 = R1;
           R1 = _savdq::P64;
           P64[Sp + 48] = _savdu::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw58() //  [R1]
         { info_tbl: [(caw58,
                       label: block_caw58_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw58: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cawao; else goto cawan;
       cawao: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cawan: // global
           I64[Hp - 160] = go_save5_info;
           P64[Hp - 152] = P64[Sp + 32];
           _savdd::P64 = P64[Sp + 40];
           P64[Hp - 144] = _savdd::P64;
           P64[Hp - 136] = P64[Sp + 48];
           _savdi::P64 = P64[Sp + 80];
           P64[Hp - 128] = _savdi::P64;
           _savdj::P64 = P64[Sp + 88];
           P64[Hp - 120] = _savdj::P64;
           P64[Hp - 112] = P64[Sp + 24];
           _savdf::I64 = I64[Sp + 56];
           I64[Hp - 104] = _savdf::I64;
           _savdg::I64 = I64[Sp + 64];
           I64[Hp - 96] = _savdg::I64;
           _savdh::I64 = I64[Sp + 72];
           I64[Hp - 88] = _savdh::I64;
           _savdm::P64 = P64[Sp + 8];
           _savdq::P64 = P64[Sp + 16];
           _caw5a::P64 = Hp - 159;
           if (R1 == 0) goto cawaZ; else goto uawd0;
       cawaZ: // global
           I64[Hp - 80] = sat_savgs_info;
           P64[Hp - 72] = _savdd::P64;
           P64[Hp - 64] = _savdi::P64;
           P64[Hp - 56] = _savdj::P64;
           P64[Hp - 48] = _savdm::P64;
           P64[Hp - 40] = _savdq::P64;
           P64[Hp - 32] = _caw5a::P64;
           I64[Hp - 24] = _savdf::I64;
           I64[Hp - 16] = _savdg::I64;
           I64[Hp - 8] = _savdh::I64;
           _caw6L::P64 = Hp - 79;
           Hp = Hp - 8;
           R1 = _caw6L::P64;
           Sp = Sp + 96;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uawd0: // global
           if (R1 == 1) goto cawb8; else goto caway;
       cawb8: // global
           I64[Hp - 80] = sat_savh1_info;
           P64[Hp - 72] = _savdd::P64;
           P64[Hp - 64] = _savdi::P64;
           P64[Hp - 56] = _savdj::P64;
           P64[Hp - 48] = _savdm::P64;
           P64[Hp - 40] = _savdq::P64;
           I64[Hp - 32] = _savdf::I64;
           I64[Hp - 24] = _savdg::I64;
           I64[Hp - 16] = _savdh::I64;
           I64[Hp - 8] = sat_savgt_info;
           P64[Hp] = _caw5a::P64;
           I64[Sp] = block_cawb0_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caway: // global
           I64[Hp - 80] = sat_saveL_info;
           P64[Hp - 72] = _savdd::P64;
           P64[Hp - 64] = _savdi::P64;
           P64[Hp - 56] = _savdj::P64;
           P64[Hp - 48] = _savdm::P64;
           P64[Hp - 40] = _savdq::P64;
           I64[Hp - 32] = _savdf::I64;
           I64[Hp - 24] = _savdg::I64;
           I64[Hp - 16] = _savdh::I64;
           I64[Hp - 8] = sat_saved_info;
           P64[Hp] = _caw5a::P64;
           I64[Sp] = block_cawap_info;
           R2 = Hp - 78;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawb0() //  [R1]
         { info_tbl: [(cawb0,
                       label: block_cawb0_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawb0: // global
           _savdd::P64 = P64[Sp + 40];
           _savdm::P64 = P64[Sp + 8];
           _savdq::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp + 40] = block_cawb5_info;
           R2 = _savdm::P64;
           _savh4::P64 = R1;
           R1 = _savdq::P64;
           P64[Sp + 48] = _savh4::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawb5() //  []
         { info_tbl: [(cawb5,
                       label: block_cawb5_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawb5: // global
           I64[Sp] = block_cawb7_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawb7() //  []
         { info_tbl: [(cawb7,
                       label: block_cawb7_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawb7: // global
           _savdg::I64 = I64[Sp + 24];
           _savdi::P64 = P64[Sp + 40];
           (_savhg::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_savhl::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp] = block_cawbn_info;
           R1 = _savdi::P64;
           if (R1 & 7 != 0) goto uawd5; else goto cawbo;
       uawd5: // global
           call _cawbn(R1) args: 0, res: 0, upd: 0;
       cawbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawbn() //  [R1]
         { info_tbl: [(cawbn,
                       label: block_cawbn_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawbn: // global
           _savdh::I64 = I64[Sp + 32];
           _savh4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cawbu; else goto cawby;
       cawbu: // global
           (_savhr::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savh4::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cawby: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_savhz::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _savh4::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cawap() //  [R1]
         { info_tbl: [(cawap,
                       label: block_cawap_info
                       rep:StackRep [False, False, True, True, False, True, True, True,
                                     True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawap: // global
           _savdd::P64 = P64[Sp + 40];
           _savdm::P64 = P64[Sp + 8];
           _savdq::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_savdd::P64 + 8] = GHC.Event.TimerManager.Finished_closure+4;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _savdd::P64);
           I64[Sp + 40] = block_cawau_info;
           R2 = _savdm::P64;
           _saveO::P64 = R1;
           R1 = _savdq::P64;
           P64[Sp + 48] = _saveO::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawau() //  []
         { info_tbl: [(cawau,
                       label: block_cawau_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawau: // global
           I64[Sp] = block_cawaw_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawaw() //  []
         { info_tbl: [(cawaw,
                       label: block_cawaw_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawaw: // global
           _savdg::I64 = I64[Sp + 24];
           _savdi::P64 = P64[Sp + 40];
           (_savf0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_savf5::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp] = block_cawaN_info;
           R1 = _savdi::P64;
           if (R1 & 7 != 0) goto uawd4; else goto cawaO;
       uawd4: // global
           call _cawaN(R1) args: 0, res: 0, upd: 0;
       cawaO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawaN() //  [R1]
         { info_tbl: [(cawaN,
                       label: block_cawaN_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawaN: // global
           _savdh::I64 = I64[Sp + 32];
           _saveO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cawaU; else goto cawaY;
       cawaU: // global
           (_savfb::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _saveO::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cawaY: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_savfj::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = _saveO::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cawbE() //  []
         { info_tbl: [(cawbE,
                       label: block_cawbE_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawbE: // global
           I64[Sp] = block_cawbG_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 40];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawbG() //  []
         { info_tbl: [(cawbG,
                       label: block_cawbG_info
                       rep:StackRep [True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawbG: // global
           _savdg::I64 = I64[Sp + 16];
           _savdi::P64 = P64[Sp + 32];
           (_savhL::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])));
           (_savhQ::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp + 16] = block_cawbW_info;
           R1 = _savdi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uawd6; else goto cawbX;
       uawd6: // global
           call _cawbW(R1) args: 0, res: 0, upd: 0;
       cawbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawbW() //  [R1]
         { info_tbl: [(cawbW,
                       label: block_cawbW_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawbW: // global
           _savdh::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cawc3; else goto cawc7;
       cawc3: // global
           (_savhW::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cawc7: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_savi4::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caw9P() //  []
         { info_tbl: [(caw9P,
                       label: block_caw9P_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw9P: // global
           I64[Sp] = block_caw9R_info;
           R2 = GHC.Event.Control.closeControl2_closure+1;
           R1 = P64[Sp + 48];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caw9R() //  []
         { info_tbl: [(caw9R,
                       label: block_caw9R_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw9R: // global
           _savdg::I64 = I64[Sp + 24];
           _savdi::P64 = P64[Sp + 40];
           (_savdG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 16])));
           (_savdL::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdg::I64)));
           I64[Sp] = block_cawa8_info;
           R1 = _savdi::P64;
           if (R1 & 7 != 0) goto uawd3; else goto cawa9;
       uawd3: // global
           call _cawa8(R1) args: 0, res: 0, upd: 0;
       cawa9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawa8() //  [R1]
         { info_tbl: [(cawa8,
                       label: block_cawa8_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawa8: // global
           _savdh::I64 = I64[Sp + 32];
           _savdu::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cawaf; else goto cawaj;
       cawaf: // global
           (_savdR::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R2 = _savdu::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
       cawaj: // global
           call "ccall" arg hints:  [‘signed’]  result hints:  [] setIOManagerWakeupFd((-1));
           (_save0::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] close(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_savdh::I64)));
           R2 = _savdu::P64;
           Sp = Sp + 56;
           call lvl1_rasDW_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.087241995 UTC

[section ""data" . GHC.Event.TimerManager.loop1_closure" {
     GHC.Event.TimerManager.loop1_closure:
         const GHC.Event.TimerManager.loop1_info;
         const 0;
 },
 GHC.Event.TimerManager.loop1_entry() //  [R2]
         { info_tbl: [(cawho,
                       label: GHC.Event.TimerManager.loop1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawho: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cawhp; else goto cawhq;
       cawhp: // global
           R2 = R2;
           R1 = GHC.Event.TimerManager.loop1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cawhq: // global
           I64[Sp - 8] = block_cawhl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uawhu; else goto cawhm;
       uawhu: // global
           call _cawhl(R1) args: 0, res: 0, upd: 0;
       cawhm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cawhl() //  [R1]
         { info_tbl: [(cawhl,
                       label: block_cawhl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawhl: // global
           R6 = I64[R1 + 55];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 63];
           I64[Sp - 16] = I64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 39];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 24;
           call GHC.Event.TimerManager.$wloop_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.093479376 UTC

[section ""data" . GHC.Event.TimerManager.loop_closure" {
     GHC.Event.TimerManager.loop_closure:
         const GHC.Event.TimerManager.loop_info;
         const 0;
 },
 GHC.Event.TimerManager.loop_entry() //  [R2]
         { info_tbl: [(cawhN,
                       label: GHC.Event.TimerManager.loop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawhN: // global
           R2 = R2;
           call GHC.Event.TimerManager.loop1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.096976076 UTC

[section ""data" . GHC.Event.TimerManager.TimerManager_closure" {
     GHC.Event.TimerManager.TimerManager_closure:
         const GHC.Event.TimerManager.TimerManager_info;
 },
 GHC.Event.TimerManager.TimerManager_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawhV: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.TimerManager.TimerManager_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 GHC.Event.TimerManager.TimerManager_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cawi0,
                       label: GHC.Event.TimerManager.TimerManager_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, True, True,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawi0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cawi4; else goto cawi3;
       cawi4: // global
           HpAlloc = 80;
           R1 = GHC.Event.TimerManager.TimerManager_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cawi3: // global
           I64[Hp - 72] = GHC.Event.TimerManager.TimerManager_con_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = R6;
           I64[Hp - 8] = I64[Sp];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 71;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.101909857 UTC

[section ""data" . GHC.Event.TimerManager.Created_closure" {
     GHC.Event.TimerManager.Created_closure:
         const GHC.Event.TimerManager.Created_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.103581345 UTC

[section ""data" . GHC.Event.TimerManager.Running_closure" {
     GHC.Event.TimerManager.Running_closure:
         const GHC.Event.TimerManager.Running_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.105211546 UTC

[section ""data" . GHC.Event.TimerManager.Dying_closure" {
     GHC.Event.TimerManager.Dying_closure:
         const GHC.Event.TimerManager.Dying_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.106801638 UTC

[section ""data" . GHC.Event.TimerManager.Finished_closure" {
     GHC.Event.TimerManager.Finished_closure:
         const GHC.Event.TimerManager.Finished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.10840178 UTC

[GHC.Event.TimerManager.TimerManager_con_entry() //  [R1]
         { info_tbl: [(cawil,
                       label: GHC.Event.TimerManager.TimerManager_con_info
                       rep:HeapRep 6 ptrs 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,84,105,109,101,114,77,97,110,97,103,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawil: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.111825193 UTC

[section ""relreadonly" . GHC.Event.TimerManager.State_closure_tbl" {
     GHC.Event.TimerManager.State_closure_tbl:
         const GHC.Event.TimerManager.Created_closure+1;
         const GHC.Event.TimerManager.Running_closure+2;
         const GHC.Event.TimerManager.Dying_closure+3;
         const GHC.Event.TimerManager.Finished_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.113581367 UTC

[GHC.Event.TimerManager.Created_con_entry() //  [R1]
         { info_tbl: [(cawit,
                       label: GHC.Event.TimerManager.Created_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawit: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.117336482 UTC

[GHC.Event.TimerManager.Running_con_entry() //  [R1]
         { info_tbl: [(cawiA,
                       label: GHC.Event.TimerManager.Running_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawiA: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.120566463 UTC

[GHC.Event.TimerManager.Dying_con_entry() //  [R1]
         { info_tbl: [(cawiH,
                       label: GHC.Event.TimerManager.Dying_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,68,121,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawiH: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.123724531 UTC

[GHC.Event.TimerManager.Finished_con_entry() //  [R1]
         { info_tbl: [(cawiO,
                       label: GHC.Event.TimerManager.Finished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,84,105,109,101,114,77,97,110,97,103,101,114,46,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawiO: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:31.126838727 UTC

[section ""relreadonly" . Savlf_srt" {
     Savlf_srt:
         const GHC.Event.TimerManager.$w$cshowsPrec_closure;
         const GHC.Event.TimerManager.$fShowState1_closure;
         const GHC.Event.TimerManager.$fShowState3_closure;
         const GHC.Event.TimerManager.$fShowState5_closure;
         const GHC.Event.TimerManager.$fShowState7_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Control.$wsendWakeup_closure;
         const GHC.Event.TimerManager.wakeManager1_closure;
         const GHC.Event.TimerManager.$fShowState_$cshow_closure;
         const GHC.Event.TimerManager.$weditTimeouts_closure;
         const GHC.Event.TimerManager.unregisterTimeout2_closure;
         const GHC.Event.TimerManager.unregisterTimeout1_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Control.sendWakeup2_closure;
         const GHC.Event.TimerManager.$wregisterTimeout_closure;
         const GHC.Event.TimerManager.registerTimeout1_closure;
         const GHC.Event.TimerManager.updateTimeout1_closure;
         const GHC.Event.Control.$wsendDie_closure;
         const GHC.Event.TimerManager.shutdown1_closure;
         const GHC.Event.Internal.evtNothing_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Event.Control.newControl1_closure;
         const GHC.Event.TimerManager.new2_closure;
         const GHC.Event.TimerManager.new1_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.Event.Control.$wreadControlMessage_closure;
         const GHC.Event.TimerManager.step1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const lvl1_rasDW_closure;
         const GHC.Event.TimerManager.$wloop_closure;
         const GHC.Event.TimerManager.loop1_closure;
 }]

