
==================== Output Cmm ====================
2018-03-16 16:05:19.013167694 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:19.014437962 UTC

[section ""data" . GHC.Event.Poll.$WPollFd_closure" {
     GHC.Event.Poll.$WPollFd_closure:
         const GHC.Event.Poll.$WPollFd_info;
 },
 GHC.Event.Poll.$WPollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(cajKe,
                       label: GHC.Event.Poll.$WPollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajKs; else goto cajKt;
       cajKs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cajKt: // global
           I64[Sp - 24] = block_cajKb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uajKA; else goto cajKc;
       uajKA: // global
           call _cajKb(R1) args: 0, res: 0, upd: 0;
       cajKc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajKb() //  [R1]
         { info_tbl: [(cajKb,
                       label: block_cajKb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKb: // global
           I64[Sp] = block_cajKh_info;
           _sajBq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajBq::I64;
           if (R1 & 7 != 0) goto uajKz; else goto cajKi;
       uajKz: // global
           call _cajKh(R1) args: 0, res: 0, upd: 0;
       cajKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajKh() //  [R1]
         { info_tbl: [(cajKh,
                       label: block_cajKh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKh: // global
           I64[Sp] = block_cajKm_info;
           _sajBs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajBs::I64;
           if (R1 & 7 != 0) goto uajKB; else goto cajKn;
       uajKB: // global
           call _cajKm(R1) args: 0, res: 0, upd: 0;
       cajKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajKm() //  [R1]
         { info_tbl: [(cajKm,
                       label: block_cajKm_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajKy; else goto cajKx;
       cajKy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajKx: // global
           _sajBu::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sajBu::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.016362332 UTC

[section ""data" . GHC.Event.Poll.$WPoll_closure" {
     GHC.Event.Poll.$WPoll_closure:
         const GHC.Event.Poll.$WPoll_info;
 },
 GHC.Event.Poll.$WPoll_entry() //  [R2, R3]
         { info_tbl: [(cajKJ,
                       label: GHC.Event.Poll.$WPoll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajKS; else goto cajKT;
       cajKS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPoll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cajKT: // global
           I64[Sp - 16] = block_cajKG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uajKZ; else goto cajKH;
       uajKZ: // global
           call _cajKG(R1) args: 0, res: 0, upd: 0;
       cajKH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajKG() //  [R1]
         { info_tbl: [(cajKG,
                       label: block_cajKG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKG: // global
           I64[Sp] = block_cajKM_info;
           _sajBy::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sajBy::P64;
           if (R1 & 7 != 0) goto uajKY; else goto cajKN;
       uajKY: // global
           call _cajKM(R1) args: 0, res: 0, upd: 0;
       cajKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajKM() //  [R1]
         { info_tbl: [(cajKM,
                       label: block_cajKM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajKM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajKX; else goto cajKW;
       cajKX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajKW: // global
           _sajBA::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sajBA::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.017806712 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$calignment_closure" {
     GHC.Event.Poll.$fStorablePollFd_$calignment_closure:
         const GHC.Event.Poll.$fStorablePollFd_$calignment_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$calignment_entry() //  []
         { info_tbl: [(cajL4,
                       label: GHC.Event.Poll.$fStorablePollFd_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajL4: // global
           R1 = Foreign.Storable.$fStorableBool7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.018499956 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd7_closure" {
     GHC.Event.Poll.$fStorablePollFd7_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.01911302 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure" {
     GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure:
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$csizeOf_entry() //  []
         { info_tbl: [(cajLb,
                       label: GHC.Event.Poll.$fStorablePollFd_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajLb: // global
           R1 = GHC.Event.Poll.$fStorablePollFd7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.020101435 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd2_closure" {
     GHC.Event.Poll.$fStorablePollFd2_closure:
         const GHC.Event.Poll.$fStorablePollFd2_info;
 },
 GHC.Event.Poll.$fStorablePollFd2_entry() //  [R2]
         { info_tbl: [(cajLl,
                       label: GHC.Event.Poll.$fStorablePollFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajLl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajLv; else goto cajLw;
       cajLv: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajLw: // global
           I64[Sp - 8] = block_cajLi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajLA; else goto cajLj;
       uajLA: // global
           call _cajLi(R1) args: 0, res: 0, upd: 0;
       cajLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajLi() //  [R1]
         { info_tbl: [(cajLi,
                       label: block_cajLi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajLi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajLz; else goto cajLy;
       cajLz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajLy: // global
           _sajBG::I64 = I64[R1 + 7];
           _sajBJ::I64 = %MO_SS_Conv_W32_W64(I32[_sajBG::I64]);
           _sajBN::I64 = %MO_SS_Conv_W16_W64(I16[_sajBG::I64 + 4]);
           _sajBR::I64 = %MO_SS_Conv_W16_W64(I16[_sajBG::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajBJ::I64;
           I64[Hp - 8] = _sajBN::I64;
           I64[Hp] = _sajBR::I64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.021689487 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd6_closure" {
     GHC.Event.Poll.$fStorablePollFd6_closure:
         const GHC.Event.Poll.$fStorablePollFd6_info;
 },
 GHC.Event.Poll.$fStorablePollFd6_entry() //  [R2, R3]
         { info_tbl: [(cajLI,
                       label: GHC.Event.Poll.$fStorablePollFd6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajLI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajM3; else goto cajM4;
       cajM3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cajM4: // global
           I64[Sp - 16] = block_cajLF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uajMa; else goto cajLG;
       uajMa: // global
           call _cajLF(R1) args: 0, res: 0, upd: 0;
       cajLG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajLF() //  [R1]
         { info_tbl: [(cajLF,
                       label: block_cajLF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajLF: // global
           I64[Sp] = block_cajLL_info;
           _sajBX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajBX::I64;
           if (R1 & 7 != 0) goto uajM9; else goto cajLM;
       uajM9: // global
           call _cajLL(R1) args: 0, res: 0, upd: 0;
       cajLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajLL() //  [R1]
         { info_tbl: [(cajLL,
                       label: block_cajLL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajLL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajM8; else goto cajM7;
       cajM8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajM7: // global
           _sajC0::I64 = I64[Sp + 8] + (I64[R1 + 7] << 3);
           _sajC4::I64 = %MO_SS_Conv_W32_W64(I32[_sajC0::I64]);
           _sajC8::I64 = %MO_SS_Conv_W16_W64(I16[_sajC0::I64 + 4]);
           _sajCc::I64 = %MO_SS_Conv_W16_W64(I16[_sajC0::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajC4::I64;
           I64[Hp - 8] = _sajC8::I64;
           I64[Hp] = _sajCc::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.02344236 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd4_closure" {
     GHC.Event.Poll.$fStorablePollFd4_closure:
         const GHC.Event.Poll.$fStorablePollFd4_info;
 },
 GHC.Event.Poll.$fStorablePollFd4_entry() //  [R2, R3]
         { info_tbl: [(cajMi,
                       label: GHC.Event.Poll.$fStorablePollFd4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajMi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajMA; else goto cajMB;
       cajMA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cajMB: // global
           I64[Sp - 16] = block_cajMf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uajMH; else goto cajMg;
       uajMH: // global
           call _cajMf(R1) args: 0, res: 0, upd: 0;
       cajMg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajMf() //  [R1]
         { info_tbl: [(cajMf,
                       label: block_cajMf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajMf: // global
           I64[Sp] = block_cajMl_info;
           _sajCi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCi::I64;
           if (R1 & 7 != 0) goto uajMG; else goto cajMm;
       uajMG: // global
           call _cajMl(R1) args: 0, res: 0, upd: 0;
       cajMm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajMl() //  [R1]
         { info_tbl: [(cajMl,
                       label: block_cajMl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajMl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajMF; else goto cajME;
       cajMF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajME: // global
           _sajCl::I64 = I64[Sp + 8] + I64[R1 + 7];
           _sajCo::I64 = %MO_SS_Conv_W32_W64(I32[_sajCl::I64]);
           _sajCs::I64 = %MO_SS_Conv_W16_W64(I16[_sajCl::I64 + 4]);
           _sajCw::I64 = %MO_SS_Conv_W16_W64(I16[_sajCl::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajCo::I64;
           I64[Hp - 8] = _sajCs::I64;
           I64[Hp] = _sajCw::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.025120064 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd1_closure" {
     GHC.Event.Poll.$fStorablePollFd1_closure:
         const GHC.Event.Poll.$fStorablePollFd1_info;
 },
 GHC.Event.Poll.$fStorablePollFd1_entry() //  [R2, R3]
         { info_tbl: [(cajMP,
                       label: GHC.Event.Poll.$fStorablePollFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajMP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajMT; else goto cajMU;
       cajMT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cajMU: // global
           I64[Sp - 16] = block_cajMM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uajN6; else goto cajMN;
       uajN6: // global
           call _cajMM(R1) args: 0, res: 0, upd: 0;
       cajMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajMM() //  [R1]
         { info_tbl: [(cajMM,
                       label: block_cajMM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajMM: // global
           I64[Sp] = block_cajMS_info;
           _sajCC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCC::I64;
           if (R1 & 7 != 0) goto uajN5; else goto cajMW;
       uajN5: // global
           call _cajMS(R1) args: 0, res: 0, upd: 0;
       cajMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajMS() //  [R1]
         { info_tbl: [(cajMS,
                       label: block_cajMS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajMS: // global
           _sajCC::I64 = I64[Sp + 8];
           _sajCF::I64 = I64[R1 + 15];
           _sajCG::I64 = I64[R1 + 23];
           I32[_sajCC::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajCC::I64 + 4] = %MO_UU_Conv_W64_W16(_sajCF::I64);
           I16[_sajCC::I64 + 6] = %MO_UU_Conv_W64_W16(_sajCG::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.026811241 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd5_closure" {
     GHC.Event.Poll.$fStorablePollFd5_closure:
         const GHC.Event.Poll.$fStorablePollFd5_info;
 },
 GHC.Event.Poll.$fStorablePollFd5_entry() //  [R2, R3, R4]
         { info_tbl: [(cajNe,
                       label: GHC.Event.Poll.$fStorablePollFd5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajNn; else goto cajNo;
       cajNn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cajNo: // global
           I64[Sp - 24] = block_cajNb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uajNH; else goto cajNc;
       uajNH: // global
           call _cajNb(R1) args: 0, res: 0, upd: 0;
       cajNc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajNb() //  [R1]
         { info_tbl: [(cajNb,
                       label: block_cajNb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNb: // global
           I64[Sp] = block_cajNh_info;
           _sajCR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCR::I64;
           if (R1 & 7 != 0) goto uajNG; else goto cajNi;
       uajNG: // global
           call _cajNh(R1) args: 0, res: 0, upd: 0;
       cajNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajNh() //  [R1]
         { info_tbl: [(cajNh,
                       label: block_cajNh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNh: // global
           I64[Sp] = block_cajNm_info;
           _sajCT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajCT::I64;
           if (R1 & 7 != 0) goto uajNI; else goto cajNr;
       uajNI: // global
           call _cajNm(R1) args: 0, res: 0, upd: 0;
       cajNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajNm() //  [R1]
         { info_tbl: [(cajNm,
                       label: block_cajNm_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNm: // global
           _sajCW::I64 = I64[R1 + 15];
           _sajCX::I64 = I64[R1 + 23];
           _sajCY::I64 = I64[Sp + 8] + (I64[Sp + 16] << 3);
           I32[_sajCY::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajCY::I64 + 4] = %MO_UU_Conv_W64_W16(_sajCW::I64);
           I16[_sajCY::I64 + 6] = %MO_UU_Conv_W64_W16(_sajCX::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.028756773 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd3_closure" {
     GHC.Event.Poll.$fStorablePollFd3_closure:
         const GHC.Event.Poll.$fStorablePollFd3_info;
 },
 GHC.Event.Poll.$fStorablePollFd3_entry() //  [R2, R3, R4]
         { info_tbl: [(cajNQ,
                       label: GHC.Event.Poll.$fStorablePollFd3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajNZ; else goto cajO0;
       cajNZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cajO0: // global
           I64[Sp - 24] = block_cajNN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uajOg; else goto cajNO;
       uajOg: // global
           call _cajNN(R1) args: 0, res: 0, upd: 0;
       cajNO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajNN() //  [R1]
         { info_tbl: [(cajNN,
                       label: block_cajNN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNN: // global
           I64[Sp] = block_cajNT_info;
           _sajDa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajDa::I64;
           if (R1 & 7 != 0) goto uajOf; else goto cajNU;
       uajOf: // global
           call _cajNT(R1) args: 0, res: 0, upd: 0;
       cajNU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajNT() //  [R1]
         { info_tbl: [(cajNT,
                       label: block_cajNT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNT: // global
           I64[Sp] = block_cajNY_info;
           _sajDc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajDc::I64;
           if (R1 & 7 != 0) goto uajOh; else goto cajO3;
       uajOh: // global
           call _cajNY(R1) args: 0, res: 0, upd: 0;
       cajO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajNY() //  [R1]
         { info_tbl: [(cajNY,
                       label: block_cajNY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajNY: // global
           _sajDf::I64 = I64[R1 + 15];
           _sajDg::I64 = I64[R1 + 23];
           _sajDh::I64 = I64[Sp + 8] + I64[Sp + 16];
           I32[_sajDh::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajDh::I64 + 4] = %MO_UU_Conv_W64_W16(_sajDf::I64);
           I16[_sajDh::I64 + 6] = %MO_UU_Conv_W64_W16(_sajDg::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.030298444 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_closure" {
     GHC.Event.Poll.$fStorablePollFd_closure:
         const Foreign.Storable.C:Storable_con_info;
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure+1;
         const GHC.Event.Poll.$fStorablePollFd_$calignment_closure+1;
         const GHC.Event.Poll.$fStorablePollFd6_closure+3;
         const GHC.Event.Poll.$fStorablePollFd5_closure+4;
         const GHC.Event.Poll.$fStorablePollFd4_closure+3;
         const GHC.Event.Poll.$fStorablePollFd3_closure+4;
         const GHC.Event.Poll.$fStorablePollFd2_closure+2;
         const GHC.Event.Poll.$fStorablePollFd1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.030926921 UTC

[section ""data" . GHC.Event.Poll.$fStorableEvent_closure" {
     GHC.Event.Poll.$fStorableEvent_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.031519721 UTC

[section ""cstring" . GHC.Event.Poll.$fShowEvent2_bytes" {
     GHC.Event.Poll.$fShowEvent2_bytes:
         I8[] [69,118,101,110,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.033443708 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec_closure" {
     GHC.Event.Poll.$w$cshowsPrec_closure:
         const GHC.Event.Poll.$w$cshowsPrec_info;
 },
 sat_sajDw_entry() //  [R1]
         { info_tbl: [(cajOw,
                       label: sat_sajDw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajOw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cajOC; else goto cajOD;
       cajOC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajOD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cajOt_info;
           _sajDp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sajDp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uajOI; else goto cajOu;
       uajOI: // global
           call _cajOt(R1) args: 0, res: 0, upd: 0;
       cajOu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cajOt() //  [R1]
         { info_tbl: [(cajOt,
                       label: block_cajOt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajOt: // global
           _sajDp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cajOz_info;
           R4 = _sajDp::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cajOz() //  [R1, R2]
         { info_tbl: [(cajOz,
                       label: block_cajOz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajOz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajOH; else goto cajOG;
       cajOH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cajOG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajDD_entry() //  [R1]
         { info_tbl: [(cajOV,
                       label: sat_sajDD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajOV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cajP2; else goto cajP3;
       cajP2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajP3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cajOS_info;
           _sajDp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sajDp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uajPa; else goto cajOT;
       uajPa: // global
           call _cajOS(R1) args: 0, res: 0, upd: 0;
       cajOT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cajOS() //  [R1]
         { info_tbl: [(cajOS,
                       label: block_cajOS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajOS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajP6; else goto cajP5;
       cajP6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cajP5: // global
           _sajDy::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cajOZ_info;
           R4 = Hp - 14;
           R3 = _sajDy::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cajOZ() //  [R1, R2]
         { info_tbl: [(cajOZ,
                       label: block_cajOZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajOZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajP9; else goto cajP8;
       cajP9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cajP8: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajDE_entry() //  [R1]
         { info_tbl: [(cajPb,
                       label: sat_sajDE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPb: // global
           _sajDE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajPc; else goto cajPd;
       cajPd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajPf; else goto cajPe;
       cajPf: // global
           HpAlloc = 32;
           goto cajPc;
       cajPc: // global
           R1 = _sajDE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajPe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajDE::P64;
           _sajDo::P64 = P64[_sajDE::P64 + 16];
           _sajDp::P64 = P64[_sajDE::P64 + 24];
           I64[Hp - 24] = sat_sajDD_info;
           P64[Hp - 8] = _sajDo::P64;
           P64[Hp] = _sajDp::P64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cajPj,
                       label: GHC.Event.Poll.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cajPn; else goto cajPm;
       cajPn: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cajPm: // global
           if (%MO_S_Lt_W64(R2, 11)) goto cajPh; else goto cajPi;
       cajPh: // global
           I64[Hp - 48] = sat_sajDw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _cajOp::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cajOp::P64;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cajPi: // global
           I64[Hp - 48] = sat_sajDE_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.036570835 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cajPw,
                       label: GHC.Event.Poll.$fShowEvent_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajPx; else goto cajPy;
       cajPx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cajPy: // global
           I64[Sp - 24] = block_cajPt_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uajPC; else goto cajPu;
       uajPC: // global
           call _cajPt(R1) args: 0, res: 0, upd: 0;
       cajPu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajPt() //  [R1]
         { info_tbl: [(cajPt,
                       label: block_cajPt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPt: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.038137367 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshow_closure" {
     GHC.Event.Poll.$fShowEvent_$cshow_closure:
         const GHC.Event.Poll.$fShowEvent_$cshow_info;
 },
 sat_sajDQ_entry() //  [R1]
         { info_tbl: [(cajPO,
                       label: sat_sajDQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajPU; else goto cajPV;
       cajPU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cajPL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uajQ0; else goto cajPM;
       uajQ0: // global
           call _cajPL(R1) args: 0, res: 0, upd: 0;
       cajPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cajPL() //  [R1]
         { info_tbl: [(cajPL,
                       label: block_cajPL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPL: // global
           I64[Sp] = block_cajPR_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cajPR() //  [R1, R2]
         { info_tbl: [(cajPR,
                       label: block_cajPR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajPR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajPZ; else goto cajPY;
       cajPZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cajPY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$fShowEvent_$cshow_entry() //  [R2]
         { info_tbl: [(cajQ1,
                       label: GHC.Event.Poll.$fShowEvent_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajQ1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajQ5; else goto cajQ4;
       cajQ5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajQ4: // global
           I64[Hp - 16] = sat_sajDQ_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.039780304 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent1_closure" {
     GHC.Event.Poll.$fShowEvent1_closure:
         const GHC.Event.Poll.$fShowEvent1_info;
 },
 GHC.Event.Poll.$fShowEvent1_entry() //  [R2, R3]
         { info_tbl: [(cajQa,
                       label: GHC.Event.Poll.$fShowEvent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajQa: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.040620402 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowList_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowList_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowList_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cajQh,
                       label: GHC.Event.Poll.$fShowEvent_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajQh: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowEvent1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.041412506 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_closure" {
     GHC.Event.Poll.$fShowEvent_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowEvent_$cshow_closure+1;
         const GHC.Event.Poll.$fShowEvent_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.042024265 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd6_bytes" {
     GHC.Event.Poll.$fShowPollFd6_bytes:
         I8[] [80,111,108,108,70,100,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.042558597 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd5_bytes" {
     GHC.Event.Poll.$fShowPollFd5_bytes:
         I8[] [112,102,100,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.043092471 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd4_bytes" {
     GHC.Event.Poll.$fShowPollFd4_bytes:
         I8[] [112,102,100,69,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.043668274 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd3_bytes" {
     GHC.Event.Poll.$fShowPollFd3_bytes:
         I8[] [112,102,100,82,101,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.044207365 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd2_bytes" {
     GHC.Event.Poll.$fShowPollFd2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.047201555 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec1_closure" {
     GHC.Event.Poll.$w$cshowsPrec1_closure:
         const GHC.Event.Poll.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Poll.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajQl: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajE4_entry() //  [R1]
         { info_tbl: [(cajR4,
                       label: sat_sajE4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajR4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajR5; else goto cajR6;
       cajR5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajR6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Poll.$fShowPollFd2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE5_entry() //  [R1]
         { info_tbl: [(cajR8,
                       label: sat_sajE5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajR8: // global
           _sajE5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajR9; else goto cajRa;
       cajRa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cajRc; else goto cajRb;
       cajRc: // global
           HpAlloc = 40;
           goto cajR9;
       cajR9: // global
           R1 = _sajE5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE5::P64;
           _sajE1::P64 = P64[_sajE5::P64 + 16];
           _sajDY::I64 = I64[_sajE5::P64 + 24];
           I64[Hp - 32] = sat_sajE4_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajDY::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE6_entry() //  [R1]
         { info_tbl: [(cajRd,
                       label: sat_sajE6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajRh; else goto cajRg;
       cajRh: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRg: // global
           _sajE1::P64 = P64[R1 + 16];
           _sajDY::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_sajE5_info;
           P64[Hp - 8] = _sajE1::P64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowPollFd3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajE7_entry() //  [R1]
         { info_tbl: [(cajRi,
                       label: sat_sajE7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRi: // global
           _sajE7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajRj; else goto cajRk;
       cajRk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajRm; else goto cajRl;
       cajRm: // global
           HpAlloc = 32;
           goto cajRj;
       cajRj: // global
           R1 = _sajE7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE7::P64;
           _sajE1::P64 = P64[_sajE7::P64 + 16];
           _sajDY::I64 = I64[_sajE7::P64 + 24];
           I64[Hp - 24] = sat_sajE6_info;
           P64[Hp - 8] = _sajE1::P64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE8_entry() //  [R1]
         { info_tbl: [(cajRo,
                       label: sat_sajE8_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRo: // global
           _sajE8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajRp; else goto cajRq;
       cajRq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cajRs; else goto cajRr;
       cajRs: // global
           HpAlloc = 48;
           goto cajRp;
       cajRp: // global
           R1 = _sajE8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE8::P64;
           _sajE1::P64 = P64[_sajE8::P64 + 16];
           _sajDX::I64 = I64[_sajE8::P64 + 24];
           _sajDY::I64 = I64[_sajE8::P64 + 32];
           I64[Hp - 40] = sat_sajE7_info;
           P64[Hp - 24] = _sajE1::P64;
           I64[Hp - 16] = _sajDY::I64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajDX::I64;
           R4 = Hp - 40;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE9_entry() //  [R1]
         { info_tbl: [(cajRt,
                       label: sat_sajE9_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cajRx; else goto cajRw;
       cajRx: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRw: // global
           _sajE1::P64 = P64[R1 + 16];
           _sajDX::I64 = I64[R1 + 24];
           _sajDY::I64 = I64[R1 + 32];
           I64[Hp - 32] = sat_sajE8_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Poll.$fShowPollFd4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajEa_entry() //  [R1]
         { info_tbl: [(cajRy,
                       label: sat_sajEa_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRy: // global
           _sajEa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajRz; else goto cajRA;
       cajRA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cajRC; else goto cajRB;
       cajRC: // global
           HpAlloc = 40;
           goto cajRz;
       cajRz: // global
           R1 = _sajEa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEa::P64;
           _sajE1::P64 = P64[_sajEa::P64 + 16];
           _sajDX::I64 = I64[_sajEa::P64 + 24];
           _sajDY::I64 = I64[_sajEa::P64 + 32];
           I64[Hp - 32] = sat_sajE9_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajEe_entry() //  [R1]
         { info_tbl: [(cajRG,
                       label: sat_sajEe_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRG: // global
           _sajEe::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cajRH; else goto cajRI;
       cajRI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cajRK; else goto cajRJ;
       cajRK: // global
           HpAlloc = 40;
           goto cajRH;
       cajRH: // global
           R1 = _sajEe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEe::P64;
           _sajE1::P64 = P64[_sajEe::P64 + 16];
           _sajDW::I64 = I64[_sajEe::P64 + 24];
           _sajDX::I64 = I64[_sajEe::P64 + 32];
           _sajDY::I64 = I64[_sajEe::P64 + 40];
           I64[Hp - 32] = sat_sajEa_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           I64[Sp - 24] = block_cajRD_info;
           R4 = Hp - 32;
           R3 = _sajDW::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cajRD() //  [R1, R2]
         { info_tbl: [(cajRD,
                       label: block_cajRD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajRN; else goto cajRM;
       cajRN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cajRM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajEf_entry() //  [R1]
         { info_tbl: [(cajRO,
                       label: sat_sajEf_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRO: // global
           _sajEf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajRP; else goto cajRQ;
       cajRQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cajRS; else goto cajRR;
       cajRS: // global
           HpAlloc = 48;
           goto cajRP;
       cajRP: // global
           R1 = _sajEf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajRR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEf::P64;
           _sajE1::P64 = P64[_sajEf::P64 + 16];
           _sajDW::I64 = I64[_sajEf::P64 + 24];
           _sajDX::I64 = I64[_sajEf::P64 + 32];
           _sajDY::I64 = I64[_sajEf::P64 + 40];
           I64[Hp - 40] = sat_sajEe_info;
           P64[Hp - 24] = _sajE1::P64;
           I64[Hp - 16] = _sajDW::I64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sajE0_entry() //  [R1, R2]
         { info_tbl: [(cajRT,
                       label: p_sajE0_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajRT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cajRX; else goto cajRW;
       cajRX: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajRW: // global
           _sajDW::I64 = I64[R1 + 7];
           _sajDX::I64 = I64[R1 + 15];
           _sajDY::I64 = I64[R1 + 23];
           I64[Hp - 40] = sat_sajEf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = _sajDW::I64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajEi_entry() //  [R1]
         { info_tbl: [(cajS7,
                       label: sat_sajEi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajS7: // global
           _sajEi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cajS8; else goto cajS9;
       cajS9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cajSb; else goto cajSa;
       cajSb: // global
           HpAlloc = 24;
           goto cajS8;
       cajS8: // global
           R1 = _sajEi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajSa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEi::P64;
           _sajDZ::P64 = P64[_sajEi::P64 + 16];
           _sajE0::P64 = P64[_sajEi::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sajDZ::P64;
           R2 = Hp - 14;
           R1 = _sajE0::P64;
           Sp = Sp - 16;
           call p_sajE0_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cajSf,
                       label: GHC.Event.Poll.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cajSj; else goto cajSi;
       cajSj: // global
           HpAlloc = 88;
           R1 = GHC.Event.Poll.$w$cshowsPrec1_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cajSi: // global
           I64[Hp - 80] = p_sajE0_info;
           I64[Hp - 72] = R3;
           I64[Hp - 64] = R4;
           I64[Hp - 56] = R5;
           _cajQp::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cajSd; else goto cajSe;
       cajSd: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cajQp::P64;
           call p_sajE0_entry(R2, R1) args: 8, res: 0, upd: 8;
       cajSe: // global
           I64[Hp - 48] = sat_sajEi_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cajQp::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.054630179 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cajSt,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajSx; else goto cajSy;
       cajSx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cajSy: // global
           I64[Sp - 24] = block_cajSq_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uajSG; else goto cajSr;
       uajSG: // global
           call _cajSq(R1) args: 0, res: 0, upd: 0;
       cajSr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajSq() //  [R1]
         { info_tbl: [(cajSq,
                       label: block_cajSq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSq: // global
           I64[Sp] = block_cajSw_info;
           _sajEn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajEn::I64;
           if (R1 & 7 != 0) goto uajSF; else goto cajSA;
       uajSF: // global
           call _cajSw(R1) args: 0, res: 0, upd: 0;
       cajSA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajSw() //  [R1]
         { info_tbl: [(cajSw,
                       label: block_cajSw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSw: // global
           R6 = P64[Sp + 16];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.055912465 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd7_closure" {
     GHC.Event.Poll.$fShowPollFd7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.056697957 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshow_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshow_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshow_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshow_entry() //  [R2]
         { info_tbl: [(cajSO,
                       label: GHC.Event.Poll.$fShowPollFd_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajSP; else goto cajSQ;
       cajSP: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajSQ: // global
           I64[Sp - 8] = block_cajSL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajSU; else goto cajSM;
       uajSU: // global
           call _cajSL(R1) args: 0, res: 0, upd: 0;
       cajSM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajSL() //  [R1]
         { info_tbl: [(cajSL,
                       label: block_cajSL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSL: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.057995017 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd1_closure" {
     GHC.Event.Poll.$fShowPollFd1_closure:
         const GHC.Event.Poll.$fShowPollFd1_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd1_entry() //  [R2, R3]
         { info_tbl: [(cajT2,
                       label: GHC.Event.Poll.$fShowPollFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajT3; else goto cajT4;
       cajT3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cajT4: // global
           I64[Sp - 16] = block_cajSZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uajT8; else goto cajT0;
       uajT8: // global
           call _cajSZ(R1) args: 0, res: 0, upd: 0;
       cajT0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajSZ() //  [R1]
         { info_tbl: [(cajSZ,
                       label: block_cajSZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajSZ: // global
           R6 = P64[Sp + 8];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.059129005 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowList_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowList_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowList_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cajTd,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTd: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowPollFd1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.059878707 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_closure" {
     GHC.Event.Poll.$fShowPollFd_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure+1;
         const GHC.Event.Poll.$fShowPollFd_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.060461802 UTC

[section ""data" . GHC.Event.Poll.$fEqEvent_closure" {
     GHC.Event.Poll.$fEqEvent_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.061313943 UTC

[section ""data" . GHC.Event.Poll.pfdRevents_closure" {
     GHC.Event.Poll.pfdRevents_closure:
         const GHC.Event.Poll.pfdRevents_info;
 },
 GHC.Event.Poll.pfdRevents_entry() //  [R2]
         { info_tbl: [(cajTn,
                       label: GHC.Event.Poll.pfdRevents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajTr; else goto cajTs;
       cajTr: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdRevents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajTs: // global
           I64[Sp - 8] = block_cajTk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajTw; else goto cajTl;
       uajTw: // global
           call _cajTk(R1) args: 0, res: 0, upd: 0;
       cajTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajTk() //  [R1]
         { info_tbl: [(cajTk,
                       label: block_cajTk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cajTv; else goto cajTu;
       cajTv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajTu: // global
           _sajEJ::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajEJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.062613313 UTC

[section ""data" . GHC.Event.Poll.pfdEvents_closure" {
     GHC.Event.Poll.pfdEvents_closure:
         const GHC.Event.Poll.pfdEvents_info;
 },
 GHC.Event.Poll.pfdEvents_entry() //  [R2]
         { info_tbl: [(cajTE,
                       label: GHC.Event.Poll.pfdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajTI; else goto cajTJ;
       cajTI: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajTJ: // global
           I64[Sp - 8] = block_cajTB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajTN; else goto cajTC;
       uajTN: // global
           call _cajTB(R1) args: 0, res: 0, upd: 0;
       cajTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajTB() //  [R1]
         { info_tbl: [(cajTB,
                       label: block_cajTB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cajTM; else goto cajTL;
       cajTM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajTL: // global
           _sajEN::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajEN::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.063917808 UTC

[section ""data" . GHC.Event.Poll.pfdFd_closure" {
     GHC.Event.Poll.pfdFd_closure:
         const GHC.Event.Poll.pfdFd_info;
 },
 GHC.Event.Poll.pfdFd_entry() //  [R2]
         { info_tbl: [(cajTV,
                       label: GHC.Event.Poll.pfdFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajTZ; else goto cajU0;
       cajTZ: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajU0: // global
           I64[Sp - 8] = block_cajTS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajU4; else goto cajTT;
       uajU4: // global
           call _cajTS(R1) args: 0, res: 0, upd: 0;
       cajTT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajTS() //  [R1]
         { info_tbl: [(cajTS,
                       label: block_cajTS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajTS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cajU3; else goto cajU2;
       cajU3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajU2: // global
           _sajER::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajER::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.06526814 UTC

[section ""data" . GHC.Event.Poll.pollFd_closure" {
     GHC.Event.Poll.pollFd_closure:
         const GHC.Event.Poll.pollFd_info;
 },
 GHC.Event.Poll.pollFd_entry() //  [R2]
         { info_tbl: [(cajUc,
                       label: GHC.Event.Poll.pollFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajUc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajUg; else goto cajUh;
       cajUg: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajUh: // global
           I64[Sp - 8] = block_cajU9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajUl; else goto cajUa;
       uajUl: // global
           call _cajU9(R1) args: 0, res: 0, upd: 0;
       cajUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajU9() //  [R1]
         { info_tbl: [(cajU9,
                       label: block_cajU9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajU9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cajUk; else goto cajUj;
       cajUk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajUj: // global
           _sajEX::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sajEX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.066537334 UTC

[section ""data" . GHC.Event.Poll.pollChanges_closure" {
     GHC.Event.Poll.pollChanges_closure:
         const GHC.Event.Poll.pollChanges_info;
 },
 GHC.Event.Poll.pollChanges_entry() //  [R2]
         { info_tbl: [(cajUt,
                       label: GHC.Event.Poll.pollChanges_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajUt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajUx; else goto cajUy;
       cajUx: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollChanges_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cajUy: // global
           I64[Sp - 8] = block_cajUq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uajUC; else goto cajUr;
       uajUC: // global
           call _cajUq(R1) args: 0, res: 0, upd: 0;
       cajUr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajUq() //  [R1]
         { info_tbl: [(cajUq,
                       label: block_cajUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajUq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cajUB; else goto cajUA;
       cajUB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cajUA: // global
           _sajF0::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sajF0::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.067634907 UTC

[section ""data" . GHC.Event.Poll.available_closure" {
     GHC.Event.Poll.available_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.068251481 UTC

[section ""cstring" . GHC.Event.Poll.$trModule4_bytes" {
     GHC.Event.Poll.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.068843455 UTC

[section ""data" . GHC.Event.Poll.$trModule3_closure" {
     GHC.Event.Poll.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.069518495 UTC

[section ""cstring" . GHC.Event.Poll.$trModule2_bytes" {
     GHC.Event.Poll.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.070076074 UTC

[section ""data" . GHC.Event.Poll.$trModule1_closure" {
     GHC.Event.Poll.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.070665904 UTC

[section ""data" . GHC.Event.Poll.$trModule_closure" {
     GHC.Event.Poll.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Poll.$trModule3_closure+1;
         const GHC.Event.Poll.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.071256692 UTC

[section ""data" . $krep_rajAW_closure" {
     $krep_rajAW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCShort_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.071843182 UTC

[section ""data" . $krep1_rajAX_closure" {
     $krep1_rajAX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.072400708 UTC

[section ""cstring" . GHC.Event.Poll.$tcEvent2_bytes" {
     GHC.Event.Poll.$tcEvent2_bytes:
         I8[] [69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.072972339 UTC

[section ""data" . GHC.Event.Poll.$tcEvent1_closure" {
     GHC.Event.Poll.$tcEvent1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcEvent2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.073570628 UTC

[section ""data" . GHC.Event.Poll.$tcEvent_closure" {
     GHC.Event.Poll.$tcEvent_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcEvent1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10782964843686049546;
         const 16589058175633483645;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.0741776 UTC

[section ""data" . $krep2_rajAY_closure" {
     $krep2_rajAY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcEvent_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.074707866 UTC

[section ""data" . GHC.Event.Poll.$tc'Event1_closure" {
     GHC.Event.Poll.$tc'Event1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rajAW_closure+1;
         const $krep2_rajAY_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.075331241 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Event3_bytes" {
     GHC.Event.Poll.$tc'Event3_bytes:
         I8[] [39,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.075887672 UTC

[section ""data" . GHC.Event.Poll.$tc'Event2_closure" {
     GHC.Event.Poll.$tc'Event2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Event3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.076458775 UTC

[section ""data" . GHC.Event.Poll.$tc'Event_closure" {
     GHC.Event.Poll.$tc'Event_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Event2_closure+1;
         const GHC.Event.Poll.$tc'Event1_closure+4;
         const 14301517435728423362;
         const 8190957594797964970;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.077040934 UTC

[section ""cstring" . GHC.Event.Poll.$tcPollFd2_bytes" {
     GHC.Event.Poll.$tcPollFd2_bytes:
         I8[] [80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.077632517 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd1_closure" {
     GHC.Event.Poll.$tcPollFd1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPollFd2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.078201975 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd_closure" {
     GHC.Event.Poll.$tcPollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPollFd1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16228031948332168786;
         const 6382085973026785723;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.078809667 UTC

[section ""data" . $krep3_rajAZ_closure" {
     $krep3_rajAZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPollFd_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.079407476 UTC

[section ""data" . $krep4_rajB0_closure" {
     $krep4_rajB0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep3_rajAZ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.080005055 UTC

[section ""data" . $krep5_rajB1_closure" {
     $krep5_rajB1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep4_rajB0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.080527122 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd1_closure" {
     GHC.Event.Poll.$tc'PollFd1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rajAX_closure+1;
         const $krep5_rajB1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.08108937 UTC

[section ""cstring" . GHC.Event.Poll.$tc'PollFd3_bytes" {
     GHC.Event.Poll.$tc'PollFd3_bytes:
         I8[] [39,80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.081686793 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd2_closure" {
     GHC.Event.Poll.$tc'PollFd2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'PollFd3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.082250945 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd_closure" {
     GHC.Event.Poll.$tc'PollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'PollFd2_closure+1;
         const GHC.Event.Poll.$tc'PollFd1_closure+4;
         const 13628496348781941345;
         const 13702663238288085101;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.082827432 UTC

[section ""data" . $krep6_rajB2_closure" {
     $krep6_rajB2_closure:
         const :_con_info;
         const $krep3_rajAZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.08341391 UTC

[section ""data" . $krep7_rajB3_closure" {
     $krep7_rajB3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure;
         const $krep6_rajB2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.083983252 UTC

[section ""data" . $krep8_rajB4_closure" {
     $krep8_rajB4_closure:
         const :_con_info;
         const $krep7_rajB3_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.084508143 UTC

[section ""data" . $krep9_rajB5_closure" {
     $krep9_rajB5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep8_rajB4_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.086149225 UTC

[section ""cstring" . GHC.Event.Poll.$tcPoll2_bytes" {
     GHC.Event.Poll.$tcPoll2_bytes:
         I8[] [80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.086683462 UTC

[section ""data" . GHC.Event.Poll.$tcPoll1_closure" {
     GHC.Event.Poll.$tcPoll1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPoll2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.087259248 UTC

[section ""data" . GHC.Event.Poll.$tcPoll_closure" {
     GHC.Event.Poll.$tcPoll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPoll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13451464419968486054;
         const 9195109480934256969;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.087882989 UTC

[section ""data" . $krep10_rajB6_closure" {
     $krep10_rajB6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPoll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.088457337 UTC

[section ""data" . $krep11_rajB7_closure" {
     $krep11_rajB7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rajB3_closure+1;
         const $krep10_rajB6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.089052326 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll1_closure" {
     GHC.Event.Poll.$tc'Poll1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rajB5_closure+1;
         const $krep11_rajB7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.08963773 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Poll3_bytes" {
     GHC.Event.Poll.$tc'Poll3_bytes:
         I8[] [39,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.090144142 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll2_closure" {
     GHC.Event.Poll.$tc'Poll2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Poll3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.090713764 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll_closure" {
     GHC.Event.Poll.$tc'Poll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Poll2_closure+1;
         const GHC.Event.Poll.$tc'Poll1_closure+4;
         const 5431567153781643515;
         const 15938353663250731731;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.091319001 UTC

[section ""data" . GHC.Event.Poll.$fBitsEvent_closure" {
     GHC.Event.Poll.$fBitsEvent_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Event.Poll.$fEqEvent_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.092030249 UTC

[section ""data" . GHC.Event.Poll.$fFiniteBitsEvent_closure" {
     GHC.Event.Poll.$fFiniteBitsEvent_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Event.Poll.$fBitsEvent_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.092608946 UTC

[section ""data" . GHC.Event.Poll.$fNumEvent_closure" {
     GHC.Event.Poll.$fNumEvent_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.093181546 UTC

[section ""cstring" . lvl_rajB8_bytes" {
     lvl_rajB8_bytes:
         I8[] [109,111,100,105,102,121,70,100,79,110,99,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,105,110,32,80,111,108,108,32,98,97,99,107,101,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.094169785 UTC

[section ""data" . GHC.Event.Poll.new3_closure" {
     GHC.Event.Poll.new3_closure:
         const GHC.Event.Poll.new3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Poll.new3_entry() //  [R1]
         { info_tbl: [(cajUL,
                       label: GHC.Event.Poll.new3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajUL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajUM; else goto cajUN;
       cajUM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajUN: // global
           (_cajUG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cajUG::I64 == 0) goto cajUI; else goto cajUH;
       cajUI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cajUH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cajUG::I64;
           I64[Sp - 24] = block_cajUJ_info;
           R2 = lvl_rajB8_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cajUJ() //  [R1]
         { info_tbl: [(cajUJ,
                       label: block_cajUJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajUJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.096190768 UTC

[section ""data" . $wc_pollLoop_rajB9_closure" {
     $wc_pollLoop_rajB9_closure:
         const $wc_pollLoop_rajB9_info;
 },
 $wc_pollLoop_rajB9_entry() //  [R2, R3, R4]
         { info_tbl: [(cajV0,
                       label: $wc_pollLoop_rajB9_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajV0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cajV1; else goto uajVL;
       cajV1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wc_pollLoop_rajB9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uajVL: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cajUS() args: 0, res: 0, upd: 0;
     }
 },
 _cajUS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajUS: // global
           _sajF3::I64 = I64[Sp];
           _sajF4::I64 = I64[Sp + 8];
           _sajF5::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_sajF5::I64,
                            2147483647)) goto cajUY; else goto cajUZ;
       cajUY: // global
           I64[Sp - 8] = block_cajV8_info;
           Sp = Sp - 8;
           _uajVR::P64 = CurrentTSO;
           I64[I64[_uajVR::P64 + 24] + 16] = Sp;
           _uajVS::I64 = CurrentNursery;
           P64[_uajVS::I64 + 8] = Hp + 8;
           I64[_uajVR::P64 + 104] = I64[_uajVR::P64 + 104] - ((Hp + 8) - I64[_uajVS::I64]);
           (_uajVP::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sajFb::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_sajF3::I64, _sajF4::I64, 2147483647);
           (_uajVQ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uajVP::I64);
           BaseReg = _uajVQ::I64;
           _uajVT::P64 = CurrentTSO;
           _uajVU::P64 = I64[_uajVT::P64 + 24];
           Sp = I64[_uajVU::P64 + 16];
           SpLim = _uajVU::P64 + 192;
           HpAlloc = 0;
           _uajVV::I64 = CurrentNursery;
           _uajVW::I64 = I64[_uajVV::I64 + 8];
           Hp = _uajVW::I64 - 8;
           _uajVX::I64 = I64[_uajVV::I64];
           HpLim = _uajVX::I64 + ((%MO_SS_Conv_W32_W64(I32[_uajVV::I64 + 48]) << 12) - 1);
           I64[_uajVT::P64 + 104] = I64[_uajVT::P64 + 104] + (_uajVW::I64 - _uajVX::I64);
           R1 = _sajFb::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
       cajUZ: // global
           I64[Sp + 16] = block_cajVB_info;
           Sp = Sp + 16;
           _uajW1::P64 = CurrentTSO;
           I64[I64[_uajW1::P64 + 24] + 16] = Sp;
           _uajW2::I64 = CurrentNursery;
           P64[_uajW2::I64 + 8] = Hp + 8;
           I64[_uajW1::P64 + 104] = I64[_uajW1::P64 + 104] - ((Hp + 8) - I64[_uajW2::I64]);
           (_uajVZ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sajFj::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_sajF3::I64, _sajF4::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sajF5::I64)));
           (_uajW0::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uajVZ::I64);
           BaseReg = _uajW0::I64;
           _uajW3::P64 = CurrentTSO;
           _uajW4::P64 = I64[_uajW3::P64 + 24];
           Sp = I64[_uajW4::P64 + 16];
           SpLim = _uajW4::P64 + 192;
           HpAlloc = 0;
           _uajW5::I64 = CurrentNursery;
           _uajW6::I64 = I64[_uajW5::I64 + 8];
           Hp = _uajW6::I64 - 8;
           _uajW7::I64 = I64[_uajW5::I64];
           HpLim = _uajW7::I64 + ((%MO_SS_Conv_W32_W64(I32[_uajW5::I64 + 48]) << 12) - 1);
           I64[_uajW3::P64 + 104] = I64[_uajW3::P64 + 104] + (_uajW6::I64 - _uajW7::I64);
           R1 = _sajFj::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajV8() //  [R1]
         { info_tbl: [(cajV8,
                       label: block_cajV8_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajV8: // global
           _sajFc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           if (_sajFc::I64 != 0) goto uajVM; else goto cajVp;
       uajVM: // global
           I64[Sp + 24] = _sajFc::I64;
           Sp = Sp + 24;
           call _cajVf() args: 0, res: 0, upd: 0;
       cajVp: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] - 2147483647;
           Sp = Sp + 8;
           call _cajUS() args: 0, res: 0, upd: 0;
     }
 },
 _cajVf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajVf: // global
           Hp = Hp + 16;
           _sajFc::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cajVm; else goto cajVl;
       cajVm: // global
           HpAlloc = 16;
           I64[Sp] = block_cajVe_info;
           R1 = _sajFc::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cajVl: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajFc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cajVe() //  [R1]
         { info_tbl: [(cajVe,
                       label: block_cajVe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajVe: // global
           I64[Sp] = R1;
           call _cajVf() args: 0, res: 0, upd: 0;
     }
 },
 _cajVB() //  [R1]
         { info_tbl: [(cajVB,
                       label: block_cajVB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajVB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cajVJ; else goto cajVI;
       cajVJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cajVI: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.098747859 UTC

[section ""data" . lvl1_rajBa_closure" {
     lvl1_rajBa_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.099284201 UTC

[section ""cstring" . lvl2_rajBb_bytes" {
     lvl2_rajBb_bytes:
         I8[] [99,95,112,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.099969846 UTC

[section ""data" . lvl3_rajBc_closure" {
     lvl3_rajBc_closure:
         const lvl3_rajBc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rajBc_entry() //  [R1]
         { info_tbl: [(cajWj,
                       label: lvl3_rajBc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajWj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajWk; else goto cajWl;
       cajWk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajWl: // global
           (_cajWg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cajWg::I64 == 0) goto cajWi; else goto cajWh;
       cajWi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cajWh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cajWg::I64;
           R2 = lvl2_rajBb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.100819249 UTC

[section ""cstring" . lvl4_rajBd_bytes" {
     lvl4_rajBd_bytes:
         I8[] [114,101,119,111,114,107,70,100,58,32,101,118,101,110,116,32,110,111,116,32,102,111,117,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.101606447 UTC

[section ""data" . lvl5_rajBe_closure" {
     lvl5_rajBe_closure:
         const lvl5_rajBe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rajBe_entry() //  [R1]
         { info_tbl: [(cajWu,
                       label: lvl5_rajBe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajWu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajWv; else goto cajWw;
       cajWv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajWw: // global
           (_cajWp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cajWp::I64 == 0) goto cajWr; else goto cajWq;
       cajWr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cajWq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cajWp::I64;
           I64[Sp - 24] = block_cajWs_info;
           R2 = lvl4_rajBd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cajWs() //  [R1]
         { info_tbl: [(cajWs,
                       label: block_cajWs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajWs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.102779187 UTC

[section ""data" . lvl6_rajBf_closure" {
     lvl6_rajBf_closure:
         const lvl6_rajBf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rajBf_entry() //  [R1]
         { info_tbl: [(cajWG,
                       label: lvl6_rajBf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajWG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajWH; else goto cajWI;
       cajWH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajWI: // global
           (_cajWD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cajWD::I64 == 0) goto cajWF; else goto cajWE;
       cajWF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cajWE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cajWD::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.loop_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.103677988 UTC

[section ""data" . lvl7_rajBg_closure" {
     lvl7_rajBg_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.104260628 UTC

[section ""data" . lvl8_rajBh_closure" {
     lvl8_rajBh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.104814768 UTC

[section ""data" . lvl9_rajBi_closure" {
     lvl9_rajBi_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.106312903 UTC

[section ""data" . lvl10_rajBj_closure" {
     lvl10_rajBj_closure:
         const lvl10_rajBj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rajBj_entry() //  [R1]
         { info_tbl: [(cajWP,
                       label: lvl10_rajBj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajWP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajWQ; else goto cajWR;
       cajWQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajWR: // global
           (_cajWM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cajWM::I64 == 0) goto cajWO; else goto cajWN;
       cajWO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cajWN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cajWM::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.removeAt_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.107359025 UTC

[section ""data" . lvl11_rajBk_closure" {
     lvl11_rajBk_closure:
         const lvl11_rajBk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rajBk_entry() //  [R1]
         { info_tbl: [(cajWY,
                       label: lvl11_rajBk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajWY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajWZ; else goto cajX0;
       cajWZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajX0: // global
           (_cajWV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cajWV::I64 == 0) goto cajWX; else goto cajWW;
       cajWX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cajWW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cajWV::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.findIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.114984607 UTC

[section ""data" . GHC.Event.Poll.new5_closure" {
     GHC.Event.Poll.new5_closure:
         const GHC.Event.Poll.new5_info;
         const 0;
 },
 sat_sajGz_entry() //  [R1]
         { info_tbl: [(cajYD,
                       label: sat_sajGz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajYD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajYE; else goto cajZE;
       cajYE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajZE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sajGo::I64 = I64[R1 + 16];
           if (_sajGo::I64 & 25 == 0) goto cajZf; else goto cajYO;
       cajZf: // global
           if (_sajGo::I64 & 28 == 0) goto cajZA; else goto cajZu;
       cajZA: // global
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cajZu: // global
           R1 = lvl9_rajBi_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cajYO: // global
           if (_sajGo::I64 & 28 == 0) goto cajZ9; else goto cajZ3;
       cajZ9: // global
           R1 = lvl8_rajBh_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cajZ3: // global
           R1 = lvl7_rajBg_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 i'_sajGD_entry() //  [R1]
         { info_tbl: [(cajZP,
                       label: i'_sajGD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajZP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cajZZ; else goto cak00;
       cajZZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cak00: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cajZM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uak04; else goto cajZN;
       uak04: // global
           call _cajZM(R1) args: 0, res: 0, upd: 0;
       cajZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cajZM() //  [R1]
         { info_tbl: [(cajZM,
                       label: block_cajZM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajZM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cak03; else goto cak02;
       cak03: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cak02: // global
           _sajGH::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7] + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajGH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajGL_entry() //  [R1]
         { info_tbl: [(cak0c,
                       label: sat_sajGL_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak0c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cak0d; else goto cak0e;
       cak0d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cak0e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cak09_info;
           _sajGg::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sajGg::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uak0j; else goto cak0a;
       uak0j: // global
           call _cak09(R1) args: 0, res: 0, upd: 0;
       cak0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cak09() //  [R1]
         { info_tbl: [(cak09,
                       label: block_cak09_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak09: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajGO_entry() //  [R1, R2, R3]
         { info_tbl: [(cak0k,
                       label: sat_sajGO_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak0k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cak0l; else goto cak0m;
       cak0l: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cak0m: // global
           I64[Sp - 32] = block_cajYq_info;
           _sajFp::P64 = P64[R1 + 5];
           _sajGg::I64 = I64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _sajFp::P64;
           I64[Sp - 16] = _sajGg::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uak0z; else goto cajYr;
       uak0z: // global
           call _cajYq(R1) args: 0, res: 0, upd: 0;
       cajYr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajYq() //  [R1]
         { info_tbl: [(cajYq,
                       label: block_cajYq_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajYq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cak0p; else goto cak0o;
       cak0p: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak0o: // global
           _sajGo::I64 = I64[R1 + 23];
           if (_sajGo::I64 != 0) goto cak0s; else goto cak0y;
       cak0s: // global
           _sajGl::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_sajGz_info;
           I64[Hp - 16] = _sajGo::I64;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajGl::I64;
           _sajFp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cajZG_info;
           R3 = Hp - 32;
           R2 = Hp - 7;
           R1 = _sajFp::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cak0y: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = GHC.Types.True_closure+2;
           _cak0x::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _cak0x::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cajZG() //  [R1]
         { info_tbl: [(cajZG,
                       label: block_cajZG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajZG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cak0v; else goto cak0u;
       cak0v: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak0u: // global
           I64[Hp - 72] = i'_sajGD_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = sat_sajGL_info;
           _cajZI::P64 = Hp - 72;
           P64[Hp - 32] = _cajZI::P64;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _cajZI::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajHT_entry() //  [R1, R2]
         { info_tbl: [(cak11,
                       label: sat_sajHT_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak11: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cak12; else goto cak13;
       cak12: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cak13: // global
           I64[Sp - 16] = block_cak0Y_info;
           _sajHD::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _sajHD::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uak18; else goto cak0Z;
       uak18: // global
           call _cak0Y(R1) args: 0, res: 0, upd: 0;
       cak0Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak0Y() //  [R1]
         { info_tbl: [(cak0Y,
                       label: block_cak0Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak0Y: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajIQ_entry() //  [R1]
         { info_tbl: [(cak1m,
                       label: sat_sajIQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak1m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cak1n; else goto cak1o;
       cak1n: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cak1o: // global
           I64[Sp - 24] = block_cak1h_info;
           _sajFz::P64 = P64[R1 + 7];
           _sajFB::P64 = P64[R1 + 15];
           R1 = _sajFB::P64;
           P64[Sp - 16] = _sajFz::P64;
           P64[Sp - 8] = _sajFB::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak1h() //  [R1]
         { info_tbl: [(cak1h,
                       label: block_cak1h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak1h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cak1r; else goto cak1q;
       cak1r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak1q: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cak1k_info;
           R2 = Hp - 7;
           _sajIN::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sajIN::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak1k() //  []
         { info_tbl: [(cak1k,
                       label: block_cak1k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak1k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new5_entry() //  [R2, R3, R4]
         { info_tbl: [(cak1t,
                       label: GHC.Event.Poll.new5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak1t: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cak1u; else goto cak1v;
       cak1u: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cak1v: // global
           I64[Sp - 32] = block_cajX5_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajX5() //  [R1]
         { info_tbl: [(cajX5,
                       label: block_cajX5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajX5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cak1y; else goto cak1x;
       cak1y: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak1x: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cajXa_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajXa() //  [R1]
         { info_tbl: [(cajXa,
                       label: block_cajXa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXa: // global
           I64[Sp] = block_cajXc_info;
           _sajFz::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sajFz::P64;
           if (R1 & 7 != 0) goto uak5z; else goto cajXd;
       uak5z: // global
           call _cajXc(R1) args: 0, res: 0, upd: 0;
       cajXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajXc() //  [R1]
         { info_tbl: [(cajXc,
                       label: block_cajXc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXc: // global
           I64[Sp - 16] = block_cajXh_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cajXh() //  [R1]
         { info_tbl: [(cajXh,
                       label: block_cajXh_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cak1D; else goto cak1C;
       cak1D: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cak1C: // global
           _sajFB::P64 = P64[Sp + 16];
           if (R1 == 0) goto cak4U; else goto cak4H;
       cak4U: // global
           I64[Hp - 16] = sat_sajIQ_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sajFB::P64;
           I64[Sp] = block_cak4R_info;
           R1 = Hp - 15;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       cak4H: // global
           Hp = Hp - 24;
           I64[Sp] = block_cak4A_info;
           R1 = _sajFB::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak4R() //  [R1]
         { info_tbl: [(cak4R,
                       label: block_cak4R_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4R: // global
           I64[Sp] = block_cak4T_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uak5Z; else goto cak4W;
       uak5Z: // global
           call _cak4T(R1) args: 0, res: 0, upd: 0;
       cak4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak4T() //  [R1]
         { info_tbl: [(cak4T,
                       label: block_cak4T_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4T: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _sajFG() args: 0, res: 0, upd: 0;
     }
 },
 _cak4A() //  [R1]
         { info_tbl: [(cak4A,
                       label: block_cak4A_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cak4K; else goto cak4J;
       cak4K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak4J: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cak4D_info;
           R2 = Hp - 7;
           _sajIF::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 24] = _sajIF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak4D() //  []
         { info_tbl: [(cak4D,
                       label: block_cak4D_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4D: // global
           I64[Sp] = block_cak4F_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto uak5X; else goto cak4M;
       uak5X: // global
           call _cak4F(R1) args: 0, res: 0, upd: 0;
       cak4M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak4F() //  [R1]
         { info_tbl: [(cak4F,
                       label: block_cak4F_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4F: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _sajFG() args: 0, res: 0, upd: 0;
     }
 },
 _sajFG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sajFG: // global
           _sajFL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cajXo_info;
           R1 = _sajFL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uak61; else goto cajXp;
       uak61: // global
           call _cajXo(R1) args: 0, res: 0, upd: 0;
       cajXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajXo() //  [R1]
         { info_tbl: [(cajXo,
                       label: block_cajXo_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXo: // global
           I64[Sp] = block_cajXt_info;
           _sajFO::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 24] = _sajFO::I64;
           if (R1 & 7 != 0) goto uak5A; else goto cajXu;
       uak5A: // global
           call _cajXt(R1) args: 0, res: 0, upd: 0;
       cajXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajXt() //  [R1]
         { info_tbl: [(cajXt,
                       label: block_cajXt_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cak1I; else goto cak1H;
       cak1I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak1H: // global
           _sajFS::P64 = P64[R1 + 7];
           _sajFR::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = I64[Sp + 24] << 3;
           I64[Sp - 8] = 0;
           P64[Sp] = _sajFS::P64;
           I64[Sp + 16] = _sajFR::I64;
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 16;
           call _cak0D() args: 0, res: 0, upd: 0;
     }
 },
 _cak0D() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak0D: // global
           Hp = Hp + 32;
           _sajHx::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cak3r; else goto cak3q;
       cak3r: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cak0C_info;
           R1 = _sajHx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cak3q: // global
           _sajFC::P64 = P64[Sp + 24];
           if (%MO_S_Lt_W64(_sajHx::I64,
                            I64[Sp])) goto cak4y; else goto cak4z;
       cak4y: // global
           _sajHA::I64 = I64[Sp + 32] + _sajHx::I64;
           _sajHD::I64 = %MO_SS_Conv_W32_W64(I32[_sajHA::I64]);
           _sajHH::I64 = %MO_SS_Conv_W16_W64(I16[_sajHA::I64 + 4]);
           if (I16[_sajHA::I64 + 6] == 0 :: W16) goto cak4u; else goto cak3w;
       cak4u: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajHD::I64;
           I64[Hp - 8] = _sajHH::I64;
           I64[Hp] = 0;
           I64[Sp - 8] = block_cak4t_info;
           R4 = Hp - 23;
           R3 = _sajFC::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
       cak3w: // global
           I64[Hp - 24] = sat_sajHT_info;
           I64[Hp - 16] = _sajHD::I64;
           _cak0T::P64 = Hp - 23;
           Hp = Hp - 16;
           I64[Sp - 24] = block_cak3s_info;
           R3 = P64[Sp + 40];
           R2 = _cak0T::P64;
           R1 = lvl11_rajBk_closure;
           I64[Sp - 16] = _sajHD::I64;
           I64[Sp - 8] = _sajHH::I64;
           Sp = Sp - 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cak4z: // global
           Hp = Hp - 32;
           call MO_Touch(P64[Sp + 16]);
           I64[Sp + 32] = block_cajXI_info;
           R1 = P64[_sajFC::P64 + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uak5I; else goto cajXJ;
       uak5I: // global
           call _cajXI(R1) args: 0, res: 0, upd: 0;
       cajXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak0C() //  [R1]
         { info_tbl: [(cak0C,
                       label: block_cak0C_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak0C: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cak0D() args: 0, res: 0, upd: 0;
     }
 },
 _cak4t() //  []
         { info_tbl: [(cak4t,
                       label: block_cak4t_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4t: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cak0D() args: 0, res: 0, upd: 0;
     }
 },
 _cak3s() //  [R1]
         { info_tbl: [(cak3s,
                       label: block_cak3s_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3s: // global
           I64[Sp] = block_cak3u_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uak5P; else goto cak3y;
       uak5P: // global
           call _cak3u(R1) args: 0, res: 0, upd: 0;
       cak3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak3u() //  [R1]
         { info_tbl: [(cak3u,
                       label: block_cak3u_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3u: // global
           if (R1 & 7 == 1) goto cak3E; else goto cak3J;
       cak3E: // global
           R1 = lvl5_rajBe_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cak3J: // global
           I64[Sp] = block_cak3H_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uak5Q; else goto cak3K;
       uak5Q: // global
           call _cak3H(R1) args: 0, res: 0, upd: 0;
       cak3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak3H() //  [R1]
         { info_tbl: [(cak3H,
                       label: block_cak3H_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3H: // global
           _sajI1::P64 = P64[R1 + 7];
           _sajI3::I64 = I64[Sp + 16];
           if (_sajI3::I64 != 0) goto cak43; else goto cak4o;
       cak43: // global
           _sajI6::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp - 8] = block_cak3R_info;
           R1 = _sajI6::P64;
           I64[Sp] = _sajI3::I64;
           P64[Sp + 16] = _sajI1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uak5R; else goto cak3S;
       uak5R: // global
           call _cak3R(R1) args: 0, res: 0, upd: 0;
       cak3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cak4o: // global
           I64[Sp + 16] = block_cak4n_info;
           R3 = _sajI1::P64;
           R2 = P64[Sp + 64];
           R1 = lvl10_rajBj_closure;
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak3R() //  [R1]
         { info_tbl: [(cak3R,
                       label: block_cak3R_info
                       rep:StackRep [True, True, False, True, True, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3R: // global
           I64[Sp - 8] = block_cak3W_info;
           _sajIa::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _sajIa::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uak5S; else goto cak3X;
       uak5S: // global
           call _cak3W(R1) args: 0, res: 0, upd: 0;
       cak3X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak3W() //  [R1]
         { info_tbl: [(cak3W,
                       label: block_cak3W_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3W: // global
           I64[Sp - 8] = block_cak41_info;
           _sajId::P64 = P64[R1 + 7];
           _sajIc::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sajId::P64;
           I64[Sp + 32] = _sajIc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uak5T; else goto cak46;
       uak5T: // global
           call _cak41(R1) args: 0, res: 0, upd: 0;
       cak46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak41() //  [R1]
         { info_tbl: [(cak41,
                       label: block_cak41_info
                       rep:StackRep [False, True, True, True, True, True, True, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak41: // global
           _sajIa::I64 = I64[Sp + 16];
           _sajIf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sajIf::I64, 0)) goto cak4l; else goto cak4k;
       cak4k: // global
           if (%MO_S_Ge_W64(_sajIf::I64,
                            _sajIa::I64)) goto cak4l; else goto cak4h;
       cak4l: // global
           R3 = _sajIf::I64;
           R2 = _sajIa::I64;
           Sp = Sp + 112;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       cak4h: // global
           _sajHx::I64 = I64[Sp + 56];
           _sajI3::I64 = I64[Sp + 24];
           _sajId::P64 = P64[Sp + 8];
           _sajIi::I64 = I64[Sp + 40] + (_sajIf::I64 << 3);
           I32[_sajIi::I64] = %MO_UU_Conv_W64_W32(I64[Sp + 32]);
           I16[_sajIi::I64 + 4] = %MO_UU_Conv_W64_W16(_sajI3::I64);
           I16[_sajIi::I64 + 6] = 0 :: W16;
           call MO_Touch(_sajId::P64);
           I64[Sp + 56] = _sajHx::I64 + 8;
           Sp = Sp + 48;
           call _cak0D() args: 0, res: 0, upd: 0;
     }
 },
 _cak4n() //  []
         { info_tbl: [(cak4n,
                       label: block_cak4n_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak4n: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cak0D() args: 0, res: 0, upd: 0;
     }
 },
 _cajXI() //  [R1]
         { info_tbl: [(cajXI,
                       label: block_cajXI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXI: // global
           I64[Sp - 8] = block_cajXN_info;
           _sajG3::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _sajG3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uak5C; else goto cajXO;
       uak5C: // global
           call _cajXN(R1) args: 0, res: 0, upd: 0;
       cajXO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajXN() //  [R1]
         { info_tbl: [(cajXN,
                       label: block_cajXN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXN: // global
           I64[Sp - 8] = block_cajXU_info;
           _sajG7::P64 = P64[R1 + 7];
           _sajG6::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sajG7::P64;
           I64[Sp + 24] = _sajG6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uak5D; else goto cajXV;
       uak5D: // global
           call _cajXU(R1) args: 0, res: 0, upd: 0;
       cajXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajXU() //  [R1]
         { info_tbl: [(cajXU,
                       label: block_cajXU_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajXU: // global
           if (R1 & 7 == 1) goto cak2v; else goto cak2D;
       cak2v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cak2y; else goto cak2x;
       cak2y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak2x: // global
           (_sajH9::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(I64[Sp + 32], I64[Sp + 16], 0);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _sajHa::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sajH9::I64));
           I64[Hp] = _sajHa::I64;
           I64[Sp + 32] = _sajHa::I64;
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
       cak2D: // global
           I64[Sp] = block_cak2B_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uak5E; else goto cak2E;
       uak5E: // global
           call _cak2B(R1) args: 0, res: 0, upd: 0;
       cak2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak2B() //  [R1]
         { info_tbl: [(cak2B,
                       label: block_cak2B_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak2B: // global
           _sajG3::I64 = I64[Sp + 16];
           _sajG6::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cak32; else goto cak3i;
       cak32: // global
           I64[Sp] = block_cak2X_info;
           R4 = (I64[R1 + 7] + 999999) / 1000000;
           R3 = _sajG3::I64;
           R2 = _sajG6::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
       cak3i: // global
           I64[Sp] = block_cak3e_info;
           R4 = (-1);
           R3 = _sajG3::I64;
           R2 = _sajG6::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cak2X() //  [R1]
         { info_tbl: [(cak2X,
                       label: block_cak2X_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak2X: // global
           I64[Sp] = block_cak2Z_info;
           _sajHn::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _sajHn::P64;
           if (R1 & 7 != 0) goto uak5L; else goto cak34;
       uak5L: // global
           call _cak2Z(R1) args: 0, res: 0, upd: 0;
       cak34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak2Z() //  [R1]
         { info_tbl: [(cak2Z,
                       label: block_cak2Z_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak2Z: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
     }
 },
 _cak3e() //  [R1]
         { info_tbl: [(cak3e,
                       label: block_cak3e_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3e: // global
           I64[Sp] = block_cak3g_info;
           _sajHt::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _sajHt::P64;
           if (R1 & 7 != 0) goto uak5N; else goto cak3k;
       uak5N: // global
           call _cak3g(R1) args: 0, res: 0, upd: 0;
       cak3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak3g() //  [R1]
         { info_tbl: [(cak3g,
                       label: block_cak3g_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak3g: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
     }
 },
 _sajG8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sajG8: // global
           _sajGT::I64 = I64[Sp + 24];
           if (_sajGT::I64 != (-1)) goto cak21; else goto cak2t;
       cak21: // global
           I64[Sp + 24] = _sajGT::I64;
           goto uak63;
       cak2t: // global
           (_sajGX::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           if (%MO_SS_Conv_W64_W32(_sajGX::I64) == 4 :: W32) goto cak2p; else goto cak2f;
       cak2p: // global
           I64[Sp + 24] = 0;
           goto uak63;
       uak63: // global
           call _cajYg() args: 0, res: 0, upd: 0;
       cak2f: // global
           I64[Sp - 8] = block_cak2b_info;
           R2 = lvl3_rajBc_closure;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cak2b() //  [R1]
         { info_tbl: [(cak2b,
                       label: block_cak2b_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak2b: // global
           I64[Sp] = block_cak2d_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uak5J; else goto cak2i;
       uak5J: // global
           call _cak2d(R1) args: 0, res: 0, upd: 0;
       cak2i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak2d() //  [R1]
         { info_tbl: [(cak2d,
                       label: block_cak2d_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak2d: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _cajYg() args: 0, res: 0, upd: 0;
     }
 },
 _cajYg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajYg: // global
           Hp = Hp + 24;
           _sajGe::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cak1P; else goto cak1O;
       cak1P: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_cajYf_info;
           R1 = _sajGe::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cak1O: // global
           _cajXy::P64 = P64[Sp + 16];
           _sajFp::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp]);
           if (_sajGe::I64 == 0) goto cak1Y; else goto cak1U;
       cak1Y: // global
           Hp = Hp - 24;
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cak1U: // global
           I64[Hp - 16] = sat_sajGO_info;
           P64[Hp - 8] = _sajFp::P64;
           I64[Hp] = _sajGe::I64;
           I64[Sp + 24] = block_cak1Q_info;
           R4 = Hp - 13;
           R3 = lvl1_rajBa_closure+1;
           R2 = _cajXy::P64;
           R1 = lvl6_rajBf_closure;
           I64[Sp + 32] = _sajGe::I64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajYf() //  [R1]
         { info_tbl: [(cajYf,
                       label: block_cajYf_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajYf: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cajYg() args: 0, res: 0, upd: 0;
     }
 },
 _cak1Q() //  [R1]
         { info_tbl: [(cak1Q,
                       label: block_cak1Q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak1Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cak1X; else goto cak1W;
       cak1X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cak1W: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.134923017 UTC

[section ""data" . GHC.Event.Poll.new4_closure" {
     GHC.Event.Poll.new4_closure:
         const GHC.Event.Poll.new4_info;
         const 0;
 },
 sat_sajJz_entry() //  [R1]
         { info_tbl: [(cak6u,
                       label: sat_sajJz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak6u: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cak6y; else goto cak6z;
       cak6y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cak6z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cak6r_info;
           _sajIY::P64 = P64[R1 + 24];
           _sajIZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sajIY::P64;
           P64[Sp - 24] = _sajIZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uakc0; else goto cak6s;
       uakc0: // global
           call _cak6r(R1) args: 0, res: 0, upd: 0;
       cak6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cak6r() //  [R1]
         { info_tbl: [(cak6r,
                       label: block_cak6r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak6r: // global
           I64[Sp] = block_cak6x_info;
           _sajJ9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajJ9::I64;
           if (R1 & 7 != 0) goto uakbZ; else goto cak6B;
       uakbZ: // global
           call _cak6x(R1) args: 0, res: 0, upd: 0;
       cak6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cak6x() //  [R1]
         { info_tbl: [(cak6x,
                       label: block_cak6x_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak6x: // global
           _sajIY::P64 = P64[Sp + 8];
           _sajJb::I64 = I64[R1 + 7];
           if (_sajJb::I64 & 1 == 0) goto cak98; else goto cak6L;
       cak98: // global
           if (_sajJb::I64 & 2 == 0) goto cakar; else goto cak9k;
       cakar: // global
           I64[Sp + 8] = block_cakaq_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakc4; else goto cakat;
       uakc4: // global
           call _cakaq(R1) args: 0, res: 0, upd: 0;
       cakat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cak9k: // global
           I64[Sp + 8] = block_cak9i_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakc3; else goto cak9m;
       uakc3: // global
           call _cak9i(R1) args: 0, res: 0, upd: 0;
       cak9m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cak6L: // global
           if (_sajJb::I64 & 2 == 0) goto cak84; else goto cak6X;
       cak84: // global
           I64[Sp + 8] = block_cak83_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakc2; else goto cak86;
       uakc2: // global
           call _cak83(R1) args: 0, res: 0, upd: 0;
       cak86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cak6X: // global
           I64[Sp + 8] = block_cak6V_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakc1; else goto cak6Z;
       uakc1: // global
           call _cak6V(R1) args: 0, res: 0, upd: 0;
       cak6Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakaq() //  [R1]
         { info_tbl: [(cakaq,
                       label: block_cakaq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakaq: // global
           _sajJv::I64 = I64[R1 + 7];
           if (_sajJv::I64 & 1 == 0) goto cakb4; else goto cakaD;
       cakb4: // global
           _sajJy::I64 = _sajJv::I64 & 2;
           if (_sajJy::I64 != 0) goto uakbW; else goto uakbV;
       uakbW: // global
           I64[Sp] = _sajJy::I64;
           call _cakbc() args: 0, res: 0, upd: 0;
       uakbV: // global
           I64[Sp] = _sajJy::I64;
           call _cakbm() args: 0, res: 0, upd: 0;
       cakaD: // global
           _sajJx::I64 = _sajJv::I64 & 2;
           if (_sajJx::I64 != 0) goto uakbS; else goto uakbR;
       uakbS: // global
           I64[Sp] = _sajJx::I64;
           call _cakaL() args: 0, res: 0, upd: 0;
       uakbR: // global
           I64[Sp] = _sajJx::I64;
           call _cakaV() args: 0, res: 0, upd: 0;
     }
 },
 _cakbc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakbc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakbj; else goto cakbi;
       cakbj: // global
           HpAlloc = 32;
           _sajJy::I64 = I64[Sp];
           I64[Sp] = block_cakbb_info;
           R1 = _sajJy::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakbi: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakbb() //  [R1]
         { info_tbl: [(cakbb,
                       label: block_cakbb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakbb: // global
           I64[Sp] = R1;
           call _cakbc() args: 0, res: 0, upd: 0;
     }
 },
 _cakbm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakbm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakbs; else goto cakbr;
       cakbs: // global
           HpAlloc = 32;
           _sajJy::I64 = I64[Sp];
           I64[Sp] = block_cakbl_info;
           R1 = _sajJy::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakbr: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakbl() //  [R1]
         { info_tbl: [(cakbl,
                       label: block_cakbl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakbl: // global
           I64[Sp] = R1;
           call _cakbm() args: 0, res: 0, upd: 0;
     }
 },
 _cakaL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakaL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakaS; else goto cakaR;
       cakaS: // global
           HpAlloc = 32;
           _sajJx::I64 = I64[Sp];
           I64[Sp] = block_cakaK_info;
           R1 = _sajJx::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakaR: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakaK() //  [R1]
         { info_tbl: [(cakaK,
                       label: block_cakaK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakaK: // global
           I64[Sp] = R1;
           call _cakaL() args: 0, res: 0, upd: 0;
     }
 },
 _cakaV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakaV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakb1; else goto cakb0;
       cakb1: // global
           HpAlloc = 32;
           _sajJx::I64 = I64[Sp];
           I64[Sp] = block_cakaU_info;
           R1 = _sajJx::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakb0: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakaU() //  [R1]
         { info_tbl: [(cakaU,
                       label: block_cakaU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakaU: // global
           I64[Sp] = R1;
           call _cakaV() args: 0, res: 0, upd: 0;
     }
 },
 _cak9i() //  [R1]
         { info_tbl: [(cak9i,
                       label: block_cak9i_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak9i: // global
           _sajJq::I64 = I64[R1 + 7];
           if (_sajJq::I64 & 1 == 0) goto cak9X; else goto cak9w;
       cak9X: // global
           _sajJt::I64 = _sajJq::I64 & 2;
           if (_sajJt::I64 != 0) goto uakbO; else goto uakbN;
       uakbO: // global
           I64[Sp] = _sajJt::I64;
           call _caka5() args: 0, res: 0, upd: 0;
       uakbN: // global
           I64[Sp] = _sajJt::I64;
           call _cakaf() args: 0, res: 0, upd: 0;
       cak9w: // global
           _sajJs::I64 = _sajJq::I64 & 2;
           if (_sajJs::I64 != 0) goto uakbK; else goto uakbJ;
       uakbK: // global
           I64[Sp] = _sajJs::I64;
           call _cak9E() args: 0, res: 0, upd: 0;
       uakbJ: // global
           I64[Sp] = _sajJs::I64;
           call _cak9O() args: 0, res: 0, upd: 0;
     }
 },
 _caka5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caka5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakac; else goto cakab;
       cakac: // global
           HpAlloc = 32;
           _sajJt::I64 = I64[Sp];
           I64[Sp] = block_caka4_info;
           R1 = _sajJt::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakab: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caka4() //  [R1]
         { info_tbl: [(caka4,
                       label: block_caka4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caka4: // global
           I64[Sp] = R1;
           call _caka5() args: 0, res: 0, upd: 0;
     }
 },
 _cakaf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakaf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakal; else goto cakak;
       cakal: // global
           HpAlloc = 32;
           _sajJt::I64 = I64[Sp];
           I64[Sp] = block_cakae_info;
           R1 = _sajJt::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakak: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakae() //  [R1]
         { info_tbl: [(cakae,
                       label: block_cakae_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakae: // global
           I64[Sp] = R1;
           call _cakaf() args: 0, res: 0, upd: 0;
     }
 },
 _cak9E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak9E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak9L; else goto cak9K;
       cak9L: // global
           HpAlloc = 32;
           _sajJs::I64 = I64[Sp];
           I64[Sp] = block_cak9D_info;
           R1 = _sajJs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak9K: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak9D() //  [R1]
         { info_tbl: [(cak9D,
                       label: block_cak9D_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak9D: // global
           I64[Sp] = R1;
           call _cak9E() args: 0, res: 0, upd: 0;
     }
 },
 _cak9O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak9O: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak9U; else goto cak9T;
       cak9U: // global
           HpAlloc = 32;
           _sajJs::I64 = I64[Sp];
           I64[Sp] = block_cak9N_info;
           R1 = _sajJs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak9T: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak9N() //  [R1]
         { info_tbl: [(cak9N,
                       label: block_cak9N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak9N: // global
           I64[Sp] = R1;
           call _cak9O() args: 0, res: 0, upd: 0;
     }
 },
 _cak83() //  [R1]
         { info_tbl: [(cak83,
                       label: block_cak83_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak83: // global
           _sajJk::I64 = I64[R1 + 7];
           if (_sajJk::I64 & 1 == 0) goto cak8H; else goto cak8g;
       cak8H: // global
           _sajJn::I64 = _sajJk::I64 & 2;
           if (_sajJn::I64 != 0) goto uakbG; else goto uakbF;
       uakbG: // global
           I64[Sp] = _sajJn::I64;
           call _cak8P() args: 0, res: 0, upd: 0;
       uakbF: // global
           I64[Sp] = _sajJn::I64;
           call _cak8Z() args: 0, res: 0, upd: 0;
       cak8g: // global
           _sajJm::I64 = _sajJk::I64 & 2;
           if (_sajJm::I64 != 0) goto uakbC; else goto uakbB;
       uakbC: // global
           I64[Sp] = _sajJm::I64;
           call _cak8o() args: 0, res: 0, upd: 0;
       uakbB: // global
           I64[Sp] = _sajJm::I64;
           call _cak8y() args: 0, res: 0, upd: 0;
     }
 },
 _cak8P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak8W; else goto cak8V;
       cak8W: // global
           HpAlloc = 32;
           _sajJn::I64 = I64[Sp];
           I64[Sp] = block_cak8O_info;
           R1 = _sajJn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak8V: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak8O() //  [R1]
         { info_tbl: [(cak8O,
                       label: block_cak8O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8O: // global
           I64[Sp] = R1;
           call _cak8P() args: 0, res: 0, upd: 0;
     }
 },
 _cak8Z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak95; else goto cak94;
       cak95: // global
           HpAlloc = 32;
           _sajJn::I64 = I64[Sp];
           I64[Sp] = block_cak8Y_info;
           R1 = _sajJn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak94: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak8Y() //  [R1]
         { info_tbl: [(cak8Y,
                       label: block_cak8Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8Y: // global
           I64[Sp] = R1;
           call _cak8Z() args: 0, res: 0, upd: 0;
     }
 },
 _cak8o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak8v; else goto cak8u;
       cak8v: // global
           HpAlloc = 32;
           _sajJm::I64 = I64[Sp];
           I64[Sp] = block_cak8n_info;
           R1 = _sajJm::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak8u: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak8n() //  [R1]
         { info_tbl: [(cak8n,
                       label: block_cak8n_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8n: // global
           I64[Sp] = R1;
           call _cak8o() args: 0, res: 0, upd: 0;
     }
 },
 _cak8y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak8E; else goto cak8D;
       cak8E: // global
           HpAlloc = 32;
           _sajJm::I64 = I64[Sp];
           I64[Sp] = block_cak8x_info;
           R1 = _sajJm::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak8D: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak8x() //  [R1]
         { info_tbl: [(cak8x,
                       label: block_cak8x_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak8x: // global
           I64[Sp] = R1;
           call _cak8y() args: 0, res: 0, upd: 0;
     }
 },
 _cak6V() //  [R1]
         { info_tbl: [(cak6V,
                       label: block_cak6V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak6V: // global
           _sajJf::I64 = I64[R1 + 7];
           if (_sajJf::I64 & 1 == 0) goto cak7A; else goto cak79;
       cak7A: // global
           _sajJi::I64 = _sajJf::I64 & 2;
           if (_sajJi::I64 != 0) goto uakby; else goto uakbx;
       uakby: // global
           I64[Sp] = _sajJi::I64;
           call _cak7I() args: 0, res: 0, upd: 0;
       uakbx: // global
           I64[Sp] = _sajJi::I64;
           call _cak7S() args: 0, res: 0, upd: 0;
       cak79: // global
           _sajJh::I64 = _sajJf::I64 & 2;
           if (_sajJh::I64 != 0) goto uakbu; else goto uakbt;
       uakbu: // global
           I64[Sp] = _sajJh::I64;
           call _cak7h() args: 0, res: 0, upd: 0;
       uakbt: // global
           I64[Sp] = _sajJh::I64;
           call _cak7r() args: 0, res: 0, upd: 0;
     }
 },
 _cak7I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak7P; else goto cak7O;
       cak7P: // global
           HpAlloc = 32;
           _sajJi::I64 = I64[Sp];
           I64[Sp] = block_cak7H_info;
           R1 = _sajJi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak7O: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak7H() //  [R1]
         { info_tbl: [(cak7H,
                       label: block_cak7H_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7H: // global
           I64[Sp] = R1;
           call _cak7I() args: 0, res: 0, upd: 0;
     }
 },
 _cak7S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak7Y; else goto cak7X;
       cak7Y: // global
           HpAlloc = 32;
           _sajJi::I64 = I64[Sp];
           I64[Sp] = block_cak7R_info;
           R1 = _sajJi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak7X: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak7R() //  [R1]
         { info_tbl: [(cak7R,
                       label: block_cak7R_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7R: // global
           I64[Sp] = R1;
           call _cak7S() args: 0, res: 0, upd: 0;
     }
 },
 _cak7h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak7o; else goto cak7n;
       cak7o: // global
           HpAlloc = 32;
           _sajJh::I64 = I64[Sp];
           I64[Sp] = block_cak7g_info;
           R1 = _sajJh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak7n: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak7g() //  [R1]
         { info_tbl: [(cak7g,
                       label: block_cak7g_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7g: // global
           I64[Sp] = R1;
           call _cak7h() args: 0, res: 0, upd: 0;
     }
 },
 _cak7r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cak7x; else goto cak7w;
       cak7x: // global
           HpAlloc = 32;
           _sajJh::I64 = I64[Sp];
           I64[Sp] = block_cak7q_info;
           R1 = _sajJh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cak7w: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cak7q() //  [R1]
         { info_tbl: [(cak7q,
                       label: block_cak7q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak7q: // global
           I64[Sp] = R1;
           call _cak7r() args: 0, res: 0, upd: 0;
     }
 },
 sat_sajJD_entry() //  [R1, R2]
         { info_tbl: [(cakcB,
                       label: sat_sajJD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakcB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakcD; else goto cakcE;
       cakcD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakcE: // global
           I64[Sp - 32] = block_cak6i_info;
           _sajIX::P64 = P64[R1 + 6];
           _sajIY::P64 = P64[R1 + 14];
           _sajIZ::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sajIX::P64;
           P64[Sp - 16] = _sajIY::P64;
           P64[Sp - 8] = _sajIZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakcK; else goto cak6j;
       uakcK: // global
           call _cak6i(R1) args: 0, res: 0, upd: 0;
       cak6j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak6i() //  [R1]
         { info_tbl: [(cak6i,
                       label: block_cak6i_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak6i: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakcH; else goto cakcG;
       cakcH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakcG: // global
           _sajJ7::P64 = P64[R1 + 7];
           I64[Hp - 32] = sat_sajJz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cakcC_info;
           R4 = Hp - 32;
           R3 = _sajJ7::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cakcC() //  []
         { info_tbl: [(cakcC,
                       label: block_cakcC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakcC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cakcL,
                       label: GHC.Event.Poll.new4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakcL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakcM; else goto cakcN;
       cakcM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakcN: // global
           I64[Sp - 32] = block_cak68_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakcR; else goto cak69;
       uakcR: // global
           call _cak68(R1) args: 0, res: 0, upd: 0;
       cak69: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cak68() //  [R1]
         { info_tbl: [(cak68,
                       label: block_cak68_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak68: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakcQ; else goto cakcP;
       cakcQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakcP: // global
           _sajJ2::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sajJD_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R3 = Hp - 22;
           R2 = _sajJ2::P64;
           Sp = Sp + 32;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.146988352 UTC

[section ""data" . GHC.Event.Poll.new2_closure" {
     GHC.Event.Poll.new2_closure:
         const GHC.Event.Poll.new2_info;
 },
 GHC.Event.Poll.new2_entry() //  []
         { info_tbl: [(cakcW,
                       label: GHC.Event.Poll.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakcW: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.148287035 UTC

[section ""data" . GHC.Event.Poll.new1_closure" {
     GHC.Event.Poll.new1_closure:
         const GHC.Event.Poll.new1_info;
         const 0;
 },
 GHC.Event.Poll.new1_entry() //  []
         { info_tbl: [(cakdo,
                       label: GHC.Event.Poll.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakdo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakdp; else goto cakdq;
       cakdp: // global
           R1 = GHC.Event.Poll.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cakdq: // global
           I64[Sp - 8] = block_cakd3_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakd3() //  [R1]
         { info_tbl: [(cakd3,
                       label: block_cakd3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakd3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakdt; else goto cakds;
       cakdt: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakds: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cakd8_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakd8() //  [R1]
         { info_tbl: [(cakd8,
                       label: block_cakd8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakd8: // global
           I64[Sp - 8] = block_cakda_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cakda() //  [R1]
         { info_tbl: [(cakda,
                       label: block_cakda_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakda: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakdx; else goto cakdw;
       cakdx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakdw: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cakdd_info;
           R2 = Hp - 7;
           _sajJS::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sajJS::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakdd() //  []
         { info_tbl: [(cakdd,
                       label: block_cakdd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakdd: // global
           I64[Sp] = block_cakdf_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakdf() //  [R1]
         { info_tbl: [(cakdf,
                       label: block_cakdf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakdf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakdB; else goto cakdA;
       cakdB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakdA: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cakdk_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakdk() //  [R1]
         { info_tbl: [(cakdk,
                       label: block_cakdk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakdk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakdE; else goto cakdD;
       cakdE: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakdD: // global
           I64[Hp - 64] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.Event.Internal.Backend_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = GHC.Event.Poll.new5_closure+4;
           P64[Hp - 16] = GHC.Event.Poll.new4_closure+5;
           P64[Hp - 8] = GHC.Event.Poll.new3_closure;
           P64[Hp] = GHC.Event.Poll.new2_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.150502942 UTC

[section ""data" . GHC.Event.Poll.new_closure" {
     GHC.Event.Poll.new_closure:
         const GHC.Event.Poll.new_info;
         const 0;
 },
 GHC.Event.Poll.new_entry() //  []
         { info_tbl: [(cakdJ,
                       label: GHC.Event.Poll.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakdJ: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.151345359 UTC

[section ""data" . GHC.Event.Poll.PollFd_closure" {
     GHC.Event.Poll.PollFd_closure:
         const GHC.Event.Poll.PollFd_info;
 },
 GHC.Event.Poll.PollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(cakdR,
                       label: GHC.Event.Poll.PollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakdR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakdV; else goto cakdU;
       cakdV: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.PollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakdU: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.15240015 UTC

[section ""data" . GHC.Event.Poll.Poll_closure" {
     GHC.Event.Poll.Poll_closure:
         const GHC.Event.Poll.Poll_info;
 },
 GHC.Event.Poll.Poll_entry() //  [R2, R3]
         { info_tbl: [(cake1,
                       label: GHC.Event.Poll.Poll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cake1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cake5; else goto cake4;
       cake5: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.Poll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cake4: // global
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.153235434 UTC

[GHC.Event.Poll.PollFd_con_entry() //  [R1]
         { info_tbl: [(cake6,
                       label: GHC.Event.Poll.PollFd_con_info
                       rep:HeapRep 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108,70,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cake6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.153993074 UTC

[GHC.Event.Poll.Poll_con_entry() //  [R1]
         { info_tbl: [(cake7,
                       label: GHC.Event.Poll.Poll_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cake7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.154651655 UTC

[section ""relreadonly" . SajSl_srt" {
     SajSl_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Poll.$w$cshowsPrec1_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure;
         const GHC.Event.Poll.$fShowPollFd1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.loop_closure;
         const GHC.Event.Array.removeAt_closure;
         const GHC.Event.Array.findIndex_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.$wlvl_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Poll.new5_closure;
         const lvl3_rajBc_closure;
         const lvl5_rajBe_closure;
         const lvl6_rajBf_closure;
         const lvl10_rajBj_closure;
         const lvl11_rajBk_closure;
         const GHC.Event.Poll.new4_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Poll.new3_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.15529947 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:19.156249896 UTC

[section ""data" . GHC.Event.Poll.$WPollFd_closure" {
     GHC.Event.Poll.$WPollFd_closure:
         const GHC.Event.Poll.$WPollFd_info;
 },
 GHC.Event.Poll.$WPollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(cakef,
                       label: GHC.Event.Poll.$WPollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakef: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caket; else goto cakeu;
       caket: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakeu: // global
           I64[Sp - 24] = block_cakec_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakeB; else goto caked;
       uakeB: // global
           call _cakec(R1) args: 0, res: 0, upd: 0;
       caked: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakec() //  [R1]
         { info_tbl: [(cakec,
                       label: block_cakec_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakec: // global
           I64[Sp] = block_cakei_info;
           _sajBq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajBq::I64;
           if (R1 & 7 != 0) goto uakeA; else goto cakej;
       uakeA: // global
           call _cakei(R1) args: 0, res: 0, upd: 0;
       cakej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakei() //  [R1]
         { info_tbl: [(cakei,
                       label: block_cakei_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakei: // global
           I64[Sp] = block_caken_info;
           _sajBs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajBs::I64;
           if (R1 & 7 != 0) goto uakeC; else goto cakeo;
       uakeC: // global
           call _caken(R1) args: 0, res: 0, upd: 0;
       cakeo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caken() //  [R1]
         { info_tbl: [(caken,
                       label: block_caken_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caken: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakez; else goto cakey;
       cakez: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakey: // global
           _sajBu::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sajBu::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.158092138 UTC

[section ""data" . GHC.Event.Poll.$WPoll_closure" {
     GHC.Event.Poll.$WPoll_closure:
         const GHC.Event.Poll.$WPoll_info;
 },
 GHC.Event.Poll.$WPoll_entry() //  [R2, R3]
         { info_tbl: [(cakeK,
                       label: GHC.Event.Poll.$WPoll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakeT; else goto cakeU;
       cakeT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPoll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakeU: // global
           I64[Sp - 16] = block_cakeH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakf0; else goto cakeI;
       uakf0: // global
           call _cakeH(R1) args: 0, res: 0, upd: 0;
       cakeI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakeH() //  [R1]
         { info_tbl: [(cakeH,
                       label: block_cakeH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakeH: // global
           I64[Sp] = block_cakeN_info;
           _sajBy::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sajBy::P64;
           if (R1 & 7 != 0) goto uakeZ; else goto cakeO;
       uakeZ: // global
           call _cakeN(R1) args: 0, res: 0, upd: 0;
       cakeO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakeN() //  [R1]
         { info_tbl: [(cakeN,
                       label: block_cakeN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakeN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakeY; else goto cakeX;
       cakeY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakeX: // global
           _sajBA::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sajBA::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.159469269 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$calignment_closure" {
     GHC.Event.Poll.$fStorablePollFd_$calignment_closure:
         const GHC.Event.Poll.$fStorablePollFd_$calignment_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$calignment_entry() //  []
         { info_tbl: [(cakf5,
                       label: GHC.Event.Poll.$fStorablePollFd_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakf5: // global
           R1 = Foreign.Storable.$fStorableBool7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.160140094 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd7_closure" {
     GHC.Event.Poll.$fStorablePollFd7_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.160795761 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure" {
     GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure:
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$csizeOf_entry() //  []
         { info_tbl: [(cakfc,
                       label: GHC.Event.Poll.$fStorablePollFd_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakfc: // global
           R1 = GHC.Event.Poll.$fStorablePollFd7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.16195942 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd2_closure" {
     GHC.Event.Poll.$fStorablePollFd2_closure:
         const GHC.Event.Poll.$fStorablePollFd2_info;
 },
 GHC.Event.Poll.$fStorablePollFd2_entry() //  [R2]
         { info_tbl: [(cakfm,
                       label: GHC.Event.Poll.$fStorablePollFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakfm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakfw; else goto cakfx;
       cakfw: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakfx: // global
           I64[Sp - 8] = block_cakfj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakfB; else goto cakfk;
       uakfB: // global
           call _cakfj(R1) args: 0, res: 0, upd: 0;
       cakfk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakfj() //  [R1]
         { info_tbl: [(cakfj,
                       label: block_cakfj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakfj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakfA; else goto cakfz;
       cakfA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakfz: // global
           _sajBG::I64 = I64[R1 + 7];
           _sajBJ::I64 = %MO_SS_Conv_W32_W64(I32[_sajBG::I64]);
           _sajBN::I64 = %MO_SS_Conv_W16_W64(I16[_sajBG::I64 + 4]);
           _sajBR::I64 = %MO_SS_Conv_W16_W64(I16[_sajBG::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajBJ::I64;
           I64[Hp - 8] = _sajBN::I64;
           I64[Hp] = _sajBR::I64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.163534909 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd6_closure" {
     GHC.Event.Poll.$fStorablePollFd6_closure:
         const GHC.Event.Poll.$fStorablePollFd6_info;
 },
 GHC.Event.Poll.$fStorablePollFd6_entry() //  [R2, R3]
         { info_tbl: [(cakfJ,
                       label: GHC.Event.Poll.$fStorablePollFd6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakfJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakg4; else goto cakg5;
       cakg4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakg5: // global
           I64[Sp - 16] = block_cakfG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakgb; else goto cakfH;
       uakgb: // global
           call _cakfG(R1) args: 0, res: 0, upd: 0;
       cakfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakfG() //  [R1]
         { info_tbl: [(cakfG,
                       label: block_cakfG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakfG: // global
           I64[Sp] = block_cakfM_info;
           _sajBX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajBX::I64;
           if (R1 & 7 != 0) goto uakga; else goto cakfN;
       uakga: // global
           call _cakfM(R1) args: 0, res: 0, upd: 0;
       cakfN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakfM() //  [R1]
         { info_tbl: [(cakfM,
                       label: block_cakfM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakfM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakg9; else goto cakg8;
       cakg9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakg8: // global
           _sajC0::I64 = I64[Sp + 8] + (I64[R1 + 7] << 3);
           _sajC4::I64 = %MO_SS_Conv_W32_W64(I32[_sajC0::I64]);
           _sajC8::I64 = %MO_SS_Conv_W16_W64(I16[_sajC0::I64 + 4]);
           _sajCc::I64 = %MO_SS_Conv_W16_W64(I16[_sajC0::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajC4::I64;
           I64[Hp - 8] = _sajC8::I64;
           I64[Hp] = _sajCc::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.165328265 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd4_closure" {
     GHC.Event.Poll.$fStorablePollFd4_closure:
         const GHC.Event.Poll.$fStorablePollFd4_info;
 },
 GHC.Event.Poll.$fStorablePollFd4_entry() //  [R2, R3]
         { info_tbl: [(cakgj,
                       label: GHC.Event.Poll.$fStorablePollFd4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakgj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakgB; else goto cakgC;
       cakgB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakgC: // global
           I64[Sp - 16] = block_cakgg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakgI; else goto cakgh;
       uakgI: // global
           call _cakgg(R1) args: 0, res: 0, upd: 0;
       cakgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakgg() //  [R1]
         { info_tbl: [(cakgg,
                       label: block_cakgg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakgg: // global
           I64[Sp] = block_cakgm_info;
           _sajCi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCi::I64;
           if (R1 & 7 != 0) goto uakgH; else goto cakgn;
       uakgH: // global
           call _cakgm(R1) args: 0, res: 0, upd: 0;
       cakgn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakgm() //  [R1]
         { info_tbl: [(cakgm,
                       label: block_cakgm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakgm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakgG; else goto cakgF;
       cakgG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakgF: // global
           _sajCl::I64 = I64[Sp + 8] + I64[R1 + 7];
           _sajCo::I64 = %MO_SS_Conv_W32_W64(I32[_sajCl::I64]);
           _sajCs::I64 = %MO_SS_Conv_W16_W64(I16[_sajCl::I64 + 4]);
           _sajCw::I64 = %MO_SS_Conv_W16_W64(I16[_sajCl::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajCo::I64;
           I64[Hp - 8] = _sajCs::I64;
           I64[Hp] = _sajCw::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.167031256 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd1_closure" {
     GHC.Event.Poll.$fStorablePollFd1_closure:
         const GHC.Event.Poll.$fStorablePollFd1_info;
 },
 GHC.Event.Poll.$fStorablePollFd1_entry() //  [R2, R3]
         { info_tbl: [(cakgQ,
                       label: GHC.Event.Poll.$fStorablePollFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakgQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakgU; else goto cakgV;
       cakgU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakgV: // global
           I64[Sp - 16] = block_cakgN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakh7; else goto cakgO;
       uakh7: // global
           call _cakgN(R1) args: 0, res: 0, upd: 0;
       cakgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakgN() //  [R1]
         { info_tbl: [(cakgN,
                       label: block_cakgN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakgN: // global
           I64[Sp] = block_cakgT_info;
           _sajCC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCC::I64;
           if (R1 & 7 != 0) goto uakh6; else goto cakgX;
       uakh6: // global
           call _cakgT(R1) args: 0, res: 0, upd: 0;
       cakgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakgT() //  [R1]
         { info_tbl: [(cakgT,
                       label: block_cakgT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakgT: // global
           _sajCC::I64 = I64[Sp + 8];
           _sajCF::I64 = I64[R1 + 15];
           _sajCG::I64 = I64[R1 + 23];
           I32[_sajCC::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajCC::I64 + 4] = %MO_UU_Conv_W64_W16(_sajCF::I64);
           I16[_sajCC::I64 + 6] = %MO_UU_Conv_W64_W16(_sajCG::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.168711717 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd5_closure" {
     GHC.Event.Poll.$fStorablePollFd5_closure:
         const GHC.Event.Poll.$fStorablePollFd5_info;
 },
 GHC.Event.Poll.$fStorablePollFd5_entry() //  [R2, R3, R4]
         { info_tbl: [(cakhf,
                       label: GHC.Event.Poll.$fStorablePollFd5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakho; else goto cakhp;
       cakho: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakhp: // global
           I64[Sp - 24] = block_cakhc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakhI; else goto cakhd;
       uakhI: // global
           call _cakhc(R1) args: 0, res: 0, upd: 0;
       cakhd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakhc() //  [R1]
         { info_tbl: [(cakhc,
                       label: block_cakhc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhc: // global
           I64[Sp] = block_cakhi_info;
           _sajCR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCR::I64;
           if (R1 & 7 != 0) goto uakhH; else goto cakhj;
       uakhH: // global
           call _cakhi(R1) args: 0, res: 0, upd: 0;
       cakhj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakhi() //  [R1]
         { info_tbl: [(cakhi,
                       label: block_cakhi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhi: // global
           I64[Sp] = block_cakhn_info;
           _sajCT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajCT::I64;
           if (R1 & 7 != 0) goto uakhJ; else goto cakhs;
       uakhJ: // global
           call _cakhn(R1) args: 0, res: 0, upd: 0;
       cakhs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakhn() //  [R1]
         { info_tbl: [(cakhn,
                       label: block_cakhn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhn: // global
           _sajCW::I64 = I64[R1 + 15];
           _sajCX::I64 = I64[R1 + 23];
           _sajCY::I64 = I64[Sp + 8] + (I64[Sp + 16] << 3);
           I32[_sajCY::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajCY::I64 + 4] = %MO_UU_Conv_W64_W16(_sajCW::I64);
           I16[_sajCY::I64 + 6] = %MO_UU_Conv_W64_W16(_sajCX::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.170608245 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd3_closure" {
     GHC.Event.Poll.$fStorablePollFd3_closure:
         const GHC.Event.Poll.$fStorablePollFd3_info;
 },
 GHC.Event.Poll.$fStorablePollFd3_entry() //  [R2, R3, R4]
         { info_tbl: [(cakhR,
                       label: GHC.Event.Poll.$fStorablePollFd3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caki0; else goto caki1;
       caki0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caki1: // global
           I64[Sp - 24] = block_cakhO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakih; else goto cakhP;
       uakih: // global
           call _cakhO(R1) args: 0, res: 0, upd: 0;
       cakhP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakhO() //  [R1]
         { info_tbl: [(cakhO,
                       label: block_cakhO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhO: // global
           I64[Sp] = block_cakhU_info;
           _sajDa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajDa::I64;
           if (R1 & 7 != 0) goto uakig; else goto cakhV;
       uakig: // global
           call _cakhU(R1) args: 0, res: 0, upd: 0;
       cakhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakhU() //  [R1]
         { info_tbl: [(cakhU,
                       label: block_cakhU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhU: // global
           I64[Sp] = block_cakhZ_info;
           _sajDc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajDc::I64;
           if (R1 & 7 != 0) goto uakii; else goto caki4;
       uakii: // global
           call _cakhZ(R1) args: 0, res: 0, upd: 0;
       caki4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakhZ() //  [R1]
         { info_tbl: [(cakhZ,
                       label: block_cakhZ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakhZ: // global
           _sajDf::I64 = I64[R1 + 15];
           _sajDg::I64 = I64[R1 + 23];
           _sajDh::I64 = I64[Sp + 8] + I64[Sp + 16];
           I32[_sajDh::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajDh::I64 + 4] = %MO_UU_Conv_W64_W16(_sajDf::I64);
           I16[_sajDh::I64 + 6] = %MO_UU_Conv_W64_W16(_sajDg::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.172100982 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_closure" {
     GHC.Event.Poll.$fStorablePollFd_closure:
         const Foreign.Storable.C:Storable_con_info;
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure+1;
         const GHC.Event.Poll.$fStorablePollFd_$calignment_closure+1;
         const GHC.Event.Poll.$fStorablePollFd6_closure+3;
         const GHC.Event.Poll.$fStorablePollFd5_closure+4;
         const GHC.Event.Poll.$fStorablePollFd4_closure+3;
         const GHC.Event.Poll.$fStorablePollFd3_closure+4;
         const GHC.Event.Poll.$fStorablePollFd2_closure+2;
         const GHC.Event.Poll.$fStorablePollFd1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.172761225 UTC

[section ""data" . GHC.Event.Poll.$fStorableEvent_closure" {
     GHC.Event.Poll.$fStorableEvent_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.17366127 UTC

[section ""cstring" . GHC.Event.Poll.$fShowEvent2_bytes" {
     GHC.Event.Poll.$fShowEvent2_bytes:
         I8[] [69,118,101,110,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.175325449 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec_closure" {
     GHC.Event.Poll.$w$cshowsPrec_closure:
         const GHC.Event.Poll.$w$cshowsPrec_info;
 },
 sat_sajDw_entry() //  [R1]
         { info_tbl: [(cakix,
                       label: sat_sajDw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakix: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakiD; else goto cakiE;
       cakiD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakiE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cakiu_info;
           _sajDp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sajDp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakiJ; else goto cakiv;
       uakiJ: // global
           call _cakiu(R1) args: 0, res: 0, upd: 0;
       cakiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakiu() //  [R1]
         { info_tbl: [(cakiu,
                       label: block_cakiu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakiu: // global
           _sajDp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cakiA_info;
           R4 = _sajDp::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakiA() //  [R1, R2]
         { info_tbl: [(cakiA,
                       label: block_cakiA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakiA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakiI; else goto cakiH;
       cakiI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakiH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajDD_entry() //  [R1]
         { info_tbl: [(cakiW,
                       label: sat_sajDD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakiW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakj3; else goto cakj4;
       cakj3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakj4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cakiT_info;
           _sajDp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sajDp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakjb; else goto cakiU;
       uakjb: // global
           call _cakiT(R1) args: 0, res: 0, upd: 0;
       cakiU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakiT() //  [R1]
         { info_tbl: [(cakiT,
                       label: block_cakiT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakiT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakj7; else goto cakj6;
       cakj7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cakj6: // global
           _sajDy::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cakj0_info;
           R4 = Hp - 14;
           R3 = _sajDy::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakj0() //  [R1, R2]
         { info_tbl: [(cakj0,
                       label: block_cakj0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakj0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakja; else goto cakj9;
       cakja: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakj9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajDE_entry() //  [R1]
         { info_tbl: [(cakjc,
                       label: sat_sajDE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakjc: // global
           _sajDE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakjd; else goto cakje;
       cakje: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakjg; else goto cakjf;
       cakjg: // global
           HpAlloc = 32;
           goto cakjd;
       cakjd: // global
           R1 = _sajDE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakjf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajDE::P64;
           _sajDo::P64 = P64[_sajDE::P64 + 16];
           _sajDp::P64 = P64[_sajDE::P64 + 24];
           I64[Hp - 24] = sat_sajDD_info;
           P64[Hp - 8] = _sajDo::P64;
           P64[Hp] = _sajDp::P64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cakjk,
                       label: GHC.Event.Poll.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakjk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cakjo; else goto cakjn;
       cakjo: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakjn: // global
           if (%MO_S_Lt_W64(R2, 11)) goto cakji; else goto cakjj;
       cakji: // global
           I64[Hp - 48] = sat_sajDw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _cakiq::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cakiq::P64;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cakjj: // global
           I64[Hp - 48] = sat_sajDE_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.178413324 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cakjx,
                       label: GHC.Event.Poll.$fShowEvent_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakjx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakjy; else goto cakjz;
       cakjy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakjz: // global
           I64[Sp - 24] = block_cakju_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakjD; else goto cakjv;
       uakjD: // global
           call _cakju(R1) args: 0, res: 0, upd: 0;
       cakjv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakju() //  [R1]
         { info_tbl: [(cakju,
                       label: block_cakju_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakju: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.179922763 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshow_closure" {
     GHC.Event.Poll.$fShowEvent_$cshow_closure:
         const GHC.Event.Poll.$fShowEvent_$cshow_info;
 },
 sat_sajDQ_entry() //  [R1]
         { info_tbl: [(cakjP,
                       label: sat_sajDQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakjP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakjV; else goto cakjW;
       cakjV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakjW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cakjM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakk1; else goto cakjN;
       uakk1: // global
           call _cakjM(R1) args: 0, res: 0, upd: 0;
       cakjN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakjM() //  [R1]
         { info_tbl: [(cakjM,
                       label: block_cakjM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakjM: // global
           I64[Sp] = block_cakjS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakjS() //  [R1, R2]
         { info_tbl: [(cakjS,
                       label: block_cakjS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakjS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakk0; else goto cakjZ;
       cakk0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakjZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$fShowEvent_$cshow_entry() //  [R2]
         { info_tbl: [(cakk2,
                       label: GHC.Event.Poll.$fShowEvent_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakk2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakk6; else goto cakk5;
       cakk6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakk5: // global
           I64[Hp - 16] = sat_sajDQ_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.181595067 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent1_closure" {
     GHC.Event.Poll.$fShowEvent1_closure:
         const GHC.Event.Poll.$fShowEvent1_info;
 },
 GHC.Event.Poll.$fShowEvent1_entry() //  [R2, R3]
         { info_tbl: [(cakkb,
                       label: GHC.Event.Poll.$fShowEvent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakkb: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.182385509 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowList_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowList_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowList_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cakki,
                       label: GHC.Event.Poll.$fShowEvent_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakki: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowEvent1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.18313291 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_closure" {
     GHC.Event.Poll.$fShowEvent_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowEvent_$cshow_closure+1;
         const GHC.Event.Poll.$fShowEvent_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.183729346 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd6_bytes" {
     GHC.Event.Poll.$fShowPollFd6_bytes:
         I8[] [80,111,108,108,70,100,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.18428578 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd5_bytes" {
     GHC.Event.Poll.$fShowPollFd5_bytes:
         I8[] [112,102,100,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.184851126 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd4_bytes" {
     GHC.Event.Poll.$fShowPollFd4_bytes:
         I8[] [112,102,100,69,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.185403828 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd3_bytes" {
     GHC.Event.Poll.$fShowPollFd3_bytes:
         I8[] [112,102,100,82,101,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.185950646 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd2_bytes" {
     GHC.Event.Poll.$fShowPollFd2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.188670729 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec1_closure" {
     GHC.Event.Poll.$w$cshowsPrec1_closure:
         const GHC.Event.Poll.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Poll.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakkm: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajE4_entry() //  [R1]
         { info_tbl: [(cakl5,
                       label: sat_sajE4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakl5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakl6; else goto cakl7;
       cakl6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Poll.$fShowPollFd2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE5_entry() //  [R1]
         { info_tbl: [(cakl9,
                       label: sat_sajE5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakl9: // global
           _sajE5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakla; else goto caklb;
       caklb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakld; else goto caklc;
       cakld: // global
           HpAlloc = 40;
           goto cakla;
       cakla: // global
           R1 = _sajE5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE5::P64;
           _sajE1::P64 = P64[_sajE5::P64 + 16];
           _sajDY::I64 = I64[_sajE5::P64 + 24];
           I64[Hp - 32] = sat_sajE4_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajDY::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE6_entry() //  [R1]
         { info_tbl: [(cakle,
                       label: sat_sajE6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakle: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakli; else goto caklh;
       cakli: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklh: // global
           _sajE1::P64 = P64[R1 + 16];
           _sajDY::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_sajE5_info;
           P64[Hp - 8] = _sajE1::P64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowPollFd3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajE7_entry() //  [R1]
         { info_tbl: [(caklj,
                       label: sat_sajE7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklj: // global
           _sajE7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caklk; else goto cakll;
       cakll: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakln; else goto caklm;
       cakln: // global
           HpAlloc = 32;
           goto caklk;
       caklk: // global
           R1 = _sajE7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE7::P64;
           _sajE1::P64 = P64[_sajE7::P64 + 16];
           _sajDY::I64 = I64[_sajE7::P64 + 24];
           I64[Hp - 24] = sat_sajE6_info;
           P64[Hp - 8] = _sajE1::P64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE8_entry() //  [R1]
         { info_tbl: [(caklp,
                       label: sat_sajE8_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklp: // global
           _sajE8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caklq; else goto caklr;
       caklr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caklt; else goto cakls;
       caklt: // global
           HpAlloc = 48;
           goto caklq;
       caklq: // global
           R1 = _sajE8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakls: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE8::P64;
           _sajE1::P64 = P64[_sajE8::P64 + 16];
           _sajDX::I64 = I64[_sajE8::P64 + 24];
           _sajDY::I64 = I64[_sajE8::P64 + 32];
           I64[Hp - 40] = sat_sajE7_info;
           P64[Hp - 24] = _sajE1::P64;
           I64[Hp - 16] = _sajDY::I64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajDX::I64;
           R4 = Hp - 40;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE9_entry() //  [R1]
         { info_tbl: [(caklu,
                       label: sat_sajE9_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakly; else goto caklx;
       cakly: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklx: // global
           _sajE1::P64 = P64[R1 + 16];
           _sajDX::I64 = I64[R1 + 24];
           _sajDY::I64 = I64[R1 + 32];
           I64[Hp - 32] = sat_sajE8_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Poll.$fShowPollFd4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajEa_entry() //  [R1]
         { info_tbl: [(caklz,
                       label: sat_sajEa_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklz: // global
           _sajEa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caklA; else goto caklB;
       caklB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caklD; else goto caklC;
       caklD: // global
           HpAlloc = 40;
           goto caklA;
       caklA: // global
           R1 = _sajEa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEa::P64;
           _sajE1::P64 = P64[_sajEa::P64 + 16];
           _sajDX::I64 = I64[_sajEa::P64 + 24];
           _sajDY::I64 = I64[_sajEa::P64 + 32];
           I64[Hp - 32] = sat_sajE9_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajEe_entry() //  [R1]
         { info_tbl: [(caklH,
                       label: sat_sajEe_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklH: // global
           _sajEe::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto caklI; else goto caklJ;
       caklJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caklL; else goto caklK;
       caklL: // global
           HpAlloc = 40;
           goto caklI;
       caklI: // global
           R1 = _sajEe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEe::P64;
           _sajE1::P64 = P64[_sajEe::P64 + 16];
           _sajDW::I64 = I64[_sajEe::P64 + 24];
           _sajDX::I64 = I64[_sajEe::P64 + 32];
           _sajDY::I64 = I64[_sajEe::P64 + 40];
           I64[Hp - 32] = sat_sajEa_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           I64[Sp - 24] = block_caklE_info;
           R4 = Hp - 32;
           R3 = _sajDW::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caklE() //  [R1, R2]
         { info_tbl: [(caklE,
                       label: block_caklE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caklO; else goto caklN;
       caklO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caklN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajEf_entry() //  [R1]
         { info_tbl: [(caklP,
                       label: sat_sajEf_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklP: // global
           _sajEf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caklQ; else goto caklR;
       caklR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caklT; else goto caklS;
       caklT: // global
           HpAlloc = 48;
           goto caklQ;
       caklQ: // global
           R1 = _sajEf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caklS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEf::P64;
           _sajE1::P64 = P64[_sajEf::P64 + 16];
           _sajDW::I64 = I64[_sajEf::P64 + 24];
           _sajDX::I64 = I64[_sajEf::P64 + 32];
           _sajDY::I64 = I64[_sajEf::P64 + 40];
           I64[Hp - 40] = sat_sajEe_info;
           P64[Hp - 24] = _sajE1::P64;
           I64[Hp - 16] = _sajDW::I64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sajE0_entry() //  [R1, R2]
         { info_tbl: [(caklU,
                       label: p_sajE0_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caklU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caklY; else goto caklX;
       caklY: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caklX: // global
           _sajDW::I64 = I64[R1 + 7];
           _sajDX::I64 = I64[R1 + 15];
           _sajDY::I64 = I64[R1 + 23];
           I64[Hp - 40] = sat_sajEf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = _sajDW::I64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajEi_entry() //  [R1]
         { info_tbl: [(cakm8,
                       label: sat_sajEi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakm8: // global
           _sajEi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakm9; else goto cakma;
       cakma: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakmc; else goto cakmb;
       cakmc: // global
           HpAlloc = 24;
           goto cakm9;
       cakm9: // global
           R1 = _sajEi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakmb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEi::P64;
           _sajDZ::P64 = P64[_sajEi::P64 + 16];
           _sajE0::P64 = P64[_sajEi::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sajDZ::P64;
           R2 = Hp - 14;
           R1 = _sajE0::P64;
           Sp = Sp - 16;
           call p_sajE0_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cakmg,
                       label: GHC.Event.Poll.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cakmk; else goto cakmj;
       cakmk: // global
           HpAlloc = 88;
           R1 = GHC.Event.Poll.$w$cshowsPrec1_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cakmj: // global
           I64[Hp - 80] = p_sajE0_info;
           I64[Hp - 72] = R3;
           I64[Hp - 64] = R4;
           I64[Hp - 56] = R5;
           _cakkq::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cakme; else goto cakmf;
       cakme: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cakkq::P64;
           call p_sajE0_entry(R2, R1) args: 8, res: 0, upd: 8;
       cakmf: // global
           I64[Hp - 48] = sat_sajEi_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cakkq::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.194668895 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cakmt,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakmx; else goto cakmy;
       cakmx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakmy: // global
           I64[Sp - 24] = block_cakmq_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakmG; else goto cakmr;
       uakmG: // global
           call _cakmq(R1) args: 0, res: 0, upd: 0;
       cakmr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakmq() //  [R1]
         { info_tbl: [(cakmq,
                       label: block_cakmq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmq: // global
           I64[Sp] = block_cakmw_info;
           _sajEn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajEn::I64;
           if (R1 & 7 != 0) goto uakmF; else goto cakmA;
       uakmF: // global
           call _cakmw(R1) args: 0, res: 0, upd: 0;
       cakmA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakmw() //  [R1]
         { info_tbl: [(cakmw,
                       label: block_cakmw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmw: // global
           R6 = P64[Sp + 16];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.196018124 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd7_closure" {
     GHC.Event.Poll.$fShowPollFd7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.196837758 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshow_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshow_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshow_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshow_entry() //  [R2]
         { info_tbl: [(cakmO,
                       label: GHC.Event.Poll.$fShowPollFd_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakmP; else goto cakmQ;
       cakmP: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakmQ: // global
           I64[Sp - 8] = block_cakmL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakmU; else goto cakmM;
       uakmU: // global
           call _cakmL(R1) args: 0, res: 0, upd: 0;
       cakmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakmL() //  [R1]
         { info_tbl: [(cakmL,
                       label: block_cakmL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmL: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.198191376 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd1_closure" {
     GHC.Event.Poll.$fShowPollFd1_closure:
         const GHC.Event.Poll.$fShowPollFd1_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd1_entry() //  [R2, R3]
         { info_tbl: [(cakn2,
                       label: GHC.Event.Poll.$fShowPollFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakn2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakn3; else goto cakn4;
       cakn3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakn4: // global
           I64[Sp - 16] = block_cakmZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakn8; else goto cakn0;
       uakn8: // global
           call _cakmZ(R1) args: 0, res: 0, upd: 0;
       cakn0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakmZ() //  [R1]
         { info_tbl: [(cakmZ,
                       label: block_cakmZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakmZ: // global
           R6 = P64[Sp + 8];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.201132116 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowList_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowList_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowList_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(caknd,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknd: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowPollFd1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.201888949 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_closure" {
     GHC.Event.Poll.$fShowPollFd_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure+1;
         const GHC.Event.Poll.$fShowPollFd_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.202452253 UTC

[section ""data" . GHC.Event.Poll.$fEqEvent_closure" {
     GHC.Event.Poll.$fEqEvent_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.203279339 UTC

[section ""data" . GHC.Event.Poll.pfdRevents_closure" {
     GHC.Event.Poll.pfdRevents_closure:
         const GHC.Event.Poll.pfdRevents_info;
 },
 GHC.Event.Poll.pfdRevents_entry() //  [R2]
         { info_tbl: [(caknn,
                       label: GHC.Event.Poll.pfdRevents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caknr; else goto cakns;
       caknr: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdRevents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakns: // global
           I64[Sp - 8] = block_caknk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaknw; else goto caknl;
       uaknw: // global
           call _caknk(R1) args: 0, res: 0, upd: 0;
       caknl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caknk() //  [R1]
         { info_tbl: [(caknk,
                       label: block_caknk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caknv; else goto caknu;
       caknv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caknu: // global
           _sajEJ::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajEJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.204561808 UTC

[section ""data" . GHC.Event.Poll.pfdEvents_closure" {
     GHC.Event.Poll.pfdEvents_closure:
         const GHC.Event.Poll.pfdEvents_info;
 },
 GHC.Event.Poll.pfdEvents_entry() //  [R2]
         { info_tbl: [(caknE,
                       label: GHC.Event.Poll.pfdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caknI; else goto caknJ;
       caknI: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caknJ: // global
           I64[Sp - 8] = block_caknB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaknN; else goto caknC;
       uaknN: // global
           call _caknB(R1) args: 0, res: 0, upd: 0;
       caknC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caknB() //  [R1]
         { info_tbl: [(caknB,
                       label: block_caknB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caknM; else goto caknL;
       caknM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caknL: // global
           _sajEN::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajEN::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.205856687 UTC

[section ""data" . GHC.Event.Poll.pfdFd_closure" {
     GHC.Event.Poll.pfdFd_closure:
         const GHC.Event.Poll.pfdFd_info;
 },
 GHC.Event.Poll.pfdFd_entry() //  [R2]
         { info_tbl: [(caknV,
                       label: GHC.Event.Poll.pfdFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caknZ; else goto cako0;
       caknZ: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cako0: // global
           I64[Sp - 8] = block_caknS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uako4; else goto caknT;
       uako4: // global
           call _caknS(R1) args: 0, res: 0, upd: 0;
       caknT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caknS() //  [R1]
         { info_tbl: [(caknS,
                       label: block_caknS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caknS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cako3; else goto cako2;
       cako3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cako2: // global
           _sajER::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajER::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.207144868 UTC

[section ""data" . GHC.Event.Poll.pollFd_closure" {
     GHC.Event.Poll.pollFd_closure:
         const GHC.Event.Poll.pollFd_info;
 },
 GHC.Event.Poll.pollFd_entry() //  [R2]
         { info_tbl: [(cakoc,
                       label: GHC.Event.Poll.pollFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakoc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakog; else goto cakoh;
       cakog: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakoh: // global
           I64[Sp - 8] = block_cako9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakol; else goto cakoa;
       uakol: // global
           call _cako9(R1) args: 0, res: 0, upd: 0;
       cakoa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cako9() //  [R1]
         { info_tbl: [(cako9,
                       label: block_cako9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cako9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakok; else goto cakoj;
       cakok: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakoj: // global
           _sajEX::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sajEX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.208447873 UTC

[section ""data" . GHC.Event.Poll.pollChanges_closure" {
     GHC.Event.Poll.pollChanges_closure:
         const GHC.Event.Poll.pollChanges_info;
 },
 GHC.Event.Poll.pollChanges_entry() //  [R2]
         { info_tbl: [(cakot,
                       label: GHC.Event.Poll.pollChanges_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakot: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakox; else goto cakoy;
       cakox: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollChanges_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakoy: // global
           I64[Sp - 8] = block_cakoq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakoC; else goto cakor;
       uakoC: // global
           call _cakoq(R1) args: 0, res: 0, upd: 0;
       cakor: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakoq() //  [R1]
         { info_tbl: [(cakoq,
                       label: block_cakoq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakoq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakoB; else goto cakoA;
       cakoB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakoA: // global
           _sajF0::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sajF0::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.20983571 UTC

[section ""data" . GHC.Event.Poll.available_closure" {
     GHC.Event.Poll.available_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.210344723 UTC

[section ""cstring" . GHC.Event.Poll.$trModule4_bytes" {
     GHC.Event.Poll.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.210869754 UTC

[section ""data" . GHC.Event.Poll.$trModule3_closure" {
     GHC.Event.Poll.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.211403232 UTC

[section ""cstring" . GHC.Event.Poll.$trModule2_bytes" {
     GHC.Event.Poll.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.211942062 UTC

[section ""data" . GHC.Event.Poll.$trModule1_closure" {
     GHC.Event.Poll.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.212513433 UTC

[section ""data" . GHC.Event.Poll.$trModule_closure" {
     GHC.Event.Poll.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Poll.$trModule3_closure+1;
         const GHC.Event.Poll.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.213120561 UTC

[section ""data" . $krep_rajAW_closure" {
     $krep_rajAW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCShort_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.213704003 UTC

[section ""data" . $krep1_rajAX_closure" {
     $krep1_rajAX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.214310313 UTC

[section ""cstring" . GHC.Event.Poll.$tcEvent2_bytes" {
     GHC.Event.Poll.$tcEvent2_bytes:
         I8[] [69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.214854662 UTC

[section ""data" . GHC.Event.Poll.$tcEvent1_closure" {
     GHC.Event.Poll.$tcEvent1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcEvent2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.215415183 UTC

[section ""data" . GHC.Event.Poll.$tcEvent_closure" {
     GHC.Event.Poll.$tcEvent_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcEvent1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10782964843686049546;
         const 16589058175633483645;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.216004017 UTC

[section ""data" . $krep2_rajAY_closure" {
     $krep2_rajAY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcEvent_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.216582664 UTC

[section ""data" . GHC.Event.Poll.$tc'Event1_closure" {
     GHC.Event.Poll.$tc'Event1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rajAW_closure+1;
         const $krep2_rajAY_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.217149188 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Event3_bytes" {
     GHC.Event.Poll.$tc'Event3_bytes:
         I8[] [39,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.217695299 UTC

[section ""data" . GHC.Event.Poll.$tc'Event2_closure" {
     GHC.Event.Poll.$tc'Event2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Event3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.21833139 UTC

[section ""data" . GHC.Event.Poll.$tc'Event_closure" {
     GHC.Event.Poll.$tc'Event_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Event2_closure+1;
         const GHC.Event.Poll.$tc'Event1_closure+4;
         const 14301517435728423362;
         const 8190957594797964970;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.21895679 UTC

[section ""cstring" . GHC.Event.Poll.$tcPollFd2_bytes" {
     GHC.Event.Poll.$tcPollFd2_bytes:
         I8[] [80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.219495797 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd1_closure" {
     GHC.Event.Poll.$tcPollFd1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPollFd2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.220053303 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd_closure" {
     GHC.Event.Poll.$tcPollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPollFd1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16228031948332168786;
         const 6382085973026785723;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.220655 UTC

[section ""data" . $krep3_rajAZ_closure" {
     $krep3_rajAZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPollFd_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.221176537 UTC

[section ""data" . $krep4_rajB0_closure" {
     $krep4_rajB0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep3_rajAZ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.222054541 UTC

[section ""data" . $krep5_rajB1_closure" {
     $krep5_rajB1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep4_rajB0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.222628388 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd1_closure" {
     GHC.Event.Poll.$tc'PollFd1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rajAX_closure+1;
         const $krep5_rajB1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.223144462 UTC

[section ""cstring" . GHC.Event.Poll.$tc'PollFd3_bytes" {
     GHC.Event.Poll.$tc'PollFd3_bytes:
         I8[] [39,80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.223694334 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd2_closure" {
     GHC.Event.Poll.$tc'PollFd2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'PollFd3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.224257592 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd_closure" {
     GHC.Event.Poll.$tc'PollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'PollFd2_closure+1;
         const GHC.Event.Poll.$tc'PollFd1_closure+4;
         const 13628496348781941345;
         const 13702663238288085101;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.224854145 UTC

[section ""data" . $krep6_rajB2_closure" {
     $krep6_rajB2_closure:
         const :_con_info;
         const $krep3_rajAZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.225449205 UTC

[section ""data" . $krep7_rajB3_closure" {
     $krep7_rajB3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure;
         const $krep6_rajB2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.226028135 UTC

[section ""data" . $krep8_rajB4_closure" {
     $krep8_rajB4_closure:
         const :_con_info;
         const $krep7_rajB3_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.22659253 UTC

[section ""data" . $krep9_rajB5_closure" {
     $krep9_rajB5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep8_rajB4_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.227174485 UTC

[section ""cstring" . GHC.Event.Poll.$tcPoll2_bytes" {
     GHC.Event.Poll.$tcPoll2_bytes:
         I8[] [80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.227721701 UTC

[section ""data" . GHC.Event.Poll.$tcPoll1_closure" {
     GHC.Event.Poll.$tcPoll1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPoll2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.22831076 UTC

[section ""data" . GHC.Event.Poll.$tcPoll_closure" {
     GHC.Event.Poll.$tcPoll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPoll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13451464419968486054;
         const 9195109480934256969;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.228908327 UTC

[section ""data" . $krep10_rajB6_closure" {
     $krep10_rajB6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPoll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.230566076 UTC

[section ""data" . $krep11_rajB7_closure" {
     $krep11_rajB7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rajB3_closure+1;
         const $krep10_rajB6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.231131172 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll1_closure" {
     GHC.Event.Poll.$tc'Poll1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rajB5_closure+1;
         const $krep11_rajB7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.23168763 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Poll3_bytes" {
     GHC.Event.Poll.$tc'Poll3_bytes:
         I8[] [39,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.232226081 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll2_closure" {
     GHC.Event.Poll.$tc'Poll2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Poll3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.232765982 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll_closure" {
     GHC.Event.Poll.$tc'Poll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Poll2_closure+1;
         const GHC.Event.Poll.$tc'Poll1_closure+4;
         const 5431567153781643515;
         const 15938353663250731731;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.233418063 UTC

[section ""data" . GHC.Event.Poll.$fBitsEvent_closure" {
     GHC.Event.Poll.$fBitsEvent_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Event.Poll.$fEqEvent_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.234158175 UTC

[section ""data" . GHC.Event.Poll.$fFiniteBitsEvent_closure" {
     GHC.Event.Poll.$fFiniteBitsEvent_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Event.Poll.$fBitsEvent_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.234740423 UTC

[section ""data" . GHC.Event.Poll.$fNumEvent_closure" {
     GHC.Event.Poll.$fNumEvent_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.235329519 UTC

[section ""cstring" . lvl_rajB8_bytes" {
     lvl_rajB8_bytes:
         I8[] [109,111,100,105,102,121,70,100,79,110,99,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,105,110,32,80,111,108,108,32,98,97,99,107,101,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.236228821 UTC

[section ""data" . GHC.Event.Poll.new3_closure" {
     GHC.Event.Poll.new3_closure:
         const GHC.Event.Poll.new3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Poll.new3_entry() //  [R1]
         { info_tbl: [(cakoL,
                       label: GHC.Event.Poll.new3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakoL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakoM; else goto cakoN;
       cakoM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakoN: // global
           (_cakoG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakoG::I64 == 0) goto cakoI; else goto cakoH;
       cakoI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakoH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakoG::I64;
           I64[Sp - 24] = block_cakoJ_info;
           R2 = lvl_rajB8_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakoJ() //  [R1]
         { info_tbl: [(cakoJ,
                       label: block_cakoJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakoJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.238302909 UTC

[section ""data" . $wc_pollLoop_rajB9_closure" {
     $wc_pollLoop_rajB9_closure:
         const $wc_pollLoop_rajB9_info;
 },
 $wc_pollLoop_rajB9_entry() //  [R2, R3, R4]
         { info_tbl: [(cakp0,
                       label: $wc_pollLoop_rajB9_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakp0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakp1; else goto uakpL;
       cakp1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wc_pollLoop_rajB9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uakpL: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cakoS() args: 0, res: 0, upd: 0;
     }
 },
 _cakoS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakoS: // global
           _sajF3::I64 = I64[Sp];
           _sajF4::I64 = I64[Sp + 8];
           _sajF5::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_sajF5::I64,
                            2147483647)) goto cakoY; else goto cakoZ;
       cakoY: // global
           I64[Sp - 8] = block_cakp8_info;
           Sp = Sp - 8;
           _uakpR::P64 = CurrentTSO;
           I64[I64[_uakpR::P64 + 24] + 16] = Sp;
           _uakpS::I64 = CurrentNursery;
           P64[_uakpS::I64 + 8] = Hp + 8;
           I64[_uakpR::P64 + 104] = I64[_uakpR::P64 + 104] - ((Hp + 8) - I64[_uakpS::I64]);
           (_uakpP::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sajFb::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_sajF3::I64, _sajF4::I64, 2147483647);
           (_uakpQ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uakpP::I64);
           BaseReg = _uakpQ::I64;
           _uakpT::P64 = CurrentTSO;
           _uakpU::P64 = I64[_uakpT::P64 + 24];
           Sp = I64[_uakpU::P64 + 16];
           SpLim = _uakpU::P64 + 192;
           HpAlloc = 0;
           _uakpV::I64 = CurrentNursery;
           _uakpW::I64 = I64[_uakpV::I64 + 8];
           Hp = _uakpW::I64 - 8;
           _uakpX::I64 = I64[_uakpV::I64];
           HpLim = _uakpX::I64 + ((%MO_SS_Conv_W32_W64(I32[_uakpV::I64 + 48]) << 12) - 1);
           I64[_uakpT::P64 + 104] = I64[_uakpT::P64 + 104] + (_uakpW::I64 - _uakpX::I64);
           R1 = _sajFb::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
       cakoZ: // global
           I64[Sp + 16] = block_cakpB_info;
           Sp = Sp + 16;
           _uakq1::P64 = CurrentTSO;
           I64[I64[_uakq1::P64 + 24] + 16] = Sp;
           _uakq2::I64 = CurrentNursery;
           P64[_uakq2::I64 + 8] = Hp + 8;
           I64[_uakq1::P64 + 104] = I64[_uakq1::P64 + 104] - ((Hp + 8) - I64[_uakq2::I64]);
           (_uakpZ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sajFj::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_sajF3::I64, _sajF4::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sajF5::I64)));
           (_uakq0::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_uakpZ::I64);
           BaseReg = _uakq0::I64;
           _uakq3::P64 = CurrentTSO;
           _uakq4::P64 = I64[_uakq3::P64 + 24];
           Sp = I64[_uakq4::P64 + 16];
           SpLim = _uakq4::P64 + 192;
           HpAlloc = 0;
           _uakq5::I64 = CurrentNursery;
           _uakq6::I64 = I64[_uakq5::I64 + 8];
           Hp = _uakq6::I64 - 8;
           _uakq7::I64 = I64[_uakq5::I64];
           HpLim = _uakq7::I64 + ((%MO_SS_Conv_W32_W64(I32[_uakq5::I64 + 48]) << 12) - 1);
           I64[_uakq3::P64 + 104] = I64[_uakq3::P64 + 104] + (_uakq6::I64 - _uakq7::I64);
           R1 = _sajFj::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakp8() //  [R1]
         { info_tbl: [(cakp8,
                       label: block_cakp8_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakp8: // global
           _sajFc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           if (_sajFc::I64 != 0) goto uakpM; else goto cakpp;
       uakpM: // global
           I64[Sp + 24] = _sajFc::I64;
           Sp = Sp + 24;
           call _cakpf() args: 0, res: 0, upd: 0;
       cakpp: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] - 2147483647;
           Sp = Sp + 8;
           call _cakoS() args: 0, res: 0, upd: 0;
     }
 },
 _cakpf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakpf: // global
           Hp = Hp + 16;
           _sajFc::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cakpm; else goto cakpl;
       cakpm: // global
           HpAlloc = 16;
           I64[Sp] = block_cakpe_info;
           R1 = _sajFc::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cakpl: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajFc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cakpe() //  [R1]
         { info_tbl: [(cakpe,
                       label: block_cakpe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakpe: // global
           I64[Sp] = R1;
           call _cakpf() args: 0, res: 0, upd: 0;
     }
 },
 _cakpB() //  [R1]
         { info_tbl: [(cakpB,
                       label: block_cakpB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakpB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakpJ; else goto cakpI;
       cakpJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cakpI: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.240838674 UTC

[section ""data" . lvl1_rajBa_closure" {
     lvl1_rajBa_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.242007819 UTC

[section ""cstring" . lvl2_rajBb_bytes" {
     lvl2_rajBb_bytes:
         I8[] [99,95,112,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.242754584 UTC

[section ""data" . lvl3_rajBc_closure" {
     lvl3_rajBc_closure:
         const lvl3_rajBc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rajBc_entry() //  [R1]
         { info_tbl: [(cakqj,
                       label: lvl3_rajBc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakqj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakqk; else goto cakql;
       cakqk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakql: // global
           (_cakqg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakqg::I64 == 0) goto cakqi; else goto cakqh;
       cakqi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakqh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakqg::I64;
           R2 = lvl2_rajBb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.243578945 UTC

[section ""cstring" . lvl4_rajBd_bytes" {
     lvl4_rajBd_bytes:
         I8[] [114,101,119,111,114,107,70,100,58,32,101,118,101,110,116,32,110,111,116,32,102,111,117,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.244342206 UTC

[section ""data" . lvl5_rajBe_closure" {
     lvl5_rajBe_closure:
         const lvl5_rajBe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rajBe_entry() //  [R1]
         { info_tbl: [(cakqu,
                       label: lvl5_rajBe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakqu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakqv; else goto cakqw;
       cakqv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakqw: // global
           (_cakqp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakqp::I64 == 0) goto cakqr; else goto cakqq;
       cakqr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakqq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakqp::I64;
           I64[Sp - 24] = block_cakqs_info;
           R2 = lvl4_rajBd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakqs() //  [R1]
         { info_tbl: [(cakqs,
                       label: block_cakqs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakqs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.245544678 UTC

[section ""data" . lvl6_rajBf_closure" {
     lvl6_rajBf_closure:
         const lvl6_rajBf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rajBf_entry() //  [R1]
         { info_tbl: [(cakqG,
                       label: lvl6_rajBf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakqG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakqH; else goto cakqI;
       cakqH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakqI: // global
           (_cakqD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakqD::I64 == 0) goto cakqF; else goto cakqE;
       cakqF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakqE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakqD::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.loop_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.246421603 UTC

[section ""data" . lvl7_rajBg_closure" {
     lvl7_rajBg_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.246975922 UTC

[section ""data" . lvl8_rajBh_closure" {
     lvl8_rajBh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.2475273 UTC

[section ""data" . lvl9_rajBi_closure" {
     lvl9_rajBi_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.248220028 UTC

[section ""data" . lvl10_rajBj_closure" {
     lvl10_rajBj_closure:
         const lvl10_rajBj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rajBj_entry() //  [R1]
         { info_tbl: [(cakqP,
                       label: lvl10_rajBj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakqP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakqQ; else goto cakqR;
       cakqQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakqR: // global
           (_cakqM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakqM::I64 == 0) goto cakqO; else goto cakqN;
       cakqO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakqN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakqM::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.removeAt_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.24927611 UTC

[section ""data" . lvl11_rajBk_closure" {
     lvl11_rajBk_closure:
         const lvl11_rajBk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rajBk_entry() //  [R1]
         { info_tbl: [(cakqY,
                       label: lvl11_rajBk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakqY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakqZ; else goto cakr0;
       cakqZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakr0: // global
           (_cakqV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakqV::I64 == 0) goto cakqX; else goto cakqW;
       cakqX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakqW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakqV::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.findIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.257225818 UTC

[section ""data" . GHC.Event.Poll.new5_closure" {
     GHC.Event.Poll.new5_closure:
         const GHC.Event.Poll.new5_info;
         const 0;
 },
 sat_sajGz_entry() //  [R1]
         { info_tbl: [(caksD,
                       label: sat_sajGz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caksD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caksE; else goto caktE;
       caksE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caktE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sajGo::I64 = I64[R1 + 16];
           if (_sajGo::I64 & 25 == 0) goto caktf; else goto caksO;
       caktf: // global
           if (_sajGo::I64 & 28 == 0) goto caktA; else goto caktu;
       caktA: // global
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caktu: // global
           R1 = lvl9_rajBi_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caksO: // global
           if (_sajGo::I64 & 28 == 0) goto cakt9; else goto cakt3;
       cakt9: // global
           R1 = lvl8_rajBh_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cakt3: // global
           R1 = lvl7_rajBg_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 i'_sajGD_entry() //  [R1]
         { info_tbl: [(caktP,
                       label: i'_sajGD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caktP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caktZ; else goto caku0;
       caktZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caku0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caktM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaku4; else goto caktN;
       uaku4: // global
           call _caktM(R1) args: 0, res: 0, upd: 0;
       caktN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caktM() //  [R1]
         { info_tbl: [(caktM,
                       label: block_caktM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caktM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caku3; else goto caku2;
       caku3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caku2: // global
           _sajGH::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7] + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajGH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajGL_entry() //  [R1]
         { info_tbl: [(cakuc,
                       label: sat_sajGL_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakuc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakud; else goto cakue;
       cakud: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakue: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caku9_info;
           _sajGg::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sajGg::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakuj; else goto cakua;
       uakuj: // global
           call _caku9(R1) args: 0, res: 0, upd: 0;
       cakua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caku9() //  [R1]
         { info_tbl: [(caku9,
                       label: block_caku9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caku9: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajGO_entry() //  [R1, R2, R3]
         { info_tbl: [(cakuk,
                       label: sat_sajGO_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakuk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakul; else goto cakum;
       cakul: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakum: // global
           I64[Sp - 32] = block_caksq_info;
           _sajFp::P64 = P64[R1 + 5];
           _sajGg::I64 = I64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _sajFp::P64;
           I64[Sp - 16] = _sajGg::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakuz; else goto caksr;
       uakuz: // global
           call _caksq(R1) args: 0, res: 0, upd: 0;
       caksr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caksq() //  [R1]
         { info_tbl: [(caksq,
                       label: block_caksq_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caksq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakup; else goto cakuo;
       cakup: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakuo: // global
           _sajGo::I64 = I64[R1 + 23];
           if (_sajGo::I64 != 0) goto cakus; else goto cakuy;
       cakus: // global
           _sajGl::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_sajGz_info;
           I64[Hp - 16] = _sajGo::I64;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajGl::I64;
           _sajFp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caktG_info;
           R3 = Hp - 32;
           R2 = Hp - 7;
           R1 = _sajFp::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cakuy: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = GHC.Types.True_closure+2;
           _cakux::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _cakux::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caktG() //  [R1]
         { info_tbl: [(caktG,
                       label: block_caktG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caktG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cakuv; else goto cakuu;
       cakuv: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakuu: // global
           I64[Hp - 72] = i'_sajGD_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = sat_sajGL_info;
           _caktI::P64 = Hp - 72;
           P64[Hp - 32] = _caktI::P64;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _caktI::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajHT_entry() //  [R1, R2]
         { info_tbl: [(cakv1,
                       label: sat_sajHT_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakv1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakv2; else goto cakv3;
       cakv2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakv3: // global
           I64[Sp - 16] = block_cakuY_info;
           _sajHD::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _sajHD::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakv8; else goto cakuZ;
       uakv8: // global
           call _cakuY(R1) args: 0, res: 0, upd: 0;
       cakuZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakuY() //  [R1]
         { info_tbl: [(cakuY,
                       label: block_cakuY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakuY: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajIQ_entry() //  [R1]
         { info_tbl: [(cakvm,
                       label: sat_sajIQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakvm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakvn; else goto cakvo;
       cakvn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cakvo: // global
           I64[Sp - 24] = block_cakvh_info;
           _sajFz::P64 = P64[R1 + 7];
           _sajFB::P64 = P64[R1 + 15];
           R1 = _sajFB::P64;
           P64[Sp - 16] = _sajFz::P64;
           P64[Sp - 8] = _sajFB::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakvh() //  [R1]
         { info_tbl: [(cakvh,
                       label: block_cakvh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakvh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakvr; else goto cakvq;
       cakvr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakvq: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cakvk_info;
           R2 = Hp - 7;
           _sajIN::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sajIN::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakvk() //  []
         { info_tbl: [(cakvk,
                       label: block_cakvk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakvk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new5_entry() //  [R2, R3, R4]
         { info_tbl: [(cakvt,
                       label: GHC.Event.Poll.new5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakvt: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cakvu; else goto cakvv;
       cakvu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakvv: // global
           I64[Sp - 32] = block_cakr5_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakr5() //  [R1]
         { info_tbl: [(cakr5,
                       label: block_cakr5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakr5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakvy; else goto cakvx;
       cakvy: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakvx: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cakra_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakra() //  [R1]
         { info_tbl: [(cakra,
                       label: block_cakra_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakra: // global
           I64[Sp] = block_cakrc_info;
           _sajFz::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sajFz::P64;
           if (R1 & 7 != 0) goto uakzz; else goto cakrd;
       uakzz: // global
           call _cakrc(R1) args: 0, res: 0, upd: 0;
       cakrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakrc() //  [R1]
         { info_tbl: [(cakrc,
                       label: block_cakrc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakrc: // global
           I64[Sp - 16] = block_cakrh_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cakrh() //  [R1]
         { info_tbl: [(cakrh,
                       label: block_cakrh_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakrh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakvD; else goto cakvC;
       cakvD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cakvC: // global
           _sajFB::P64 = P64[Sp + 16];
           if (R1 == 0) goto cakyU; else goto cakyH;
       cakyU: // global
           I64[Hp - 16] = sat_sajIQ_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sajFB::P64;
           I64[Sp] = block_cakyR_info;
           R1 = Hp - 15;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       cakyH: // global
           Hp = Hp - 24;
           I64[Sp] = block_cakyA_info;
           R1 = _sajFB::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakyR() //  [R1]
         { info_tbl: [(cakyR,
                       label: block_cakyR_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyR: // global
           I64[Sp] = block_cakyT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uakzZ; else goto cakyW;
       uakzZ: // global
           call _cakyT(R1) args: 0, res: 0, upd: 0;
       cakyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakyT() //  [R1]
         { info_tbl: [(cakyT,
                       label: block_cakyT_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyT: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _sajFG() args: 0, res: 0, upd: 0;
     }
 },
 _cakyA() //  [R1]
         { info_tbl: [(cakyA,
                       label: block_cakyA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakyK; else goto cakyJ;
       cakyK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakyJ: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cakyD_info;
           R2 = Hp - 7;
           _sajIF::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 24] = _sajIF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakyD() //  []
         { info_tbl: [(cakyD,
                       label: block_cakyD_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyD: // global
           I64[Sp] = block_cakyF_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto uakzX; else goto cakyM;
       uakzX: // global
           call _cakyF(R1) args: 0, res: 0, upd: 0;
       cakyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakyF() //  [R1]
         { info_tbl: [(cakyF,
                       label: block_cakyF_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyF: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _sajFG() args: 0, res: 0, upd: 0;
     }
 },
 _sajFG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sajFG: // global
           _sajFL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cakro_info;
           R1 = _sajFL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakA1; else goto cakrp;
       uakA1: // global
           call _cakro(R1) args: 0, res: 0, upd: 0;
       cakrp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakro() //  [R1]
         { info_tbl: [(cakro,
                       label: block_cakro_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakro: // global
           I64[Sp] = block_cakrt_info;
           _sajFO::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 24] = _sajFO::I64;
           if (R1 & 7 != 0) goto uakzA; else goto cakru;
       uakzA: // global
           call _cakrt(R1) args: 0, res: 0, upd: 0;
       cakru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakrt() //  [R1]
         { info_tbl: [(cakrt,
                       label: block_cakrt_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakrt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakvI; else goto cakvH;
       cakvI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakvH: // global
           _sajFS::P64 = P64[R1 + 7];
           _sajFR::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = I64[Sp + 24] << 3;
           I64[Sp - 8] = 0;
           P64[Sp] = _sajFS::P64;
           I64[Sp + 16] = _sajFR::I64;
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 16;
           call _cakuD() args: 0, res: 0, upd: 0;
     }
 },
 _cakuD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakuD: // global
           Hp = Hp + 32;
           _sajHx::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cakxr; else goto cakxq;
       cakxr: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cakuC_info;
           R1 = _sajHx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cakxq: // global
           _sajFC::P64 = P64[Sp + 24];
           if (%MO_S_Lt_W64(_sajHx::I64,
                            I64[Sp])) goto cakyy; else goto cakyz;
       cakyy: // global
           _sajHA::I64 = I64[Sp + 32] + _sajHx::I64;
           _sajHD::I64 = %MO_SS_Conv_W32_W64(I32[_sajHA::I64]);
           _sajHH::I64 = %MO_SS_Conv_W16_W64(I16[_sajHA::I64 + 4]);
           if (I16[_sajHA::I64 + 6] == 0 :: W16) goto cakyu; else goto cakxw;
       cakyu: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajHD::I64;
           I64[Hp - 8] = _sajHH::I64;
           I64[Hp] = 0;
           I64[Sp - 8] = block_cakyt_info;
           R4 = Hp - 23;
           R3 = _sajFC::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
       cakxw: // global
           I64[Hp - 24] = sat_sajHT_info;
           I64[Hp - 16] = _sajHD::I64;
           _cakuT::P64 = Hp - 23;
           Hp = Hp - 16;
           I64[Sp - 24] = block_cakxs_info;
           R3 = P64[Sp + 40];
           R2 = _cakuT::P64;
           R1 = lvl11_rajBk_closure;
           I64[Sp - 16] = _sajHD::I64;
           I64[Sp - 8] = _sajHH::I64;
           Sp = Sp - 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cakyz: // global
           Hp = Hp - 32;
           call MO_Touch(P64[Sp + 16]);
           I64[Sp + 32] = block_cakrI_info;
           R1 = P64[_sajFC::P64 + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uakzI; else goto cakrJ;
       uakzI: // global
           call _cakrI(R1) args: 0, res: 0, upd: 0;
       cakrJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakuC() //  [R1]
         { info_tbl: [(cakuC,
                       label: block_cakuC_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakuC: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cakuD() args: 0, res: 0, upd: 0;
     }
 },
 _cakyt() //  []
         { info_tbl: [(cakyt,
                       label: block_cakyt_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyt: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cakuD() args: 0, res: 0, upd: 0;
     }
 },
 _cakxs() //  [R1]
         { info_tbl: [(cakxs,
                       label: block_cakxs_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxs: // global
           I64[Sp] = block_cakxu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uakzP; else goto cakxy;
       uakzP: // global
           call _cakxu(R1) args: 0, res: 0, upd: 0;
       cakxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakxu() //  [R1]
         { info_tbl: [(cakxu,
                       label: block_cakxu_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxu: // global
           if (R1 & 7 == 1) goto cakxE; else goto cakxJ;
       cakxE: // global
           R1 = lvl5_rajBe_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cakxJ: // global
           I64[Sp] = block_cakxH_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uakzQ; else goto cakxK;
       uakzQ: // global
           call _cakxH(R1) args: 0, res: 0, upd: 0;
       cakxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakxH() //  [R1]
         { info_tbl: [(cakxH,
                       label: block_cakxH_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxH: // global
           _sajI1::P64 = P64[R1 + 7];
           _sajI3::I64 = I64[Sp + 16];
           if (_sajI3::I64 != 0) goto caky3; else goto cakyo;
       caky3: // global
           _sajI6::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp - 8] = block_cakxR_info;
           R1 = _sajI6::P64;
           I64[Sp] = _sajI3::I64;
           P64[Sp + 16] = _sajI1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakzR; else goto cakxS;
       uakzR: // global
           call _cakxR(R1) args: 0, res: 0, upd: 0;
       cakxS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cakyo: // global
           I64[Sp + 16] = block_cakyn_info;
           R3 = _sajI1::P64;
           R2 = P64[Sp + 64];
           R1 = lvl10_rajBj_closure;
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakxR() //  [R1]
         { info_tbl: [(cakxR,
                       label: block_cakxR_info
                       rep:StackRep [True, True, False, True, True, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxR: // global
           I64[Sp - 8] = block_cakxW_info;
           _sajIa::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _sajIa::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakzS; else goto cakxX;
       uakzS: // global
           call _cakxW(R1) args: 0, res: 0, upd: 0;
       cakxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakxW() //  [R1]
         { info_tbl: [(cakxW,
                       label: block_cakxW_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxW: // global
           I64[Sp - 8] = block_caky1_info;
           _sajId::P64 = P64[R1 + 7];
           _sajIc::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sajId::P64;
           I64[Sp + 32] = _sajIc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakzT; else goto caky6;
       uakzT: // global
           call _caky1(R1) args: 0, res: 0, upd: 0;
       caky6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caky1() //  [R1]
         { info_tbl: [(caky1,
                       label: block_caky1_info
                       rep:StackRep [False, True, True, True, True, True, True, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caky1: // global
           _sajIa::I64 = I64[Sp + 16];
           _sajIf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sajIf::I64, 0)) goto cakyl; else goto cakyk;
       cakyk: // global
           if (%MO_S_Ge_W64(_sajIf::I64,
                            _sajIa::I64)) goto cakyl; else goto cakyh;
       cakyl: // global
           R3 = _sajIf::I64;
           R2 = _sajIa::I64;
           Sp = Sp + 112;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       cakyh: // global
           _sajHx::I64 = I64[Sp + 56];
           _sajI3::I64 = I64[Sp + 24];
           _sajId::P64 = P64[Sp + 8];
           _sajIi::I64 = I64[Sp + 40] + (_sajIf::I64 << 3);
           I32[_sajIi::I64] = %MO_UU_Conv_W64_W32(I64[Sp + 32]);
           I16[_sajIi::I64 + 4] = %MO_UU_Conv_W64_W16(_sajI3::I64);
           I16[_sajIi::I64 + 6] = 0 :: W16;
           call MO_Touch(_sajId::P64);
           I64[Sp + 56] = _sajHx::I64 + 8;
           Sp = Sp + 48;
           call _cakuD() args: 0, res: 0, upd: 0;
     }
 },
 _cakyn() //  []
         { info_tbl: [(cakyn,
                       label: block_cakyn_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakyn: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cakuD() args: 0, res: 0, upd: 0;
     }
 },
 _cakrI() //  [R1]
         { info_tbl: [(cakrI,
                       label: block_cakrI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakrI: // global
           I64[Sp - 8] = block_cakrN_info;
           _sajG3::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _sajG3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakzC; else goto cakrO;
       uakzC: // global
           call _cakrN(R1) args: 0, res: 0, upd: 0;
       cakrO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakrN() //  [R1]
         { info_tbl: [(cakrN,
                       label: block_cakrN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakrN: // global
           I64[Sp - 8] = block_cakrU_info;
           _sajG7::P64 = P64[R1 + 7];
           _sajG6::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sajG7::P64;
           I64[Sp + 24] = _sajG6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakzD; else goto cakrV;
       uakzD: // global
           call _cakrU(R1) args: 0, res: 0, upd: 0;
       cakrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakrU() //  [R1]
         { info_tbl: [(cakrU,
                       label: block_cakrU_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakrU: // global
           if (R1 & 7 == 1) goto cakwv; else goto cakwD;
       cakwv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakwy; else goto cakwx;
       cakwy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakwx: // global
           (_sajH9::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(I64[Sp + 32], I64[Sp + 16], 0);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _sajHa::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sajH9::I64));
           I64[Hp] = _sajHa::I64;
           I64[Sp + 32] = _sajHa::I64;
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
       cakwD: // global
           I64[Sp] = block_cakwB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uakzE; else goto cakwE;
       uakzE: // global
           call _cakwB(R1) args: 0, res: 0, upd: 0;
       cakwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakwB() //  [R1]
         { info_tbl: [(cakwB,
                       label: block_cakwB_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakwB: // global
           _sajG3::I64 = I64[Sp + 16];
           _sajG6::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cakx2; else goto cakxi;
       cakx2: // global
           I64[Sp] = block_cakwX_info;
           R4 = (I64[R1 + 7] + 999999) / 1000000;
           R3 = _sajG3::I64;
           R2 = _sajG6::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
       cakxi: // global
           I64[Sp] = block_cakxe_info;
           R4 = (-1);
           R3 = _sajG3::I64;
           R2 = _sajG6::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cakwX() //  [R1]
         { info_tbl: [(cakwX,
                       label: block_cakwX_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakwX: // global
           I64[Sp] = block_cakwZ_info;
           _sajHn::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _sajHn::P64;
           if (R1 & 7 != 0) goto uakzL; else goto cakx4;
       uakzL: // global
           call _cakwZ(R1) args: 0, res: 0, upd: 0;
       cakx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakwZ() //  [R1]
         { info_tbl: [(cakwZ,
                       label: block_cakwZ_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakwZ: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
     }
 },
 _cakxe() //  [R1]
         { info_tbl: [(cakxe,
                       label: block_cakxe_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxe: // global
           I64[Sp] = block_cakxg_info;
           _sajHt::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _sajHt::P64;
           if (R1 & 7 != 0) goto uakzN; else goto cakxk;
       uakzN: // global
           call _cakxg(R1) args: 0, res: 0, upd: 0;
       cakxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakxg() //  [R1]
         { info_tbl: [(cakxg,
                       label: block_cakxg_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakxg: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
     }
 },
 _sajG8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sajG8: // global
           _sajGT::I64 = I64[Sp + 24];
           if (_sajGT::I64 != (-1)) goto cakw1; else goto cakwt;
       cakw1: // global
           I64[Sp + 24] = _sajGT::I64;
           goto uakA3;
       cakwt: // global
           (_sajGX::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           if (%MO_SS_Conv_W64_W32(_sajGX::I64) == 4 :: W32) goto cakwp; else goto cakwf;
       cakwp: // global
           I64[Sp + 24] = 0;
           goto uakA3;
       uakA3: // global
           call _caksg() args: 0, res: 0, upd: 0;
       cakwf: // global
           I64[Sp - 8] = block_cakwb_info;
           R2 = lvl3_rajBc_closure;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cakwb() //  [R1]
         { info_tbl: [(cakwb,
                       label: block_cakwb_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakwb: // global
           I64[Sp] = block_cakwd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uakzJ; else goto cakwi;
       uakzJ: // global
           call _cakwd(R1) args: 0, res: 0, upd: 0;
       cakwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakwd() //  [R1]
         { info_tbl: [(cakwd,
                       label: block_cakwd_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakwd: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _caksg() args: 0, res: 0, upd: 0;
     }
 },
 _caksg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caksg: // global
           Hp = Hp + 24;
           _sajGe::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cakvP; else goto cakvO;
       cakvP: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_caksf_info;
           R1 = _sajGe::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cakvO: // global
           _cakry::P64 = P64[Sp + 16];
           _sajFp::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp]);
           if (_sajGe::I64 == 0) goto cakvY; else goto cakvU;
       cakvY: // global
           Hp = Hp - 24;
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cakvU: // global
           I64[Hp - 16] = sat_sajGO_info;
           P64[Hp - 8] = _sajFp::P64;
           I64[Hp] = _sajGe::I64;
           I64[Sp + 24] = block_cakvQ_info;
           R4 = Hp - 13;
           R3 = lvl1_rajBa_closure+1;
           R2 = _cakry::P64;
           R1 = lvl6_rajBf_closure;
           I64[Sp + 32] = _sajGe::I64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caksf() //  [R1]
         { info_tbl: [(caksf,
                       label: block_caksf_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caksf: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _caksg() args: 0, res: 0, upd: 0;
     }
 },
 _cakvQ() //  [R1]
         { info_tbl: [(cakvQ,
                       label: block_cakvQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakvQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakvX; else goto cakvW;
       cakvX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakvW: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.276586234 UTC

[section ""data" . GHC.Event.Poll.new4_closure" {
     GHC.Event.Poll.new4_closure:
         const GHC.Event.Poll.new4_info;
         const 0;
 },
 sat_sajJz_entry() //  [R1]
         { info_tbl: [(cakAu,
                       label: sat_sajJz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakAu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cakAy; else goto cakAz;
       cakAy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakAz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cakAr_info;
           _sajIY::P64 = P64[R1 + 24];
           _sajIZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sajIY::P64;
           P64[Sp - 24] = _sajIZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uakG0; else goto cakAs;
       uakG0: // global
           call _cakAr(R1) args: 0, res: 0, upd: 0;
       cakAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakAr() //  [R1]
         { info_tbl: [(cakAr,
                       label: block_cakAr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakAr: // global
           I64[Sp] = block_cakAx_info;
           _sajJ9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajJ9::I64;
           if (R1 & 7 != 0) goto uakFZ; else goto cakAB;
       uakFZ: // global
           call _cakAx(R1) args: 0, res: 0, upd: 0;
       cakAB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakAx() //  [R1]
         { info_tbl: [(cakAx,
                       label: block_cakAx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakAx: // global
           _sajIY::P64 = P64[Sp + 8];
           _sajJb::I64 = I64[R1 + 7];
           if (_sajJb::I64 & 1 == 0) goto cakD8; else goto cakAL;
       cakD8: // global
           if (_sajJb::I64 & 2 == 0) goto cakEr; else goto cakDk;
       cakEr: // global
           I64[Sp + 8] = block_cakEq_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakG4; else goto cakEt;
       uakG4: // global
           call _cakEq(R1) args: 0, res: 0, upd: 0;
       cakEt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cakDk: // global
           I64[Sp + 8] = block_cakDi_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakG3; else goto cakDm;
       uakG3: // global
           call _cakDi(R1) args: 0, res: 0, upd: 0;
       cakDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cakAL: // global
           if (_sajJb::I64 & 2 == 0) goto cakC4; else goto cakAX;
       cakC4: // global
           I64[Sp + 8] = block_cakC3_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakG2; else goto cakC6;
       uakG2: // global
           call _cakC3(R1) args: 0, res: 0, upd: 0;
       cakC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cakAX: // global
           I64[Sp + 8] = block_cakAV_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uakG1; else goto cakAZ;
       uakG1: // global
           call _cakAV(R1) args: 0, res: 0, upd: 0;
       cakAZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakEq() //  [R1]
         { info_tbl: [(cakEq,
                       label: block_cakEq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEq: // global
           _sajJv::I64 = I64[R1 + 7];
           if (_sajJv::I64 & 1 == 0) goto cakF4; else goto cakED;
       cakF4: // global
           _sajJy::I64 = _sajJv::I64 & 2;
           if (_sajJy::I64 != 0) goto uakFW; else goto uakFV;
       uakFW: // global
           I64[Sp] = _sajJy::I64;
           call _cakFc() args: 0, res: 0, upd: 0;
       uakFV: // global
           I64[Sp] = _sajJy::I64;
           call _cakFm() args: 0, res: 0, upd: 0;
       cakED: // global
           _sajJx::I64 = _sajJv::I64 & 2;
           if (_sajJx::I64 != 0) goto uakFS; else goto uakFR;
       uakFS: // global
           I64[Sp] = _sajJx::I64;
           call _cakEL() args: 0, res: 0, upd: 0;
       uakFR: // global
           I64[Sp] = _sajJx::I64;
           call _cakEV() args: 0, res: 0, upd: 0;
     }
 },
 _cakFc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakFc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakFj; else goto cakFi;
       cakFj: // global
           HpAlloc = 32;
           _sajJy::I64 = I64[Sp];
           I64[Sp] = block_cakFb_info;
           R1 = _sajJy::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakFi: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakFb() //  [R1]
         { info_tbl: [(cakFb,
                       label: block_cakFb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakFb: // global
           I64[Sp] = R1;
           call _cakFc() args: 0, res: 0, upd: 0;
     }
 },
 _cakFm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakFm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakFs; else goto cakFr;
       cakFs: // global
           HpAlloc = 32;
           _sajJy::I64 = I64[Sp];
           I64[Sp] = block_cakFl_info;
           R1 = _sajJy::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakFr: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakFl() //  [R1]
         { info_tbl: [(cakFl,
                       label: block_cakFl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakFl: // global
           I64[Sp] = R1;
           call _cakFm() args: 0, res: 0, upd: 0;
     }
 },
 _cakEL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakES; else goto cakER;
       cakES: // global
           HpAlloc = 32;
           _sajJx::I64 = I64[Sp];
           I64[Sp] = block_cakEK_info;
           R1 = _sajJx::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakER: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakEK() //  [R1]
         { info_tbl: [(cakEK,
                       label: block_cakEK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEK: // global
           I64[Sp] = R1;
           call _cakEL() args: 0, res: 0, upd: 0;
     }
 },
 _cakEV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakF1; else goto cakF0;
       cakF1: // global
           HpAlloc = 32;
           _sajJx::I64 = I64[Sp];
           I64[Sp] = block_cakEU_info;
           R1 = _sajJx::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakF0: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakEU() //  [R1]
         { info_tbl: [(cakEU,
                       label: block_cakEU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEU: // global
           I64[Sp] = R1;
           call _cakEV() args: 0, res: 0, upd: 0;
     }
 },
 _cakDi() //  [R1]
         { info_tbl: [(cakDi,
                       label: block_cakDi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakDi: // global
           _sajJq::I64 = I64[R1 + 7];
           if (_sajJq::I64 & 1 == 0) goto cakDX; else goto cakDw;
       cakDX: // global
           _sajJt::I64 = _sajJq::I64 & 2;
           if (_sajJt::I64 != 0) goto uakFO; else goto uakFN;
       uakFO: // global
           I64[Sp] = _sajJt::I64;
           call _cakE5() args: 0, res: 0, upd: 0;
       uakFN: // global
           I64[Sp] = _sajJt::I64;
           call _cakEf() args: 0, res: 0, upd: 0;
       cakDw: // global
           _sajJs::I64 = _sajJq::I64 & 2;
           if (_sajJs::I64 != 0) goto uakFK; else goto uakFJ;
       uakFK: // global
           I64[Sp] = _sajJs::I64;
           call _cakDE() args: 0, res: 0, upd: 0;
       uakFJ: // global
           I64[Sp] = _sajJs::I64;
           call _cakDO() args: 0, res: 0, upd: 0;
     }
 },
 _cakE5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakE5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakEc; else goto cakEb;
       cakEc: // global
           HpAlloc = 32;
           _sajJt::I64 = I64[Sp];
           I64[Sp] = block_cakE4_info;
           R1 = _sajJt::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakEb: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakE4() //  [R1]
         { info_tbl: [(cakE4,
                       label: block_cakE4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakE4: // global
           I64[Sp] = R1;
           call _cakE5() args: 0, res: 0, upd: 0;
     }
 },
 _cakEf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakEl; else goto cakEk;
       cakEl: // global
           HpAlloc = 32;
           _sajJt::I64 = I64[Sp];
           I64[Sp] = block_cakEe_info;
           R1 = _sajJt::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakEk: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakEe() //  [R1]
         { info_tbl: [(cakEe,
                       label: block_cakEe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakEe: // global
           I64[Sp] = R1;
           call _cakEf() args: 0, res: 0, upd: 0;
     }
 },
 _cakDE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakDE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakDL; else goto cakDK;
       cakDL: // global
           HpAlloc = 32;
           _sajJs::I64 = I64[Sp];
           I64[Sp] = block_cakDD_info;
           R1 = _sajJs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakDK: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakDD() //  [R1]
         { info_tbl: [(cakDD,
                       label: block_cakDD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakDD: // global
           I64[Sp] = R1;
           call _cakDE() args: 0, res: 0, upd: 0;
     }
 },
 _cakDO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakDO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakDU; else goto cakDT;
       cakDU: // global
           HpAlloc = 32;
           _sajJs::I64 = I64[Sp];
           I64[Sp] = block_cakDN_info;
           R1 = _sajJs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakDT: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakDN() //  [R1]
         { info_tbl: [(cakDN,
                       label: block_cakDN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakDN: // global
           I64[Sp] = R1;
           call _cakDO() args: 0, res: 0, upd: 0;
     }
 },
 _cakC3() //  [R1]
         { info_tbl: [(cakC3,
                       label: block_cakC3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakC3: // global
           _sajJk::I64 = I64[R1 + 7];
           if (_sajJk::I64 & 1 == 0) goto cakCH; else goto cakCg;
       cakCH: // global
           _sajJn::I64 = _sajJk::I64 & 2;
           if (_sajJn::I64 != 0) goto uakFG; else goto uakFF;
       uakFG: // global
           I64[Sp] = _sajJn::I64;
           call _cakCP() args: 0, res: 0, upd: 0;
       uakFF: // global
           I64[Sp] = _sajJn::I64;
           call _cakCZ() args: 0, res: 0, upd: 0;
       cakCg: // global
           _sajJm::I64 = _sajJk::I64 & 2;
           if (_sajJm::I64 != 0) goto uakFC; else goto uakFB;
       uakFC: // global
           I64[Sp] = _sajJm::I64;
           call _cakCo() args: 0, res: 0, upd: 0;
       uakFB: // global
           I64[Sp] = _sajJm::I64;
           call _cakCy() args: 0, res: 0, upd: 0;
     }
 },
 _cakCP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakCW; else goto cakCV;
       cakCW: // global
           HpAlloc = 32;
           _sajJn::I64 = I64[Sp];
           I64[Sp] = block_cakCO_info;
           R1 = _sajJn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakCV: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakCO() //  [R1]
         { info_tbl: [(cakCO,
                       label: block_cakCO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCO: // global
           I64[Sp] = R1;
           call _cakCP() args: 0, res: 0, upd: 0;
     }
 },
 _cakCZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakD5; else goto cakD4;
       cakD5: // global
           HpAlloc = 32;
           _sajJn::I64 = I64[Sp];
           I64[Sp] = block_cakCY_info;
           R1 = _sajJn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakD4: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakCY() //  [R1]
         { info_tbl: [(cakCY,
                       label: block_cakCY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCY: // global
           I64[Sp] = R1;
           call _cakCZ() args: 0, res: 0, upd: 0;
     }
 },
 _cakCo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakCv; else goto cakCu;
       cakCv: // global
           HpAlloc = 32;
           _sajJm::I64 = I64[Sp];
           I64[Sp] = block_cakCn_info;
           R1 = _sajJm::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakCu: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakCn() //  [R1]
         { info_tbl: [(cakCn,
                       label: block_cakCn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCn: // global
           I64[Sp] = R1;
           call _cakCo() args: 0, res: 0, upd: 0;
     }
 },
 _cakCy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakCE; else goto cakCD;
       cakCE: // global
           HpAlloc = 32;
           _sajJm::I64 = I64[Sp];
           I64[Sp] = block_cakCx_info;
           R1 = _sajJm::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakCD: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakCx() //  [R1]
         { info_tbl: [(cakCx,
                       label: block_cakCx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakCx: // global
           I64[Sp] = R1;
           call _cakCy() args: 0, res: 0, upd: 0;
     }
 },
 _cakAV() //  [R1]
         { info_tbl: [(cakAV,
                       label: block_cakAV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakAV: // global
           _sajJf::I64 = I64[R1 + 7];
           if (_sajJf::I64 & 1 == 0) goto cakBA; else goto cakB9;
       cakBA: // global
           _sajJi::I64 = _sajJf::I64 & 2;
           if (_sajJi::I64 != 0) goto uakFy; else goto uakFx;
       uakFy: // global
           I64[Sp] = _sajJi::I64;
           call _cakBI() args: 0, res: 0, upd: 0;
       uakFx: // global
           I64[Sp] = _sajJi::I64;
           call _cakBS() args: 0, res: 0, upd: 0;
       cakB9: // global
           _sajJh::I64 = _sajJf::I64 & 2;
           if (_sajJh::I64 != 0) goto uakFu; else goto uakFt;
       uakFu: // global
           I64[Sp] = _sajJh::I64;
           call _cakBh() args: 0, res: 0, upd: 0;
       uakFt: // global
           I64[Sp] = _sajJh::I64;
           call _cakBr() args: 0, res: 0, upd: 0;
     }
 },
 _cakBI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakBP; else goto cakBO;
       cakBP: // global
           HpAlloc = 32;
           _sajJi::I64 = I64[Sp];
           I64[Sp] = block_cakBH_info;
           R1 = _sajJi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakBO: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakBH() //  [R1]
         { info_tbl: [(cakBH,
                       label: block_cakBH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBH: // global
           I64[Sp] = R1;
           call _cakBI() args: 0, res: 0, upd: 0;
     }
 },
 _cakBS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakBY; else goto cakBX;
       cakBY: // global
           HpAlloc = 32;
           _sajJi::I64 = I64[Sp];
           I64[Sp] = block_cakBR_info;
           R1 = _sajJi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakBX: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakBR() //  [R1]
         { info_tbl: [(cakBR,
                       label: block_cakBR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBR: // global
           I64[Sp] = R1;
           call _cakBS() args: 0, res: 0, upd: 0;
     }
 },
 _cakBh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakBo; else goto cakBn;
       cakBo: // global
           HpAlloc = 32;
           _sajJh::I64 = I64[Sp];
           I64[Sp] = block_cakBg_info;
           R1 = _sajJh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakBn: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakBg() //  [R1]
         { info_tbl: [(cakBg,
                       label: block_cakBg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBg: // global
           I64[Sp] = R1;
           call _cakBh() args: 0, res: 0, upd: 0;
     }
 },
 _cakBr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakBx; else goto cakBw;
       cakBx: // global
           HpAlloc = 32;
           _sajJh::I64 = I64[Sp];
           I64[Sp] = block_cakBq_info;
           R1 = _sajJh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cakBw: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cakBq() //  [R1]
         { info_tbl: [(cakBq,
                       label: block_cakBq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakBq: // global
           I64[Sp] = R1;
           call _cakBr() args: 0, res: 0, upd: 0;
     }
 },
 sat_sajJD_entry() //  [R1, R2]
         { info_tbl: [(cakGB,
                       label: sat_sajJD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakGB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakGD; else goto cakGE;
       cakGD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakGE: // global
           I64[Sp - 32] = block_cakAi_info;
           _sajIX::P64 = P64[R1 + 6];
           _sajIY::P64 = P64[R1 + 14];
           _sajIZ::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sajIX::P64;
           P64[Sp - 16] = _sajIY::P64;
           P64[Sp - 8] = _sajIZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakGK; else goto cakAj;
       uakGK: // global
           call _cakAi(R1) args: 0, res: 0, upd: 0;
       cakAj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakAi() //  [R1]
         { info_tbl: [(cakAi,
                       label: block_cakAi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakAi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakGH; else goto cakGG;
       cakGH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakGG: // global
           _sajJ7::P64 = P64[R1 + 7];
           I64[Hp - 32] = sat_sajJz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cakGC_info;
           R4 = Hp - 32;
           R3 = _sajJ7::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cakGC() //  []
         { info_tbl: [(cakGC,
                       label: block_cakGC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakGC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cakGL,
                       label: GHC.Event.Poll.new4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakGL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakGM; else goto cakGN;
       cakGM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakGN: // global
           I64[Sp - 32] = block_cakA8_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakGR; else goto cakA9;
       uakGR: // global
           call _cakA8(R1) args: 0, res: 0, upd: 0;
       cakA9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakA8() //  [R1]
         { info_tbl: [(cakA8,
                       label: block_cakA8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakA8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakGQ; else goto cakGP;
       cakGQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakGP: // global
           _sajJ2::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sajJD_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R3 = Hp - 22;
           R2 = _sajJ2::P64;
           Sp = Sp + 32;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.288336597 UTC

[section ""data" . GHC.Event.Poll.new2_closure" {
     GHC.Event.Poll.new2_closure:
         const GHC.Event.Poll.new2_info;
 },
 GHC.Event.Poll.new2_entry() //  []
         { info_tbl: [(cakGW,
                       label: GHC.Event.Poll.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakGW: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.289721612 UTC

[section ""data" . GHC.Event.Poll.new1_closure" {
     GHC.Event.Poll.new1_closure:
         const GHC.Event.Poll.new1_info;
         const 0;
 },
 GHC.Event.Poll.new1_entry() //  []
         { info_tbl: [(cakHo,
                       label: GHC.Event.Poll.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakHp; else goto cakHq;
       cakHp: // global
           R1 = GHC.Event.Poll.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cakHq: // global
           I64[Sp - 8] = block_cakH3_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakH3() //  [R1]
         { info_tbl: [(cakH3,
                       label: block_cakH3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakH3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakHt; else goto cakHs;
       cakHt: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakHs: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cakH8_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakH8() //  [R1]
         { info_tbl: [(cakH8,
                       label: block_cakH8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakH8: // global
           I64[Sp - 8] = block_cakHa_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cakHa() //  [R1]
         { info_tbl: [(cakHa,
                       label: block_cakHa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakHx; else goto cakHw;
       cakHx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakHw: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cakHd_info;
           R2 = Hp - 7;
           _sajJS::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sajJS::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakHd() //  []
         { info_tbl: [(cakHd,
                       label: block_cakHd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHd: // global
           I64[Sp] = block_cakHf_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakHf() //  [R1]
         { info_tbl: [(cakHf,
                       label: block_cakHf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakHB; else goto cakHA;
       cakHB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakHA: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cakHk_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakHk() //  [R1]
         { info_tbl: [(cakHk,
                       label: block_cakHk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cakHE; else goto cakHD;
       cakHE: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakHD: // global
           I64[Hp - 64] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.Event.Internal.Backend_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = GHC.Event.Poll.new5_closure+4;
           P64[Hp - 16] = GHC.Event.Poll.new4_closure+5;
           P64[Hp - 8] = GHC.Event.Poll.new3_closure;
           P64[Hp] = GHC.Event.Poll.new2_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.291884422 UTC

[section ""data" . GHC.Event.Poll.new_closure" {
     GHC.Event.Poll.new_closure:
         const GHC.Event.Poll.new_info;
         const 0;
 },
 GHC.Event.Poll.new_entry() //  []
         { info_tbl: [(cakHJ,
                       label: GHC.Event.Poll.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHJ: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.292778846 UTC

[section ""data" . GHC.Event.Poll.PollFd_closure" {
     GHC.Event.Poll.PollFd_closure:
         const GHC.Event.Poll.PollFd_info;
 },
 GHC.Event.Poll.PollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(cakHR,
                       label: GHC.Event.Poll.PollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakHR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakHV; else goto cakHU;
       cakHV: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.PollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakHU: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.293831367 UTC

[section ""data" . GHC.Event.Poll.Poll_closure" {
     GHC.Event.Poll.Poll_closure:
         const GHC.Event.Poll.Poll_info;
 },
 GHC.Event.Poll.Poll_entry() //  [R2, R3]
         { info_tbl: [(cakI1,
                       label: GHC.Event.Poll.Poll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakI1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakI5; else goto cakI4;
       cakI5: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.Poll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakI4: // global
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.294686918 UTC

[GHC.Event.Poll.PollFd_con_entry() //  [R1]
         { info_tbl: [(cakI6,
                       label: GHC.Event.Poll.PollFd_con_info
                       rep:HeapRep 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108,70,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakI6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.295413676 UTC

[GHC.Event.Poll.Poll_con_entry() //  [R1]
         { info_tbl: [(cakI8,
                       label: GHC.Event.Poll.Poll_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakI8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.29607269 UTC

[section ""relreadonly" . SajSl_srt" {
     SajSl_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Poll.$w$cshowsPrec1_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure;
         const GHC.Event.Poll.$fShowPollFd1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.loop_closure;
         const GHC.Event.Array.removeAt_closure;
         const GHC.Event.Array.findIndex_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.$wlvl_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Poll.new5_closure;
         const lvl3_rajBc_closure;
         const lvl5_rajBe_closure;
         const lvl6_rajBf_closure;
         const lvl10_rajBj_closure;
         const lvl11_rajBk_closure;
         const GHC.Event.Poll.new4_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Poll.new3_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.296969859 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:19.298578988 UTC

[section ""data" . GHC.Event.Poll.$WPollFd_closure" {
     GHC.Event.Poll.$WPollFd_closure:
         const GHC.Event.Poll.$WPollFd_info;
 },
 GHC.Event.Poll.$WPollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(cakIh,
                       label: GHC.Event.Poll.$WPollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakIh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakIv; else goto cakIw;
       cakIv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakIw: // global
           I64[Sp - 24] = block_cakIe_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakID; else goto cakIf;
       uakID: // global
           call _cakIe(R1) args: 0, res: 0, upd: 0;
       cakIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakIe() //  [R1]
         { info_tbl: [(cakIe,
                       label: block_cakIe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakIe: // global
           I64[Sp] = block_cakIk_info;
           _sajBq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajBq::I64;
           if (R1 & 7 != 0) goto uakIC; else goto cakIl;
       uakIC: // global
           call _cakIk(R1) args: 0, res: 0, upd: 0;
       cakIl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakIk() //  [R1]
         { info_tbl: [(cakIk,
                       label: block_cakIk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakIk: // global
           I64[Sp] = block_cakIp_info;
           _sajBs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajBs::I64;
           if (R1 & 7 != 0) goto uakIE; else goto cakIq;
       uakIE: // global
           call _cakIp(R1) args: 0, res: 0, upd: 0;
       cakIq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakIp() //  [R1]
         { info_tbl: [(cakIp,
                       label: block_cakIp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakIp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakIB; else goto cakIA;
       cakIB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakIA: // global
           _sajBu::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _sajBu::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.308112111 UTC

[section ""data" . GHC.Event.Poll.$WPoll_closure" {
     GHC.Event.Poll.$WPoll_closure:
         const GHC.Event.Poll.$WPoll_info;
 },
 GHC.Event.Poll.$WPoll_entry() //  [R2, R3]
         { info_tbl: [(cakJ6,
                       label: GHC.Event.Poll.$WPoll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakJf; else goto cakJg;
       cakJf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPoll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakJg: // global
           I64[Sp - 16] = block_cakJ3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakJm; else goto cakJ4;
       uakJm: // global
           call _cakJ3(R1) args: 0, res: 0, upd: 0;
       cakJ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakJ3() //  [R1]
         { info_tbl: [(cakJ3,
                       label: block_cakJ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakJ3: // global
           I64[Sp] = block_cakJ9_info;
           _sajBy::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sajBy::P64;
           if (R1 & 7 != 0) goto uakJl; else goto cakJa;
       uakJl: // global
           call _cakJ9(R1) args: 0, res: 0, upd: 0;
       cakJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakJ9() //  [R1]
         { info_tbl: [(cakJ9,
                       label: block_cakJ9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakJ9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakJk; else goto cakJj;
       cakJk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakJj: // global
           _sajBA::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sajBA::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.315697456 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$calignment_closure" {
     GHC.Event.Poll.$fStorablePollFd_$calignment_closure:
         const GHC.Event.Poll.$fStorablePollFd_$calignment_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$calignment_entry() //  []
         { info_tbl: [(cakJG,
                       label: GHC.Event.Poll.$fStorablePollFd_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakJG: // global
           R1 = Foreign.Storable.$fStorableBool7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.31889526 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd7_closure" {
     GHC.Event.Poll.$fStorablePollFd7_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.320694912 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure" {
     GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure:
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$csizeOf_entry() //  []
         { info_tbl: [(cakJT,
                       label: GHC.Event.Poll.$fStorablePollFd_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakJT: // global
           R1 = GHC.Event.Poll.$fStorablePollFd7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.325931287 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd2_closure" {
     GHC.Event.Poll.$fStorablePollFd2_closure:
         const GHC.Event.Poll.$fStorablePollFd2_info;
 },
 GHC.Event.Poll.$fStorablePollFd2_entry() //  [R2]
         { info_tbl: [(cakK8,
                       label: GHC.Event.Poll.$fStorablePollFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakK8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakKi; else goto cakKj;
       cakKi: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakKj: // global
           I64[Sp - 8] = block_cakK5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakKn; else goto cakK6;
       uakKn: // global
           call _cakK5(R1) args: 0, res: 0, upd: 0;
       cakK6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakK5() //  [R1]
         { info_tbl: [(cakK5,
                       label: block_cakK5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakK5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakKm; else goto cakKl;
       cakKm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakKl: // global
           _sajBG::I64 = I64[R1 + 7];
           _sajBJ::I64 = %MO_SS_Conv_W32_W64(I32[_sajBG::I64]);
           _sajBN::I64 = %MO_SS_Conv_W16_W64(I16[_sajBG::I64 + 4]);
           _sajBR::I64 = %MO_SS_Conv_W16_W64(I16[_sajBG::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajBJ::I64;
           I64[Hp - 8] = _sajBN::I64;
           I64[Hp] = _sajBR::I64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.332061605 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd6_closure" {
     GHC.Event.Poll.$fStorablePollFd6_closure:
         const GHC.Event.Poll.$fStorablePollFd6_info;
 },
 GHC.Event.Poll.$fStorablePollFd6_entry() //  [R2, R3]
         { info_tbl: [(cakKF,
                       label: GHC.Event.Poll.$fStorablePollFd6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakKF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakL0; else goto cakL1;
       cakL0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakL1: // global
           I64[Sp - 16] = block_cakKC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakL7; else goto cakKD;
       uakL7: // global
           call _cakKC(R1) args: 0, res: 0, upd: 0;
       cakKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakKC() //  [R1]
         { info_tbl: [(cakKC,
                       label: block_cakKC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakKC: // global
           I64[Sp] = block_cakKI_info;
           _sajBX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajBX::I64;
           if (R1 & 7 != 0) goto uakL6; else goto cakKJ;
       uakL6: // global
           call _cakKI(R1) args: 0, res: 0, upd: 0;
       cakKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakKI() //  [R1]
         { info_tbl: [(cakKI,
                       label: block_cakKI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakKI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakL5; else goto cakL4;
       cakL5: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakL4: // global
           _sajC0::I64 = I64[Sp + 8] + (I64[R1 + 7] << 3);
           _sajC4::I64 = %MO_SS_Conv_W32_W64(I32[_sajC0::I64]);
           _sajC8::I64 = %MO_SS_Conv_W16_W64(I16[_sajC0::I64 + 4]);
           _sajCc::I64 = %MO_SS_Conv_W16_W64(I16[_sajC0::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajC4::I64;
           I64[Hp - 8] = _sajC8::I64;
           I64[Hp] = _sajCc::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.339694821 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd4_closure" {
     GHC.Event.Poll.$fStorablePollFd4_closure:
         const GHC.Event.Poll.$fStorablePollFd4_info;
 },
 GHC.Event.Poll.$fStorablePollFd4_entry() //  [R2, R3]
         { info_tbl: [(cakLv,
                       label: GHC.Event.Poll.$fStorablePollFd4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakLv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakLN; else goto cakLO;
       cakLN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakLO: // global
           I64[Sp - 16] = block_cakLs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakLU; else goto cakLt;
       uakLU: // global
           call _cakLs(R1) args: 0, res: 0, upd: 0;
       cakLt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakLs() //  [R1]
         { info_tbl: [(cakLs,
                       label: block_cakLs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakLs: // global
           I64[Sp] = block_cakLy_info;
           _sajCi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCi::I64;
           if (R1 & 7 != 0) goto uakLT; else goto cakLz;
       uakLT: // global
           call _cakLy(R1) args: 0, res: 0, upd: 0;
       cakLz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakLy() //  [R1]
         { info_tbl: [(cakLy,
                       label: block_cakLy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakLy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakLS; else goto cakLR;
       cakLS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakLR: // global
           _sajCl::I64 = I64[Sp + 8] + I64[R1 + 7];
           _sajCo::I64 = %MO_SS_Conv_W32_W64(I32[_sajCl::I64]);
           _sajCs::I64 = %MO_SS_Conv_W16_W64(I16[_sajCl::I64 + 4]);
           _sajCw::I64 = %MO_SS_Conv_W16_W64(I16[_sajCl::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajCo::I64;
           I64[Hp - 8] = _sajCs::I64;
           I64[Hp] = _sajCw::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.347822389 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd1_closure" {
     GHC.Event.Poll.$fStorablePollFd1_closure:
         const GHC.Event.Poll.$fStorablePollFd1_info;
 },
 GHC.Event.Poll.$fStorablePollFd1_entry() //  [R2, R3]
         { info_tbl: [(cakMi,
                       label: GHC.Event.Poll.$fStorablePollFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakMi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakMm; else goto cakMn;
       cakMm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakMn: // global
           I64[Sp - 16] = block_cakMf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakMz; else goto cakMg;
       uakMz: // global
           call _cakMf(R1) args: 0, res: 0, upd: 0;
       cakMg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakMf() //  [R1]
         { info_tbl: [(cakMf,
                       label: block_cakMf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakMf: // global
           I64[Sp] = block_cakMl_info;
           _sajCC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCC::I64;
           if (R1 & 7 != 0) goto uakMy; else goto cakMp;
       uakMy: // global
           call _cakMl(R1) args: 0, res: 0, upd: 0;
       cakMp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakMl() //  [R1]
         { info_tbl: [(cakMl,
                       label: block_cakMl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakMl: // global
           _sajCC::I64 = I64[Sp + 8];
           _sajCF::I64 = I64[R1 + 15];
           _sajCG::I64 = I64[R1 + 23];
           I32[_sajCC::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajCC::I64 + 4] = %MO_UU_Conv_W64_W16(_sajCF::I64);
           I16[_sajCC::I64 + 6] = %MO_UU_Conv_W64_W16(_sajCG::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.355442669 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd5_closure" {
     GHC.Event.Poll.$fStorablePollFd5_closure:
         const GHC.Event.Poll.$fStorablePollFd5_info;
 },
 GHC.Event.Poll.$fStorablePollFd5_entry() //  [R2, R3, R4]
         { info_tbl: [(cakMY,
                       label: GHC.Event.Poll.$fStorablePollFd5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakMY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakN7; else goto cakN8;
       cakN7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakN8: // global
           I64[Sp - 24] = block_cakMV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakNr; else goto cakMW;
       uakNr: // global
           call _cakMV(R1) args: 0, res: 0, upd: 0;
       cakMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakMV() //  [R1]
         { info_tbl: [(cakMV,
                       label: block_cakMV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakMV: // global
           I64[Sp] = block_cakN1_info;
           _sajCR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajCR::I64;
           if (R1 & 7 != 0) goto uakNq; else goto cakN2;
       uakNq: // global
           call _cakN1(R1) args: 0, res: 0, upd: 0;
       cakN2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakN1() //  [R1]
         { info_tbl: [(cakN1,
                       label: block_cakN1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakN1: // global
           I64[Sp] = block_cakN6_info;
           _sajCT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajCT::I64;
           if (R1 & 7 != 0) goto uakNs; else goto cakNb;
       uakNs: // global
           call _cakN6(R1) args: 0, res: 0, upd: 0;
       cakNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakN6() //  [R1]
         { info_tbl: [(cakN6,
                       label: block_cakN6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakN6: // global
           _sajCW::I64 = I64[R1 + 15];
           _sajCX::I64 = I64[R1 + 23];
           _sajCY::I64 = I64[Sp + 8] + (I64[Sp + 16] << 3);
           I32[_sajCY::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajCY::I64 + 4] = %MO_UU_Conv_W64_W16(_sajCW::I64);
           I16[_sajCY::I64 + 6] = %MO_UU_Conv_W64_W16(_sajCX::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.366183056 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd3_closure" {
     GHC.Event.Poll.$fStorablePollFd3_closure:
         const GHC.Event.Poll.$fStorablePollFd3_info;
 },
 GHC.Event.Poll.$fStorablePollFd3_entry() //  [R2, R3, R4]
         { info_tbl: [(cakNX,
                       label: GHC.Event.Poll.$fStorablePollFd3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakNX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakO6; else goto cakO7;
       cakO6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakO7: // global
           I64[Sp - 24] = block_cakNU_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakOn; else goto cakNV;
       uakOn: // global
           call _cakNU(R1) args: 0, res: 0, upd: 0;
       cakNV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakNU() //  [R1]
         { info_tbl: [(cakNU,
                       label: block_cakNU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakNU: // global
           I64[Sp] = block_cakO0_info;
           _sajDa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajDa::I64;
           if (R1 & 7 != 0) goto uakOm; else goto cakO1;
       uakOm: // global
           call _cakO0(R1) args: 0, res: 0, upd: 0;
       cakO1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakO0() //  [R1]
         { info_tbl: [(cakO0,
                       label: block_cakO0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakO0: // global
           I64[Sp] = block_cakO5_info;
           _sajDc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajDc::I64;
           if (R1 & 7 != 0) goto uakOo; else goto cakOa;
       uakOo: // global
           call _cakO5(R1) args: 0, res: 0, upd: 0;
       cakOa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakO5() //  [R1]
         { info_tbl: [(cakO5,
                       label: block_cakO5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakO5: // global
           _sajDf::I64 = I64[R1 + 15];
           _sajDg::I64 = I64[R1 + 23];
           _sajDh::I64 = I64[Sp + 8] + I64[Sp + 16];
           I32[_sajDh::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_sajDh::I64 + 4] = %MO_UU_Conv_W64_W16(_sajDf::I64);
           I16[_sajDh::I64 + 6] = %MO_UU_Conv_W64_W16(_sajDg::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.374955789 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_closure" {
     GHC.Event.Poll.$fStorablePollFd_closure:
         const Foreign.Storable.C:Storable_con_info;
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure+1;
         const GHC.Event.Poll.$fStorablePollFd_$calignment_closure+1;
         const GHC.Event.Poll.$fStorablePollFd6_closure+3;
         const GHC.Event.Poll.$fStorablePollFd5_closure+4;
         const GHC.Event.Poll.$fStorablePollFd4_closure+3;
         const GHC.Event.Poll.$fStorablePollFd3_closure+4;
         const GHC.Event.Poll.$fStorablePollFd2_closure+2;
         const GHC.Event.Poll.$fStorablePollFd1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.376836531 UTC

[section ""data" . GHC.Event.Poll.$fStorableEvent_closure" {
     GHC.Event.Poll.$fStorableEvent_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.379021277 UTC

[section ""cstring" . GHC.Event.Poll.$fShowEvent2_bytes" {
     GHC.Event.Poll.$fShowEvent2_bytes:
         I8[] [69,118,101,110,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.382040346 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec_closure" {
     GHC.Event.Poll.$w$cshowsPrec_closure:
         const GHC.Event.Poll.$w$cshowsPrec_info;
 },
 sat_sajDw_entry() //  [R1]
         { info_tbl: [(cakP2,
                       label: sat_sajDw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakP2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakP8; else goto cakP9;
       cakP8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakP9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cakOZ_info;
           _sajDp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sajDp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakPe; else goto cakP0;
       uakPe: // global
           call _cakOZ(R1) args: 0, res: 0, upd: 0;
       cakP0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakOZ() //  [R1]
         { info_tbl: [(cakOZ,
                       label: block_cakOZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakOZ: // global
           _sajDp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cakP5_info;
           R4 = _sajDp::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakP5() //  [R1, R2]
         { info_tbl: [(cakP5,
                       label: block_cakP5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakP5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakPd; else goto cakPc;
       cakPd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakPc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajDD_entry() //  [R1]
         { info_tbl: [(cakPr,
                       label: sat_sajDD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakPr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakPy; else goto cakPz;
       cakPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakPz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cakPo_info;
           _sajDp::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sajDp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uakPG; else goto cakPp;
       uakPG: // global
           call _cakPo(R1) args: 0, res: 0, upd: 0;
       cakPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakPo() //  [R1]
         { info_tbl: [(cakPo,
                       label: block_cakPo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakPo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakPC; else goto cakPB;
       cakPC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cakPB: // global
           _sajDy::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cakPv_info;
           R4 = Hp - 14;
           R3 = _sajDy::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakPv() //  [R1, R2]
         { info_tbl: [(cakPv,
                       label: block_cakPv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakPv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakPF; else goto cakPE;
       cakPF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakPE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajDE_entry() //  [R1]
         { info_tbl: [(cakPH,
                       label: sat_sajDE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakPH: // global
           _sajDE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakPI; else goto cakPJ;
       cakPJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakPL; else goto cakPK;
       cakPL: // global
           HpAlloc = 32;
           goto cakPI;
       cakPI: // global
           R1 = _sajDE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakPK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajDE::P64;
           _sajDo::P64 = P64[_sajDE::P64 + 16];
           _sajDp::P64 = P64[_sajDE::P64 + 24];
           I64[Hp - 24] = sat_sajDD_info;
           P64[Hp - 8] = _sajDo::P64;
           P64[Hp] = _sajDp::P64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cakPP,
                       label: GHC.Event.Poll.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakPP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cakPT; else goto cakPS;
       cakPT: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakPS: // global
           if (%MO_S_Lt_W64(R2, 11)) goto cakPN; else goto cakPO;
       cakPN: // global
           I64[Hp - 48] = sat_sajDw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _cakOV::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cakOV::P64;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cakPO: // global
           I64[Hp - 48] = sat_sajDE_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.400686861 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cakQB,
                       label: GHC.Event.Poll.$fShowEvent_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakQB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakQC; else goto cakQD;
       cakQC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakQD: // global
           I64[Sp - 24] = block_cakQy_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakQH; else goto cakQz;
       uakQH: // global
           call _cakQy(R1) args: 0, res: 0, upd: 0;
       cakQz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakQy() //  [R1]
         { info_tbl: [(cakQy,
                       label: block_cakQy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakQy: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.406637298 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshow_closure" {
     GHC.Event.Poll.$fShowEvent_$cshow_closure:
         const GHC.Event.Poll.$fShowEvent_$cshow_info;
 },
 sat_sajDQ_entry() //  [R1]
         { info_tbl: [(cakR2,
                       label: sat_sajDQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakR2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakR8; else goto cakR9;
       cakR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cakQZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakRe; else goto cakR0;
       uakRe: // global
           call _cakQZ(R1) args: 0, res: 0, upd: 0;
       cakR0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cakQZ() //  [R1]
         { info_tbl: [(cakQZ,
                       label: block_cakQZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakQZ: // global
           I64[Sp] = block_cakR5_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakR5() //  [R1, R2]
         { info_tbl: [(cakR5,
                       label: block_cakR5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakR5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakRd; else goto cakRc;
       cakRd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakRc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$fShowEvent_$cshow_entry() //  [R2]
         { info_tbl: [(cakRf,
                       label: GHC.Event.Poll.$fShowEvent_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakRf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakRj; else goto cakRi;
       cakRj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakRi: // global
           I64[Hp - 16] = sat_sajDQ_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.415883556 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent1_closure" {
     GHC.Event.Poll.$fShowEvent1_closure:
         const GHC.Event.Poll.$fShowEvent1_info;
 },
 GHC.Event.Poll.$fShowEvent1_entry() //  [R2, R3]
         { info_tbl: [(cakRE,
                       label: GHC.Event.Poll.$fShowEvent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakRE: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.419265145 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowList_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowList_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowList_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cakRP,
                       label: GHC.Event.Poll.$fShowEvent_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakRP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowEvent1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.422473807 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_closure" {
     GHC.Event.Poll.$fShowEvent_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowEvent_$cshow_closure+1;
         const GHC.Event.Poll.$fShowEvent_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.424200775 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd6_bytes" {
     GHC.Event.Poll.$fShowPollFd6_bytes:
         I8[] [80,111,108,108,70,100,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.426169256 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd5_bytes" {
     GHC.Event.Poll.$fShowPollFd5_bytes:
         I8[] [112,102,100,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.427790218 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd4_bytes" {
     GHC.Event.Poll.$fShowPollFd4_bytes:
         I8[] [112,102,100,69,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.429358691 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd3_bytes" {
     GHC.Event.Poll.$fShowPollFd3_bytes:
         I8[] [112,102,100,82,101,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.431487396 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd2_bytes" {
     GHC.Event.Poll.$fShowPollFd2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.43543879 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec1_closure" {
     GHC.Event.Poll.$w$cshowsPrec1_closure:
         const GHC.Event.Poll.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Poll.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakS3: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajE4_entry() //  [R1]
         { info_tbl: [(cakSM,
                       label: sat_sajE4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakSM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakSN; else goto cakSO;
       cakSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakSO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Poll.$fShowPollFd2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE5_entry() //  [R1]
         { info_tbl: [(cakSQ,
                       label: sat_sajE5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakSQ: // global
           _sajE5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakSR; else goto cakSS;
       cakSS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakSU; else goto cakST;
       cakSU: // global
           HpAlloc = 40;
           goto cakSR;
       cakSR: // global
           R1 = _sajE5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakST: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE5::P64;
           _sajE1::P64 = P64[_sajE5::P64 + 16];
           _sajDY::I64 = I64[_sajE5::P64 + 24];
           I64[Hp - 32] = sat_sajE4_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajDY::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE6_entry() //  [R1]
         { info_tbl: [(cakSV,
                       label: sat_sajE6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakSV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakSZ; else goto cakSY;
       cakSZ: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakSY: // global
           _sajE1::P64 = P64[R1 + 16];
           _sajDY::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_sajE5_info;
           P64[Hp - 8] = _sajE1::P64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowPollFd3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajE7_entry() //  [R1]
         { info_tbl: [(cakT0,
                       label: sat_sajE7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakT0: // global
           _sajE7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakT1; else goto cakT2;
       cakT2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakT4; else goto cakT3;
       cakT4: // global
           HpAlloc = 32;
           goto cakT1;
       cakT1: // global
           R1 = _sajE7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakT3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE7::P64;
           _sajE1::P64 = P64[_sajE7::P64 + 16];
           _sajDY::I64 = I64[_sajE7::P64 + 24];
           I64[Hp - 24] = sat_sajE6_info;
           P64[Hp - 8] = _sajE1::P64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE8_entry() //  [R1]
         { info_tbl: [(cakT6,
                       label: sat_sajE8_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakT6: // global
           _sajE8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakT7; else goto cakT8;
       cakT8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cakTa; else goto cakT9;
       cakTa: // global
           HpAlloc = 48;
           goto cakT7;
       cakT7: // global
           R1 = _sajE8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakT9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajE8::P64;
           _sajE1::P64 = P64[_sajE8::P64 + 16];
           _sajDX::I64 = I64[_sajE8::P64 + 24];
           _sajDY::I64 = I64[_sajE8::P64 + 32];
           I64[Hp - 40] = sat_sajE7_info;
           P64[Hp - 24] = _sajE1::P64;
           I64[Hp - 16] = _sajDY::I64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajDX::I64;
           R4 = Hp - 40;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajE9_entry() //  [R1]
         { info_tbl: [(cakTb,
                       label: sat_sajE9_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakTf; else goto cakTe;
       cakTf: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakTe: // global
           _sajE1::P64 = P64[R1 + 16];
           _sajDX::I64 = I64[R1 + 24];
           _sajDY::I64 = I64[R1 + 32];
           I64[Hp - 32] = sat_sajE8_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Poll.$fShowPollFd4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajEa_entry() //  [R1]
         { info_tbl: [(cakTg,
                       label: sat_sajEa_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTg: // global
           _sajEa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakTh; else goto cakTi;
       cakTi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakTk; else goto cakTj;
       cakTk: // global
           HpAlloc = 40;
           goto cakTh;
       cakTh: // global
           R1 = _sajEa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEa::P64;
           _sajE1::P64 = P64[_sajEa::P64 + 16];
           _sajDX::I64 = I64[_sajEa::P64 + 24];
           _sajDY::I64 = I64[_sajEa::P64 + 32];
           I64[Hp - 32] = sat_sajE9_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajEe_entry() //  [R1]
         { info_tbl: [(cakTo,
                       label: sat_sajEe_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTo: // global
           _sajEe::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cakTp; else goto cakTq;
       cakTq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cakTs; else goto cakTr;
       cakTs: // global
           HpAlloc = 40;
           goto cakTp;
       cakTp: // global
           R1 = _sajEe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakTr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEe::P64;
           _sajE1::P64 = P64[_sajEe::P64 + 16];
           _sajDW::I64 = I64[_sajEe::P64 + 24];
           _sajDX::I64 = I64[_sajEe::P64 + 32];
           _sajDY::I64 = I64[_sajEe::P64 + 40];
           I64[Hp - 32] = sat_sajEa_info;
           P64[Hp - 16] = _sajE1::P64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           I64[Sp - 24] = block_cakTl_info;
           R4 = Hp - 32;
           R3 = _sajDW::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakTl() //  [R1, R2]
         { info_tbl: [(cakTl,
                       label: block_cakTl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakTv; else goto cakTu;
       cakTv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cakTu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajEf_entry() //  [R1]
         { info_tbl: [(cakTw,
                       label: sat_sajEf_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTw: // global
           _sajEf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakTx; else goto cakTy;
       cakTy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cakTA; else goto cakTz;
       cakTA: // global
           HpAlloc = 48;
           goto cakTx;
       cakTx: // global
           R1 = _sajEf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEf::P64;
           _sajE1::P64 = P64[_sajEf::P64 + 16];
           _sajDW::I64 = I64[_sajEf::P64 + 24];
           _sajDX::I64 = I64[_sajEf::P64 + 32];
           _sajDY::I64 = I64[_sajEf::P64 + 40];
           I64[Hp - 40] = sat_sajEe_info;
           P64[Hp - 24] = _sajE1::P64;
           I64[Hp - 16] = _sajDW::I64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_sajE0_entry() //  [R1, R2]
         { info_tbl: [(cakTB,
                       label: p_sajE0_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cakTF; else goto cakTE;
       cakTF: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakTE: // global
           _sajDW::I64 = I64[R1 + 7];
           _sajDX::I64 = I64[R1 + 15];
           _sajDY::I64 = I64[R1 + 23];
           I64[Hp - 40] = sat_sajEf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = _sajDW::I64;
           I64[Hp - 8] = _sajDX::I64;
           I64[Hp] = _sajDY::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajEi_entry() //  [R1]
         { info_tbl: [(cakTP,
                       label: sat_sajEi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTP: // global
           _sajEi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cakTQ; else goto cakTR;
       cakTR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cakTT; else goto cakTS;
       cakTT: // global
           HpAlloc = 24;
           goto cakTQ;
       cakTQ: // global
           R1 = _sajEi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakTS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sajEi::P64;
           _sajDZ::P64 = P64[_sajEi::P64 + 16];
           _sajE0::P64 = P64[_sajEi::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sajDZ::P64;
           R2 = Hp - 14;
           R1 = _sajE0::P64;
           Sp = Sp - 16;
           call p_sajE0_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cakTX,
                       label: GHC.Event.Poll.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakTX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cakU1; else goto cakU0;
       cakU1: // global
           HpAlloc = 88;
           R1 = GHC.Event.Poll.$w$cshowsPrec1_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cakU0: // global
           I64[Hp - 80] = p_sajE0_info;
           I64[Hp - 72] = R3;
           I64[Hp - 64] = R4;
           I64[Hp - 56] = R5;
           _cakS7::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto cakTV; else goto cakTW;
       cakTV: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _cakS7::P64;
           call p_sajE0_entry(R2, R1) args: 8, res: 0, upd: 8;
       cakTW: // global
           I64[Hp - 48] = sat_sajEi_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _cakS7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.467029667 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cakV1,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakV1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakV5; else goto cakV6;
       cakV5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakV6: // global
           I64[Sp - 24] = block_cakUY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uakVe; else goto cakUZ;
       uakVe: // global
           call _cakUY(R1) args: 0, res: 0, upd: 0;
       cakUZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakUY() //  [R1]
         { info_tbl: [(cakUY,
                       label: block_cakUY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakUY: // global
           I64[Sp] = block_cakV4_info;
           _sajEn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sajEn::I64;
           if (R1 & 7 != 0) goto uakVd; else goto cakV8;
       uakVd: // global
           call _cakV4(R1) args: 0, res: 0, upd: 0;
       cakV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakV4() //  [R1]
         { info_tbl: [(cakV4,
                       label: block_cakV4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakV4: // global
           R6 = P64[Sp + 16];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.47516521 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd7_closure" {
     GHC.Event.Poll.$fShowPollFd7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.477168322 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshow_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshow_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshow_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshow_entry() //  [R2]
         { info_tbl: [(cakVA,
                       label: GHC.Event.Poll.$fShowPollFd_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakVA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakVB; else goto cakVC;
       cakVB: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakVC: // global
           I64[Sp - 8] = block_cakVx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakVG; else goto cakVy;
       uakVG: // global
           call _cakVx(R1) args: 0, res: 0, upd: 0;
       cakVy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakVx() //  [R1]
         { info_tbl: [(cakVx,
                       label: block_cakVx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakVx: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.482715766 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd1_closure" {
     GHC.Event.Poll.$fShowPollFd1_closure:
         const GHC.Event.Poll.$fShowPollFd1_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd1_entry() //  [R2, R3]
         { info_tbl: [(cakVX,
                       label: GHC.Event.Poll.$fShowPollFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakVX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakVY; else goto cakVZ;
       cakVY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cakVZ: // global
           I64[Sp - 16] = block_cakVU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uakW3; else goto cakVV;
       uakW3: // global
           call _cakVU(R1) args: 0, res: 0, upd: 0;
       cakVV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakVU() //  [R1]
         { info_tbl: [(cakVU,
                       label: block_cakVU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakVU: // global
           R6 = P64[Sp + 8];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.488137801 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowList_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowList_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowList_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cakWh,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakWh: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowPollFd1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.491663646 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_closure" {
     GHC.Event.Poll.$fShowPollFd_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure+1;
         const GHC.Event.Poll.$fShowPollFd_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.493436417 UTC

[section ""data" . GHC.Event.Poll.$fEqEvent_closure" {
     GHC.Event.Poll.$fEqEvent_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.495421543 UTC

[section ""data" . GHC.Event.Poll.pfdRevents_closure" {
     GHC.Event.Poll.pfdRevents_closure:
         const GHC.Event.Poll.pfdRevents_info;
 },
 GHC.Event.Poll.pfdRevents_entry() //  [R2]
         { info_tbl: [(cakWx,
                       label: GHC.Event.Poll.pfdRevents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakWx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakWB; else goto cakWC;
       cakWB: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdRevents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakWC: // global
           I64[Sp - 8] = block_cakWu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakWG; else goto cakWv;
       uakWG: // global
           call _cakWu(R1) args: 0, res: 0, upd: 0;
       cakWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakWu() //  [R1]
         { info_tbl: [(cakWu,
                       label: block_cakWu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakWF; else goto cakWE;
       cakWF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakWE: // global
           _sajEJ::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajEJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.500968062 UTC

[section ""data" . GHC.Event.Poll.pfdEvents_closure" {
     GHC.Event.Poll.pfdEvents_closure:
         const GHC.Event.Poll.pfdEvents_info;
 },
 GHC.Event.Poll.pfdEvents_entry() //  [R2]
         { info_tbl: [(cakWY,
                       label: GHC.Event.Poll.pfdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakWY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakX2; else goto cakX3;
       cakX2: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakX3: // global
           I64[Sp - 8] = block_cakWV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakX7; else goto cakWW;
       uakX7: // global
           call _cakWV(R1) args: 0, res: 0, upd: 0;
       cakWW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakWV() //  [R1]
         { info_tbl: [(cakWV,
                       label: block_cakWV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakWV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakX6; else goto cakX5;
       cakX6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakX5: // global
           _sajEN::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _sajEN::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.506906722 UTC

[section ""data" . GHC.Event.Poll.pfdFd_closure" {
     GHC.Event.Poll.pfdFd_closure:
         const GHC.Event.Poll.pfdFd_info;
 },
 GHC.Event.Poll.pfdFd_entry() //  [R2]
         { info_tbl: [(cakXp,
                       label: GHC.Event.Poll.pfdFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakXp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakXt; else goto cakXu;
       cakXt: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakXu: // global
           I64[Sp - 8] = block_cakXm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakXy; else goto cakXn;
       uakXy: // global
           call _cakXm(R1) args: 0, res: 0, upd: 0;
       cakXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakXm() //  [R1]
         { info_tbl: [(cakXm,
                       label: block_cakXm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakXm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakXx; else goto cakXw;
       cakXx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakXw: // global
           _sajER::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajER::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.512938153 UTC

[section ""data" . GHC.Event.Poll.pollFd_closure" {
     GHC.Event.Poll.pollFd_closure:
         const GHC.Event.Poll.pollFd_info;
 },
 GHC.Event.Poll.pollFd_entry() //  [R2]
         { info_tbl: [(cakXQ,
                       label: GHC.Event.Poll.pollFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakXQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakXU; else goto cakXV;
       cakXU: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakXV: // global
           I64[Sp - 8] = block_cakXN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakXZ; else goto cakXO;
       uakXZ: // global
           call _cakXN(R1) args: 0, res: 0, upd: 0;
       cakXO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakXN() //  [R1]
         { info_tbl: [(cakXN,
                       label: block_cakXN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakXN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakXY; else goto cakXX;
       cakXY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakXX: // global
           _sajEX::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sajEX::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.518864939 UTC

[section ""data" . GHC.Event.Poll.pollChanges_closure" {
     GHC.Event.Poll.pollChanges_closure:
         const GHC.Event.Poll.pollChanges_info;
 },
 GHC.Event.Poll.pollChanges_entry() //  [R2]
         { info_tbl: [(cakYh,
                       label: GHC.Event.Poll.pollChanges_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakYh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cakYl; else goto cakYm;
       cakYl: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollChanges_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cakYm: // global
           I64[Sp - 8] = block_cakYe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uakYq; else goto cakYf;
       uakYq: // global
           call _cakYe(R1) args: 0, res: 0, upd: 0;
       cakYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakYe() //  [R1]
         { info_tbl: [(cakYe,
                       label: block_cakYe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakYe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cakYp; else goto cakYo;
       cakYp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakYo: // global
           _sajF0::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sajF0::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.52446347 UTC

[section ""data" . GHC.Event.Poll.available_closure" {
     GHC.Event.Poll.available_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.526142715 UTC

[section ""cstring" . GHC.Event.Poll.$trModule4_bytes" {
     GHC.Event.Poll.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.52779391 UTC

[section ""data" . GHC.Event.Poll.$trModule3_closure" {
     GHC.Event.Poll.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.529662232 UTC

[section ""cstring" . GHC.Event.Poll.$trModule2_bytes" {
     GHC.Event.Poll.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.53127155 UTC

[section ""data" . GHC.Event.Poll.$trModule1_closure" {
     GHC.Event.Poll.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.532903727 UTC

[section ""data" . GHC.Event.Poll.$trModule_closure" {
     GHC.Event.Poll.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Poll.$trModule3_closure+1;
         const GHC.Event.Poll.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.534701153 UTC

[section ""data" . $krep_rajAW_closure" {
     $krep_rajAW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCShort_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.536428728 UTC

[section ""data" . $krep1_rajAX_closure" {
     $krep1_rajAX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.538877995 UTC

[section ""cstring" . GHC.Event.Poll.$tcEvent2_bytes" {
     GHC.Event.Poll.$tcEvent2_bytes:
         I8[] [69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.540522892 UTC

[section ""data" . GHC.Event.Poll.$tcEvent1_closure" {
     GHC.Event.Poll.$tcEvent1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcEvent2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.542141409 UTC

[section ""data" . GHC.Event.Poll.$tcEvent_closure" {
     GHC.Event.Poll.$tcEvent_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcEvent1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10782964843686049546;
         const 16589058175633483645;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.543928906 UTC

[section ""data" . $krep2_rajAY_closure" {
     $krep2_rajAY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcEvent_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.545903181 UTC

[section ""data" . GHC.Event.Poll.$tc'Event1_closure" {
     GHC.Event.Poll.$tc'Event1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rajAW_closure+1;
         const $krep2_rajAY_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.547612553 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Event3_bytes" {
     GHC.Event.Poll.$tc'Event3_bytes:
         I8[] [39,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.549341639 UTC

[section ""data" . GHC.Event.Poll.$tc'Event2_closure" {
     GHC.Event.Poll.$tc'Event2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Event3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.550986689 UTC

[section ""data" . GHC.Event.Poll.$tc'Event_closure" {
     GHC.Event.Poll.$tc'Event_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Event2_closure+1;
         const GHC.Event.Poll.$tc'Event1_closure+4;
         const 14301517435728423362;
         const 8190957594797964970;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.552783156 UTC

[section ""cstring" . GHC.Event.Poll.$tcPollFd2_bytes" {
     GHC.Event.Poll.$tcPollFd2_bytes:
         I8[] [80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.554448818 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd1_closure" {
     GHC.Event.Poll.$tcPollFd1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPollFd2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.556071133 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd_closure" {
     GHC.Event.Poll.$tcPollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPollFd1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16228031948332168786;
         const 6382085973026785723;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.558194828 UTC

[section ""data" . $krep3_rajAZ_closure" {
     $krep3_rajAZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPollFd_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.559892613 UTC

[section ""data" . $krep4_rajB0_closure" {
     $krep4_rajB0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep3_rajAZ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.561678329 UTC

[section ""data" . $krep5_rajB1_closure" {
     $krep5_rajB1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep4_rajB0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.563837664 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd1_closure" {
     GHC.Event.Poll.$tc'PollFd1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rajAX_closure+1;
         const $krep5_rajB1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.565997639 UTC

[section ""cstring" . GHC.Event.Poll.$tc'PollFd3_bytes" {
     GHC.Event.Poll.$tc'PollFd3_bytes:
         I8[] [39,80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.567549908 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd2_closure" {
     GHC.Event.Poll.$tc'PollFd2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'PollFd3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.56916151 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd_closure" {
     GHC.Event.Poll.$tc'PollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'PollFd2_closure+1;
         const GHC.Event.Poll.$tc'PollFd1_closure+4;
         const 13628496348781941345;
         const 13702663238288085101;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.570888421 UTC

[section ""data" . $krep6_rajB2_closure" {
     $krep6_rajB2_closure:
         const :_con_info;
         const $krep3_rajAZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.572504257 UTC

[section ""data" . $krep7_rajB3_closure" {
     $krep7_rajB3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure;
         const $krep6_rajB2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.574211864 UTC

[section ""data" . $krep8_rajB4_closure" {
     $krep8_rajB4_closure:
         const :_con_info;
         const $krep7_rajB3_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.575931093 UTC

[section ""data" . $krep9_rajB5_closure" {
     $krep9_rajB5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep8_rajB4_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.577942273 UTC

[section ""cstring" . GHC.Event.Poll.$tcPoll2_bytes" {
     GHC.Event.Poll.$tcPoll2_bytes:
         I8[] [80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.579627379 UTC

[section ""data" . GHC.Event.Poll.$tcPoll1_closure" {
     GHC.Event.Poll.$tcPoll1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPoll2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.581434722 UTC

[section ""data" . GHC.Event.Poll.$tcPoll_closure" {
     GHC.Event.Poll.$tcPoll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPoll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13451464419968486054;
         const 9195109480934256969;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.583303397 UTC

[section ""data" . $krep10_rajB6_closure" {
     $krep10_rajB6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPoll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.584999988 UTC

[section ""data" . $krep11_rajB7_closure" {
     $krep11_rajB7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rajB3_closure+1;
         const $krep10_rajB6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.586732545 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll1_closure" {
     GHC.Event.Poll.$tc'Poll1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rajB5_closure+1;
         const $krep11_rajB7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.58887396 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Poll3_bytes" {
     GHC.Event.Poll.$tc'Poll3_bytes:
         I8[] [39,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.590559478 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll2_closure" {
     GHC.Event.Poll.$tc'Poll2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Poll3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.592210266 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll_closure" {
     GHC.Event.Poll.$tc'Poll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Poll2_closure+1;
         const GHC.Event.Poll.$tc'Poll1_closure+4;
         const 5431567153781643515;
         const 15938353663250731731;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.594620676 UTC

[section ""data" . GHC.Event.Poll.$fBitsEvent_closure" {
     GHC.Event.Poll.$fBitsEvent_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Event.Poll.$fEqEvent_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.596769353 UTC

[section ""data" . GHC.Event.Poll.$fFiniteBitsEvent_closure" {
     GHC.Event.Poll.$fFiniteBitsEvent_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Event.Poll.$fBitsEvent_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.598532854 UTC

[section ""data" . GHC.Event.Poll.$fNumEvent_closure" {
     GHC.Event.Poll.$fNumEvent_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.600277718 UTC

[section ""cstring" . lvl_rajB8_bytes" {
     lvl_rajB8_bytes:
         I8[] [109,111,100,105,102,121,70,100,79,110,99,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,105,110,32,80,111,108,108,32,98,97,99,107,101,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.602250463 UTC

[section ""data" . GHC.Event.Poll.new3_closure" {
     GHC.Event.Poll.new3_closure:
         const GHC.Event.Poll.new3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Poll.new3_entry() //  [R1]
         { info_tbl: [(cakZq,
                       label: GHC.Event.Poll.new3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakZq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cakZr; else goto cakZs;
       cakZr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakZs: // global
           (_cakZl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cakZl::I64 == 0) goto cakZn; else goto cakZm;
       cakZn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cakZm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cakZl::I64;
           I64[Sp - 24] = block_cakZo_info;
           R2 = lvl_rajB8_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cakZo() //  [R1]
         { info_tbl: [(cakZo,
                       label: block_cakZo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakZo: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.609214029 UTC

[section ""data" . $wc_pollLoop_rajB9_closure" {
     $wc_pollLoop_rajB9_closure:
         const $wc_pollLoop_rajB9_info;
 },
 $wc_pollLoop_rajB9_entry() //  [R2, R3, R4]
         { info_tbl: [(cakZP,
                       label: $wc_pollLoop_rajB9_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakZP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cakZQ; else goto ual0A;
       cakZQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wc_pollLoop_rajB9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ual0A: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cakZH() args: 0, res: 0, upd: 0;
     }
 },
 _cakZH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakZH: // global
           _sajF3::I64 = I64[Sp];
           _sajF4::I64 = I64[Sp + 8];
           _sajF5::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_sajF5::I64,
                            2147483647)) goto cakZN; else goto cakZO;
       cakZN: // global
           I64[Sp - 8] = block_cakZX_info;
           Sp = Sp - 8;
           _ual0G::P64 = CurrentTSO;
           I64[I64[_ual0G::P64 + 24] + 16] = Sp;
           _ual0H::I64 = CurrentNursery;
           P64[_ual0H::I64 + 8] = Hp + 8;
           I64[_ual0G::P64 + 104] = I64[_ual0G::P64 + 104] - ((Hp + 8) - I64[_ual0H::I64]);
           (_ual0E::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sajFb::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_sajF3::I64, _sajF4::I64, 2147483647);
           (_ual0F::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ual0E::I64);
           BaseReg = _ual0F::I64;
           _ual0I::P64 = CurrentTSO;
           _ual0J::P64 = I64[_ual0I::P64 + 24];
           Sp = I64[_ual0J::P64 + 16];
           SpLim = _ual0J::P64 + 192;
           HpAlloc = 0;
           _ual0K::I64 = CurrentNursery;
           _ual0L::I64 = I64[_ual0K::I64 + 8];
           Hp = _ual0L::I64 - 8;
           _ual0M::I64 = I64[_ual0K::I64];
           HpLim = _ual0M::I64 + ((%MO_SS_Conv_W32_W64(I32[_ual0K::I64 + 48]) << 12) - 1);
           I64[_ual0I::P64 + 104] = I64[_ual0I::P64 + 104] + (_ual0L::I64 - _ual0M::I64);
           R1 = _sajFb::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
       cakZO: // global
           I64[Sp + 16] = block_cal0q_info;
           Sp = Sp + 16;
           _ual0Q::P64 = CurrentTSO;
           I64[I64[_ual0Q::P64 + 24] + 16] = Sp;
           _ual0R::I64 = CurrentNursery;
           P64[_ual0R::I64 + 8] = Hp + 8;
           I64[_ual0Q::P64 + 104] = I64[_ual0Q::P64 + 104] - ((Hp + 8) - I64[_ual0R::I64]);
           (_ual0O::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sajFj::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_sajF3::I64, _sajF4::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sajF5::I64)));
           (_ual0P::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ual0O::I64);
           BaseReg = _ual0P::I64;
           _ual0S::P64 = CurrentTSO;
           _ual0T::P64 = I64[_ual0S::P64 + 24];
           Sp = I64[_ual0T::P64 + 16];
           SpLim = _ual0T::P64 + 192;
           HpAlloc = 0;
           _ual0U::I64 = CurrentNursery;
           _ual0V::I64 = I64[_ual0U::I64 + 8];
           Hp = _ual0V::I64 - 8;
           _ual0W::I64 = I64[_ual0U::I64];
           HpLim = _ual0W::I64 + ((%MO_SS_Conv_W32_W64(I32[_ual0U::I64 + 48]) << 12) - 1);
           I64[_ual0S::P64 + 104] = I64[_ual0S::P64 + 104] + (_ual0V::I64 - _ual0W::I64);
           R1 = _sajFj::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cakZX() //  [R1]
         { info_tbl: [(cakZX,
                       label: block_cakZX_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakZX: // global
           _sajFc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           if (_sajFc::I64 != 0) goto ual0B; else goto cal0e;
       ual0B: // global
           I64[Sp + 24] = _sajFc::I64;
           Sp = Sp + 24;
           call _cal04() args: 0, res: 0, upd: 0;
       cal0e: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] - 2147483647;
           Sp = Sp + 8;
           call _cakZH() args: 0, res: 0, upd: 0;
     }
 },
 _cal04() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal04: // global
           Hp = Hp + 16;
           _sajFc::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cal0b; else goto cal0a;
       cal0b: // global
           HpAlloc = 16;
           I64[Sp] = block_cal03_info;
           R1 = _sajFc::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cal0a: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajFc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cal03() //  [R1]
         { info_tbl: [(cal03,
                       label: block_cal03_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal03: // global
           I64[Sp] = R1;
           call _cal04() args: 0, res: 0, upd: 0;
     }
 },
 _cal0q() //  [R1]
         { info_tbl: [(cal0q,
                       label: block_cal0q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal0q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cal0y; else goto cal0x;
       cal0y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cal0x: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.622977687 UTC

[section ""data" . lvl1_rajBa_closure" {
     lvl1_rajBa_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.625183585 UTC

[section ""cstring" . lvl2_rajBb_bytes" {
     lvl2_rajBb_bytes:
         I8[] [99,95,112,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.627113107 UTC

[section ""data" . lvl3_rajBc_closure" {
     lvl3_rajBc_closure:
         const lvl3_rajBc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rajBc_entry() //  [R1]
         { info_tbl: [(cal24,
                       label: lvl3_rajBc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cal25; else goto cal26;
       cal25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal26: // global
           (_cal21::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cal21::I64 == 0) goto cal23; else goto cal22;
       cal23: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cal22: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cal21::I64;
           R2 = lvl2_rajBb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.631115061 UTC

[section ""cstring" . lvl4_rajBd_bytes" {
     lvl4_rajBd_bytes:
         I8[] [114,101,119,111,114,107,70,100,58,32,101,118,101,110,116,32,110,111,116,32,102,111,117,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.633012547 UTC

[section ""data" . lvl5_rajBe_closure" {
     lvl5_rajBe_closure:
         const lvl5_rajBe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rajBe_entry() //  [R1]
         { info_tbl: [(cal2n,
                       label: lvl5_rajBe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal2n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cal2o; else goto cal2p;
       cal2o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal2p: // global
           (_cal2i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cal2i::I64 == 0) goto cal2k; else goto cal2j;
       cal2k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cal2j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cal2i::I64;
           I64[Sp - 24] = block_cal2l_info;
           R2 = lvl4_rajBd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cal2l() //  [R1]
         { info_tbl: [(cal2l,
                       label: block_cal2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal2l: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.638413077 UTC

[section ""data" . lvl6_rajBf_closure" {
     lvl6_rajBf_closure:
         const lvl6_rajBf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rajBf_entry() //  [R1]
         { info_tbl: [(cal2J,
                       label: lvl6_rajBf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal2J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cal2K; else goto cal2L;
       cal2K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal2L: // global
           (_cal2G::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cal2G::I64 == 0) goto cal2I; else goto cal2H;
       cal2I: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cal2H: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cal2G::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.loop_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.642577653 UTC

[section ""data" . lvl7_rajBg_closure" {
     lvl7_rajBg_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.644243772 UTC

[section ""data" . lvl8_rajBh_closure" {
     lvl8_rajBh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.645918821 UTC

[section ""data" . lvl9_rajBi_closure" {
     lvl9_rajBi_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.647805355 UTC

[section ""data" . lvl10_rajBj_closure" {
     lvl10_rajBj_closure:
         const lvl10_rajBj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rajBj_entry() //  [R1]
         { info_tbl: [(cal32,
                       label: lvl10_rajBj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal32: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cal33; else goto cal34;
       cal33: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal34: // global
           (_cal2Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cal2Z::I64 == 0) goto cal31; else goto cal30;
       cal31: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cal30: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cal2Z::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.removeAt_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.651791715 UTC

[section ""data" . lvl11_rajBk_closure" {
     lvl11_rajBk_closure:
         const lvl11_rajBk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rajBk_entry() //  [R1]
         { info_tbl: [(cal3i,
                       label: lvl11_rajBk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cal3j; else goto cal3k;
       cal3j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal3k: // global
           (_cal3f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cal3f::I64 == 0) goto cal3h; else goto cal3g;
       cal3h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cal3g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cal3f::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.findIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.663030428 UTC

[section ""data" . GHC.Event.Poll.new5_closure" {
     GHC.Event.Poll.new5_closure:
         const GHC.Event.Poll.new5_info;
         const 0;
 },
 sat_sajGz_entry() //  [R1]
         { info_tbl: [(cal54,
                       label: sat_sajGz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cal55; else goto cal65;
       cal55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal65: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sajGo::I64 = I64[R1 + 16];
           if (_sajGo::I64 & 25 == 0) goto cal5G; else goto cal5f;
       cal5G: // global
           if (_sajGo::I64 & 28 == 0) goto cal61; else goto cal5V;
       cal61: // global
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cal5V: // global
           R1 = lvl9_rajBi_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cal5f: // global
           if (_sajGo::I64 & 28 == 0) goto cal5A; else goto cal5u;
       cal5A: // global
           R1 = lvl8_rajBh_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cal5u: // global
           R1 = lvl7_rajBg_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 i'_sajGD_entry() //  [R1]
         { info_tbl: [(cal6g,
                       label: i'_sajGD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal6g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cal6q; else goto cal6r;
       cal6q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal6r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cal6d_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ual6v; else goto cal6e;
       ual6v: // global
           call _cal6d(R1) args: 0, res: 0, upd: 0;
       cal6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cal6d() //  [R1]
         { info_tbl: [(cal6d,
                       label: block_cal6d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal6d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cal6u; else goto cal6t;
       cal6u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cal6t: // global
           _sajGH::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7] + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajGH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajGL_entry() //  [R1]
         { info_tbl: [(cal6D,
                       label: sat_sajGL_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal6D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cal6E; else goto cal6F;
       cal6E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cal6F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cal6A_info;
           _sajGg::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sajGg::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ual6K; else goto cal6B;
       ual6K: // global
           call _cal6A(R1) args: 0, res: 0, upd: 0;
       cal6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cal6A() //  [R1]
         { info_tbl: [(cal6A,
                       label: block_cal6A_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal6A: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sajGO_entry() //  [R1, R2, R3]
         { info_tbl: [(cal6L,
                       label: sat_sajGO_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal6L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cal6M; else goto cal6N;
       cal6M: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cal6N: // global
           I64[Sp - 32] = block_cal4R_info;
           _sajFp::P64 = P64[R1 + 5];
           _sajGg::I64 = I64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _sajFp::P64;
           I64[Sp - 16] = _sajGg::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ual70; else goto cal4S;
       ual70: // global
           call _cal4R(R1) args: 0, res: 0, upd: 0;
       cal4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal4R() //  [R1]
         { info_tbl: [(cal4R,
                       label: block_cal4R_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal4R: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cal6Q; else goto cal6P;
       cal6Q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal6P: // global
           _sajGo::I64 = I64[R1 + 23];
           if (_sajGo::I64 != 0) goto cal6T; else goto cal6Z;
       cal6T: // global
           _sajGl::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_sajGz_info;
           I64[Hp - 16] = _sajGo::I64;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sajGl::I64;
           _sajFp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cal67_info;
           R3 = Hp - 32;
           R2 = Hp - 7;
           R1 = _sajFp::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cal6Z: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = GHC.Types.True_closure+2;
           _cal6Y::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _cal6Y::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cal67() //  [R1]
         { info_tbl: [(cal67,
                       label: block_cal67_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal67: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cal6W; else goto cal6V;
       cal6W: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal6V: // global
           I64[Hp - 72] = i'_sajGD_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = sat_sajGL_info;
           _cal69::P64 = Hp - 72;
           P64[Hp - 32] = _cal69::P64;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _cal69::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajHT_entry() //  [R1, R2]
         { info_tbl: [(cal7s,
                       label: sat_sajHT_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal7s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cal7t; else goto cal7u;
       cal7t: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cal7u: // global
           I64[Sp - 16] = block_cal7p_info;
           _sajHD::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _sajHD::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ual7z; else goto cal7q;
       ual7z: // global
           call _cal7p(R1) args: 0, res: 0, upd: 0;
       cal7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal7p() //  [R1]
         { info_tbl: [(cal7p,
                       label: block_cal7p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal7p: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sajIQ_entry() //  [R1]
         { info_tbl: [(cal7N,
                       label: sat_sajIQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal7N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cal7O; else goto cal7P;
       cal7O: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cal7P: // global
           I64[Sp - 24] = block_cal7I_info;
           _sajFz::P64 = P64[R1 + 7];
           _sajFB::P64 = P64[R1 + 15];
           R1 = _sajFB::P64;
           P64[Sp - 16] = _sajFz::P64;
           P64[Sp - 8] = _sajFB::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal7I() //  [R1]
         { info_tbl: [(cal7I,
                       label: block_cal7I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal7I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cal7S; else goto cal7R;
       cal7S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal7R: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cal7L_info;
           R2 = Hp - 7;
           _sajIN::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sajIN::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal7L() //  []
         { info_tbl: [(cal7L,
                       label: block_cal7L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal7L: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new5_entry() //  [R2, R3, R4]
         { info_tbl: [(cal7U,
                       label: GHC.Event.Poll.new5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal7U: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cal7V; else goto cal7W;
       cal7V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cal7W: // global
           I64[Sp - 32] = block_cal3w_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal3w() //  [R1]
         { info_tbl: [(cal3w,
                       label: block_cal3w_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3w: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cal7Z; else goto cal7Y;
       cal7Z: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal7Y: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cal3B_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal3B() //  [R1]
         { info_tbl: [(cal3B,
                       label: block_cal3B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3B: // global
           I64[Sp] = block_cal3D_info;
           _sajFz::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sajFz::P64;
           if (R1 & 7 != 0) goto ualc0; else goto cal3E;
       ualc0: // global
           call _cal3D(R1) args: 0, res: 0, upd: 0;
       cal3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal3D() //  [R1]
         { info_tbl: [(cal3D,
                       label: block_cal3D_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3D: // global
           I64[Sp - 16] = block_cal3I_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cal3I() //  [R1]
         { info_tbl: [(cal3I,
                       label: block_cal3I_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cal84; else goto cal83;
       cal84: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cal83: // global
           _sajFB::P64 = P64[Sp + 16];
           if (R1 == 0) goto calbl; else goto calb8;
       calbl: // global
           I64[Hp - 16] = sat_sajIQ_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sajFB::P64;
           I64[Sp] = block_calbi_info;
           R1 = Hp - 15;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       calb8: // global
           Hp = Hp - 24;
           I64[Sp] = block_calb1_info;
           R1 = _sajFB::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calbi() //  [R1]
         { info_tbl: [(calbi,
                       label: block_calbi_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calbi: // global
           I64[Sp] = block_calbk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ualcq; else goto calbn;
       ualcq: // global
           call _calbk(R1) args: 0, res: 0, upd: 0;
       calbn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calbk() //  [R1]
         { info_tbl: [(calbk,
                       label: block_calbk_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calbk: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _sajFG() args: 0, res: 0, upd: 0;
     }
 },
 _calb1() //  [R1]
         { info_tbl: [(calb1,
                       label: block_calb1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calb1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calbb; else goto calba;
       calbb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calba: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_calb4_info;
           R2 = Hp - 7;
           _sajIF::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 24] = _sajIF::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _calb4() //  []
         { info_tbl: [(calb4,
                       label: block_calb4_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calb4: // global
           I64[Sp] = block_calb6_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ualco; else goto calbd;
       ualco: // global
           call _calb6(R1) args: 0, res: 0, upd: 0;
       calbd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calb6() //  [R1]
         { info_tbl: [(calb6,
                       label: block_calb6_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calb6: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _sajFG() args: 0, res: 0, upd: 0;
     }
 },
 _sajFG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sajFG: // global
           _sajFL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cal3P_info;
           R1 = _sajFL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualcs; else goto cal3Q;
       ualcs: // global
           call _cal3P(R1) args: 0, res: 0, upd: 0;
       cal3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal3P() //  [R1]
         { info_tbl: [(cal3P,
                       label: block_cal3P_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3P: // global
           I64[Sp] = block_cal3U_info;
           _sajFO::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 24] = _sajFO::I64;
           if (R1 & 7 != 0) goto ualc1; else goto cal3V;
       ualc1: // global
           call _cal3U(R1) args: 0, res: 0, upd: 0;
       cal3V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal3U() //  [R1]
         { info_tbl: [(cal3U,
                       label: block_cal3U_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal3U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cal89; else goto cal88;
       cal89: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal88: // global
           _sajFS::P64 = P64[R1 + 7];
           _sajFR::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = I64[Sp + 24] << 3;
           I64[Sp - 8] = 0;
           P64[Sp] = _sajFS::P64;
           I64[Sp + 16] = _sajFR::I64;
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 16;
           call _cal74() args: 0, res: 0, upd: 0;
     }
 },
 _cal74() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal74: // global
           Hp = Hp + 32;
           _sajHx::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cal9S; else goto cal9R;
       cal9S: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cal73_info;
           R1 = _sajHx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cal9R: // global
           _sajFC::P64 = P64[Sp + 24];
           if (%MO_S_Lt_W64(_sajHx::I64,
                            I64[Sp])) goto calaZ; else goto calb0;
       calaZ: // global
           _sajHA::I64 = I64[Sp + 32] + _sajHx::I64;
           _sajHD::I64 = %MO_SS_Conv_W32_W64(I32[_sajHA::I64]);
           _sajHH::I64 = %MO_SS_Conv_W16_W64(I16[_sajHA::I64 + 4]);
           if (I16[_sajHA::I64 + 6] == 0 :: W16) goto calaV; else goto cal9X;
       calaV: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _sajHD::I64;
           I64[Hp - 8] = _sajHH::I64;
           I64[Hp] = 0;
           I64[Sp - 8] = block_calaU_info;
           R4 = Hp - 23;
           R3 = _sajFC::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
       cal9X: // global
           I64[Hp - 24] = sat_sajHT_info;
           I64[Hp - 16] = _sajHD::I64;
           _cal7k::P64 = Hp - 23;
           Hp = Hp - 16;
           I64[Sp - 24] = block_cal9T_info;
           R3 = P64[Sp + 40];
           R2 = _cal7k::P64;
           R1 = lvl11_rajBk_closure;
           I64[Sp - 16] = _sajHD::I64;
           I64[Sp - 8] = _sajHH::I64;
           Sp = Sp - 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       calb0: // global
           Hp = Hp - 32;
           call MO_Touch(P64[Sp + 16]);
           I64[Sp + 32] = block_cal49_info;
           R1 = P64[_sajFC::P64 + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto ualc9; else goto cal4a;
       ualc9: // global
           call _cal49(R1) args: 0, res: 0, upd: 0;
       cal4a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal73() //  [R1]
         { info_tbl: [(cal73,
                       label: block_cal73_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal73: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cal74() args: 0, res: 0, upd: 0;
     }
 },
 _calaU() //  []
         { info_tbl: [(calaU,
                       label: block_calaU_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calaU: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cal74() args: 0, res: 0, upd: 0;
     }
 },
 _cal9T() //  [R1]
         { info_tbl: [(cal9T,
                       label: block_cal9T_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal9T: // global
           I64[Sp] = block_cal9V_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ualcg; else goto cal9Z;
       ualcg: // global
           call _cal9V(R1) args: 0, res: 0, upd: 0;
       cal9Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal9V() //  [R1]
         { info_tbl: [(cal9V,
                       label: block_cal9V_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal9V: // global
           if (R1 & 7 == 1) goto cala5; else goto calaa;
       cala5: // global
           R1 = lvl5_rajBe_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       calaa: // global
           I64[Sp] = block_cala8_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ualch; else goto calab;
       ualch: // global
           call _cala8(R1) args: 0, res: 0, upd: 0;
       calab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cala8() //  [R1]
         { info_tbl: [(cala8,
                       label: block_cala8_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cala8: // global
           _sajI1::P64 = P64[R1 + 7];
           _sajI3::I64 = I64[Sp + 16];
           if (_sajI3::I64 != 0) goto calau; else goto calaP;
       calau: // global
           _sajI6::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp - 8] = block_calai_info;
           R1 = _sajI6::P64;
           I64[Sp] = _sajI3::I64;
           P64[Sp + 16] = _sajI1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualci; else goto calaj;
       ualci: // global
           call _calai(R1) args: 0, res: 0, upd: 0;
       calaj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       calaP: // global
           I64[Sp + 16] = block_calaO_info;
           R3 = _sajI1::P64;
           R2 = P64[Sp + 64];
           R1 = lvl10_rajBj_closure;
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _calai() //  [R1]
         { info_tbl: [(calai,
                       label: block_calai_info
                       rep:StackRep [True, True, False, True, True, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calai: // global
           I64[Sp - 8] = block_calan_info;
           _sajIa::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _sajIa::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualcj; else goto calao;
       ualcj: // global
           call _calan(R1) args: 0, res: 0, upd: 0;
       calao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calan() //  [R1]
         { info_tbl: [(calan,
                       label: block_calan_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calan: // global
           I64[Sp - 8] = block_calas_info;
           _sajId::P64 = P64[R1 + 7];
           _sajIc::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sajId::P64;
           I64[Sp + 32] = _sajIc::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualck; else goto calax;
       ualck: // global
           call _calas(R1) args: 0, res: 0, upd: 0;
       calax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calas() //  [R1]
         { info_tbl: [(calas,
                       label: block_calas_info
                       rep:StackRep [False, True, True, True, True, True, True, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calas: // global
           _sajIa::I64 = I64[Sp + 16];
           _sajIf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sajIf::I64, 0)) goto calaM; else goto calaL;
       calaL: // global
           if (%MO_S_Ge_W64(_sajIf::I64,
                            _sajIa::I64)) goto calaM; else goto calaI;
       calaM: // global
           R3 = _sajIf::I64;
           R2 = _sajIa::I64;
           Sp = Sp + 112;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       calaI: // global
           _sajHx::I64 = I64[Sp + 56];
           _sajI3::I64 = I64[Sp + 24];
           _sajId::P64 = P64[Sp + 8];
           _sajIi::I64 = I64[Sp + 40] + (_sajIf::I64 << 3);
           I32[_sajIi::I64] = %MO_UU_Conv_W64_W32(I64[Sp + 32]);
           I16[_sajIi::I64 + 4] = %MO_UU_Conv_W64_W16(_sajI3::I64);
           I16[_sajIi::I64 + 6] = 0 :: W16;
           call MO_Touch(_sajId::P64);
           I64[Sp + 56] = _sajHx::I64 + 8;
           Sp = Sp + 48;
           call _cal74() args: 0, res: 0, upd: 0;
     }
 },
 _calaO() //  []
         { info_tbl: [(calaO,
                       label: block_calaO_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calaO: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cal74() args: 0, res: 0, upd: 0;
     }
 },
 _cal49() //  [R1]
         { info_tbl: [(cal49,
                       label: block_cal49_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal49: // global
           I64[Sp - 8] = block_cal4e_info;
           _sajG3::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _sajG3::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualc3; else goto cal4f;
       ualc3: // global
           call _cal4e(R1) args: 0, res: 0, upd: 0;
       cal4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal4e() //  [R1]
         { info_tbl: [(cal4e,
                       label: block_cal4e_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal4e: // global
           I64[Sp - 8] = block_cal4l_info;
           _sajG7::P64 = P64[R1 + 7];
           _sajG6::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sajG7::P64;
           I64[Sp + 24] = _sajG6::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualc4; else goto cal4m;
       ualc4: // global
           call _cal4l(R1) args: 0, res: 0, upd: 0;
       cal4m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal4l() //  [R1]
         { info_tbl: [(cal4l,
                       label: block_cal4l_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal4l: // global
           if (R1 & 7 == 1) goto cal8W; else goto cal94;
       cal8W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cal8Z; else goto cal8Y;
       cal8Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal8Y: // global
           (_sajH9::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(I64[Sp + 32], I64[Sp + 16], 0);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _sajHa::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sajH9::I64));
           I64[Hp] = _sajHa::I64;
           I64[Sp + 32] = _sajHa::I64;
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
       cal94: // global
           I64[Sp] = block_cal92_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ualc5; else goto cal95;
       ualc5: // global
           call _cal92(R1) args: 0, res: 0, upd: 0;
       cal95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal92() //  [R1]
         { info_tbl: [(cal92,
                       label: block_cal92_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal92: // global
           _sajG3::I64 = I64[Sp + 16];
           _sajG6::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cal9t; else goto cal9J;
       cal9t: // global
           I64[Sp] = block_cal9o_info;
           R4 = (I64[R1 + 7] + 999999) / 1000000;
           R3 = _sajG3::I64;
           R2 = _sajG6::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
       cal9J: // global
           I64[Sp] = block_cal9F_info;
           R4 = (-1);
           R3 = _sajG3::I64;
           R2 = _sajG6::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cal9o() //  [R1]
         { info_tbl: [(cal9o,
                       label: block_cal9o_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal9o: // global
           I64[Sp] = block_cal9q_info;
           _sajHn::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _sajHn::P64;
           if (R1 & 7 != 0) goto ualcc; else goto cal9v;
       ualcc: // global
           call _cal9q(R1) args: 0, res: 0, upd: 0;
       cal9v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal9q() //  [R1]
         { info_tbl: [(cal9q,
                       label: block_cal9q_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal9q: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
     }
 },
 _cal9F() //  [R1]
         { info_tbl: [(cal9F,
                       label: block_cal9F_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal9F: // global
           I64[Sp] = block_cal9H_info;
           _sajHt::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _sajHt::P64;
           if (R1 & 7 != 0) goto ualce; else goto cal9L;
       ualce: // global
           call _cal9H(R1) args: 0, res: 0, upd: 0;
       cal9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal9H() //  [R1]
         { info_tbl: [(cal9H,
                       label: block_cal9H_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal9H: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _sajG8() args: 0, res: 0, upd: 0;
     }
 },
 _sajG8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sajG8: // global
           _sajGT::I64 = I64[Sp + 24];
           if (_sajGT::I64 != (-1)) goto cal8s; else goto cal8U;
       cal8s: // global
           I64[Sp + 24] = _sajGT::I64;
           goto ualcu;
       cal8U: // global
           (_sajGX::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           if (%MO_SS_Conv_W64_W32(_sajGX::I64) == 4 :: W32) goto cal8Q; else goto cal8G;
       cal8Q: // global
           I64[Sp + 24] = 0;
           goto ualcu;
       ualcu: // global
           call _cal4H() args: 0, res: 0, upd: 0;
       cal8G: // global
           I64[Sp - 8] = block_cal8C_info;
           R2 = lvl3_rajBc_closure;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cal8C() //  [R1]
         { info_tbl: [(cal8C,
                       label: block_cal8C_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal8C: // global
           I64[Sp] = block_cal8E_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ualca; else goto cal8J;
       ualca: // global
           call _cal8E(R1) args: 0, res: 0, upd: 0;
       cal8J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal8E() //  [R1]
         { info_tbl: [(cal8E,
                       label: block_cal8E_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal8E: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _cal4H() args: 0, res: 0, upd: 0;
     }
 },
 _cal4H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal4H: // global
           Hp = Hp + 24;
           _sajGe::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cal8g; else goto cal8f;
       cal8g: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_cal4G_info;
           R1 = _sajGe::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cal8f: // global
           _cal3Z::P64 = P64[Sp + 16];
           _sajFp::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp]);
           if (_sajGe::I64 == 0) goto cal8p; else goto cal8l;
       cal8p: // global
           Hp = Hp - 24;
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cal8l: // global
           I64[Hp - 16] = sat_sajGO_info;
           P64[Hp - 8] = _sajFp::P64;
           I64[Hp] = _sajGe::I64;
           I64[Sp + 24] = block_cal8h_info;
           R4 = Hp - 13;
           R3 = lvl1_rajBa_closure+1;
           R2 = _cal3Z::P64;
           R1 = lvl6_rajBf_closure;
           I64[Sp + 32] = _sajGe::I64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal4G() //  [R1]
         { info_tbl: [(cal4G,
                       label: block_cal4G_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal4G: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cal4H() args: 0, res: 0, upd: 0;
     }
 },
 _cal8h() //  [R1]
         { info_tbl: [(cal8h,
                       label: block_cal8h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal8h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cal8o; else goto cal8n;
       cal8o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cal8n: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.762743112 UTC

[section ""data" . GHC.Event.Poll.new4_closure" {
     GHC.Event.Poll.new4_closure:
         const GHC.Event.Poll.new4_info;
         const 0;
 },
 sat_sajJz_entry() //  [R1]
         { info_tbl: [(calgE,
                       label: sat_sajJz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calgE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto calgI; else goto calgJ;
       calgI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calgJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_calgB_info;
           _sajIY::P64 = P64[R1 + 24];
           _sajIZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sajIY::P64;
           P64[Sp - 24] = _sajIZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ualma; else goto calgC;
       ualma: // global
           call _calgB(R1) args: 0, res: 0, upd: 0;
       calgC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _calgB() //  [R1]
         { info_tbl: [(calgB,
                       label: block_calgB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calgB: // global
           I64[Sp] = block_calgH_info;
           _sajJ9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sajJ9::I64;
           if (R1 & 7 != 0) goto ualm9; else goto calgL;
       ualm9: // global
           call _calgH(R1) args: 0, res: 0, upd: 0;
       calgL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _calgH() //  [R1]
         { info_tbl: [(calgH,
                       label: block_calgH_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calgH: // global
           _sajIY::P64 = P64[Sp + 8];
           _sajJb::I64 = I64[R1 + 7];
           if (_sajJb::I64 & 1 == 0) goto calji; else goto calgV;
       calji: // global
           if (_sajJb::I64 & 2 == 0) goto calkB; else goto calju;
       calkB: // global
           I64[Sp + 8] = block_calkA_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ualme; else goto calkD;
       ualme: // global
           call _calkA(R1) args: 0, res: 0, upd: 0;
       calkD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       calju: // global
           I64[Sp + 8] = block_caljs_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ualmd; else goto caljw;
       ualmd: // global
           call _caljs(R1) args: 0, res: 0, upd: 0;
       caljw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       calgV: // global
           if (_sajJb::I64 & 2 == 0) goto calie; else goto calh7;
       calie: // global
           I64[Sp + 8] = block_calid_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ualmc; else goto calig;
       ualmc: // global
           call _calid(R1) args: 0, res: 0, upd: 0;
       calig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       calh7: // global
           I64[Sp + 8] = block_calh5_info;
           R1 = _sajIY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ualmb; else goto calh9;
       ualmb: // global
           call _calh5(R1) args: 0, res: 0, upd: 0;
       calh9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _calkA() //  [R1]
         { info_tbl: [(calkA,
                       label: block_calkA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calkA: // global
           _sajJv::I64 = I64[R1 + 7];
           if (_sajJv::I64 & 1 == 0) goto calle; else goto calkN;
       calle: // global
           _sajJy::I64 = _sajJv::I64 & 2;
           if (_sajJy::I64 != 0) goto ualm6; else goto ualm5;
       ualm6: // global
           I64[Sp] = _sajJy::I64;
           call _callm() args: 0, res: 0, upd: 0;
       ualm5: // global
           I64[Sp] = _sajJy::I64;
           call _callw() args: 0, res: 0, upd: 0;
       calkN: // global
           _sajJx::I64 = _sajJv::I64 & 2;
           if (_sajJx::I64 != 0) goto ualm2; else goto ualm1;
       ualm2: // global
           I64[Sp] = _sajJx::I64;
           call _calkV() args: 0, res: 0, upd: 0;
       ualm1: // global
           I64[Sp] = _sajJx::I64;
           call _call5() args: 0, res: 0, upd: 0;
     }
 },
 _callm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       callm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto callt; else goto calls;
       callt: // global
           HpAlloc = 32;
           _sajJy::I64 = I64[Sp];
           I64[Sp] = block_calll_info;
           R1 = _sajJy::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calls: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calll() //  [R1]
         { info_tbl: [(calll,
                       label: block_calll_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calll: // global
           I64[Sp] = R1;
           call _callm() args: 0, res: 0, upd: 0;
     }
 },
 _callw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       callw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto callC; else goto callB;
       callC: // global
           HpAlloc = 32;
           _sajJy::I64 = I64[Sp];
           I64[Sp] = block_callv_info;
           R1 = _sajJy::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       callB: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _callv() //  [R1]
         { info_tbl: [(callv,
                       label: block_callv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       callv: // global
           I64[Sp] = R1;
           call _callw() args: 0, res: 0, upd: 0;
     }
 },
 _calkV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calkV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto call2; else goto call1;
       call2: // global
           HpAlloc = 32;
           _sajJx::I64 = I64[Sp];
           I64[Sp] = block_calkU_info;
           R1 = _sajJx::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       call1: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calkU() //  [R1]
         { info_tbl: [(calkU,
                       label: block_calkU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calkU: // global
           I64[Sp] = R1;
           call _calkV() args: 0, res: 0, upd: 0;
     }
 },
 _call5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       call5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto callb; else goto calla;
       callb: // global
           HpAlloc = 32;
           _sajJx::I64 = I64[Sp];
           I64[Sp] = block_call4_info;
           R1 = _sajJx::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calla: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _call4() //  [R1]
         { info_tbl: [(call4,
                       label: block_call4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       call4: // global
           I64[Sp] = R1;
           call _call5() args: 0, res: 0, upd: 0;
     }
 },
 _caljs() //  [R1]
         { info_tbl: [(caljs,
                       label: block_caljs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caljs: // global
           _sajJq::I64 = I64[R1 + 7];
           if (_sajJq::I64 & 1 == 0) goto calk7; else goto caljG;
       calk7: // global
           _sajJt::I64 = _sajJq::I64 & 2;
           if (_sajJt::I64 != 0) goto uallY; else goto uallX;
       uallY: // global
           I64[Sp] = _sajJt::I64;
           call _calkf() args: 0, res: 0, upd: 0;
       uallX: // global
           I64[Sp] = _sajJt::I64;
           call _calkp() args: 0, res: 0, upd: 0;
       caljG: // global
           _sajJs::I64 = _sajJq::I64 & 2;
           if (_sajJs::I64 != 0) goto uallU; else goto uallT;
       uallU: // global
           I64[Sp] = _sajJs::I64;
           call _caljO() args: 0, res: 0, upd: 0;
       uallT: // global
           I64[Sp] = _sajJs::I64;
           call _caljY() args: 0, res: 0, upd: 0;
     }
 },
 _calkf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calkf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calkm; else goto calkl;
       calkm: // global
           HpAlloc = 32;
           _sajJt::I64 = I64[Sp];
           I64[Sp] = block_calke_info;
           R1 = _sajJt::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calkl: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calke() //  [R1]
         { info_tbl: [(calke,
                       label: block_calke_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calke: // global
           I64[Sp] = R1;
           call _calkf() args: 0, res: 0, upd: 0;
     }
 },
 _calkp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calkp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calkv; else goto calku;
       calkv: // global
           HpAlloc = 32;
           _sajJt::I64 = I64[Sp];
           I64[Sp] = block_calko_info;
           R1 = _sajJt::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calku: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calko() //  [R1]
         { info_tbl: [(calko,
                       label: block_calko_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calko: // global
           I64[Sp] = R1;
           call _calkp() args: 0, res: 0, upd: 0;
     }
 },
 _caljO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caljO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caljV; else goto caljU;
       caljV: // global
           HpAlloc = 32;
           _sajJs::I64 = I64[Sp];
           I64[Sp] = block_caljN_info;
           R1 = _sajJs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caljU: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caljN() //  [R1]
         { info_tbl: [(caljN,
                       label: block_caljN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caljN: // global
           I64[Sp] = R1;
           call _caljO() args: 0, res: 0, upd: 0;
     }
 },
 _caljY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caljY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calk4; else goto calk3;
       calk4: // global
           HpAlloc = 32;
           _sajJs::I64 = I64[Sp];
           I64[Sp] = block_caljX_info;
           R1 = _sajJs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calk3: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caljX() //  [R1]
         { info_tbl: [(caljX,
                       label: block_caljX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caljX: // global
           I64[Sp] = R1;
           call _caljY() args: 0, res: 0, upd: 0;
     }
 },
 _calid() //  [R1]
         { info_tbl: [(calid,
                       label: block_calid_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calid: // global
           _sajJk::I64 = I64[R1 + 7];
           if (_sajJk::I64 & 1 == 0) goto caliR; else goto caliq;
       caliR: // global
           _sajJn::I64 = _sajJk::I64 & 2;
           if (_sajJn::I64 != 0) goto uallQ; else goto uallP;
       uallQ: // global
           I64[Sp] = _sajJn::I64;
           call _caliZ() args: 0, res: 0, upd: 0;
       uallP: // global
           I64[Sp] = _sajJn::I64;
           call _calj9() args: 0, res: 0, upd: 0;
       caliq: // global
           _sajJm::I64 = _sajJk::I64 & 2;
           if (_sajJm::I64 != 0) goto uallM; else goto uallL;
       uallM: // global
           I64[Sp] = _sajJm::I64;
           call _caliy() args: 0, res: 0, upd: 0;
       uallL: // global
           I64[Sp] = _sajJm::I64;
           call _caliI() args: 0, res: 0, upd: 0;
     }
 },
 _caliZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caliZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calj6; else goto calj5;
       calj6: // global
           HpAlloc = 32;
           _sajJn::I64 = I64[Sp];
           I64[Sp] = block_caliY_info;
           R1 = _sajJn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calj5: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caliY() //  [R1]
         { info_tbl: [(caliY,
                       label: block_caliY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caliY: // global
           I64[Sp] = R1;
           call _caliZ() args: 0, res: 0, upd: 0;
     }
 },
 _calj9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calj9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caljf; else goto calje;
       caljf: // global
           HpAlloc = 32;
           _sajJn::I64 = I64[Sp];
           I64[Sp] = block_calj8_info;
           R1 = _sajJn::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calje: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calj8() //  [R1]
         { info_tbl: [(calj8,
                       label: block_calj8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calj8: // global
           I64[Sp] = R1;
           call _calj9() args: 0, res: 0, upd: 0;
     }
 },
 _caliy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caliy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caliF; else goto caliE;
       caliF: // global
           HpAlloc = 32;
           _sajJm::I64 = I64[Sp];
           I64[Sp] = block_calix_info;
           R1 = _sajJm::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caliE: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calix() //  [R1]
         { info_tbl: [(calix,
                       label: block_calix_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calix: // global
           I64[Sp] = R1;
           call _caliy() args: 0, res: 0, upd: 0;
     }
 },
 _caliI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caliI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caliO; else goto caliN;
       caliO: // global
           HpAlloc = 32;
           _sajJm::I64 = I64[Sp];
           I64[Sp] = block_caliH_info;
           R1 = _sajJm::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       caliN: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caliH() //  [R1]
         { info_tbl: [(caliH,
                       label: block_caliH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caliH: // global
           I64[Sp] = R1;
           call _caliI() args: 0, res: 0, upd: 0;
     }
 },
 _calh5() //  [R1]
         { info_tbl: [(calh5,
                       label: block_calh5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calh5: // global
           _sajJf::I64 = I64[R1 + 7];
           if (_sajJf::I64 & 1 == 0) goto calhK; else goto calhj;
       calhK: // global
           _sajJi::I64 = _sajJf::I64 & 2;
           if (_sajJi::I64 != 0) goto uallI; else goto uallH;
       uallI: // global
           I64[Sp] = _sajJi::I64;
           call _calhS() args: 0, res: 0, upd: 0;
       uallH: // global
           I64[Sp] = _sajJi::I64;
           call _cali2() args: 0, res: 0, upd: 0;
       calhj: // global
           _sajJh::I64 = _sajJf::I64 & 2;
           if (_sajJh::I64 != 0) goto uallE; else goto uallD;
       uallE: // global
           I64[Sp] = _sajJh::I64;
           call _calhr() args: 0, res: 0, upd: 0;
       uallD: // global
           I64[Sp] = _sajJh::I64;
           call _calhB() args: 0, res: 0, upd: 0;
     }
 },
 _calhS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calhS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calhZ; else goto calhY;
       calhZ: // global
           HpAlloc = 32;
           _sajJi::I64 = I64[Sp];
           I64[Sp] = block_calhR_info;
           R1 = _sajJi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calhY: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calhR() //  [R1]
         { info_tbl: [(calhR,
                       label: block_calhR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calhR: // global
           I64[Sp] = R1;
           call _calhS() args: 0, res: 0, upd: 0;
     }
 },
 _cali2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cali2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cali8; else goto cali7;
       cali8: // global
           HpAlloc = 32;
           _sajJi::I64 = I64[Sp];
           I64[Sp] = block_cali1_info;
           R1 = _sajJi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cali7: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cali1() //  [R1]
         { info_tbl: [(cali1,
                       label: block_cali1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cali1: // global
           I64[Sp] = R1;
           call _cali2() args: 0, res: 0, upd: 0;
     }
 },
 _calhr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calhr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calhy; else goto calhx;
       calhy: // global
           HpAlloc = 32;
           _sajJh::I64 = I64[Sp];
           I64[Sp] = block_calhq_info;
           R1 = _sajJh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calhx: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calhq() //  [R1]
         { info_tbl: [(calhq,
                       label: block_calhq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calhq: // global
           I64[Sp] = R1;
           call _calhr() args: 0, res: 0, upd: 0;
     }
 },
 _calhB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calhB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calhH; else goto calhG;
       calhH: // global
           HpAlloc = 32;
           _sajJh::I64 = I64[Sp];
           I64[Sp] = block_calhA_info;
           R1 = _sajJh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       calhG: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _calhA() //  [R1]
         { info_tbl: [(calhA,
                       label: block_calhA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calhA: // global
           I64[Sp] = R1;
           call _calhB() args: 0, res: 0, upd: 0;
     }
 },
 sat_sajJD_entry() //  [R1, R2]
         { info_tbl: [(calmL,
                       label: sat_sajJD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calmL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto calmN; else goto calmO;
       calmN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calmO: // global
           I64[Sp - 32] = block_calgs_info;
           _sajIX::P64 = P64[R1 + 6];
           _sajIY::P64 = P64[R1 + 14];
           _sajIZ::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sajIX::P64;
           P64[Sp - 16] = _sajIY::P64;
           P64[Sp - 8] = _sajIZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ualmU; else goto calgt;
       ualmU: // global
           call _calgs(R1) args: 0, res: 0, upd: 0;
       calgt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calgs() //  [R1]
         { info_tbl: [(calgs,
                       label: block_calgs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calgs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto calmR; else goto calmQ;
       calmR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calmQ: // global
           _sajJ7::P64 = P64[R1 + 7];
           I64[Hp - 32] = sat_sajJz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_calmM_info;
           R4 = Hp - 32;
           R3 = _sajJ7::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _calmM() //  []
         { info_tbl: [(calmM,
                       label: block_calmM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calmM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(calmV,
                       label: GHC.Event.Poll.new4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calmV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto calmW; else goto calmX;
       calmW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calmX: // global
           I64[Sp - 32] = block_calgi_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ualn1; else goto calgj;
       ualn1: // global
           call _calgi(R1) args: 0, res: 0, upd: 0;
       calgj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calgi() //  [R1]
         { info_tbl: [(calgi,
                       label: block_calgi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calgi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caln0; else goto calmZ;
       caln0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calmZ: // global
           _sajJ2::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sajJD_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R3 = Hp - 22;
           R2 = _sajJ2::P64;
           Sp = Sp + 32;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.832309786 UTC

[section ""data" . GHC.Event.Poll.new2_closure" {
     GHC.Event.Poll.new2_closure:
         const GHC.Event.Poll.new2_info;
 },
 GHC.Event.Poll.new2_entry() //  []
         { info_tbl: [(calpV,
                       label: GHC.Event.Poll.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calpV: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.836088874 UTC

[section ""data" . GHC.Event.Poll.new1_closure" {
     GHC.Event.Poll.new1_closure:
         const GHC.Event.Poll.new1_info;
         const 0;
 },
 GHC.Event.Poll.new1_entry() //  []
         { info_tbl: [(calqs,
                       label: GHC.Event.Poll.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calqs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calqt; else goto calqu;
       calqt: // global
           R1 = GHC.Event.Poll.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       calqu: // global
           I64[Sp - 8] = block_calq7_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calq7() //  [R1]
         { info_tbl: [(calq7,
                       label: block_calq7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calq7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto calqx; else goto calqw;
       calqx: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calqw: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_calqc_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calqc() //  [R1]
         { info_tbl: [(calqc,
                       label: block_calqc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calqc: // global
           I64[Sp - 8] = block_calqe_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _calqe() //  [R1]
         { info_tbl: [(calqe,
                       label: block_calqe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calqe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calqB; else goto calqA;
       calqB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calqA: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_calqh_info;
           R2 = Hp - 7;
           _sajJS::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sajJS::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _calqh() //  []
         { info_tbl: [(calqh,
                       label: block_calqh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calqh: // global
           I64[Sp] = block_calqj_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calqj() //  [R1]
         { info_tbl: [(calqj,
                       label: block_calqj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calqj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto calqF; else goto calqE;
       calqF: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calqE: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_calqo_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calqo() //  [R1]
         { info_tbl: [(calqo,
                       label: block_calqo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calqo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto calqI; else goto calqH;
       calqI: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calqH: // global
           I64[Hp - 64] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.Event.Internal.Backend_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = GHC.Event.Poll.new5_closure+4;
           P64[Hp - 16] = GHC.Event.Poll.new4_closure+5;
           P64[Hp - 8] = GHC.Event.Poll.new3_closure;
           P64[Hp] = GHC.Event.Poll.new2_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.851042645 UTC

[section ""data" . GHC.Event.Poll.new_closure" {
     GHC.Event.Poll.new_closure:
         const GHC.Event.Poll.new_info;
         const 0;
 },
 GHC.Event.Poll.new_entry() //  []
         { info_tbl: [(calri,
                       label: GHC.Event.Poll.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calri: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.854988556 UTC

[section ""data" . GHC.Event.Poll.PollFd_closure" {
     GHC.Event.Poll.PollFd_closure:
         const GHC.Event.Poll.PollFd_info;
 },
 GHC.Event.Poll.PollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(calru,
                       label: GHC.Event.Poll.PollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calru: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calry; else goto calrx;
       calry: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.PollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calrx: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.859068333 UTC

[section ""data" . GHC.Event.Poll.Poll_closure" {
     GHC.Event.Poll.Poll_closure:
         const GHC.Event.Poll.Poll_info;
 },
 GHC.Event.Poll.Poll_entry() //  [R2, R3]
         { info_tbl: [(calrJ,
                       label: GHC.Event.Poll.Poll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calrJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calrN; else goto calrM;
       calrN: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.Poll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       calrM: // global
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.862663788 UTC

[GHC.Event.Poll.PollFd_con_entry() //  [R1]
         { info_tbl: [(calrT,
                       label: GHC.Event.Poll.PollFd_con_info
                       rep:HeapRep 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108,70,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calrT: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.865736626 UTC

[GHC.Event.Poll.Poll_con_entry() //  [R1]
         { info_tbl: [(calrZ,
                       label: GHC.Event.Poll.Poll_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calrZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:19.868728976 UTC

[section ""relreadonly" . SajSl_srt" {
     SajSl_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Poll.$w$cshowsPrec1_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure;
         const GHC.Event.Poll.$fShowPollFd1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.loop_closure;
         const GHC.Event.Array.removeAt_closure;
         const GHC.Event.Array.findIndex_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.$wlvl_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Poll.new5_closure;
         const lvl3_rajBc_closure;
         const lvl5_rajBe_closure;
         const lvl6_rajBf_closure;
         const lvl10_rajBj_closure;
         const lvl11_rajBk_closure;
         const GHC.Event.Poll.new4_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Poll.new3_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.20957312 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:22.211166404 UTC

[section ""data" . GHC.Event.Poll.$WPollFd_closure" {
     GHC.Event.Poll.$WPollFd_closure:
         const GHC.Event.Poll.$WPollFd_info;
 },
 GHC.Event.Poll.$WPollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(calAY,
                       label: GHC.Event.Poll.$WPollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calAY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calBc; else goto calBd;
       calBc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calBd: // global
           I64[Sp - 24] = block_calAV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ualBk; else goto calAW;
       ualBk: // global
           call _calAV(R1) args: 0, res: 0, upd: 0;
       calAW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calAV() //  [R1]
         { info_tbl: [(calAV,
                       label: block_calAV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calAV: // global
           I64[Sp] = block_calB1_info;
           _salsa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _salsa::I64;
           if (R1 & 7 != 0) goto ualBj; else goto calB2;
       ualBj: // global
           call _calB1(R1) args: 0, res: 0, upd: 0;
       calB2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calB1() //  [R1]
         { info_tbl: [(calB1,
                       label: block_calB1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calB1: // global
           I64[Sp] = block_calB6_info;
           _salsc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _salsc::I64;
           if (R1 & 7 != 0) goto ualBl; else goto calB7;
       ualBl: // global
           call _calB6(R1) args: 0, res: 0, upd: 0;
       calB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calB6() //  [R1]
         { info_tbl: [(calB6,
                       label: block_calB6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calB6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calBi; else goto calBh;
       calBi: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calBh: // global
           _salse::I64 = I64[R1 + 7];
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = _salse::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.22065391 UTC

[section ""data" . GHC.Event.Poll.$WPoll_closure" {
     GHC.Event.Poll.$WPoll_closure:
         const GHC.Event.Poll.$WPoll_info;
 },
 GHC.Event.Poll.$WPoll_entry() //  [R2, R3]
         { info_tbl: [(calBR,
                       label: GHC.Event.Poll.$WPoll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calBR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calC0; else goto calC1;
       calC0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$WPoll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       calC1: // global
           I64[Sp - 16] = block_calBO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ualC7; else goto calBP;
       ualC7: // global
           call _calBO(R1) args: 0, res: 0, upd: 0;
       calBP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calBO() //  [R1]
         { info_tbl: [(calBO,
                       label: block_calBO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calBO: // global
           I64[Sp] = block_calBU_info;
           _salsi::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _salsi::P64;
           if (R1 & 7 != 0) goto ualC6; else goto calBV;
       ualC6: // global
           call _calBU(R1) args: 0, res: 0, upd: 0;
       calBV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calBU() //  [R1]
         { info_tbl: [(calBU,
                       label: block_calBU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calBU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calC5; else goto calC4;
       calC5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calC4: // global
           _salsk::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _salsk::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.227866623 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$calignment_closure" {
     GHC.Event.Poll.$fStorablePollFd_$calignment_closure:
         const GHC.Event.Poll.$fStorablePollFd_$calignment_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$calignment_entry() //  []
         { info_tbl: [(calCu,
                       label: GHC.Event.Poll.$fStorablePollFd_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calCu: // global
           R1 = Foreign.Storable.$fStorableBool7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.231102737 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd7_closure" {
     GHC.Event.Poll.$fStorablePollFd7_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.232795965 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure" {
     GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure:
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_info;
 },
 GHC.Event.Poll.$fStorablePollFd_$csizeOf_entry() //  []
         { info_tbl: [(calCH,
                       label: GHC.Event.Poll.$fStorablePollFd_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calCH: // global
           R1 = GHC.Event.Poll.$fStorablePollFd7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.236412372 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd2_closure" {
     GHC.Event.Poll.$fStorablePollFd2_closure:
         const GHC.Event.Poll.$fStorablePollFd2_info;
 },
 GHC.Event.Poll.$fStorablePollFd2_entry() //  [R2]
         { info_tbl: [(calCW,
                       label: GHC.Event.Poll.$fStorablePollFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calCW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calD6; else goto calD7;
       calD6: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calD7: // global
           I64[Sp - 8] = block_calCT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualDb; else goto calCU;
       ualDb: // global
           call _calCT(R1) args: 0, res: 0, upd: 0;
       calCU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calCT() //  [R1]
         { info_tbl: [(calCT,
                       label: block_calCT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calCT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calDa; else goto calD9;
       calDa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calD9: // global
           _salsq::I64 = I64[R1 + 7];
           _salst::I64 = %MO_SS_Conv_W32_W64(I32[_salsq::I64]);
           _salsx::I64 = %MO_SS_Conv_W16_W64(I16[_salsq::I64 + 4]);
           _salsB::I64 = %MO_SS_Conv_W16_W64(I16[_salsq::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _salst::I64;
           I64[Hp - 8] = _salsx::I64;
           I64[Hp] = _salsB::I64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.244942139 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd6_closure" {
     GHC.Event.Poll.$fStorablePollFd6_closure:
         const GHC.Event.Poll.$fStorablePollFd6_info;
 },
 GHC.Event.Poll.$fStorablePollFd6_entry() //  [R2, R3]
         { info_tbl: [(calDv,
                       label: GHC.Event.Poll.$fStorablePollFd6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calDv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calDQ; else goto calDR;
       calDQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       calDR: // global
           I64[Sp - 16] = block_calDs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ualDX; else goto calDt;
       ualDX: // global
           call _calDs(R1) args: 0, res: 0, upd: 0;
       calDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calDs() //  [R1]
         { info_tbl: [(calDs,
                       label: block_calDs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calDs: // global
           I64[Sp] = block_calDy_info;
           _salsH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _salsH::I64;
           if (R1 & 7 != 0) goto ualDW; else goto calDz;
       ualDW: // global
           call _calDy(R1) args: 0, res: 0, upd: 0;
       calDz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calDy() //  [R1]
         { info_tbl: [(calDy,
                       label: block_calDy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calDy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calDV; else goto calDU;
       calDV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calDU: // global
           _salsK::I64 = I64[Sp + 8] + (I64[R1 + 7] << 3);
           _salsO::I64 = %MO_SS_Conv_W32_W64(I32[_salsK::I64]);
           _salsS::I64 = %MO_SS_Conv_W16_W64(I16[_salsK::I64 + 4]);
           _salsW::I64 = %MO_SS_Conv_W16_W64(I16[_salsK::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _salsO::I64;
           I64[Hp - 8] = _salsS::I64;
           I64[Hp] = _salsW::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.253216559 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd4_closure" {
     GHC.Event.Poll.$fStorablePollFd4_closure:
         const GHC.Event.Poll.$fStorablePollFd4_info;
 },
 GHC.Event.Poll.$fStorablePollFd4_entry() //  [R2, R3]
         { info_tbl: [(calEo,
                       label: GHC.Event.Poll.$fStorablePollFd4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calEo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calEG; else goto calEH;
       calEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       calEH: // global
           I64[Sp - 16] = block_calEl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ualEN; else goto calEm;
       ualEN: // global
           call _calEl(R1) args: 0, res: 0, upd: 0;
       calEm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calEl() //  [R1]
         { info_tbl: [(calEl,
                       label: block_calEl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calEl: // global
           I64[Sp] = block_calEr_info;
           _salt2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _salt2::I64;
           if (R1 & 7 != 0) goto ualEM; else goto calEs;
       ualEM: // global
           call _calEr(R1) args: 0, res: 0, upd: 0;
       calEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calEr() //  [R1]
         { info_tbl: [(calEr,
                       label: block_calEr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calEr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calEL; else goto calEK;
       calEL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calEK: // global
           _salt5::I64 = I64[Sp + 8] + I64[R1 + 7];
           _salt8::I64 = %MO_SS_Conv_W32_W64(I32[_salt5::I64]);
           _saltc::I64 = %MO_SS_Conv_W16_W64(I16[_salt5::I64 + 4]);
           _saltg::I64 = %MO_SS_Conv_W16_W64(I16[_salt5::I64 + 6]);
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _salt8::I64;
           I64[Hp - 8] = _saltc::I64;
           I64[Hp] = _saltg::I64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.26127768 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd1_closure" {
     GHC.Event.Poll.$fStorablePollFd1_closure:
         const GHC.Event.Poll.$fStorablePollFd1_info;
 },
 GHC.Event.Poll.$fStorablePollFd1_entry() //  [R2, R3]
         { info_tbl: [(calFe,
                       label: GHC.Event.Poll.$fStorablePollFd1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calFe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calFi; else goto calFj;
       calFi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       calFj: // global
           I64[Sp - 16] = block_calFb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ualFv; else goto calFc;
       ualFv: // global
           call _calFb(R1) args: 0, res: 0, upd: 0;
       calFc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calFb() //  [R1]
         { info_tbl: [(calFb,
                       label: block_calFb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calFb: // global
           I64[Sp] = block_calFh_info;
           _saltm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saltm::I64;
           if (R1 & 7 != 0) goto ualFu; else goto calFl;
       ualFu: // global
           call _calFh(R1) args: 0, res: 0, upd: 0;
       calFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calFh() //  [R1]
         { info_tbl: [(calFh,
                       label: block_calFh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calFh: // global
           _saltm::I64 = I64[Sp + 8];
           _saltp::I64 = I64[R1 + 15];
           _saltq::I64 = I64[R1 + 23];
           I32[_saltm::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_saltm::I64 + 4] = %MO_UU_Conv_W64_W16(_saltp::I64);
           I16[_saltm::I64 + 6] = %MO_UU_Conv_W64_W16(_saltq::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.26876007 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd5_closure" {
     GHC.Event.Poll.$fStorablePollFd5_closure:
         const GHC.Event.Poll.$fStorablePollFd5_info;
 },
 GHC.Event.Poll.$fStorablePollFd5_entry() //  [R2, R3, R4]
         { info_tbl: [(calFX,
                       label: GHC.Event.Poll.$fStorablePollFd5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calFX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calG6; else goto calG7;
       calG6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calG7: // global
           I64[Sp - 24] = block_calFU_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ualGq; else goto calFV;
       ualGq: // global
           call _calFU(R1) args: 0, res: 0, upd: 0;
       calFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calFU() //  [R1]
         { info_tbl: [(calFU,
                       label: block_calFU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calFU: // global
           I64[Sp] = block_calG0_info;
           _saltB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saltB::I64;
           if (R1 & 7 != 0) goto ualGp; else goto calG1;
       ualGp: // global
           call _calG0(R1) args: 0, res: 0, upd: 0;
       calG1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calG0() //  [R1]
         { info_tbl: [(calG0,
                       label: block_calG0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calG0: // global
           I64[Sp] = block_calG5_info;
           _saltD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saltD::I64;
           if (R1 & 7 != 0) goto ualGr; else goto calGa;
       ualGr: // global
           call _calG5(R1) args: 0, res: 0, upd: 0;
       calGa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calG5() //  [R1]
         { info_tbl: [(calG5,
                       label: block_calG5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calG5: // global
           _saltG::I64 = I64[R1 + 15];
           _saltH::I64 = I64[R1 + 23];
           _saltI::I64 = I64[Sp + 8] + (I64[Sp + 16] << 3);
           I32[_saltI::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_saltI::I64 + 4] = %MO_UU_Conv_W64_W16(_saltG::I64);
           I16[_saltI::I64 + 6] = %MO_UU_Conv_W64_W16(_saltH::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.278544032 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd3_closure" {
     GHC.Event.Poll.$fStorablePollFd3_closure:
         const GHC.Event.Poll.$fStorablePollFd3_info;
 },
 GHC.Event.Poll.$fStorablePollFd3_entry() //  [R2, R3, R4]
         { info_tbl: [(calH0,
                       label: GHC.Event.Poll.$fStorablePollFd3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calH0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calH9; else goto calHa;
       calH9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fStorablePollFd3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calHa: // global
           I64[Sp - 24] = block_calGX_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ualHq; else goto calGY;
       ualHq: // global
           call _calGX(R1) args: 0, res: 0, upd: 0;
       calGY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calGX() //  [R1]
         { info_tbl: [(calGX,
                       label: block_calGX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calGX: // global
           I64[Sp] = block_calH3_info;
           _saltU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _saltU::I64;
           if (R1 & 7 != 0) goto ualHp; else goto calH4;
       ualHp: // global
           call _calH3(R1) args: 0, res: 0, upd: 0;
       calH4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calH3() //  [R1]
         { info_tbl: [(calH3,
                       label: block_calH3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calH3: // global
           I64[Sp] = block_calH8_info;
           _saltW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _saltW::I64;
           if (R1 & 7 != 0) goto ualHr; else goto calHd;
       ualHr: // global
           call _calH8(R1) args: 0, res: 0, upd: 0;
       calHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calH8() //  [R1]
         { info_tbl: [(calH8,
                       label: block_calH8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calH8: // global
           _saltZ::I64 = I64[R1 + 15];
           _salu0::I64 = I64[R1 + 23];
           _salu1::I64 = I64[Sp + 8] + I64[Sp + 16];
           I32[_salu1::I64] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I16[_salu1::I64 + 4] = %MO_UU_Conv_W64_W16(_saltZ::I64);
           I16[_salu1::I64 + 6] = %MO_UU_Conv_W64_W16(_salu0::I64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.288148435 UTC

[section ""data" . GHC.Event.Poll.$fStorablePollFd_closure" {
     GHC.Event.Poll.$fStorablePollFd_closure:
         const Foreign.Storable.C:Storable_con_info;
         const GHC.Event.Poll.$fStorablePollFd_$csizeOf_closure+1;
         const GHC.Event.Poll.$fStorablePollFd_$calignment_closure+1;
         const GHC.Event.Poll.$fStorablePollFd6_closure+3;
         const GHC.Event.Poll.$fStorablePollFd5_closure+4;
         const GHC.Event.Poll.$fStorablePollFd4_closure+3;
         const GHC.Event.Poll.$fStorablePollFd3_closure+4;
         const GHC.Event.Poll.$fStorablePollFd2_closure+2;
         const GHC.Event.Poll.$fStorablePollFd1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.289947049 UTC

[section ""data" . GHC.Event.Poll.$fStorableEvent_closure" {
     GHC.Event.Poll.$fStorableEvent_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.291685712 UTC

[section ""cstring" . GHC.Event.Poll.$fShowEvent2_bytes" {
     GHC.Event.Poll.$fShowEvent2_bytes:
         I8[] [69,118,101,110,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.29461561 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec_closure" {
     GHC.Event.Poll.$w$cshowsPrec_closure:
         const GHC.Event.Poll.$w$cshowsPrec_info;
 },
 sat_salug_entry() //  [R1]
         { info_tbl: [(calI9,
                       label: sat_salug_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calI9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto calIf; else goto calIg;
       calIf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calIg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_calI6_info;
           _salu9::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _salu9::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ualIl; else goto calI7;
       ualIl: // global
           call _calI6(R1) args: 0, res: 0, upd: 0;
       calI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _calI6() //  [R1]
         { info_tbl: [(calI6,
                       label: block_calI6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calI6: // global
           _salu9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_calIc_info;
           R4 = _salu9::P64;
           R3 = I64[R1 + 7];
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _calIc() //  [R1, R2]
         { info_tbl: [(calIc,
                       label: block_calIc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calIc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calIk; else goto calIj;
       calIk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       calIj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_salun_entry() //  [R1]
         { info_tbl: [(calIy,
                       label: sat_salun_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calIy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto calIF; else goto calIG;
       calIF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calIG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_calIv_info;
           _salu9::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _salu9::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ualIN; else goto calIw;
       ualIN: // global
           call _calIv(R1) args: 0, res: 0, upd: 0;
       calIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _calIv() //  [R1]
         { info_tbl: [(calIv,
                       label: block_calIv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calIv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calIJ; else goto calII;
       calIJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       calII: // global
           _salui::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_calIC_info;
           R4 = Hp - 14;
           R3 = _salui::I64;
           R2 = 11;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _calIC() //  [R1, R2]
         { info_tbl: [(calIC,
                       label: block_calIC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calIC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calIM; else goto calIL;
       calIM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       calIL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluo_entry() //  [R1]
         { info_tbl: [(calIO,
                       label: sat_saluo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calIO: // global
           _saluo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calIP; else goto calIQ;
       calIQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calIS; else goto calIR;
       calIS: // global
           HpAlloc = 32;
           goto calIP;
       calIP: // global
           R1 = _saluo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calIR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluo::P64;
           _salu8::P64 = P64[_saluo::P64 + 16];
           _salu9::P64 = P64[_saluo::P64 + 24];
           I64[Hp - 24] = sat_salun_info;
           P64[Hp - 8] = _salu8::P64;
           P64[Hp] = _salu9::P64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(calIW,
                       label: GHC.Event.Poll.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calIW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto calJ0; else goto calIZ;
       calJ0: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calIZ: // global
           if (%MO_S_Lt_W64(R2, 11)) goto calIU; else goto calIV;
       calIU: // global
           I64[Hp - 48] = sat_salug_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _calI2::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _calI2::P64;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       calIV: // global
           I64[Hp - 48] = sat_saluo_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.313148088 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(calJY,
                       label: GHC.Event.Poll.$fShowEvent_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calJY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calJZ; else goto calK0;
       calJZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calK0: // global
           I64[Sp - 24] = block_calJV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ualK4; else goto calJW;
       ualK4: // global
           call _calJV(R1) args: 0, res: 0, upd: 0;
       calJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calJV() //  [R1]
         { info_tbl: [(calJV,
                       label: block_calJV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calJV: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.318994682 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshow_closure" {
     GHC.Event.Poll.$fShowEvent_$cshow_closure:
         const GHC.Event.Poll.$fShowEvent_$cshow_info;
 },
 sat_saluA_entry() //  [R1]
         { info_tbl: [(calKq,
                       label: sat_saluA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calKq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calKw; else goto calKx;
       calKw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calKx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_calKn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ualKC; else goto calKo;
       ualKC: // global
           call _calKn(R1) args: 0, res: 0, upd: 0;
       calKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _calKn() //  [R1]
         { info_tbl: [(calKn,
                       label: block_calKn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calKn: // global
           I64[Sp] = block_calKt_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _calKt() //  [R1, R2]
         { info_tbl: [(calKt,
                       label: block_calKt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calKt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calKB; else goto calKA;
       calKB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       calKA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$fShowEvent_$cshow_entry() //  [R2]
         { info_tbl: [(calKD,
                       label: GHC.Event.Poll.$fShowEvent_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calKD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calKH; else goto calKG;
       calKH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowEvent_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calKG: // global
           I64[Hp - 16] = sat_saluA_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Event.Poll.$fShowEvent2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.328700234 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent1_closure" {
     GHC.Event.Poll.$fShowEvent1_closure:
         const GHC.Event.Poll.$fShowEvent1_info;
 },
 GHC.Event.Poll.$fShowEvent1_entry() //  [R2, R3]
         { info_tbl: [(calL8,
                       label: GHC.Event.Poll.$fShowEvent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calL8: // global
           R4 = R3;
           R3 = R2;
           R2 = 0;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.33198175 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_$cshowList_closure" {
     GHC.Event.Poll.$fShowEvent_$cshowList_closure:
         const GHC.Event.Poll.$fShowEvent_$cshowList_info;
 },
 GHC.Event.Poll.$fShowEvent_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(calLj,
                       label: GHC.Event.Poll.$fShowEvent_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calLj: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowEvent1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.335374375 UTC

[section ""data" . GHC.Event.Poll.$fShowEvent_closure" {
     GHC.Event.Poll.$fShowEvent_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowEvent_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowEvent_$cshow_closure+1;
         const GHC.Event.Poll.$fShowEvent_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.3370601 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd6_bytes" {
     GHC.Event.Poll.$fShowPollFd6_bytes:
         I8[] [80,111,108,108,70,100,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.338698614 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd5_bytes" {
     GHC.Event.Poll.$fShowPollFd5_bytes:
         I8[] [112,102,100,70,100,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.340317678 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd4_bytes" {
     GHC.Event.Poll.$fShowPollFd4_bytes:
         I8[] [112,102,100,69,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.341938429 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd3_bytes" {
     GHC.Event.Poll.$fShowPollFd3_bytes:
         I8[] [112,102,100,82,101,118,101,110,116,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.343609122 UTC

[section ""cstring" . GHC.Event.Poll.$fShowPollFd2_bytes" {
     GHC.Event.Poll.$fShowPollFd2_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.347997543 UTC

[section ""data" . GHC.Event.Poll.$w$cshowsPrec1_closure" {
     GHC.Event.Poll.$w$cshowsPrec1_closure:
         const GHC.Event.Poll.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.Event.Poll.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calLx: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saluO_entry() //  [R1]
         { info_tbl: [(calMg,
                       label: sat_saluO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calMh; else goto calMi;
       calMh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Event.Poll.$fShowPollFd2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluP_entry() //  [R1]
         { info_tbl: [(calMk,
                       label: sat_saluP_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMk: // global
           _saluP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calMl; else goto calMm;
       calMm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto calMo; else goto calMn;
       calMo: // global
           HpAlloc = 40;
           goto calMl;
       calMl: // global
           R1 = _saluP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluP::P64;
           _saluL::P64 = P64[_saluP::P64 + 16];
           _saluI::I64 = I64[_saluP::P64 + 24];
           I64[Hp - 32] = sat_saluO_info;
           P64[Hp - 16] = _saluL::P64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _saluI::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluQ_entry() //  [R1]
         { info_tbl: [(calMp,
                       label: sat_saluQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calMt; else goto calMs;
       calMt: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMs: // global
           _saluL::P64 = P64[R1 + 16];
           _saluI::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_saluP_info;
           P64[Hp - 8] = _saluL::P64;
           I64[Hp] = _saluI::I64;
           R3 = Hp - 24;
           R2 = GHC.Event.Poll.$fShowPollFd3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saluR_entry() //  [R1]
         { info_tbl: [(calMu,
                       label: sat_saluR_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMu: // global
           _saluR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calMv; else goto calMw;
       calMw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto calMy; else goto calMx;
       calMy: // global
           HpAlloc = 32;
           goto calMv;
       calMv: // global
           R1 = _saluR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluR::P64;
           _saluL::P64 = P64[_saluR::P64 + 16];
           _saluI::I64 = I64[_saluR::P64 + 24];
           I64[Hp - 24] = sat_saluQ_info;
           P64[Hp - 8] = _saluL::P64;
           I64[Hp] = _saluI::I64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluS_entry() //  [R1]
         { info_tbl: [(calMA,
                       label: sat_saluS_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMA: // global
           _saluS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calMB; else goto calMC;
       calMC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto calME; else goto calMD;
       calME: // global
           HpAlloc = 48;
           goto calMB;
       calMB: // global
           R1 = _saluS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluS::P64;
           _saluL::P64 = P64[_saluS::P64 + 16];
           _saluH::I64 = I64[_saluS::P64 + 24];
           _saluI::I64 = I64[_saluS::P64 + 32];
           I64[Hp - 40] = sat_saluR_info;
           P64[Hp - 24] = _saluL::P64;
           I64[Hp - 16] = _saluI::I64;
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _saluH::I64;
           R4 = Hp - 40;
           R3 = Hp - 7;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Event.Poll.$w$cshowsPrec_entry(R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluT_entry() //  [R1]
         { info_tbl: [(calMF,
                       label: sat_saluT_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto calMJ; else goto calMI;
       calMJ: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMI: // global
           _saluL::P64 = P64[R1 + 16];
           _saluH::I64 = I64[R1 + 24];
           _saluI::I64 = I64[R1 + 32];
           I64[Hp - 32] = sat_saluS_info;
           P64[Hp - 16] = _saluL::P64;
           I64[Hp - 8] = _saluH::I64;
           I64[Hp] = _saluI::I64;
           R3 = Hp - 32;
           R2 = GHC.Event.Poll.$fShowPollFd4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saluU_entry() //  [R1]
         { info_tbl: [(calMK,
                       label: sat_saluU_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMK: // global
           _saluU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calML; else goto calMM;
       calMM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto calMO; else goto calMN;
       calMO: // global
           HpAlloc = 40;
           goto calML;
       calML: // global
           R1 = _saluU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluU::P64;
           _saluL::P64 = P64[_saluU::P64 + 16];
           _saluH::I64 = I64[_saluU::P64 + 24];
           _saluI::I64 = I64[_saluU::P64 + 32];
           I64[Hp - 32] = sat_saluT_info;
           P64[Hp - 16] = _saluL::P64;
           I64[Hp - 8] = _saluH::I64;
           I64[Hp] = _saluI::I64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluY_entry() //  [R1]
         { info_tbl: [(calMS,
                       label: sat_saluY_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMS: // global
           _saluY::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto calMT; else goto calMU;
       calMU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto calMW; else goto calMV;
       calMW: // global
           HpAlloc = 40;
           goto calMT;
       calMT: // global
           R1 = _saluY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calMV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluY::P64;
           _saluL::P64 = P64[_saluY::P64 + 16];
           _saluG::I64 = I64[_saluY::P64 + 24];
           _saluH::I64 = I64[_saluY::P64 + 32];
           _saluI::I64 = I64[_saluY::P64 + 40];
           I64[Hp - 32] = sat_saluU_info;
           P64[Hp - 16] = _saluL::P64;
           I64[Hp - 8] = _saluH::I64;
           I64[Hp] = _saluI::I64;
           I64[Sp - 24] = block_calMP_info;
           R4 = Hp - 32;
           R3 = _saluG::I64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _calMP() //  [R1, R2]
         { info_tbl: [(calMP,
                       label: block_calMP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calMP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calMZ; else goto calMY;
       calMZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       calMY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_saluZ_entry() //  [R1]
         { info_tbl: [(calN0,
                       label: sat_saluZ_info
                       rep:HeapRep 1 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calN0: // global
           _saluZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calN1; else goto calN2;
       calN2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto calN4; else goto calN3;
       calN4: // global
           HpAlloc = 48;
           goto calN1;
       calN1: // global
           R1 = _saluZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calN3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saluZ::P64;
           _saluL::P64 = P64[_saluZ::P64 + 16];
           _saluG::I64 = I64[_saluZ::P64 + 24];
           _saluH::I64 = I64[_saluZ::P64 + 32];
           _saluI::I64 = I64[_saluZ::P64 + 40];
           I64[Hp - 40] = sat_saluY_info;
           P64[Hp - 24] = _saluL::P64;
           I64[Hp - 16] = _saluG::I64;
           I64[Hp - 8] = _saluH::I64;
           I64[Hp] = _saluI::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_saluK_entry() //  [R1, R2]
         { info_tbl: [(calN5,
                       label: p_saluK_info
                       rep:HeapRep 3 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calN5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto calN9; else goto calN8;
       calN9: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calN8: // global
           _saluG::I64 = I64[R1 + 7];
           _saluH::I64 = I64[R1 + 15];
           _saluI::I64 = I64[R1 + 23];
           I64[Hp - 40] = sat_saluZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = _saluG::I64;
           I64[Hp - 8] = _saluH::I64;
           I64[Hp] = _saluI::I64;
           R3 = Hp - 40;
           R2 = GHC.Event.Poll.$fShowPollFd6_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_salv2_entry() //  [R1]
         { info_tbl: [(calNj,
                       label: sat_salv2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calNj: // global
           _salv2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto calNk; else goto calNl;
       calNl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto calNn; else goto calNm;
       calNn: // global
           HpAlloc = 24;
           goto calNk;
       calNk: // global
           R1 = _salv2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calNm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _salv2::P64;
           _saluJ::P64 = P64[_salv2::P64 + 16];
           _saluK::P64 = P64[_salv2::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _saluJ::P64;
           R2 = Hp - 14;
           R1 = _saluK::P64;
           Sp = Sp - 16;
           call p_saluK_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Event.Poll.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(calNr,
                       label: GHC.Event.Poll.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [True, True, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calNr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto calNv; else goto calNu;
       calNv: // global
           HpAlloc = 88;
           R1 = GHC.Event.Poll.$w$cshowsPrec1_closure;
           I64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       calNu: // global
           I64[Hp - 80] = p_saluK_info;
           I64[Hp - 72] = R3;
           I64[Hp - 64] = R4;
           I64[Hp - 56] = R5;
           _calLB::P64 = Hp - 79;
           if (%MO_S_Lt_W64(R2, 11)) goto calNp; else goto calNq;
       calNp: // global
           Hp = Hp - 56;
           R2 = R6;
           R1 = _calLB::P64;
           call p_saluK_entry(R2, R1) args: 8, res: 0, upd: 8;
       calNq: // global
           I64[Hp - 48] = sat_salv2_info;
           P64[Hp - 32] = R6;
           P64[Hp - 24] = _calLB::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.380259122 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(calOX,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calOX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calP1; else goto calP2;
       calP1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       calP2: // global
           I64[Sp - 24] = block_calOU_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ualPa; else goto calOV;
       ualPa: // global
           call _calOU(R1) args: 0, res: 0, upd: 0;
       calOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calOU() //  [R1]
         { info_tbl: [(calOU,
                       label: block_calOU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calOU: // global
           I64[Sp] = block_calP0_info;
           _salv7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _salv7::I64;
           if (R1 & 7 != 0) goto ualP9; else goto calP4;
       ualP9: // global
           call _calP0(R1) args: 0, res: 0, upd: 0;
       calP4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calP0() //  [R1]
         { info_tbl: [(calP0,
                       label: block_calP0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calP0: // global
           R6 = P64[Sp + 16];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.387888284 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd7_closure" {
     GHC.Event.Poll.$fShowPollFd7_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.38985852 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshow_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshow_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshow_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshow_entry() //  [R2]
         { info_tbl: [(calPy,
                       label: GHC.Event.Poll.$fShowPollFd_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calPy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calPz; else goto calPA;
       calPz: // global
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calPA: // global
           I64[Sp - 8] = block_calPv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualPE; else goto calPw;
       ualPE: // global
           call _calPv(R1) args: 0, res: 0, upd: 0;
       calPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calPv() //  [R1]
         { info_tbl: [(calPv,
                       label: block_calPv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calPv: // global
           R6 = GHC.Types.[]_closure+1;
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.396279651 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd1_closure" {
     GHC.Event.Poll.$fShowPollFd1_closure:
         const GHC.Event.Poll.$fShowPollFd1_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd1_entry() //  [R2, R3]
         { info_tbl: [(calPX,
                       label: GHC.Event.Poll.$fShowPollFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calPX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calPY; else goto calPZ;
       calPY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.$fShowPollFd1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       calPZ: // global
           I64[Sp - 16] = block_calPU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ualQ3; else goto calPV;
       ualQ3: // global
           call _calPU(R1) args: 0, res: 0, upd: 0;
       calPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calPU() //  [R1]
         { info_tbl: [(calPU,
                       label: block_calPU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calPU: // global
           R6 = P64[Sp + 8];
           R5 = I64[R1 + 23];
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Event.Poll.$w$cshowsPrec1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.401657754 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_$cshowList_closure" {
     GHC.Event.Poll.$fShowPollFd_$cshowList_closure:
         const GHC.Event.Poll.$fShowPollFd_$cshowList_info;
         const 0;
 },
 GHC.Event.Poll.$fShowPollFd_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(calQi,
                       label: GHC.Event.Poll.$fShowPollFd_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calQi: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Event.Poll.$fShowPollFd1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.404868285 UTC

[section ""data" . GHC.Event.Poll.$fShowPollFd_closure" {
     GHC.Event.Poll.$fShowPollFd_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure+3;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure+1;
         const GHC.Event.Poll.$fShowPollFd_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.407002464 UTC

[section ""data" . GHC.Event.Poll.$fEqEvent_closure" {
     GHC.Event.Poll.$fEqEvent_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.408977818 UTC

[section ""data" . GHC.Event.Poll.pfdRevents_closure" {
     GHC.Event.Poll.pfdRevents_closure:
         const GHC.Event.Poll.pfdRevents_info;
 },
 GHC.Event.Poll.pfdRevents_entry() //  [R2]
         { info_tbl: [(calQy,
                       label: GHC.Event.Poll.pfdRevents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calQy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calQC; else goto calQD;
       calQC: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdRevents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calQD: // global
           I64[Sp - 8] = block_calQv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualQH; else goto calQw;
       ualQH: // global
           call _calQv(R1) args: 0, res: 0, upd: 0;
       calQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calQv() //  [R1]
         { info_tbl: [(calQv,
                       label: block_calQv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calQv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calQG; else goto calQF;
       calQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calQF: // global
           _salvt::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _salvt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.414986845 UTC

[section ""data" . GHC.Event.Poll.pfdEvents_closure" {
     GHC.Event.Poll.pfdEvents_closure:
         const GHC.Event.Poll.pfdEvents_info;
 },
 GHC.Event.Poll.pfdEvents_entry() //  [R2]
         { info_tbl: [(calR1,
                       label: GHC.Event.Poll.pfdEvents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calR1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calR5; else goto calR6;
       calR5: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdEvents_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calR6: // global
           I64[Sp - 8] = block_calQY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualRa; else goto calQZ;
       ualRa: // global
           call _calQY(R1) args: 0, res: 0, upd: 0;
       calQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calQY() //  [R1]
         { info_tbl: [(calQY,
                       label: block_calQY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calQY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calR9; else goto calR8;
       calR9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calR8: // global
           _salvx::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _salvx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.420590128 UTC

[section ""data" . GHC.Event.Poll.pfdFd_closure" {
     GHC.Event.Poll.pfdFd_closure:
         const GHC.Event.Poll.pfdFd_info;
 },
 GHC.Event.Poll.pfdFd_entry() //  [R2]
         { info_tbl: [(calRu,
                       label: GHC.Event.Poll.pfdFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calRu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calRy; else goto calRz;
       calRy: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pfdFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calRz: // global
           I64[Sp - 8] = block_calRr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualRD; else goto calRs;
       ualRD: // global
           call _calRr(R1) args: 0, res: 0, upd: 0;
       calRs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calRr() //  [R1]
         { info_tbl: [(calRr,
                       label: block_calRr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calRr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calRC; else goto calRB;
       calRC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calRB: // global
           _salvB::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _salvB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.426603656 UTC

[section ""data" . GHC.Event.Poll.pollFd_closure" {
     GHC.Event.Poll.pollFd_closure:
         const GHC.Event.Poll.pollFd_info;
 },
 GHC.Event.Poll.pollFd_entry() //  [R2]
         { info_tbl: [(calRX,
                       label: GHC.Event.Poll.pollFd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calRX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calS1; else goto calS2;
       calS1: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollFd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calS2: // global
           I64[Sp - 8] = block_calRU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualS6; else goto calRV;
       ualS6: // global
           call _calRU(R1) args: 0, res: 0, upd: 0;
       calRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calRU() //  [R1]
         { info_tbl: [(calRU,
                       label: block_calRU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calRU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calS5; else goto calS4;
       calS5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calS4: // global
           _salvH::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _salvH::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.432604338 UTC

[section ""data" . GHC.Event.Poll.pollChanges_closure" {
     GHC.Event.Poll.pollChanges_closure:
         const GHC.Event.Poll.pollChanges_info;
 },
 GHC.Event.Poll.pollChanges_entry() //  [R2]
         { info_tbl: [(calSq,
                       label: GHC.Event.Poll.pollChanges_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calSq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto calSu; else goto calSv;
       calSu: // global
           R2 = R2;
           R1 = GHC.Event.Poll.pollChanges_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       calSv: // global
           I64[Sp - 8] = block_calSn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ualSz; else goto calSo;
       ualSz: // global
           call _calSn(R1) args: 0, res: 0, upd: 0;
       calSo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calSn() //  [R1]
         { info_tbl: [(calSn,
                       label: block_calSn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calSn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calSy; else goto calSx;
       calSy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calSx: // global
           _salvK::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _salvK::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.438179788 UTC

[section ""data" . GHC.Event.Poll.available_closure" {
     GHC.Event.Poll.available_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.439825571 UTC

[section ""cstring" . GHC.Event.Poll.$trModule4_bytes" {
     GHC.Event.Poll.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.441459711 UTC

[section ""data" . GHC.Event.Poll.$trModule3_closure" {
     GHC.Event.Poll.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.443113685 UTC

[section ""cstring" . GHC.Event.Poll.$trModule2_bytes" {
     GHC.Event.Poll.$trModule2_bytes:
         I8[] [71,72,67,46,69,118,101,110,116,46,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.444620123 UTC

[section ""data" . GHC.Event.Poll.$trModule1_closure" {
     GHC.Event.Poll.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.446663992 UTC

[section ""data" . GHC.Event.Poll.$trModule_closure" {
     GHC.Event.Poll.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Event.Poll.$trModule3_closure+1;
         const GHC.Event.Poll.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.448365499 UTC

[section ""data" . $krep_rajAW_closure" {
     $krep_rajAW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCShort_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.450438798 UTC

[section ""data" . $krep1_rajAX_closure" {
     $krep1_rajAX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.Posix.Types.$tcFd_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.45211245 UTC

[section ""cstring" . GHC.Event.Poll.$tcEvent2_bytes" {
     GHC.Event.Poll.$tcEvent2_bytes:
         I8[] [69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.453771922 UTC

[section ""data" . GHC.Event.Poll.$tcEvent1_closure" {
     GHC.Event.Poll.$tcEvent1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcEvent2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.45538384 UTC

[section ""data" . GHC.Event.Poll.$tcEvent_closure" {
     GHC.Event.Poll.$tcEvent_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcEvent1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10782964843686049546;
         const 16589058175633483645;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.457789492 UTC

[section ""data" . $krep2_rajAY_closure" {
     $krep2_rajAY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcEvent_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.459458492 UTC

[section ""data" . GHC.Event.Poll.$tc'Event1_closure" {
     GHC.Event.Poll.$tc'Event1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rajAW_closure+1;
         const $krep2_rajAY_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.461071391 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Event3_bytes" {
     GHC.Event.Poll.$tc'Event3_bytes:
         I8[] [39,69,118,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.462700747 UTC

[section ""data" . GHC.Event.Poll.$tc'Event2_closure" {
     GHC.Event.Poll.$tc'Event2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Event3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.464428409 UTC

[section ""data" . GHC.Event.Poll.$tc'Event_closure" {
     GHC.Event.Poll.$tc'Event_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Event2_closure+1;
         const GHC.Event.Poll.$tc'Event1_closure+4;
         const 14301517435728423362;
         const 8190957594797964970;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.466256746 UTC

[section ""cstring" . GHC.Event.Poll.$tcPollFd2_bytes" {
     GHC.Event.Poll.$tcPollFd2_bytes:
         I8[] [80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.467835785 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd1_closure" {
     GHC.Event.Poll.$tcPollFd1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPollFd2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.469743352 UTC

[section ""data" . GHC.Event.Poll.$tcPollFd_closure" {
     GHC.Event.Poll.$tcPollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPollFd1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16228031948332168786;
         const 6382085973026785723;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.471495117 UTC

[section ""data" . $krep3_rajAZ_closure" {
     $krep3_rajAZ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPollFd_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.473167738 UTC

[section ""data" . $krep4_rajB0_closure" {
     $krep4_rajB0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep3_rajAZ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.474845283 UTC

[section ""data" . $krep5_rajB1_closure" {
     $krep5_rajB1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rajAY_closure+1;
         const $krep4_rajB0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.476512891 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd1_closure" {
     GHC.Event.Poll.$tc'PollFd1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rajAX_closure+1;
         const $krep5_rajB1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.478175536 UTC

[section ""cstring" . GHC.Event.Poll.$tc'PollFd3_bytes" {
     GHC.Event.Poll.$tc'PollFd3_bytes:
         I8[] [39,80,111,108,108,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.479797605 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd2_closure" {
     GHC.Event.Poll.$tc'PollFd2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'PollFd3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.482397247 UTC

[section ""data" . GHC.Event.Poll.$tc'PollFd_closure" {
     GHC.Event.Poll.$tc'PollFd_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'PollFd2_closure+1;
         const GHC.Event.Poll.$tc'PollFd1_closure+4;
         const 13628496348781941345;
         const 13702663238288085101;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.484210371 UTC

[section ""data" . $krep6_rajB2_closure" {
     $krep6_rajB2_closure:
         const :_con_info;
         const $krep3_rajAZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.485817908 UTC

[section ""data" . $krep7_rajB3_closure" {
     $krep7_rajB3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Array.$tcArray_closure;
         const $krep6_rajB2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.48744464 UTC

[section ""data" . $krep8_rajB4_closure" {
     $krep8_rajB4_closure:
         const :_con_info;
         const $krep7_rajB3_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.489041914 UTC

[section ""data" . $krep9_rajB5_closure" {
     $krep9_rajB5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep8_rajB4_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.491082876 UTC

[section ""cstring" . GHC.Event.Poll.$tcPoll2_bytes" {
     GHC.Event.Poll.$tcPoll2_bytes:
         I8[] [80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.492639337 UTC

[section ""data" . GHC.Event.Poll.$tcPoll1_closure" {
     GHC.Event.Poll.$tcPoll1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tcPoll2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.494227175 UTC

[section ""data" . GHC.Event.Poll.$tcPoll_closure" {
     GHC.Event.Poll.$tcPoll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tcPoll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13451464419968486054;
         const 9195109480934256969;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.495950401 UTC

[section ""data" . $krep10_rajB6_closure" {
     $krep10_rajB6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Event.Poll.$tcPoll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.497893138 UTC

[section ""data" . $krep11_rajB7_closure" {
     $krep11_rajB7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rajB3_closure+1;
         const $krep10_rajB6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.499448982 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll1_closure" {
     GHC.Event.Poll.$tc'Poll1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_rajB5_closure+1;
         const $krep11_rajB7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.500999854 UTC

[section ""cstring" . GHC.Event.Poll.$tc'Poll3_bytes" {
     GHC.Event.Poll.$tc'Poll3_bytes:
         I8[] [39,80,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.502568047 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll2_closure" {
     GHC.Event.Poll.$tc'Poll2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Event.Poll.$tc'Poll3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.504244565 UTC

[section ""data" . GHC.Event.Poll.$tc'Poll_closure" {
     GHC.Event.Poll.$tc'Poll_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Event.Poll.$trModule_closure+1;
         const GHC.Event.Poll.$tc'Poll2_closure+1;
         const GHC.Event.Poll.$tc'Poll1_closure+4;
         const 5431567153781643515;
         const 15938353663250731731;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.506525364 UTC

[section ""data" . GHC.Event.Poll.$fBitsEvent_closure" {
     GHC.Event.Poll.$fBitsEvent_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Event.Poll.$fEqEvent_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.508588296 UTC

[section ""data" . GHC.Event.Poll.$fFiniteBitsEvent_closure" {
     GHC.Event.Poll.$fFiniteBitsEvent_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Event.Poll.$fBitsEvent_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.510361952 UTC

[section ""data" . GHC.Event.Poll.$fNumEvent_closure" {
     GHC.Event.Poll.$fNumEvent_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.51206718 UTC

[section ""cstring" . lvl_rajB8_bytes" {
     lvl_rajB8_bytes:
         I8[] [109,111,100,105,102,121,70,100,79,110,99,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,105,110,32,80,111,108,108,32,98,97,99,107,101,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.514362129 UTC

[section ""data" . GHC.Event.Poll.new3_closure" {
     GHC.Event.Poll.new3_closure:
         const GHC.Event.Poll.new3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Event.Poll.new3_entry() //  [R1]
         { info_tbl: [(calTB,
                       label: GHC.Event.Poll.new3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calTB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calTC; else goto calTD;
       calTC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calTD: // global
           (_calTw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_calTw::I64 == 0) goto calTy; else goto calTx;
       calTy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       calTx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _calTw::I64;
           I64[Sp - 24] = block_calTz_info;
           R2 = lvl_rajB8_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _calTz() //  [R1]
         { info_tbl: [(calTz,
                       label: block_calTz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calTz: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.520791734 UTC

[section ""data" . $wc_pollLoop_rajB9_closure" {
     $wc_pollLoop_rajB9_closure:
         const $wc_pollLoop_rajB9_info;
 },
 $wc_pollLoop_rajB9_entry() //  [R2, R3, R4]
         { info_tbl: [(calU2,
                       label: $wc_pollLoop_rajB9_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calU2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto calU3; else goto ualUN;
       calU3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wc_pollLoop_rajB9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ualUN: // global
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _calTU() args: 0, res: 0, upd: 0;
     }
 },
 _calTU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calTU: // global
           _salvN::I64 = I64[Sp];
           _salvO::I64 = I64[Sp + 8];
           _salvP::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_salvP::I64,
                            2147483647)) goto calU0; else goto calU1;
       calU0: // global
           I64[Sp - 8] = block_calUa_info;
           Sp = Sp - 8;
           _ualUT::P64 = CurrentTSO;
           I64[I64[_ualUT::P64 + 24] + 16] = Sp;
           _ualUU::I64 = CurrentNursery;
           P64[_ualUU::I64 + 8] = Hp + 8;
           I64[_ualUT::P64 + 104] = I64[_ualUT::P64 + 104] - ((Hp + 8) - I64[_ualUU::I64]);
           (_ualUR::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_salvV::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_salvN::I64, _salvO::I64, 2147483647);
           (_ualUS::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ualUR::I64);
           BaseReg = _ualUS::I64;
           _ualUV::P64 = CurrentTSO;
           _ualUW::P64 = I64[_ualUV::P64 + 24];
           Sp = I64[_ualUW::P64 + 16];
           SpLim = _ualUW::P64 + 192;
           HpAlloc = 0;
           _ualUX::I64 = CurrentNursery;
           _ualUY::I64 = I64[_ualUX::I64 + 8];
           Hp = _ualUY::I64 - 8;
           _ualUZ::I64 = I64[_ualUX::I64];
           HpLim = _ualUZ::I64 + ((%MO_SS_Conv_W32_W64(I32[_ualUX::I64 + 48]) << 12) - 1);
           I64[_ualUV::P64 + 104] = I64[_ualUV::P64 + 104] + (_ualUY::I64 - _ualUZ::I64);
           R1 = _salvV::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
       calU1: // global
           I64[Sp + 16] = block_calUD_info;
           Sp = Sp + 16;
           _ualV3::P64 = CurrentTSO;
           I64[I64[_ualV3::P64 + 24] + 16] = Sp;
           _ualV4::I64 = CurrentNursery;
           P64[_ualV4::I64 + 8] = Hp + 8;
           I64[_ualV3::P64 + 104] = I64[_ualV3::P64 + 104] - ((Hp + 8) - I64[_ualV4::I64]);
           (_ualV1::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_salw3::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(_salvN::I64, _salvO::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_salvP::I64)));
           (_ualV2::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ualV1::I64);
           BaseReg = _ualV2::I64;
           _ualV5::P64 = CurrentTSO;
           _ualV6::P64 = I64[_ualV5::P64 + 24];
           Sp = I64[_ualV6::P64 + 16];
           SpLim = _ualV6::P64 + 192;
           HpAlloc = 0;
           _ualV7::I64 = CurrentNursery;
           _ualV8::I64 = I64[_ualV7::I64 + 8];
           Hp = _ualV8::I64 - 8;
           _ualV9::I64 = I64[_ualV7::I64];
           HpLim = _ualV9::I64 + ((%MO_SS_Conv_W32_W64(I32[_ualV7::I64 + 48]) << 12) - 1);
           I64[_ualV5::P64 + 104] = I64[_ualV5::P64 + 104] + (_ualV8::I64 - _ualV9::I64);
           R1 = _salw3::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calUa() //  [R1]
         { info_tbl: [(calUa,
                       label: block_calUa_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calUa: // global
           _salvW::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           if (_salvW::I64 != 0) goto ualUO; else goto calUr;
       ualUO: // global
           I64[Sp + 24] = _salvW::I64;
           Sp = Sp + 24;
           call _calUh() args: 0, res: 0, upd: 0;
       calUr: // global
           I64[Sp + 8] = I64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 24] = I64[Sp + 24] - 2147483647;
           Sp = Sp + 8;
           call _calTU() args: 0, res: 0, upd: 0;
     }
 },
 _calUh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calUh: // global
           Hp = Hp + 16;
           _salvW::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto calUo; else goto calUn;
       calUo: // global
           HpAlloc = 16;
           I64[Sp] = block_calUg_info;
           R1 = _salvW::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       calUn: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _salvW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _calUg() //  [R1]
         { info_tbl: [(calUg,
                       label: block_calUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calUg: // global
           I64[Sp] = R1;
           call _calUh() args: 0, res: 0, upd: 0;
     }
 },
 _calUD() //  [R1]
         { info_tbl: [(calUD,
                       label: block_calUD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calUD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto calUL; else goto calUK;
       calUL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       calUK: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.53463395 UTC

[section ""data" . lvl1_rajBa_closure" {
     lvl1_rajBa_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.536278661 UTC

[section ""cstring" . lvl2_rajBb_bytes" {
     lvl2_rajBb_bytes:
         I8[] [99,95,112,111,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.53853542 UTC

[section ""data" . lvl3_rajBc_closure" {
     lvl3_rajBc_closure:
         const lvl3_rajBc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rajBc_entry() //  [R1]
         { info_tbl: [(calWm,
                       label: lvl3_rajBc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calWm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calWn; else goto calWo;
       calWn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calWo: // global
           (_calWj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_calWj::I64 == 0) goto calWl; else goto calWk;
       calWl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       calWk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _calWj::I64;
           R2 = lvl2_rajBb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.542934316 UTC

[section ""cstring" . lvl4_rajBd_bytes" {
     lvl4_rajBd_bytes:
         I8[] [114,101,119,111,114,107,70,100,58,32,101,118,101,110,116,32,110,111,116,32,102,111,117,110,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.544815993 UTC

[section ""data" . lvl5_rajBe_closure" {
     lvl5_rajBe_closure:
         const lvl5_rajBe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rajBe_entry() //  [R1]
         { info_tbl: [(calWG,
                       label: lvl5_rajBe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calWG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto calWH; else goto calWI;
       calWH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calWI: // global
           (_calWB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_calWB::I64 == 0) goto calWD; else goto calWC;
       calWD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       calWC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _calWB::I64;
           I64[Sp - 24] = block_calWE_info;
           R2 = lvl4_rajBd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _calWE() //  [R1]
         { info_tbl: [(calWE,
                       label: block_calWE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calWE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.55060404 UTC

[section ""data" . lvl6_rajBf_closure" {
     lvl6_rajBf_closure:
         const lvl6_rajBf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rajBf_entry() //  [R1]
         { info_tbl: [(calX4,
                       label: lvl6_rajBf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calX4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calX5; else goto calX6;
       calX5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calX6: // global
           (_calX1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_calX1::I64 == 0) goto calX3; else goto calX2;
       calX3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       calX2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _calX1::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.loop_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.554401257 UTC

[section ""data" . lvl7_rajBg_closure" {
     lvl7_rajBg_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.55604703 UTC

[section ""data" . lvl8_rajBh_closure" {
     lvl8_rajBh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.557962721 UTC

[section ""data" . lvl9_rajBi_closure" {
     lvl9_rajBi_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.559878495 UTC

[section ""data" . lvl10_rajBj_closure" {
     lvl10_rajBj_closure:
         const lvl10_rajBj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rajBj_entry() //  [R1]
         { info_tbl: [(calXo,
                       label: lvl10_rajBj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calXp; else goto calXq;
       calXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calXq: // global
           (_calXl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_calXl::I64 == 0) goto calXn; else goto calXm;
       calXn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       calXm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _calXl::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.removeAt_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.563922261 UTC

[section ""data" . lvl11_rajBk_closure" {
     lvl11_rajBk_closure:
         const lvl11_rajBk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rajBk_entry() //  [R1]
         { info_tbl: [(calXF,
                       label: lvl11_rajBk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calXF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calXG; else goto calXH;
       calXG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calXH: // global
           (_calXC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_calXC::I64 == 0) goto calXE; else goto calXD;
       calXE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       calXD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _calXC::I64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 16;
           call GHC.Event.Array.findIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.574921142 UTC

[section ""data" . GHC.Event.Poll.new5_closure" {
     GHC.Event.Poll.new5_closure:
         const GHC.Event.Poll.new5_info;
         const 0;
 },
 sat_salxj_entry() //  [R1]
         { info_tbl: [(calZs,
                       label: sat_salxj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calZs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto calZt; else goto cam0t;
       calZt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cam0t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _salx8::I64 = I64[R1 + 16];
           if (_salx8::I64 & 25 == 0) goto cam04; else goto calZD;
       cam04: // global
           if (_salx8::I64 & 28 == 0) goto cam0p; else goto cam0j;
       cam0p: // global
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cam0j: // global
           R1 = lvl9_rajBi_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       calZD: // global
           if (_salx8::I64 & 28 == 0) goto calZY; else goto calZS;
       calZY: // global
           R1 = lvl8_rajBh_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       calZS: // global
           R1 = lvl7_rajBg_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 i'_salxn_entry() //  [R1]
         { info_tbl: [(cam0E,
                       label: i'_salxn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam0E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cam0O; else goto cam0P;
       cam0O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cam0P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cam0B_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uam0T; else goto cam0C;
       uam0T: // global
           call _cam0B(R1) args: 0, res: 0, upd: 0;
       cam0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cam0B() //  [R1]
         { info_tbl: [(cam0B,
                       label: block_cam0B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam0B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cam0S; else goto cam0R;
       cam0S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cam0R: // global
           _salxr::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7] + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _salxr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_salxv_entry() //  [R1]
         { info_tbl: [(cam11,
                       label: sat_salxv_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam11: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cam12; else goto cam13;
       cam12: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cam13: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cam0Y_info;
           _salx0::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _salx0::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uam18; else goto cam0Z;
       uam18: // global
           call _cam0Y(R1) args: 0, res: 0, upd: 0;
       cam0Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cam0Y() //  [R1]
         { info_tbl: [(cam0Y,
                       label: block_cam0Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam0Y: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_salxy_entry() //  [R1, R2, R3]
         { info_tbl: [(cam19,
                       label: sat_salxy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam19: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cam1a; else goto cam1b;
       cam1a: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cam1b: // global
           I64[Sp - 32] = block_calZf_info;
           _salw9::P64 = P64[R1 + 5];
           _salx0::I64 = I64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _salw9::P64;
           I64[Sp - 16] = _salx0::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uam1o; else goto calZg;
       uam1o: // global
           call _calZf(R1) args: 0, res: 0, upd: 0;
       calZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calZf() //  [R1]
         { info_tbl: [(calZf,
                       label: block_calZf_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calZf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cam1e; else goto cam1d;
       cam1e: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam1d: // global
           _salx8::I64 = I64[R1 + 23];
           if (_salx8::I64 != 0) goto cam1h; else goto cam1n;
       cam1h: // global
           _salx5::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_salxj_info;
           I64[Hp - 16] = _salx8::I64;
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _salx5::I64;
           _salw9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cam0v_info;
           R3 = Hp - 32;
           R2 = Hp - 7;
           R1 = _salw9::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cam1n: // global
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = GHC.Types.True_closure+2;
           _cam1m::P64 = Hp - 31;
           Hp = Hp - 16;
           R1 = _cam1m::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cam0v() //  [R1]
         { info_tbl: [(cam0v,
                       label: block_cam0v_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam0v: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cam1k; else goto cam1j;
       cam1k: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam1j: // global
           I64[Hp - 72] = i'_salxn_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = sat_salxv_info;
           _cam0x::P64 = Hp - 72;
           P64[Hp - 32] = _cam0x::P64;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _cam0x::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_salyD_entry() //  [R1, R2]
         { info_tbl: [(cam1Q,
                       label: sat_salyD_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam1Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cam1R; else goto cam1S;
       cam1R: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cam1S: // global
           I64[Sp - 16] = block_cam1N_info;
           _salyn::I64 = I64[R1 + 7];
           R1 = R2;
           I64[Sp - 8] = _salyn::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uam1X; else goto cam1O;
       uam1X: // global
           call _cam1N(R1) args: 0, res: 0, upd: 0;
       cam1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam1N() //  [R1]
         { info_tbl: [(cam1N,
                       label: block_cam1N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam1N: // global
           R1 = I64[((I64[R1 + 7] == I64[Sp + 8]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_salzA_entry() //  [R1]
         { info_tbl: [(cam2b,
                       label: sat_salzA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam2b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cam2c; else goto cam2d;
       cam2c: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cam2d: // global
           I64[Sp - 24] = block_cam26_info;
           _salwj::P64 = P64[R1 + 7];
           _salwl::P64 = P64[R1 + 15];
           R1 = _salwl::P64;
           P64[Sp - 16] = _salwj::P64;
           P64[Sp - 8] = _salwl::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam26() //  [R1]
         { info_tbl: [(cam26,
                       label: block_cam26_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam26: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cam2g; else goto cam2f;
       cam2g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam2f: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_cam29_info;
           R2 = Hp - 7;
           _salzx::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _salzx::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam29() //  []
         { info_tbl: [(cam29,
                       label: block_cam29_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam29: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new5_entry() //  [R2, R3, R4]
         { info_tbl: [(cam2i,
                       label: GHC.Event.Poll.new5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam2i: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cam2j; else goto cam2k;
       cam2j: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cam2k: // global
           I64[Sp - 32] = block_calXU_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calXU() //  [R1]
         { info_tbl: [(calXU,
                       label: block_calXU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calXU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cam2n; else goto cam2m;
       cam2n: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam2m: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_calXZ_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calXZ() //  [R1]
         { info_tbl: [(calXZ,
                       label: block_calXZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calXZ: // global
           I64[Sp] = block_calY1_info;
           _salwj::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _salwj::P64;
           if (R1 & 7 != 0) goto uam6o; else goto calY2;
       uam6o: // global
           call _calY1(R1) args: 0, res: 0, upd: 0;
       calY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calY1() //  [R1]
         { info_tbl: [(calY1,
                       label: block_calY1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calY1: // global
           I64[Sp - 16] = block_calY6_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _calY6() //  [R1]
         { info_tbl: [(calY6,
                       label: block_calY6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calY6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cam2s; else goto cam2r;
       cam2s: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cam2r: // global
           _salwl::P64 = P64[Sp + 16];
           if (R1 == 0) goto cam5J; else goto cam5w;
       cam5J: // global
           I64[Hp - 16] = sat_salzA_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _salwl::P64;
           I64[Sp] = block_cam5G_info;
           R1 = Hp - 15;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       cam5w: // global
           Hp = Hp - 24;
           I64[Sp] = block_cam5p_info;
           R1 = _salwl::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam5G() //  [R1]
         { info_tbl: [(cam5G,
                       label: block_cam5G_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5G: // global
           I64[Sp] = block_cam5I_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uam6O; else goto cam5L;
       uam6O: // global
           call _cam5I(R1) args: 0, res: 0, upd: 0;
       cam5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam5I() //  [R1]
         { info_tbl: [(cam5I,
                       label: block_cam5I_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5I: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _salwq() args: 0, res: 0, upd: 0;
     }
 },
 _cam5p() //  [R1]
         { info_tbl: [(cam5p,
                       label: block_cam5p_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cam5z; else goto cam5y;
       cam5z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam5y: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cam5s_info;
           R2 = Hp - 7;
           _salzp::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 24] = _salzp::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam5s() //  []
         { info_tbl: [(cam5s,
                       label: block_cam5s_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5s: // global
           I64[Sp] = block_cam5u_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto uam6M; else goto cam5B;
       uam6M: // global
           call _cam5u(R1) args: 0, res: 0, upd: 0;
       cam5B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam5u() //  [R1]
         { info_tbl: [(cam5u,
                       label: block_cam5u_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5u: // global
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call _salwq() args: 0, res: 0, upd: 0;
     }
 },
 _salwq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       salwq: // global
           _salwv::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_calYd_info;
           R1 = _salwv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uam6Q; else goto calYe;
       uam6Q: // global
           call _calYd(R1) args: 0, res: 0, upd: 0;
       calYe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calYd() //  [R1]
         { info_tbl: [(calYd,
                       label: block_calYd_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calYd: // global
           I64[Sp] = block_calYi_info;
           _salwy::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp + 24] = _salwy::I64;
           if (R1 & 7 != 0) goto uam6p; else goto calYj;
       uam6p: // global
           call _calYi(R1) args: 0, res: 0, upd: 0;
       calYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calYi() //  [R1]
         { info_tbl: [(calYi,
                       label: block_calYi_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calYi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cam2x; else goto cam2w;
       cam2x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam2w: // global
           _salwC::P64 = P64[R1 + 7];
           _salwB::I64 = I64[R1 + 15];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 16] = I64[Sp + 24] << 3;
           I64[Sp - 8] = 0;
           P64[Sp] = _salwC::P64;
           I64[Sp + 16] = _salwB::I64;
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 16;
           call _cam1s() args: 0, res: 0, upd: 0;
     }
 },
 _cam1s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam1s: // global
           Hp = Hp + 32;
           _salyh::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cam4g; else goto cam4f;
       cam4g: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cam1r_info;
           R1 = _salyh::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cam4f: // global
           _salwm::P64 = P64[Sp + 24];
           if (%MO_S_Lt_W64(_salyh::I64,
                            I64[Sp])) goto cam5n; else goto cam5o;
       cam5n: // global
           _salyk::I64 = I64[Sp + 32] + _salyh::I64;
           _salyn::I64 = %MO_SS_Conv_W32_W64(I32[_salyk::I64]);
           _salyr::I64 = %MO_SS_Conv_W16_W64(I16[_salyk::I64 + 4]);
           if (I16[_salyk::I64 + 6] == 0 :: W16) goto cam5j; else goto cam4l;
       cam5j: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = _salyn::I64;
           I64[Hp - 8] = _salyr::I64;
           I64[Hp] = 0;
           I64[Sp - 8] = block_cam5i_info;
           R4 = Hp - 23;
           R3 = _salwm::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp - 8;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
       cam4l: // global
           I64[Hp - 24] = sat_salyD_info;
           I64[Hp - 16] = _salyn::I64;
           _cam1I::P64 = Hp - 23;
           Hp = Hp - 16;
           I64[Sp - 24] = block_cam4h_info;
           R3 = P64[Sp + 40];
           R2 = _cam1I::P64;
           R1 = lvl11_rajBk_closure;
           I64[Sp - 16] = _salyn::I64;
           I64[Sp - 8] = _salyr::I64;
           Sp = Sp - 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cam5o: // global
           Hp = Hp - 32;
           call MO_Touch(P64[Sp + 16]);
           I64[Sp + 32] = block_calYx_info;
           R1 = P64[_salwm::P64 + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto uam6x; else goto calYy;
       uam6x: // global
           call _calYx(R1) args: 0, res: 0, upd: 0;
       calYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam1r() //  [R1]
         { info_tbl: [(cam1r,
                       label: block_cam1r_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam1r: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cam1s() args: 0, res: 0, upd: 0;
     }
 },
 _cam5i() //  []
         { info_tbl: [(cam5i,
                       label: block_cam5i_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5i: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cam1s() args: 0, res: 0, upd: 0;
     }
 },
 _cam4h() //  [R1]
         { info_tbl: [(cam4h,
                       label: block_cam4h_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam4h: // global
           I64[Sp] = block_cam4j_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uam6E; else goto cam4n;
       uam6E: // global
           call _cam4j(R1) args: 0, res: 0, upd: 0;
       cam4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam4j() //  [R1]
         { info_tbl: [(cam4j,
                       label: block_cam4j_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam4j: // global
           if (R1 & 7 == 1) goto cam4t; else goto cam4y;
       cam4t: // global
           R1 = lvl5_rajBe_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cam4y: // global
           I64[Sp] = block_cam4w_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uam6F; else goto cam4z;
       uam6F: // global
           call _cam4w(R1) args: 0, res: 0, upd: 0;
       cam4z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam4w() //  [R1]
         { info_tbl: [(cam4w,
                       label: block_cam4w_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam4w: // global
           _salyL::P64 = P64[R1 + 7];
           _salyN::I64 = I64[Sp + 16];
           if (_salyN::I64 != 0) goto cam4S; else goto cam5d;
       cam4S: // global
           _salyQ::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp - 8] = block_cam4G_info;
           R1 = _salyQ::P64;
           I64[Sp] = _salyN::I64;
           P64[Sp + 16] = _salyL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uam6G; else goto cam4H;
       uam6G: // global
           call _cam4G(R1) args: 0, res: 0, upd: 0;
       cam4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cam5d: // global
           I64[Sp + 16] = block_cam5c_info;
           R3 = _salyL::P64;
           R2 = P64[Sp + 64];
           R1 = lvl10_rajBj_closure;
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam4G() //  [R1]
         { info_tbl: [(cam4G,
                       label: block_cam4G_info
                       rep:StackRep [True, True, False, True, True, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam4G: // global
           I64[Sp - 8] = block_cam4L_info;
           _salyU::I64 = I64[R1 + 23];
           R1 = P64[R1 + 7];
           I64[Sp] = _salyU::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uam6H; else goto cam4M;
       uam6H: // global
           call _cam4L(R1) args: 0, res: 0, upd: 0;
       cam4M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam4L() //  [R1]
         { info_tbl: [(cam4L,
                       label: block_cam4L_info
                       rep:StackRep [True, True, True, False, True, True, False, False,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam4L: // global
           I64[Sp - 8] = block_cam4Q_info;
           _salyX::P64 = P64[R1 + 7];
           _salyW::I64 = I64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _salyX::P64;
           I64[Sp + 32] = _salyW::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uam6I; else goto cam4V;
       uam6I: // global
           call _cam4Q(R1) args: 0, res: 0, upd: 0;
       cam4V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam4Q() //  [R1]
         { info_tbl: [(cam4Q,
                       label: block_cam4Q_info
                       rep:StackRep [False, True, True, True, True, True, True, False,
                                     False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam4Q: // global
           _salyU::I64 = I64[Sp + 16];
           _salyZ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_salyZ::I64, 0)) goto cam5a; else goto cam59;
       cam59: // global
           if (%MO_S_Ge_W64(_salyZ::I64,
                            _salyU::I64)) goto cam5a; else goto cam56;
       cam5a: // global
           R3 = _salyZ::I64;
           R2 = _salyU::I64;
           Sp = Sp + 112;
           call GHC.Event.Array.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
       cam56: // global
           _salyh::I64 = I64[Sp + 56];
           _salyN::I64 = I64[Sp + 24];
           _salyX::P64 = P64[Sp + 8];
           _salz2::I64 = I64[Sp + 40] + (_salyZ::I64 << 3);
           I32[_salz2::I64] = %MO_UU_Conv_W64_W32(I64[Sp + 32]);
           I16[_salz2::I64 + 4] = %MO_UU_Conv_W64_W16(_salyN::I64);
           I16[_salz2::I64 + 6] = 0 :: W16;
           call MO_Touch(_salyX::P64);
           I64[Sp + 56] = _salyh::I64 + 8;
           Sp = Sp + 48;
           call _cam1s() args: 0, res: 0, upd: 0;
     }
 },
 _cam5c() //  []
         { info_tbl: [(cam5c,
                       label: block_cam5c_info
                       rep:StackRep [True, True, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam5c: // global
           I64[Sp + 16] = I64[Sp + 16] + 8;
           Sp = Sp + 8;
           call _cam1s() args: 0, res: 0, upd: 0;
     }
 },
 _calYx() //  [R1]
         { info_tbl: [(calYx,
                       label: block_calYx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calYx: // global
           I64[Sp - 8] = block_calYC_info;
           _salwN::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp] = _salwN::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uam6r; else goto calYD;
       uam6r: // global
           call _calYC(R1) args: 0, res: 0, upd: 0;
       calYD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calYC() //  [R1]
         { info_tbl: [(calYC,
                       label: block_calYC_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calYC: // global
           I64[Sp - 8] = block_calYJ_info;
           _salwR::P64 = P64[R1 + 7];
           _salwQ::I64 = I64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _salwR::P64;
           I64[Sp + 24] = _salwQ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uam6s; else goto calYK;
       uam6s: // global
           call _calYJ(R1) args: 0, res: 0, upd: 0;
       calYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calYJ() //  [R1]
         { info_tbl: [(calYJ,
                       label: block_calYJ_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calYJ: // global
           if (R1 & 7 == 1) goto cam3k; else goto cam3s;
       cam3k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cam3n; else goto cam3m;
       cam3n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam3m: // global
           (_salxT::I64) = call "ccall" arg hints:  [PtrHint, ,
                                                     ‘signed’]  result hints:  [‘signed’] poll(I64[Sp + 32], I64[Sp + 16], 0);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _salxU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_salxT::I64));
           I64[Hp] = _salxU::I64;
           I64[Sp + 32] = _salxU::I64;
           Sp = Sp + 8;
           call _salwS() args: 0, res: 0, upd: 0;
       cam3s: // global
           I64[Sp] = block_cam3q_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uam6t; else goto cam3t;
       uam6t: // global
           call _cam3q(R1) args: 0, res: 0, upd: 0;
       cam3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam3q() //  [R1]
         { info_tbl: [(cam3q,
                       label: block_cam3q_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam3q: // global
           _salwN::I64 = I64[Sp + 16];
           _salwQ::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cam3R; else goto cam47;
       cam3R: // global
           I64[Sp] = block_cam3M_info;
           R4 = (I64[R1 + 7] + 999999) / 1000000;
           R3 = _salwN::I64;
           R2 = _salwQ::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
       cam47: // global
           I64[Sp] = block_cam43_info;
           R4 = (-1);
           R3 = _salwN::I64;
           R2 = _salwQ::I64;
           call $wc_pollLoop_rajB9_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cam3M() //  [R1]
         { info_tbl: [(cam3M,
                       label: block_cam3M_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam3M: // global
           I64[Sp] = block_cam3O_info;
           _saly7::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _saly7::P64;
           if (R1 & 7 != 0) goto uam6A; else goto cam3T;
       uam6A: // global
           call _cam3O(R1) args: 0, res: 0, upd: 0;
       cam3T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam3O() //  [R1]
         { info_tbl: [(cam3O,
                       label: block_cam3O_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam3O: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _salwS() args: 0, res: 0, upd: 0;
     }
 },
 _cam43() //  [R1]
         { info_tbl: [(cam43,
                       label: block_cam43_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam43: // global
           I64[Sp] = block_cam45_info;
           _salyd::P64 = R1;
           R1 = R1;
           P64[Sp + 32] = _salyd::P64;
           if (R1 & 7 != 0) goto uam6C; else goto cam49;
       uam6C: // global
           call _cam45(R1) args: 0, res: 0, upd: 0;
       cam49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam45() //  [R1]
         { info_tbl: [(cam45,
                       label: block_cam45_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam45: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _salwS() args: 0, res: 0, upd: 0;
     }
 },
 _salwS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       salwS: // global
           _salxD::I64 = I64[Sp + 24];
           if (_salxD::I64 != (-1)) goto cam2Q; else goto cam3i;
       cam2Q: // global
           I64[Sp + 24] = _salxD::I64;
           goto uam6S;
       cam3i: // global
           (_salxH::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           if (%MO_SS_Conv_W64_W32(_salxH::I64) == 4 :: W32) goto cam3e; else goto cam34;
       cam3e: // global
           I64[Sp + 24] = 0;
           goto uam6S;
       uam6S: // global
           call _calZ5() args: 0, res: 0, upd: 0;
       cam34: // global
           I64[Sp - 8] = block_cam30_info;
           R2 = lvl3_rajBc_closure;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrno1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cam30() //  [R1]
         { info_tbl: [(cam30,
                       label: block_cam30_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam30: // global
           I64[Sp] = block_cam32_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uam6y; else goto cam37;
       uam6y: // global
           call _cam32(R1) args: 0, res: 0, upd: 0;
       cam37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam32() //  [R1]
         { info_tbl: [(cam32,
                       label: block_cam32_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam32: // global
           I64[Sp + 32] = I64[R1 + 7];
           Sp = Sp + 8;
           call _calZ5() args: 0, res: 0, upd: 0;
     }
 },
 _calZ5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calZ5: // global
           Hp = Hp + 24;
           _salwY::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cam2E; else goto cam2D;
       cam2E: // global
           HpAlloc = 24;
           I64[Sp - 8] = block_calZ4_info;
           R1 = _salwY::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cam2D: // global
           _calYn::P64 = P64[Sp + 16];
           _salw9::P64 = P64[Sp + 32];
           call MO_Touch(P64[Sp]);
           if (_salwY::I64 == 0) goto cam2N; else goto cam2J;
       cam2N: // global
           Hp = Hp - 24;
           R1 = GHC.Event.Poll.$fShowPollFd7_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cam2J: // global
           I64[Hp - 16] = sat_salxy_info;
           P64[Hp - 8] = _salw9::P64;
           I64[Hp] = _salwY::I64;
           I64[Sp + 24] = block_cam2F_info;
           R4 = Hp - 13;
           R3 = lvl1_rajBa_closure+1;
           R2 = _calYn::P64;
           R1 = lvl6_rajBf_closure;
           I64[Sp + 32] = _salwY::I64;
           Sp = Sp + 24;
           call stg_ap_pppv_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _calZ4() //  [R1]
         { info_tbl: [(calZ4,
                       label: block_calZ4_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calZ4: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _calZ5() args: 0, res: 0, upd: 0;
     }
 },
 _cam2F() //  [R1]
         { info_tbl: [(cam2F,
                       label: block_cam2F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam2F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cam2M; else goto cam2L;
       cam2M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cam2L: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.677338767 UTC

[section ""data" . GHC.Event.Poll.new4_closure" {
     GHC.Event.Poll.new4_closure:
         const GHC.Event.Poll.new4_info;
         const 0;
 },
 sat_salAj_entry() //  [R1]
         { info_tbl: [(camc6,
                       label: sat_salAj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camc6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto camca; else goto camcb;
       camca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       camcb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_camc3_info;
           _salzI::P64 = P64[R1 + 24];
           _salzJ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _salzI::P64;
           P64[Sp - 24] = _salzJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uamhC; else goto camc4;
       uamhC: // global
           call _camc3(R1) args: 0, res: 0, upd: 0;
       camc4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _camc3() //  [R1]
         { info_tbl: [(camc3,
                       label: block_camc3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camc3: // global
           I64[Sp] = block_camc9_info;
           _salzT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _salzT::I64;
           if (R1 & 7 != 0) goto uamhB; else goto camcd;
       uamhB: // global
           call _camc9(R1) args: 0, res: 0, upd: 0;
       camcd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _camc9() //  [R1]
         { info_tbl: [(camc9,
                       label: block_camc9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camc9: // global
           _salzI::P64 = P64[Sp + 8];
           _salzV::I64 = I64[R1 + 7];
           if (_salzV::I64 & 1 == 0) goto cameK; else goto camcn;
       cameK: // global
           if (_salzV::I64 & 2 == 0) goto camg3; else goto cameW;
       camg3: // global
           I64[Sp + 8] = block_camg2_info;
           R1 = _salzI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uamhG; else goto camg5;
       uamhG: // global
           call _camg2(R1) args: 0, res: 0, upd: 0;
       camg5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cameW: // global
           I64[Sp + 8] = block_cameU_info;
           R1 = _salzI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uamhF; else goto cameY;
       uamhF: // global
           call _cameU(R1) args: 0, res: 0, upd: 0;
       cameY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       camcn: // global
           if (_salzV::I64 & 2 == 0) goto camdG; else goto camcz;
       camdG: // global
           I64[Sp + 8] = block_camdF_info;
           R1 = _salzI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uamhE; else goto camdI;
       uamhE: // global
           call _camdF(R1) args: 0, res: 0, upd: 0;
       camdI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       camcz: // global
           I64[Sp + 8] = block_camcx_info;
           R1 = _salzI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uamhD; else goto camcB;
       uamhD: // global
           call _camcx(R1) args: 0, res: 0, upd: 0;
       camcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _camg2() //  [R1]
         { info_tbl: [(camg2,
                       label: block_camg2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camg2: // global
           _salAf::I64 = I64[R1 + 7];
           if (_salAf::I64 & 1 == 0) goto camgG; else goto camgf;
       camgG: // global
           _salAi::I64 = _salAf::I64 & 2;
           if (_salAi::I64 != 0) goto uamhy; else goto uamhx;
       uamhy: // global
           I64[Sp] = _salAi::I64;
           call _camgO() args: 0, res: 0, upd: 0;
       uamhx: // global
           I64[Sp] = _salAi::I64;
           call _camgY() args: 0, res: 0, upd: 0;
       camgf: // global
           _salAh::I64 = _salAf::I64 & 2;
           if (_salAh::I64 != 0) goto uamhu; else goto uamht;
       uamhu: // global
           I64[Sp] = _salAh::I64;
           call _camgn() args: 0, res: 0, upd: 0;
       uamht: // global
           I64[Sp] = _salAh::I64;
           call _camgx() args: 0, res: 0, upd: 0;
     }
 },
 _camgO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camgV; else goto camgU;
       camgV: // global
           HpAlloc = 32;
           _salAi::I64 = I64[Sp];
           I64[Sp] = block_camgN_info;
           R1 = _salAi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camgU: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camgN() //  [R1]
         { info_tbl: [(camgN,
                       label: block_camgN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgN: // global
           I64[Sp] = R1;
           call _camgO() args: 0, res: 0, upd: 0;
     }
 },
 _camgY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camh4; else goto camh3;
       camh4: // global
           HpAlloc = 32;
           _salAi::I64 = I64[Sp];
           I64[Sp] = block_camgX_info;
           R1 = _salAi::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camh3: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camgX() //  [R1]
         { info_tbl: [(camgX,
                       label: block_camgX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgX: // global
           I64[Sp] = R1;
           call _camgY() args: 0, res: 0, upd: 0;
     }
 },
 _camgn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camgu; else goto camgt;
       camgu: // global
           HpAlloc = 32;
           _salAh::I64 = I64[Sp];
           I64[Sp] = block_camgm_info;
           R1 = _salAh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camgt: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camgm() //  [R1]
         { info_tbl: [(camgm,
                       label: block_camgm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgm: // global
           I64[Sp] = R1;
           call _camgn() args: 0, res: 0, upd: 0;
     }
 },
 _camgx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camgD; else goto camgC;
       camgD: // global
           HpAlloc = 32;
           _salAh::I64 = I64[Sp];
           I64[Sp] = block_camgw_info;
           R1 = _salAh::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camgC: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camgw() //  [R1]
         { info_tbl: [(camgw,
                       label: block_camgw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camgw: // global
           I64[Sp] = R1;
           call _camgx() args: 0, res: 0, upd: 0;
     }
 },
 _cameU() //  [R1]
         { info_tbl: [(cameU,
                       label: block_cameU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cameU: // global
           _salAa::I64 = I64[R1 + 7];
           if (_salAa::I64 & 1 == 0) goto camfz; else goto camf8;
       camfz: // global
           _salAd::I64 = _salAa::I64 & 2;
           if (_salAd::I64 != 0) goto uamhq; else goto uamhp;
       uamhq: // global
           I64[Sp] = _salAd::I64;
           call _camfH() args: 0, res: 0, upd: 0;
       uamhp: // global
           I64[Sp] = _salAd::I64;
           call _camfR() args: 0, res: 0, upd: 0;
       camf8: // global
           _salAc::I64 = _salAa::I64 & 2;
           if (_salAc::I64 != 0) goto uamhm; else goto uamhl;
       uamhm: // global
           I64[Sp] = _salAc::I64;
           call _camfg() args: 0, res: 0, upd: 0;
       uamhl: // global
           I64[Sp] = _salAc::I64;
           call _camfq() args: 0, res: 0, upd: 0;
     }
 },
 _camfH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camfO; else goto camfN;
       camfO: // global
           HpAlloc = 32;
           _salAd::I64 = I64[Sp];
           I64[Sp] = block_camfG_info;
           R1 = _salAd::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camfN: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camfG() //  [R1]
         { info_tbl: [(camfG,
                       label: block_camfG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfG: // global
           I64[Sp] = R1;
           call _camfH() args: 0, res: 0, upd: 0;
     }
 },
 _camfR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camfX; else goto camfW;
       camfX: // global
           HpAlloc = 32;
           _salAd::I64 = I64[Sp];
           I64[Sp] = block_camfQ_info;
           R1 = _salAd::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camfW: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camfQ() //  [R1]
         { info_tbl: [(camfQ,
                       label: block_camfQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfQ: // global
           I64[Sp] = R1;
           call _camfR() args: 0, res: 0, upd: 0;
     }
 },
 _camfg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camfn; else goto camfm;
       camfn: // global
           HpAlloc = 32;
           _salAc::I64 = I64[Sp];
           I64[Sp] = block_camff_info;
           R1 = _salAc::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camfm: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camff() //  [R1]
         { info_tbl: [(camff,
                       label: block_camff_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camff: // global
           I64[Sp] = R1;
           call _camfg() args: 0, res: 0, upd: 0;
     }
 },
 _camfq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camfw; else goto camfv;
       camfw: // global
           HpAlloc = 32;
           _salAc::I64 = I64[Sp];
           I64[Sp] = block_camfp_info;
           R1 = _salAc::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camfv: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 4;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camfp() //  [R1]
         { info_tbl: [(camfp,
                       label: block_camfp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camfp: // global
           I64[Sp] = R1;
           call _camfq() args: 0, res: 0, upd: 0;
     }
 },
 _camdF() //  [R1]
         { info_tbl: [(camdF,
                       label: block_camdF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camdF: // global
           _salA4::I64 = I64[R1 + 7];
           if (_salA4::I64 & 1 == 0) goto camej; else goto camdS;
       camej: // global
           _salA7::I64 = _salA4::I64 & 2;
           if (_salA7::I64 != 0) goto uamhi; else goto uamhh;
       uamhi: // global
           I64[Sp] = _salA7::I64;
           call _camer() args: 0, res: 0, upd: 0;
       uamhh: // global
           I64[Sp] = _salA7::I64;
           call _cameB() args: 0, res: 0, upd: 0;
       camdS: // global
           _salA6::I64 = _salA4::I64 & 2;
           if (_salA6::I64 != 0) goto uamhe; else goto uamhd;
       uamhe: // global
           I64[Sp] = _salA6::I64;
           call _came0() args: 0, res: 0, upd: 0;
       uamhd: // global
           I64[Sp] = _salA6::I64;
           call _camea() args: 0, res: 0, upd: 0;
     }
 },
 _camer() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camer: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camey; else goto camex;
       camey: // global
           HpAlloc = 32;
           _salA7::I64 = I64[Sp];
           I64[Sp] = block_cameq_info;
           R1 = _salA7::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camex: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cameq() //  [R1]
         { info_tbl: [(cameq,
                       label: block_cameq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cameq: // global
           I64[Sp] = R1;
           call _camer() args: 0, res: 0, upd: 0;
     }
 },
 _cameB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cameB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cameH; else goto cameG;
       cameH: // global
           HpAlloc = 32;
           _salA7::I64 = I64[Sp];
           I64[Sp] = block_cameA_info;
           R1 = _salA7::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cameG: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cameA() //  [R1]
         { info_tbl: [(cameA,
                       label: block_cameA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cameA: // global
           I64[Sp] = R1;
           call _cameB() args: 0, res: 0, upd: 0;
     }
 },
 _came0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       came0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto came7; else goto came6;
       came7: // global
           HpAlloc = 32;
           _salA6::I64 = I64[Sp];
           I64[Sp] = block_camdZ_info;
           R1 = _salA6::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       came6: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camdZ() //  [R1]
         { info_tbl: [(camdZ,
                       label: block_camdZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camdZ: // global
           I64[Sp] = R1;
           call _came0() args: 0, res: 0, upd: 0;
     }
 },
 _camea() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camea: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cameg; else goto camef;
       cameg: // global
           HpAlloc = 32;
           _salA6::I64 = I64[Sp];
           I64[Sp] = block_came9_info;
           R1 = _salA6::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camef: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 1;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _came9() //  [R1]
         { info_tbl: [(came9,
                       label: block_came9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       came9: // global
           I64[Sp] = R1;
           call _camea() args: 0, res: 0, upd: 0;
     }
 },
 _camcx() //  [R1]
         { info_tbl: [(camcx,
                       label: block_camcx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camcx: // global
           _salzZ::I64 = I64[R1 + 7];
           if (_salzZ::I64 & 1 == 0) goto camdc; else goto camcL;
       camdc: // global
           _salA2::I64 = _salzZ::I64 & 2;
           if (_salA2::I64 != 0) goto uamha; else goto uamh9;
       uamha: // global
           I64[Sp] = _salA2::I64;
           call _camdk() args: 0, res: 0, upd: 0;
       uamh9: // global
           I64[Sp] = _salA2::I64;
           call _camdu() args: 0, res: 0, upd: 0;
       camcL: // global
           _salA1::I64 = _salzZ::I64 & 2;
           if (_salA1::I64 != 0) goto uamh6; else goto uamh5;
       uamh6: // global
           I64[Sp] = _salA1::I64;
           call _camcT() args: 0, res: 0, upd: 0;
       uamh5: // global
           I64[Sp] = _salA1::I64;
           call _camd3() args: 0, res: 0, upd: 0;
     }
 },
 _camdk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camdk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camdr; else goto camdq;
       camdr: // global
           HpAlloc = 32;
           _salA2::I64 = I64[Sp];
           I64[Sp] = block_camdj_info;
           R1 = _salA2::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camdq: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 4;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camdj() //  [R1]
         { info_tbl: [(camdj,
                       label: block_camdj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camdj: // global
           I64[Sp] = R1;
           call _camdk() args: 0, res: 0, upd: 0;
     }
 },
 _camdu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camdu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camdA; else goto camdz;
       camdA: // global
           HpAlloc = 32;
           _salA2::I64 = I64[Sp];
           I64[Sp] = block_camdt_info;
           R1 = _salA2::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camdz: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 0;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camdt() //  [R1]
         { info_tbl: [(camdt,
                       label: block_camdt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camdt: // global
           I64[Sp] = R1;
           call _camdu() args: 0, res: 0, upd: 0;
     }
 },
 _camcT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camcT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camd0; else goto camcZ;
       camd0: // global
           HpAlloc = 32;
           _salA1::I64 = I64[Sp];
           I64[Sp] = block_camcS_info;
           R1 = _salA1::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camcZ: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 5;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camcS() //  [R1]
         { info_tbl: [(camcS,
                       label: block_camcS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camcS: // global
           I64[Sp] = R1;
           call _camcT() args: 0, res: 0, upd: 0;
     }
 },
 _camd3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camd3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camd9; else goto camd8;
       camd9: // global
           HpAlloc = 32;
           _salA1::I64 = I64[Sp];
           I64[Sp] = block_camd2_info;
           R1 = _salA1::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       camd8: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = I64[Sp + 8];
           I64[Hp - 8] = 5;
           I64[Hp] = 1;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _camd2() //  [R1]
         { info_tbl: [(camd2,
                       label: block_camd2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camd2: // global
           I64[Sp] = R1;
           call _camd3() args: 0, res: 0, upd: 0;
     }
 },
 sat_salAn_entry() //  [R1, R2]
         { info_tbl: [(camid,
                       label: sat_salAn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camid: // global
           if ((Sp + -32) < SpLim) (likely: False) goto camif; else goto camig;
       camif: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       camig: // global
           I64[Sp - 32] = block_cambU_info;
           _salzH::P64 = P64[R1 + 6];
           _salzI::P64 = P64[R1 + 14];
           _salzJ::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _salzH::P64;
           P64[Sp - 16] = _salzI::P64;
           P64[Sp - 8] = _salzJ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uamim; else goto cambV;
       uamim: // global
           call _cambU(R1) args: 0, res: 0, upd: 0;
       cambV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cambU() //  [R1]
         { info_tbl: [(cambU,
                       label: block_cambU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cambU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto camij; else goto camii;
       camij: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       camii: // global
           _salzR::P64 = P64[R1 + 7];
           I64[Hp - 32] = sat_salAj_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_camie_info;
           R4 = Hp - 32;
           R3 = _salzR::P64;
           R2 = GHC.Event.Poll.$fStorablePollFd_closure+1;
           Sp = Sp + 24;
           call GHC.Event.Array.$wsnoc_entry(R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _camie() //  []
         { info_tbl: [(camie,
                       label: block_camie_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camie: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Event.Poll.new4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(camin,
                       label: GHC.Event.Poll.new4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camin: // global
           if ((Sp + -32) < SpLim) (likely: False) goto camio; else goto camip;
       camio: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.new4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       camip: // global
           I64[Sp - 32] = block_cambK_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uamit; else goto cambL;
       uamit: // global
           call _cambK(R1) args: 0, res: 0, upd: 0;
       cambL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cambK() //  [R1]
         { info_tbl: [(cambK,
                       label: block_cambK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cambK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camis; else goto camir;
       camis: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       camir: // global
           _salzM::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_salAn_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R3 = Hp - 22;
           R2 = _salzM::P64;
           Sp = Sp + 32;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.748219266 UTC

[section ""data" . GHC.Event.Poll.new2_closure" {
     GHC.Event.Poll.new2_closure:
         const GHC.Event.Poll.new2_info;
 },
 GHC.Event.Poll.new2_entry() //  []
         { info_tbl: [(camm6,
                       label: GHC.Event.Poll.new2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camm6: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.752732547 UTC

[section ""data" . GHC.Event.Poll.new1_closure" {
     GHC.Event.Poll.new1_closure:
         const GHC.Event.Poll.new1_info;
         const 0;
 },
 GHC.Event.Poll.new1_entry() //  []
         { info_tbl: [(cammE,
                       label: GHC.Event.Poll.new1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cammF; else goto cammG;
       cammF: // global
           R1 = GHC.Event.Poll.new1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cammG: // global
           I64[Sp - 8] = block_cammj_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cammj() //  [R1]
         { info_tbl: [(cammj,
                       label: block_cammj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cammJ; else goto cammI;
       cammJ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cammI: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cammo_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cammo() //  [R1]
         { info_tbl: [(cammo,
                       label: block_cammo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammo: // global
           I64[Sp - 8] = block_cammq_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cammq() //  [R1]
         { info_tbl: [(cammq,
                       label: block_cammq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cammN; else goto cammM;
       cammN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cammM: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cammt_info;
           R2 = Hp - 7;
           _salAC::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _salAC::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cammt() //  []
         { info_tbl: [(cammt,
                       label: block_cammt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammt: // global
           I64[Sp] = block_cammv_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cammv() //  [R1]
         { info_tbl: [(cammv,
                       label: block_cammv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cammR; else goto cammQ;
       cammR: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cammQ: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = GHC.Event.Array.AC_con_info;
           P64[Hp - 16] = Hp - 47;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp] = block_cammA_info;
           R1 = Hp - 23;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cammA() //  [R1]
         { info_tbl: [(cammA,
                       label: block_cammA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cammA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cammU; else goto cammT;
       cammU: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cammT: // global
           I64[Hp - 64] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.Event.Internal.Backend_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = GHC.Event.Poll.new5_closure+4;
           P64[Hp - 16] = GHC.Event.Poll.new4_closure+5;
           P64[Hp - 8] = GHC.Event.Poll.new3_closure;
           P64[Hp] = GHC.Event.Poll.new2_closure+2;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.772247779 UTC

[section ""data" . GHC.Event.Poll.new_closure" {
     GHC.Event.Poll.new_closure:
         const GHC.Event.Poll.new_info;
         const 0;
 },
 GHC.Event.Poll.new_entry() //  []
         { info_tbl: [(camnP,
                       label: GHC.Event.Poll.new_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camnP: // global
           call GHC.Event.Poll.new1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.776216992 UTC

[section ""data" . GHC.Event.Poll.PollFd_closure" {
     GHC.Event.Poll.PollFd_closure:
         const GHC.Event.Poll.PollFd_info;
 },
 GHC.Event.Poll.PollFd_entry() //  [R2, R3, R4]
         { info_tbl: [(camo1,
                       label: GHC.Event.Poll.PollFd_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camo1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camo5; else goto camo4;
       camo5: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.PollFd_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       camo4: // global
           I64[Hp - 24] = GHC.Event.Poll.PollFd_con_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.780796393 UTC

[section ""data" . GHC.Event.Poll.Poll_closure" {
     GHC.Event.Poll.Poll_closure:
         const GHC.Event.Poll.Poll_info;
 },
 GHC.Event.Poll.Poll_entry() //  [R2, R3]
         { info_tbl: [(camoh,
                       label: GHC.Event.Poll.Poll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camoh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto camol; else goto camok;
       camol: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Event.Poll.Poll_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       camok: // global
           I64[Hp - 16] = GHC.Event.Poll.Poll_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.785513959 UTC

[GHC.Event.Poll.PollFd_con_entry() //  [R1]
         { info_tbl: [(camos,
                       label: GHC.Event.Poll.PollFd_con_info
                       rep:HeapRep 3 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108,70,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camos: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.789678859 UTC

[GHC.Event.Poll.Poll_con_entry() //  [R1]
         { info_tbl: [(camoz,
                       label: GHC.Event.Poll.Poll_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,69,118,101,110,116,46,80,111,108,108,46,80,111,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camoz: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.794157459 UTC

[section ""relreadonly" . SalNx_srt" {
     SalNx_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Event.Poll.$w$cshowsPrec1_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshowsPrec_closure;
         const GHC.Event.Poll.$fShowPollFd_$cshow_closure;
         const GHC.Event.Poll.$fShowPollFd1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Array.loop_closure;
         const GHC.Event.Array.removeAt_closure;
         const GHC.Event.Array.findIndex_closure;
         const GHC.Event.Array.$wsnoc_closure;
         const GHC.Event.Array.$wlvl_closure;
         const Foreign.C.Error.throwErrno1_closure;
         const GHC.Event.Poll.new5_closure;
         const lvl3_rajBc_closure;
         const lvl5_rajBe_closure;
         const lvl6_rajBf_closure;
         const lvl10_rajBj_closure;
         const lvl11_rajBk_closure;
         const GHC.Event.Poll.new4_closure;
         const GHC.Event.Poll.new1_closure;
         const GHC.Event.Poll.new3_closure;
 }]

