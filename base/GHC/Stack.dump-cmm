
==================== Output Cmm ====================
2018-03-16 16:05:05.10003207 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:05.101132258 UTC

[section ""data" . GHC.Stack.errorWithStackTrace1_closure" {
     GHC.Stack.errorWithStackTrace1_closure:
         const GHC.Stack.errorWithStackTrace1_info;
         const 0;
 },
 sat_sa3mE_entry() //  [R1]
         { info_tbl: [(ca3nw,
                       label: sat_sa3mE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3nw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3nx; else goto ca3ny;
       ca3nx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3ny: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Stack.CCS.renderStack_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3mG_entry() //  [R1]
         { info_tbl: [(ca3nA,
                       label: sat_sa3mG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3nA: // global
           _sa3mG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3nB; else goto ca3nC;
       ca3nC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca3nE; else goto ca3nD;
       ca3nE: // global
           HpAlloc = 48;
           goto ca3nB;
       ca3nB: // global
           R1 = _sa3mG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3nD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3mG::P64;
           _sa3mB::P64 = P64[_sa3mG::P64 + 16];
           _sa3mC::P64 = P64[_sa3mG::P64 + 24];
           I64[Hp - 40] = sat_sa3mE_info;
           P64[Hp - 24] = _sa3mB::P64;
           I64[Hp - 16] = GHC.Exception.ErrorCallWithLocation_con_info;
           P64[Hp - 8] = _sa3mC::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace1_entry() //  [R2, R3]
         { info_tbl: [(ca3nF,
                       label: GHC.Stack.errorWithStackTrace1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3nF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca3nJ; else goto ca3nI;
       ca3nJ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3nI: // global
           I64[Hp - 24] = sat_sa3mG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.103044115 UTC

[section ""data" . GHC.Stack.errorWithStackTrace2_closure" {
     GHC.Stack.errorWithStackTrace2_closure:
         const GHC.Stack.errorWithStackTrace2_info;
         const 0;
 },
 sat_sa3mJ_entry() //  [R1]
         { info_tbl: [(ca3nX,
                       label: sat_sa3mJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3nX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3nY; else goto ca3nZ;
       ca3nY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3nZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.$bErrorCall_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3mK_entry() //  [R1]
         { info_tbl: [(ca3o0,
                       label: sat_sa3mK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3o0: // global
           _sa3mK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3o1; else goto ca3o2;
       ca3o2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3o4; else goto ca3o3;
       ca3o4: // global
           HpAlloc = 24;
           goto ca3o1;
       ca3o1: // global
           R1 = _sa3mK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3o3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3mK::P64;
           _sa3mH::P64 = P64[_sa3mK::P64 + 16];
           I64[Hp - 16] = sat_sa3mJ_info;
           P64[Hp] = _sa3mH::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace2_entry() //  [R2]
         { info_tbl: [(ca3o5,
                       label: GHC.Stack.errorWithStackTrace2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3o5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3o9; else goto ca3o8;
       ca3o9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3o8: // global
           I64[Hp - 16] = sat_sa3mK_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.105226064 UTC

[section ""data" . GHC.Stack.errorWithStackTrace_closure" {
     GHC.Stack.errorWithStackTrace_closure:
         const GHC.Stack.errorWithStackTrace_info;
         const 0;
 },
 GHC.Stack.errorWithStackTrace_entry() //  [R2]
         { info_tbl: [(ca3oq,
                       label: GHC.Stack.errorWithStackTrace_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3oq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3or; else goto ca3os;
       ca3or: // global
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3os: // global
           I64[Sp - 16] = block_ca3oe_info;
           R3 = GHC.Types.[]_closure+1;
           _sa3mL::P64 = R2;
           R2 = CCCS;
           P64[Sp - 8] = _sa3mL::P64;
           Sp = Sp - 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3oe() //  [R1]
         { info_tbl: [(ca3oe,
                       label: block_ca3oe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3oe: // global
           I64[Sp] = block_ca3og_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua3oD; else goto ca3oh;
       ua3oD: // global
           call _ca3og(R1) args: 0, res: 0, upd: 0;
       ca3oh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3og() //  [R1]
         { info_tbl: [(ca3og,
                       label: block_ca3og_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3og: // global
           _sa3mL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ca3ok; else goto ca3ol;
       ca3ok: // global
           I64[Sp + 8] = block_ca3oA_info;
           R2 = _sa3mL::P64;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace2_entry(R2) args: 8, res: 8, upd: 8;
       ca3ol: // global
           I64[Sp + 8] = block_ca3oA_info;
           R3 = _sa3mL::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace1_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3oA() //  [R1]
         { info_tbl: [(ca3oA,
                       label: block_ca3oA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3oA: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.106524163 UTC

[section ""cstring" . lvl_ra3mz_bytes" {
     lvl_ra3mz_bytes:
         I8[] [112,111,112,67,97,108,108,83,116,97,99,107,58,32,101,109,112,116,121,32,115,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.10728235 UTC

[section ""data" . GHC.Stack.withFrozenCallStack1_closure" {
     GHC.Stack.withFrozenCallStack1_closure:
         const GHC.Stack.withFrozenCallStack1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stack.withFrozenCallStack1_entry() //  [R1]
         { info_tbl: [(ca3oM,
                       label: GHC.Stack.withFrozenCallStack1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3oM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3oN; else goto ca3oO;
       ca3oN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3oO: // global
           (_ca3oH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca3oH::I64 == 0) goto ca3oJ; else goto ca3oI;
       ca3oJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca3oI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca3oH::I64;
           I64[Sp - 24] = block_ca3oK_info;
           R2 = lvl_ra3mz_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca3oK() //  [R1]
         { info_tbl: [(ca3oK,
                       label: block_ca3oK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3oK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.108552901 UTC

[section ""data" . GHC.Stack.popCallStack_closure" {
     GHC.Stack.popCallStack_closure:
         const GHC.Stack.popCallStack_info;
         const 0;
 },
 GHC.Stack.popCallStack_entry() //  [R2]
         { info_tbl: [(ca3p4,
                       label: GHC.Stack.popCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3p4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3p5; else goto ca3p6;
       ca3p5: // global
           R2 = R2;
           R1 = GHC.Stack.popCallStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3p6: // global
           I64[Sp - 8] = block_ca3oW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3ph; else goto ca3oX;
       ua3ph: // global
           call _ca3oW(R1) args: 0, res: 0, upd: 0;
       ca3oX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3oW() //  [R1]
         { info_tbl: [(ca3oW,
                       label: block_ca3oW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3oW: // global
           _ca3p3::P64 = R1 & 7;
           if (_ca3p3::P64 < 3) goto ua3pg; else goto ca3p2;
       ua3pg: // global
           if (_ca3p3::P64 < 2) goto ca3p0; else goto ca3p1;
       ca3p0: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3p1: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3p2: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.110010588 UTC

[section ""data" . GHC.Stack.callStack_closure" {
     GHC.Stack.callStack_closure:
         const GHC.Stack.callStack_info;
 },
 GHC.Stack.callStack_entry() //  [R2]
         { info_tbl: [(ca3pu,
                       label: GHC.Stack.callStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3pu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3pv; else goto ca3pw;
       ca3pv: // global
           R2 = R2;
           R1 = GHC.Stack.callStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3pw: // global
           I64[Sp - 8] = block_ca3pm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3pH; else goto ca3pn;
       ua3pH: // global
           call _ca3pm(R1) args: 0, res: 0, upd: 0;
       ca3pn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3pm() //  [R1]
         { info_tbl: [(ca3pm,
                       label: block_ca3pm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3pm: // global
           _ca3pt::P64 = R1 & 7;
           if (_ca3pt::P64 < 3) goto ua3pG; else goto ca3ps;
       ua3pG: // global
           if (_ca3pt::P64 < 2) goto ca3pq; else goto ca3pr;
       ca3pq: // global
           R1 = GHC.Stack.Types.EmptyCallStack_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca3pr: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3ps: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.111594604 UTC

[section ""data" . GHC.Stack.withFrozenCallStack_closure" {
     GHC.Stack.withFrozenCallStack_closure:
         const GHC.Stack.withFrozenCallStack_info;
         const 0;
 },
 sat_sa3ni_entry() //  [R1]
         { info_tbl: [(ca3pY,
                       label: sat_sa3ni_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3pY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3pZ; else goto ca3q0;
       ca3pZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3q0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca3pQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua3qb; else goto ca3pR;
       ua3qb: // global
           call _ca3pQ(R1) args: 0, res: 0, upd: 0;
       ca3pR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca3pQ() //  [R1]
         { info_tbl: [(ca3pQ,
                       label: block_ca3pQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3pQ: // global
           _ca3pX::P64 = R1 & 7;
           if (_ca3pX::P64 < 3) goto ua3qa; else goto ca3pW;
       ua3qa: // global
           if (_ca3pX::P64 < 2) goto ca3pU; else goto ca3pV;
       ca3pU: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3pV: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3pW: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.withFrozenCallStack_entry() //  [R2, R3]
         { info_tbl: [(ca3qd,
                       label: GHC.Stack.withFrozenCallStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3qd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca3qh; else goto ca3qg;
       ca3qh: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.withFrozenCallStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3qg: // global
           I64[Hp - 32] = sat_sa3ni_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Stack.Types.FreezeCallStack_con_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.112985486 UTC

[section ""cstring" . GHC.Stack.$trModule4_bytes" {
     GHC.Stack.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.113590088 UTC

[section ""data" . GHC.Stack.$trModule3_closure" {
     GHC.Stack.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.114103048 UTC

[section ""cstring" . GHC.Stack.$trModule2_bytes" {
     GHC.Stack.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.115057866 UTC

[section ""data" . GHC.Stack.$trModule1_closure" {
     GHC.Stack.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.115594714 UTC

[section ""data" . GHC.Stack.$trModule_closure" {
     GHC.Stack.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.$trModule3_closure+1;
         const GHC.Stack.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.116132734 UTC

[section ""relreadonly" . Sa3nK_srt" {
     Sa3nK_srt:
         const GHC.Stack.CCS.renderStack_closure;
         const GHC.Exception.$fExceptionErrorCall_$ctoException_closure;
         const GHC.Stack.errorWithStackTrace1_closure;
         const GHC.Stack.errorWithStackTrace2_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const GHC.Stack.errorWithStackTrace_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Stack.popCallStack_closure;
         const GHC.Stack.withFrozenCallStack1_closure;
         const GHC.Stack.withFrozenCallStack_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.116715776 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:05.117660722 UTC

[section ""data" . GHC.Stack.errorWithStackTrace1_closure" {
     GHC.Stack.errorWithStackTrace1_closure:
         const GHC.Stack.errorWithStackTrace1_info;
         const 0;
 },
 sat_sa3mE_entry() //  [R1]
         { info_tbl: [(ca3qu,
                       label: sat_sa3mE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3qu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3qv; else goto ca3qw;
       ca3qv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3qw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Stack.CCS.renderStack_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3mG_entry() //  [R1]
         { info_tbl: [(ca3qy,
                       label: sat_sa3mG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3qy: // global
           _sa3mG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3qz; else goto ca3qA;
       ca3qA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca3qC; else goto ca3qB;
       ca3qC: // global
           HpAlloc = 48;
           goto ca3qz;
       ca3qz: // global
           R1 = _sa3mG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3qB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3mG::P64;
           _sa3mB::P64 = P64[_sa3mG::P64 + 16];
           _sa3mC::P64 = P64[_sa3mG::P64 + 24];
           I64[Hp - 40] = sat_sa3mE_info;
           P64[Hp - 24] = _sa3mB::P64;
           I64[Hp - 16] = GHC.Exception.ErrorCallWithLocation_con_info;
           P64[Hp - 8] = _sa3mC::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace1_entry() //  [R2, R3]
         { info_tbl: [(ca3qD,
                       label: GHC.Stack.errorWithStackTrace1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3qD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca3qH; else goto ca3qG;
       ca3qH: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3qG: // global
           I64[Hp - 24] = sat_sa3mG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.119438485 UTC

[section ""data" . GHC.Stack.errorWithStackTrace2_closure" {
     GHC.Stack.errorWithStackTrace2_closure:
         const GHC.Stack.errorWithStackTrace2_info;
         const 0;
 },
 sat_sa3mJ_entry() //  [R1]
         { info_tbl: [(ca3qU,
                       label: sat_sa3mJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3qU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3qV; else goto ca3qW;
       ca3qV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3qW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.$bErrorCall_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3mK_entry() //  [R1]
         { info_tbl: [(ca3qX,
                       label: sat_sa3mK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3qX: // global
           _sa3mK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3qY; else goto ca3qZ;
       ca3qZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3r1; else goto ca3r0;
       ca3r1: // global
           HpAlloc = 24;
           goto ca3qY;
       ca3qY: // global
           R1 = _sa3mK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3r0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3mK::P64;
           _sa3mH::P64 = P64[_sa3mK::P64 + 16];
           I64[Hp - 16] = sat_sa3mJ_info;
           P64[Hp] = _sa3mH::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace2_entry() //  [R2]
         { info_tbl: [(ca3r2,
                       label: GHC.Stack.errorWithStackTrace2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3r2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3r6; else goto ca3r5;
       ca3r6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3r5: // global
           I64[Hp - 16] = sat_sa3mK_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.121149134 UTC

[section ""data" . GHC.Stack.errorWithStackTrace_closure" {
     GHC.Stack.errorWithStackTrace_closure:
         const GHC.Stack.errorWithStackTrace_info;
         const 0;
 },
 GHC.Stack.errorWithStackTrace_entry() //  [R2]
         { info_tbl: [(ca3rn,
                       label: GHC.Stack.errorWithStackTrace_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3ro; else goto ca3rp;
       ca3ro: // global
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3rp: // global
           I64[Sp - 16] = block_ca3rb_info;
           R3 = GHC.Types.[]_closure+1;
           _sa3mL::P64 = R2;
           R2 = CCCS;
           P64[Sp - 8] = _sa3mL::P64;
           Sp = Sp - 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3rb() //  [R1]
         { info_tbl: [(ca3rb,
                       label: block_ca3rb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rb: // global
           I64[Sp] = block_ca3rd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua3rA; else goto ca3re;
       ua3rA: // global
           call _ca3rd(R1) args: 0, res: 0, upd: 0;
       ca3re: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3rd() //  [R1]
         { info_tbl: [(ca3rd,
                       label: block_ca3rd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rd: // global
           _sa3mL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ca3rh; else goto ca3ri;
       ca3rh: // global
           I64[Sp + 8] = block_ca3rx_info;
           R2 = _sa3mL::P64;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace2_entry(R2) args: 8, res: 8, upd: 8;
       ca3ri: // global
           I64[Sp + 8] = block_ca3rx_info;
           R3 = _sa3mL::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace1_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3rx() //  [R1]
         { info_tbl: [(ca3rx,
                       label: block_ca3rx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rx: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.122501486 UTC

[section ""cstring" . lvl_ra3mz_bytes" {
     lvl_ra3mz_bytes:
         I8[] [112,111,112,67,97,108,108,83,116,97,99,107,58,32,101,109,112,116,121,32,115,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.123240316 UTC

[section ""data" . GHC.Stack.withFrozenCallStack1_closure" {
     GHC.Stack.withFrozenCallStack1_closure:
         const GHC.Stack.withFrozenCallStack1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stack.withFrozenCallStack1_entry() //  [R1]
         { info_tbl: [(ca3rJ,
                       label: GHC.Stack.withFrozenCallStack1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3rK; else goto ca3rL;
       ca3rK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3rL: // global
           (_ca3rE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca3rE::I64 == 0) goto ca3rG; else goto ca3rF;
       ca3rG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca3rF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca3rE::I64;
           I64[Sp - 24] = block_ca3rH_info;
           R2 = lvl_ra3mz_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca3rH() //  [R1]
         { info_tbl: [(ca3rH,
                       label: block_ca3rH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.124899142 UTC

[section ""data" . GHC.Stack.popCallStack_closure" {
     GHC.Stack.popCallStack_closure:
         const GHC.Stack.popCallStack_info;
         const 0;
 },
 GHC.Stack.popCallStack_entry() //  [R2]
         { info_tbl: [(ca3s1,
                       label: GHC.Stack.popCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3s1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3s2; else goto ca3s3;
       ca3s2: // global
           R2 = R2;
           R1 = GHC.Stack.popCallStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3s3: // global
           I64[Sp - 8] = block_ca3rT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3se; else goto ca3rU;
       ua3se: // global
           call _ca3rT(R1) args: 0, res: 0, upd: 0;
       ca3rU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3rT() //  [R1]
         { info_tbl: [(ca3rT,
                       label: block_ca3rT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3rT: // global
           _ca3s0::P64 = R1 & 7;
           if (_ca3s0::P64 < 3) goto ua3sd; else goto ca3rZ;
       ua3sd: // global
           if (_ca3s0::P64 < 2) goto ca3rX; else goto ca3rY;
       ca3rX: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3rY: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3rZ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.126262241 UTC

[section ""data" . GHC.Stack.callStack_closure" {
     GHC.Stack.callStack_closure:
         const GHC.Stack.callStack_info;
 },
 GHC.Stack.callStack_entry() //  [R2]
         { info_tbl: [(ca3sr,
                       label: GHC.Stack.callStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3sr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3ss; else goto ca3st;
       ca3ss: // global
           R2 = R2;
           R1 = GHC.Stack.callStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3st: // global
           I64[Sp - 8] = block_ca3sj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3sE; else goto ca3sk;
       ua3sE: // global
           call _ca3sj(R1) args: 0, res: 0, upd: 0;
       ca3sk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3sj() //  [R1]
         { info_tbl: [(ca3sj,
                       label: block_ca3sj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3sj: // global
           _ca3sq::P64 = R1 & 7;
           if (_ca3sq::P64 < 3) goto ua3sD; else goto ca3sp;
       ua3sD: // global
           if (_ca3sq::P64 < 2) goto ca3sn; else goto ca3so;
       ca3sn: // global
           R1 = GHC.Stack.Types.EmptyCallStack_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca3so: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3sp: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.127798953 UTC

[section ""data" . GHC.Stack.withFrozenCallStack_closure" {
     GHC.Stack.withFrozenCallStack_closure:
         const GHC.Stack.withFrozenCallStack_info;
         const 0;
 },
 sat_sa3ni_entry() //  [R1]
         { info_tbl: [(ca3sV,
                       label: sat_sa3ni_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3sV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3sW; else goto ca3sX;
       ca3sW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3sX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca3sN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua3t8; else goto ca3sO;
       ua3t8: // global
           call _ca3sN(R1) args: 0, res: 0, upd: 0;
       ca3sO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca3sN() //  [R1]
         { info_tbl: [(ca3sN,
                       label: block_ca3sN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3sN: // global
           _ca3sU::P64 = R1 & 7;
           if (_ca3sU::P64 < 3) goto ua3t7; else goto ca3sT;
       ua3t7: // global
           if (_ca3sU::P64 < 2) goto ca3sR; else goto ca3sS;
       ca3sR: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3sS: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3sT: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.withFrozenCallStack_entry() //  [R2, R3]
         { info_tbl: [(ca3ta,
                       label: GHC.Stack.withFrozenCallStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3ta: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca3te; else goto ca3td;
       ca3te: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.withFrozenCallStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3td: // global
           I64[Hp - 32] = sat_sa3ni_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Stack.Types.FreezeCallStack_con_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.129165803 UTC

[section ""cstring" . GHC.Stack.$trModule4_bytes" {
     GHC.Stack.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.129706836 UTC

[section ""data" . GHC.Stack.$trModule3_closure" {
     GHC.Stack.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.130216403 UTC

[section ""cstring" . GHC.Stack.$trModule2_bytes" {
     GHC.Stack.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.130745577 UTC

[section ""data" . GHC.Stack.$trModule1_closure" {
     GHC.Stack.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.131305692 UTC

[section ""data" . GHC.Stack.$trModule_closure" {
     GHC.Stack.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.$trModule3_closure+1;
         const GHC.Stack.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.131845188 UTC

[section ""relreadonly" . Sa3nK_srt" {
     Sa3nK_srt:
         const GHC.Stack.CCS.renderStack_closure;
         const GHC.Exception.$fExceptionErrorCall_$ctoException_closure;
         const GHC.Stack.errorWithStackTrace1_closure;
         const GHC.Stack.errorWithStackTrace2_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const GHC.Stack.errorWithStackTrace_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Stack.popCallStack_closure;
         const GHC.Stack.withFrozenCallStack1_closure;
         const GHC.Stack.withFrozenCallStack_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.132616892 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:05.134994007 UTC

[section ""data" . GHC.Stack.errorWithStackTrace1_closure" {
     GHC.Stack.errorWithStackTrace1_closure:
         const GHC.Stack.errorWithStackTrace1_info;
         const 0;
 },
 sat_sa3mE_entry() //  [R1]
         { info_tbl: [(ca3tr,
                       label: sat_sa3mE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3tr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3ts; else goto ca3tt;
       ca3ts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3tt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Stack.CCS.renderStack_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3mG_entry() //  [R1]
         { info_tbl: [(ca3tv,
                       label: sat_sa3mG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3tv: // global
           _sa3mG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3tw; else goto ca3tx;
       ca3tx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca3tz; else goto ca3ty;
       ca3tz: // global
           HpAlloc = 48;
           goto ca3tw;
       ca3tw: // global
           R1 = _sa3mG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3ty: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3mG::P64;
           _sa3mB::P64 = P64[_sa3mG::P64 + 16];
           _sa3mC::P64 = P64[_sa3mG::P64 + 24];
           I64[Hp - 40] = sat_sa3mE_info;
           P64[Hp - 24] = _sa3mB::P64;
           I64[Hp - 16] = GHC.Exception.ErrorCallWithLocation_con_info;
           P64[Hp - 8] = _sa3mC::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace1_entry() //  [R2, R3]
         { info_tbl: [(ca3tA,
                       label: GHC.Stack.errorWithStackTrace1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3tA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca3tE; else goto ca3tD;
       ca3tE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3tD: // global
           I64[Hp - 24] = sat_sa3mG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.142788172 UTC

[section ""data" . GHC.Stack.errorWithStackTrace2_closure" {
     GHC.Stack.errorWithStackTrace2_closure:
         const GHC.Stack.errorWithStackTrace2_info;
         const 0;
 },
 sat_sa3mJ_entry() //  [R1]
         { info_tbl: [(ca3u4,
                       label: sat_sa3mJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3u4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3u5; else goto ca3u6;
       ca3u5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3u6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.$bErrorCall_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3mK_entry() //  [R1]
         { info_tbl: [(ca3u7,
                       label: sat_sa3mK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3u7: // global
           _sa3mK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3u8; else goto ca3u9;
       ca3u9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3ub; else goto ca3ua;
       ca3ub: // global
           HpAlloc = 24;
           goto ca3u8;
       ca3u8: // global
           R1 = _sa3mK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3ua: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3mK::P64;
           _sa3mH::P64 = P64[_sa3mK::P64 + 16];
           I64[Hp - 16] = sat_sa3mJ_info;
           P64[Hp] = _sa3mH::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace2_entry() //  [R2]
         { info_tbl: [(ca3uc,
                       label: GHC.Stack.errorWithStackTrace2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3uc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3ug; else goto ca3uf;
       ca3ug: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3uf: // global
           I64[Hp - 16] = sat_sa3mK_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.150768068 UTC

[section ""data" . GHC.Stack.errorWithStackTrace_closure" {
     GHC.Stack.errorWithStackTrace_closure:
         const GHC.Stack.errorWithStackTrace_info;
         const 0;
 },
 GHC.Stack.errorWithStackTrace_entry() //  [R2]
         { info_tbl: [(ca3uJ,
                       label: GHC.Stack.errorWithStackTrace_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3uJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3uK; else goto ca3uL;
       ca3uK: // global
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3uL: // global
           I64[Sp - 16] = block_ca3ux_info;
           R3 = GHC.Types.[]_closure+1;
           _sa3mL::P64 = R2;
           R2 = CCCS;
           P64[Sp - 8] = _sa3mL::P64;
           Sp = Sp - 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3ux() //  [R1]
         { info_tbl: [(ca3ux,
                       label: block_ca3ux_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3ux: // global
           I64[Sp] = block_ca3uz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua3uW; else goto ca3uA;
       ua3uW: // global
           call _ca3uz(R1) args: 0, res: 0, upd: 0;
       ca3uA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3uz() //  [R1]
         { info_tbl: [(ca3uz,
                       label: block_ca3uz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3uz: // global
           _sa3mL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ca3uD; else goto ca3uE;
       ca3uD: // global
           I64[Sp + 8] = block_ca3uT_info;
           R2 = _sa3mL::P64;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace2_entry(R2) args: 8, res: 8, upd: 8;
       ca3uE: // global
           I64[Sp + 8] = block_ca3uT_info;
           R3 = _sa3mL::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace1_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3uT() //  [R1]
         { info_tbl: [(ca3uT,
                       label: block_ca3uT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3uT: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.159375073 UTC

[section ""cstring" . lvl_ra3mz_bytes" {
     lvl_ra3mz_bytes:
         I8[] [112,111,112,67,97,108,108,83,116,97,99,107,58,32,101,109,112,116,121,32,115,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.16120628 UTC

[section ""data" . GHC.Stack.withFrozenCallStack1_closure" {
     GHC.Stack.withFrozenCallStack1_closure:
         const GHC.Stack.withFrozenCallStack1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stack.withFrozenCallStack1_entry() //  [R1]
         { info_tbl: [(ca3vn,
                       label: GHC.Stack.withFrozenCallStack1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3vn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3vo; else goto ca3vp;
       ca3vo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3vp: // global
           (_ca3vi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca3vi::I64 == 0) goto ca3vk; else goto ca3vj;
       ca3vk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca3vj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca3vi::I64;
           I64[Sp - 24] = block_ca3vl_info;
           R2 = lvl_ra3mz_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca3vl() //  [R1]
         { info_tbl: [(ca3vl,
                       label: block_ca3vl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3vl: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.166934678 UTC

[section ""data" . GHC.Stack.popCallStack_closure" {
     GHC.Stack.popCallStack_closure:
         const GHC.Stack.popCallStack_info;
         const 0;
 },
 GHC.Stack.popCallStack_entry() //  [R2]
         { info_tbl: [(ca3vP,
                       label: GHC.Stack.popCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3vP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3vQ; else goto ca3vR;
       ca3vQ: // global
           R2 = R2;
           R1 = GHC.Stack.popCallStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3vR: // global
           I64[Sp - 8] = block_ca3vH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3w2; else goto ca3vI;
       ua3w2: // global
           call _ca3vH(R1) args: 0, res: 0, upd: 0;
       ca3vI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3vH() //  [R1]
         { info_tbl: [(ca3vH,
                       label: block_ca3vH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3vH: // global
           _ca3vO::P64 = R1 & 7;
           if (_ca3vO::P64 < 3) goto ua3w1; else goto ca3vN;
       ua3w1: // global
           if (_ca3vO::P64 < 2) goto ca3vL; else goto ca3vM;
       ca3vL: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3vM: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3vN: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.172961434 UTC

[section ""data" . GHC.Stack.callStack_closure" {
     GHC.Stack.callStack_closure:
         const GHC.Stack.callStack_info;
 },
 GHC.Stack.callStack_entry() //  [R2]
         { info_tbl: [(ca3wu,
                       label: GHC.Stack.callStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3wu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3wv; else goto ca3ww;
       ca3wv: // global
           R2 = R2;
           R1 = GHC.Stack.callStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3ww: // global
           I64[Sp - 8] = block_ca3wm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3wH; else goto ca3wn;
       ua3wH: // global
           call _ca3wm(R1) args: 0, res: 0, upd: 0;
       ca3wn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3wm() //  [R1]
         { info_tbl: [(ca3wm,
                       label: block_ca3wm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3wm: // global
           _ca3wt::P64 = R1 & 7;
           if (_ca3wt::P64 < 3) goto ua3wG; else goto ca3ws;
       ua3wG: // global
           if (_ca3wt::P64 < 2) goto ca3wq; else goto ca3wr;
       ca3wq: // global
           R1 = GHC.Stack.Types.EmptyCallStack_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca3wr: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3ws: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.178895306 UTC

[section ""data" . GHC.Stack.withFrozenCallStack_closure" {
     GHC.Stack.withFrozenCallStack_closure:
         const GHC.Stack.withFrozenCallStack_info;
         const 0;
 },
 sat_sa3ni_entry() //  [R1]
         { info_tbl: [(ca3xd,
                       label: sat_sa3ni_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3xd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3xe; else goto ca3xf;
       ca3xe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3xf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca3x5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua3xq; else goto ca3x6;
       ua3xq: // global
           call _ca3x5(R1) args: 0, res: 0, upd: 0;
       ca3x6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca3x5() //  [R1]
         { info_tbl: [(ca3x5,
                       label: block_ca3x5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3x5: // global
           _ca3xc::P64 = R1 & 7;
           if (_ca3xc::P64 < 3) goto ua3xp; else goto ca3xb;
       ua3xp: // global
           if (_ca3xc::P64 < 2) goto ca3x9; else goto ca3xa;
       ca3x9: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3xa: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3xb: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.withFrozenCallStack_entry() //  [R2, R3]
         { info_tbl: [(ca3xs,
                       label: GHC.Stack.withFrozenCallStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3xs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca3xw; else goto ca3xv;
       ca3xw: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.withFrozenCallStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3xv: // global
           I64[Hp - 32] = sat_sa3ni_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Stack.Types.FreezeCallStack_con_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.186340897 UTC

[section ""cstring" . GHC.Stack.$trModule4_bytes" {
     GHC.Stack.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.188174852 UTC

[section ""data" . GHC.Stack.$trModule3_closure" {
     GHC.Stack.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.189757463 UTC

[section ""cstring" . GHC.Stack.$trModule2_bytes" {
     GHC.Stack.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.191343215 UTC

[section ""data" . GHC.Stack.$trModule1_closure" {
     GHC.Stack.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.192929893 UTC

[section ""data" . GHC.Stack.$trModule_closure" {
     GHC.Stack.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.$trModule3_closure+1;
         const GHC.Stack.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.19457131 UTC

[section ""relreadonly" . Sa3nK_srt" {
     Sa3nK_srt:
         const GHC.Stack.CCS.renderStack_closure;
         const GHC.Exception.$fExceptionErrorCall_$ctoException_closure;
         const GHC.Stack.errorWithStackTrace1_closure;
         const GHC.Stack.errorWithStackTrace2_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const GHC.Stack.errorWithStackTrace_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Stack.popCallStack_closure;
         const GHC.Stack.withFrozenCallStack1_closure;
         const GHC.Stack.withFrozenCallStack_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.304931979 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:05.306714015 UTC

[section ""data" . GHC.Stack.errorWithStackTrace1_closure" {
     GHC.Stack.errorWithStackTrace1_closure:
         const GHC.Stack.errorWithStackTrace1_info;
         const 0;
 },
 sat_sa3xZ_entry() //  [R1]
         { info_tbl: [(ca3yR,
                       label: sat_sa3xZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3yR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3yS; else goto ca3yT;
       ca3yS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3yT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Stack.CCS.renderStack_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3y1_entry() //  [R1]
         { info_tbl: [(ca3yV,
                       label: sat_sa3y1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3yV: // global
           _sa3y1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3yW; else goto ca3yX;
       ca3yX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca3yZ; else goto ca3yY;
       ca3yZ: // global
           HpAlloc = 48;
           goto ca3yW;
       ca3yW: // global
           R1 = _sa3y1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3yY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3y1::P64;
           _sa3xW::P64 = P64[_sa3y1::P64 + 16];
           _sa3xX::P64 = P64[_sa3y1::P64 + 24];
           I64[Hp - 40] = sat_sa3xZ_info;
           P64[Hp - 24] = _sa3xW::P64;
           I64[Hp - 16] = GHC.Exception.ErrorCallWithLocation_con_info;
           P64[Hp - 8] = _sa3xX::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace1_entry() //  [R2, R3]
         { info_tbl: [(ca3z0,
                       label: GHC.Stack.errorWithStackTrace1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3z0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca3z4; else goto ca3z3;
       ca3z4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3z3: // global
           I64[Hp - 24] = sat_sa3y1_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.314765724 UTC

[section ""data" . GHC.Stack.errorWithStackTrace2_closure" {
     GHC.Stack.errorWithStackTrace2_closure:
         const GHC.Stack.errorWithStackTrace2_info;
         const 0;
 },
 sat_sa3y4_entry() //  [R1]
         { info_tbl: [(ca3zA,
                       label: sat_sa3y4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3zA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3zB; else goto ca3zC;
       ca3zB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3zC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Exception.$bErrorCall_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa3y5_entry() //  [R1]
         { info_tbl: [(ca3zD,
                       label: sat_sa3y5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3zD: // global
           _sa3y5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca3zE; else goto ca3zF;
       ca3zF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3zH; else goto ca3zG;
       ca3zH: // global
           HpAlloc = 24;
           goto ca3zE;
       ca3zE: // global
           R1 = _sa3y5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3zG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa3y5::P64;
           _sa3y2::P64 = P64[_sa3y5::P64 + 16];
           I64[Hp - 16] = sat_sa3y4_info;
           P64[Hp] = _sa3y2::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Exception.$fExceptionErrorCall_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.errorWithStackTrace2_entry() //  [R2]
         { info_tbl: [(ca3zI,
                       label: GHC.Stack.errorWithStackTrace2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3zI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca3zM; else goto ca3zL;
       ca3zM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3zL: // global
           I64[Hp - 16] = sat_sa3y5_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.322263724 UTC

[section ""data" . GHC.Stack.errorWithStackTrace_closure" {
     GHC.Stack.errorWithStackTrace_closure:
         const GHC.Stack.errorWithStackTrace_info;
         const 0;
 },
 GHC.Stack.errorWithStackTrace_entry() //  [R2]
         { info_tbl: [(ca3Aj,
                       label: GHC.Stack.errorWithStackTrace_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3Aj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca3Ak; else goto ca3Al;
       ca3Ak: // global
           R2 = R2;
           R1 = GHC.Stack.errorWithStackTrace_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3Al: // global
           I64[Sp - 16] = block_ca3A7_info;
           R3 = GHC.Types.[]_closure+1;
           _sa3y6::P64 = R2;
           R2 = CCCS;
           P64[Sp - 8] = _sa3y6::P64;
           Sp = Sp - 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3A7() //  [R1]
         { info_tbl: [(ca3A7,
                       label: block_ca3A7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3A7: // global
           I64[Sp] = block_ca3A9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua3Aw; else goto ca3Aa;
       ua3Aw: // global
           call _ca3A9(R1) args: 0, res: 0, upd: 0;
       ca3Aa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3A9() //  [R1]
         { info_tbl: [(ca3A9,
                       label: block_ca3A9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3A9: // global
           _sa3y6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ca3Ad; else goto ca3Ae;
       ca3Ad: // global
           I64[Sp + 8] = block_ca3At_info;
           R2 = _sa3y6::P64;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace2_entry(R2) args: 8, res: 8, upd: 8;
       ca3Ae: // global
           I64[Sp + 8] = block_ca3At_info;
           R3 = _sa3y6::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.errorWithStackTrace1_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca3At() //  [R1]
         { info_tbl: [(ca3At,
                       label: block_ca3At_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3At: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.330432626 UTC

[section ""cstring" . lvl_ra3mz_bytes" {
     lvl_ra3mz_bytes:
         I8[] [112,111,112,67,97,108,108,83,116,97,99,107,58,32,101,109,112,116,121,32,115,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.33212888 UTC

[section ""data" . GHC.Stack.withFrozenCallStack1_closure" {
     GHC.Stack.withFrozenCallStack1_closure:
         const GHC.Stack.withFrozenCallStack1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stack.withFrozenCallStack1_entry() //  [R1]
         { info_tbl: [(ca3B2,
                       label: GHC.Stack.withFrozenCallStack1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3B2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3B3; else goto ca3B4;
       ca3B3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3B4: // global
           (_ca3AX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca3AX::I64 == 0) goto ca3AZ; else goto ca3AY;
       ca3AZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca3AY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca3AX::I64;
           I64[Sp - 24] = block_ca3B0_info;
           R2 = lvl_ra3mz_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca3B0() //  [R1]
         { info_tbl: [(ca3B0,
                       label: block_ca3B0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3B0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.337761753 UTC

[section ""data" . GHC.Stack.popCallStack_closure" {
     GHC.Stack.popCallStack_closure:
         const GHC.Stack.popCallStack_info;
         const 0;
 },
 GHC.Stack.popCallStack_entry() //  [R2]
         { info_tbl: [(ca3Bw,
                       label: GHC.Stack.popCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3Bw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3Bx; else goto ca3By;
       ca3Bx: // global
           R2 = R2;
           R1 = GHC.Stack.popCallStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3By: // global
           I64[Sp - 8] = block_ca3Bo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3BJ; else goto ca3Bp;
       ua3BJ: // global
           call _ca3Bo(R1) args: 0, res: 0, upd: 0;
       ca3Bp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3Bo() //  [R1]
         { info_tbl: [(ca3Bo,
                       label: block_ca3Bo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3Bo: // global
           _ca3Bv::P64 = R1 & 7;
           if (_ca3Bv::P64 < 3) goto ua3BI; else goto ca3Bu;
       ua3BI: // global
           if (_ca3Bv::P64 < 2) goto ca3Bs; else goto ca3Bt;
       ca3Bs: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3Bt: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3Bu: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.34333893 UTC

[section ""data" . GHC.Stack.callStack_closure" {
     GHC.Stack.callStack_closure:
         const GHC.Stack.callStack_info;
 },
 GHC.Stack.callStack_entry() //  [R2]
         { info_tbl: [(ca3Cc,
                       label: GHC.Stack.callStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3Cc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca3Cd; else goto ca3Ce;
       ca3Cd: // global
           R2 = R2;
           R1 = GHC.Stack.callStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca3Ce: // global
           I64[Sp - 8] = block_ca3C4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3Cp; else goto ca3C5;
       ua3Cp: // global
           call _ca3C4(R1) args: 0, res: 0, upd: 0;
       ca3C5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3C4() //  [R1]
         { info_tbl: [(ca3C4,
                       label: block_ca3C4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3C4: // global
           _ca3Cb::P64 = R1 & 7;
           if (_ca3Cb::P64 < 3) goto ua3Co; else goto ca3Ca;
       ua3Co: // global
           if (_ca3Cb::P64 < 2) goto ca3C8; else goto ca3C9;
       ca3C8: // global
           R1 = GHC.Stack.Types.EmptyCallStack_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca3C9: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca3Ca: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.349229305 UTC

[section ""data" . GHC.Stack.withFrozenCallStack_closure" {
     GHC.Stack.withFrozenCallStack_closure:
         const GHC.Stack.withFrozenCallStack_info;
         const 0;
 },
 sat_sa3yD_entry() //  [R1]
         { info_tbl: [(ca3CX,
                       label: sat_sa3yD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3CX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca3CY; else goto ca3CZ;
       ca3CY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3CZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca3CP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua3Da; else goto ca3CQ;
       ua3Da: // global
           call _ca3CP(R1) args: 0, res: 0, upd: 0;
       ca3CQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca3CP() //  [R1]
         { info_tbl: [(ca3CP,
                       label: block_ca3CP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3CP: // global
           _ca3CW::P64 = R1 & 7;
           if (_ca3CW::P64 < 3) goto ua3D9; else goto ca3CV;
       ua3D9: // global
           if (_ca3CW::P64 < 2) goto ca3CT; else goto ca3CU;
       ca3CT: // global
           R1 = GHC.Stack.withFrozenCallStack1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3CU: // global
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca3CV: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.withFrozenCallStack_entry() //  [R2, R3]
         { info_tbl: [(ca3Dc,
                       label: GHC.Stack.withFrozenCallStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3Dc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca3Dg; else goto ca3Df;
       ca3Dg: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.withFrozenCallStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca3Df: // global
           I64[Hp - 32] = sat_sa3yD_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Stack.Types.FreezeCallStack_con_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.356576249 UTC

[section ""cstring" . GHC.Stack.$trModule4_bytes" {
     GHC.Stack.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.358191457 UTC

[section ""data" . GHC.Stack.$trModule3_closure" {
     GHC.Stack.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.359829102 UTC

[section ""cstring" . GHC.Stack.$trModule2_bytes" {
     GHC.Stack.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.361740181 UTC

[section ""data" . GHC.Stack.$trModule1_closure" {
     GHC.Stack.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.363406436 UTC

[section ""data" . GHC.Stack.$trModule_closure" {
     GHC.Stack.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.$trModule3_closure+1;
         const GHC.Stack.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.364963298 UTC

[section ""relreadonly" . Sa3z5_srt" {
     Sa3z5_srt:
         const GHC.Stack.CCS.renderStack_closure;
         const GHC.Exception.$fExceptionErrorCall_$ctoException_closure;
         const GHC.Stack.errorWithStackTrace1_closure;
         const GHC.Stack.errorWithStackTrace2_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const GHC.Stack.errorWithStackTrace_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Stack.popCallStack_closure;
         const GHC.Stack.withFrozenCallStack1_closure;
         const GHC.Stack.withFrozenCallStack_closure;
 }]

